<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1178. 猜字谜</title>
    <url>/2023/07/04/1178-%E7%8C%9C%E5%AD%97%E8%B0%9C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>状态压缩</li>
<li>求二进制数表示的集合的全部子集</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">		unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; wordMap;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findNumOfValidWords</span><span class="params">(vector&lt;string&gt;&amp; words, vector&lt;string&gt;&amp; puzzles)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (string &amp;word : words) &#123;</span><br><span class="line">				<span class="type">int</span> hsh = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">char</span> &amp;chr : word) &#123;</span><br><span class="line">					hsh |= <span class="number">1</span> &lt;&lt; (chr - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				wordMap[hsh]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (string &amp;puzzle : puzzles) &#123;</span><br><span class="line">				<span class="type">int</span> hsh = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">char</span> &amp;chr : puzzle) &#123;</span><br><span class="line">					hsh |= <span class="number">1</span> &lt;&lt; (chr - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> subSet = hsh;; subSet = (subSet - <span class="number">1</span>) &amp; hsh) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!subSet) <span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">if</span> (wordMap.<span class="built_in">count</span>(subSet) &amp;&amp; (subSet &amp; (<span class="number">1</span> &lt;&lt; (puzzle[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>)))) &#123;</span><br><span class="line">						cnt += wordMap[subSet];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				ans.<span class="built_in">push_back</span>(cnt);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( m\cdot w+n\cdot
\left( p+2^{bitCount\left( p \right)} \right) \right)\)</span></p>
<p>其中<span
class="math inline">\(m\)</span>为<code>words</code>数组长度，<span
class="math inline">\(w\)</span>为<code>word</code>的长度且最大为50；<span
class="math inline">\(n\)</span>为<code>puzzles</code>数组长度，<span
class="math inline">\(p\)</span>为<code>puzzle</code>的长度且限定为7</p>
<p><span class="math inline">\(bitCount\left( p
\right)\)</span>代表十进制整数<span
class="math inline">\(p\)</span>的二进制表达中的<code>1个数</code>；<span
class="math inline">\(2^{bitCount\left( p
\right)}\)</span>这一时间复杂度，是求<span
class="math inline">\(p\)</span>二进制表达集合的所有子集</p>
<p>由于<span
class="math inline">\(p\)</span>在这里限定为7，可视为常数；故而时间复杂度也可表达为<span
class="math inline">\(O\left( m\cdot w+n\cdot 2^{bitCount\left( p
\right)} \right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( m
\right)\)</span>，新增了哈希表</p>
<h1 id="思路">思路</h1>
<p>按照传统思路，比较两个字符串的组成至少需要线性时间复杂度；若两个数组内的字符串两两比较，则时间复杂度高达3次方</p>
<p>由于题目说所有字符串只包含小写字母，且需求是对比两个字符串的组成，字符串内部的重复字符并不影响最终结果</p>
<p>所以使用一个32位的<code>int</code>类型变量的低26位，来表达字符串内的字符组成；该<code>int</code>变量也可视作该字符串的<strong>哈希值</strong></p>
<blockquote>
<p>比如字符串为abd，那么用二进制表达为1011</p>
</blockquote>
<p>具体步骤设计如下：</p>
<ul>
<li><p>遍历<code>words</code>数组，计算内部所有<code>word</code>字符串的哈希值</p>
<p>并新建一个哈希表<code>wordMap</code>记录相同哈希值的字符串个数</p></li>
<li><p>遍历<code>puzzles</code>数组，计算内部所有<code>puzzle</code>字符串的哈希值的子集</p>
<p>如果<code>wordMap</code>存在对应子集的记录，且子集包含<code>puzzle</code>的第一个字母</p>
<p>说明该子集代表的<code>word</code>可以作为当前<code>puzzle</code>的谜底</p></li>
</ul>
<p>按照上述步骤即可轻松解题，但需牢记求<strong>二进制数表示的集合的全部子集</strong>模板，来源于<a
href="https://oi-wiki.org/math/binary-set/#%E5%AD%90%E9%9B%86%E9%81%8D%E5%8E%86">网址</a>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 降序遍历 m 的子集</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = m;; s = (s - <span class="number">1</span>) &amp; m) &#123;</span><br><span class="line">    <span class="comment">// s 是 m 的一个子集</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>状态压缩</tag>
        <tag>哈希函数</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>1252. 奇数值单元格的数目</title>
    <url>/2023/07/04/1252-%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>状态压缩</li>
<li>排列组合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>同下</p>
<h1 id="思路">思路</h1>
<p>已知二维数组<code>M</code>有<code>m</code>行，<code>n</code>列；<code>indices</code>数组有<code>l</code>个元素，且每个元素都是长度为2的一维数组</p>
<p>比如某元素值为<code>[0,1]</code>，代表<strong>二维数组中行序号为0的单元格</strong>先加一、<strong>列序号为1的单元格</strong>再加一</p>
<p>正常的暴力方式如下：</p>
<ol type="1">
<li><p>开辟<code>m * n</code>大小的二维数组空间</p></li>
<li><p>遍历<code>indices</code>数组每个元素的同时，每次分别按行、按列地对二维数组进行批量修改</p>
<p>时间复杂度高达<span class="math inline">\(O\left( l\cdot \left( m+n
\right) \right)\)</span></p></li>
<li><p>遍历二维数组的所有单元格，判断有多少个奇数</p>
<p>时间复杂度<span class="math inline">\(O\left( m\cdot n
\right)\)</span></p></li>
</ol>
<p>组合拳下来，时间复杂度高达<span class="math inline">\(O\left( l\cdot
\left( m+n \right) +\left( m\cdot n \right)
\right)\)</span>，空间复杂度高达<span class="math inline">\(O\left(
m\cdot n \right)\)</span></p>
<h2 id="空间优化">空间优化</h2>
<p>由于每次都是对某行或某列的所有单元格进行批量加1，可以做如下优化：</p>
<ul>
<li><p>设置一个长度为<code>m</code>的<code>rows</code>数组，下标映射为二维数组<code>M</code>的行序号，值映射为二维数组对应行的增量</p></li>
<li><p>设置一个长度为<code>n</code>的<code>cols</code>数组，下标映射为二维数组<code>M</code>的列序号，值映射为二维数组对应列的增量</p></li>
</ul>
<p>那么有： <span class="math display">\[
M\left[ i \right] \left[ j \right] =rows\left[ i \right] +cols\left[ j
\right]
\]</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">oddCells</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">			<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rows</span><span class="params">(m, <span class="number">0</span>)</span>, <span class="title">cols</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;indice : indices) &#123;</span><br><span class="line">				rows[indice[<span class="number">0</span>]]++;</span><br><span class="line">				cols[indice[<span class="number">1</span>]]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span> ((rows[i] + cols[j]) &amp; <span class="number">1</span>) ans++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( l+m\cdot n
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( m+n
\right)\)</span></p>
<h2 id="计数优化-集合运算">计数优化 &amp; 集合运算</h2>
<p>根据数学性质，<code>奇数 = 奇数 + 偶数</code></p>
<ul>
<li><p>假设有<code>rows = &#123;1,1&#125;</code>，<code>cols = &#123;0,2,0&#125;</code></p>
<p>从两个集合中各取任意一个元素，都可求和为奇数；可行的组合数为<code>2 * 3 = 6</code></p>
<p>意味着整个二维数组都是奇数，共有6个奇数</p></li>
<li><p>假设有<code>rows = &#123;1,1,0&#125;</code>，<code>cols = &#123;1,0,1&#125;</code></p>
<p><code>rows</code>取<code>&#123;1,1&#125;</code>时，<code>cols</code>取<code>&#123;0&#125;</code>才可为奇数，此时可行的组合数为<code>2 * 1 = 2</code></p>
<p><code>rows</code>取<code>&#123;0&#125;</code>时，<code>cols</code>取<code>&#123;1,1&#125;</code>才可为奇数，此时可行的组合数为<code>1 * 2 = 2</code></p>
<p>意味着整个二维数组中，共有<code>2 + 2 = 4</code>个奇数</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">oddCells</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">			<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rows</span><span class="params">(m, <span class="number">0</span>)</span>, <span class="title">cols</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;indice : indices) &#123;</span><br><span class="line">				rows[indice[<span class="number">0</span>]]++;</span><br><span class="line">				cols[indice[<span class="number">1</span>]]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> rowOdd = <span class="number">0</span>, colOdd = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">				rowOdd += rows[i] &amp; <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">				colOdd += cols[i] &amp; <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> rowOdd * (n - colOdd) + (m - rowOdd) * colOdd;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( l+m+n
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( m+n
\right)\)</span></p>
<h2 id="位运算-状态压缩-集合运算">位运算 &amp; 状态压缩 &amp;
集合运算</h2>
<p>题目限定了<code>m</code>与<code>n</code>均不超过50，使用两个<code>long</code>类型的变量来替代<code>rows</code>与<code>cols</code>数组</p>
<p>用比特位1代表增量为奇数，用比特位0代表增量为偶数</p>
<p>各统计两个变量的<code>1个数</code>，即各自拥有的奇数个数，再做上述的集合运算即可</p>
<p><code>bitCount</code>实现请参见<code>191. 位1的个数</code>，不再赘述</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">bitCount</span><span class="params">(<span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="comment">//--------分治法--------</span></span><br><span class="line">			n = (n &amp; <span class="number">0x5555555555555555</span>) + ((n &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x5555555555555555</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x3333333333333333</span>) + ((n &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3333333333333333</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x0f0f0f0f0f0f0f0f</span>) + ((n &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f0f0f0f0f</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x00ff00ff00ff00ff</span>) + ((n &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00ff00ff00ff00ff</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x0000ffff0000ffff</span>) + ((n &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff0000ffff</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x00000000ffffffff</span>) + ((n &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0x00000000ffffffff</span>);</span><br><span class="line">			<span class="keyword">return</span> n;</span><br><span class="line">			<span class="comment">//--------分治法--------</span></span><br><span class="line">			<span class="comment">//--------Brian Kernighan法--------</span></span><br><span class="line"><span class="comment">//			int cnt = 0;</span></span><br><span class="line"><span class="comment">//			while (n) &#123;</span></span><br><span class="line"><span class="comment">//				n &amp;= n - 1;</span></span><br><span class="line"><span class="comment">//				cnt++;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//			return cnt;</span></span><br><span class="line">			<span class="comment">//--------Brian Kernighan法--------</span></span><br><span class="line">			<span class="comment">//--------lowBit--------</span></span><br><span class="line"><span class="comment">//			int cnt = 0;</span></span><br><span class="line"><span class="comment">//			while (n) &#123;</span></span><br><span class="line"><span class="comment">//				n -= (n &amp; -n);</span></span><br><span class="line"><span class="comment">//				cnt++;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//			return cnt;</span></span><br><span class="line">			<span class="comment">//--------lowBit--------</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">oddCells</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">			<span class="type">long</span> rows = <span class="number">0</span>, cols = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;indice : indices) &#123;</span><br><span class="line">				rows ^= <span class="number">1L</span> &lt;&lt; indice[<span class="number">0</span>];</span><br><span class="line">				cols ^= <span class="number">1L</span> &lt;&lt; indice[<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> rowOdd = <span class="built_in">bitCount</span>(rows), colOdd = <span class="built_in">bitCount</span>(cols);</span><br><span class="line">			<span class="keyword">return</span> rowOdd * (n - colOdd) + (m - rowOdd) * colOdd;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( l+\log C
\right)\)</span>，这里<span
class="math inline">\(C\)</span>等于<code>long</code>的位数64</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>状态压缩</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>138. 复制带随机指针的链表</title>
    <url>/2023/07/03/138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>哈希表与链表的综合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		unordered_map&lt;Node*, Node*&gt; m;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">			Node *cur = head, *dummyHead = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>), *curNew = dummyHead;</span><br><span class="line">			<span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				Node *node = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">				curNew-&gt;next = node;</span><br><span class="line">				curNew = curNew-&gt;next;</span><br><span class="line">				m[cur] = node;</span><br><span class="line">				cur = cur-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			curNew-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">			cur = head;</span><br><span class="line">			<span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				m[cur]-&gt;random = m[cur-&gt;random];</span><br><span class="line">				cur = cur-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本题难点就在于，如何保证新链表的<code>random</code>结构与旧链表的<code>random</code>结构完全一样</p>
<p>假设已知旧链表节点A指向节点B，新链表中对应的节点分别为C与D，如何记录C与D的关系？</p>
<img src="/2023/07/03/138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/1.png" class="" title="image-20230602200206991">
<p>显然需要使用哈希表来记录新旧节点之间的映射，新节点才可以根据映射来获悉旧节点的指向关系</p>
<img src="/2023/07/03/138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/2.png" class="" title="image-20230602200953233">
<p>当然，算法也可以修改为递归</p>
<ol type="1">
<li><p>子问题：创造新节点，连接起来，修改<code>random</code>三个操作</p></li>
<li><p>递归语句顺序：递归方向分为一去一回，去方向到达临界点时返回</p>
<p>创造新节点可以在去方向完成</p>
<p>节点连接，修改<code>random</code>必须在回方向完成；因为前者操作需要更新上一个节点的<code>next</code>，后者操作须等待哈希表记录映射关系后</p></li>
<li><p>临界点：当前节点为空</p></li>
<li><p>返回值：当前新节点地址，用以更新上一个节点的<code>next</code></p></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		unordered_map&lt;Node*, Node*&gt; m;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">			Node *node = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">			m[head] = node;</span><br><span class="line">			node-&gt;next = <span class="built_in">copyRandomList</span>(head-&gt;next);</span><br><span class="line">			node-&gt;random = m[head-&gt;random];</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>136. 只出现一次的数字</title>
    <url>/2023/07/04/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>异或技巧</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">				ans ^= nums[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( n
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>异或有以下性质，摘选自<a
href="https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677">百度百科</a>：</p>
<ul>
<li><p><strong>归零律</strong></p>
<img src="/2023/07/04/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/1.png" class="" title="image-20230621143031540"></li>
<li><p><strong>恒等律</strong></p>
<img src="/2023/07/04/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/2.png" class="" title="image-20230621143110296"></li>
<li><p><strong>交换律</strong></p>
<img src="/2023/07/04/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/3.png" class="" title="image-20230621143154698"></li>
<li><p><strong>结合律</strong></p>
<img src="/2023/07/04/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/4.png" class="" title="image-20230621143305054"></li>
</ul>
<p>值相同的数作异或运算为空，那么数组内所有元素的异或运算结果即可得到数组中只出现一次的数字</p>
<p>比如<code>nums</code>为<code>&#123;1,1,2,2,3&#125;</code>，二进制表达为<code>&#123;001,001,010,010,011&#125;</code></p>
<p>那么<code>001 ^ 001 ^ 010 ^ 010 ^ 011 = 011</code>，即为十进制数字3</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>142. 环形链表 II</title>
    <url>/2023/07/02/142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>快慢指针/双指针</li>
<li>链表的环</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">			ListNode *slow = head, *fast = head;</span><br><span class="line">			<span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				slow = slow-&gt;next;</span><br><span class="line">				fast = fast-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (fast != <span class="literal">nullptr</span>) fast = fast-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (fast != <span class="literal">nullptr</span> &amp;&amp; slow == fast) &#123;</span><br><span class="line">					ListNode *slow = head;</span><br><span class="line">					<span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">						slow = slow-&gt;next;</span><br><span class="line">						fast = fast-&gt;next;</span><br><span class="line">					&#125;</span><br><span class="line">                    <span class="comment">//这里换成slow是一样的</span></span><br><span class="line">					<span class="keyword">return</span> fast;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>我曾在<code>141. 环形链表</code>的题解中阐述了如何用快慢指针判断链表是否存在环，本题是其升级版，要寻找环的入口</p>
<p>我们已知链表头，能求得相遇点，现在要找到环入口，绘图如下</p>
<img src="/2023/07/02/142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/1.png" class="" title="image-20230522160752871">
<h2 id="通式">通式</h2>
<p>根据<code>快指针移动速度是慢指针移动速度的两倍</code>这一性质，可以得到以下通式
<span class="math display">\[
\underset{\text{慢指针到达相遇点所需时间}}{\underbrace{\frac{L+m\times
C+X}{1}}}=\underset{\text{快指针到达相遇点所需时间}}{\underbrace{\frac{L+n\times
C+X}{2}}}
\]</span> 解释如下</p>
<blockquote>
<p>L：链表头到环入口的距离</p>
<p>X：环入口到相遇点的距离</p>
<p>C：环的周长</p>
<p>m，n：未知数，各指针绕环次数</p>
</blockquote>
<p>两个未知数是无法编程的，可以优化一下</p>
<h2
id="慢指针在环内第一圈就能与快指针重合">慢指针在环内第一圈就能与快指针重合</h2>
<p>慢指针达到环入口时，假设快指针与慢指针的相对距离长度为<code>M</code></p>
<img src="/2023/07/02/142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/2.png" class="" title="image-20230522162507163">
<p>显然，<code>M</code>必小于周长<code>C</code></p>
<p>根据<code>141. 环形链表</code>的题解中提到的相遇时间公式，能得到下面不等式；代表慢指针在进入环内的第一圈就与快指针相遇了
<span class="math display">\[
\underset{\text{相遇时间}}{\underbrace{\frac{M}{2-1}}}&lt;\underset{\text{慢指针绕环一次的时间}}{\underbrace{C=\frac{C}{1}}}
\]</span> 所以，通式可以优化为 <span class="math display">\[
\underset{\text{慢指针到达相遇点所需时间}}{\underbrace{\frac{L+X}{1}}}=\underset{\text{快指针到达相遇点所需时间}}{\underbrace{\frac{L+n\times
C+X}{2}}}
\]</span></p>
<h2 id="实现">实现</h2>
<p>通式变形，可以得到 <span class="math display">\[
2\times \left( L+X \right) =L+n\times C+X
\]</span></p>
<p><span class="math display">\[
L=n\times C-X
\]</span></p>
<p><span class="math display">\[
L=\left( n-1 \right) \times C+\left( C-X \right)
\]</span></p>
<p>最终通式的含义可以这么理解</p>
<blockquote>
<p>某指针A从链表头出发</p>
<p>某指针B同时从相遇点出发，先走过C-X个单位到达环入口，再绕环n-1次</p>
<p>最终两个指针将在环入口相遇</p>
</blockquote>
<p>再结合题解的源码看，就一目了然了</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>143. 重排链表</title>
    <url>/2023/07/02/143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>快慢指针</li>
<li>链表的反转</li>
<li>链表的合并</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">mergeList</span><span class="params">(ListNode* smallList, ListNode* largeList)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (largeList == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">			ListNode *largeNext = largeList-&gt;next;</span><br><span class="line">			largeList-&gt;next = smallList-&gt;next;</span><br><span class="line">			smallList-&gt;next = largeList;</span><br><span class="line">			<span class="built_in">mergeList</span>(largeList-&gt;next, largeNext);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">			ListNode *tail = head;</span><br><span class="line">			<span class="keyword">while</span> (tail != <span class="literal">nullptr</span> &amp;&amp; tail-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				ListNode *node = tail-&gt;next;</span><br><span class="line">				tail-&gt;next = node-&gt;next;</span><br><span class="line">				node-&gt;next = dummyHead-&gt;next;</span><br><span class="line">				dummyHead-&gt;next = node;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">ListNode* <span class="title">splitList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *slow = head, *fast = head;</span><br><span class="line">			<span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				slow = slow-&gt;next;</span><br><span class="line">				fast = fast-&gt;next-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			ListNode *newHead = slow-&gt;next;</span><br><span class="line">			slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">return</span> newHead;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="built_in">mergeList</span>(head, <span class="built_in">reverseList</span>(<span class="built_in">splitList</span>(head)));</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本题主要考察链表的常用操作，共分为以下三个步骤：</p>
<ol type="1">
<li>找到链表的中点并拆分，使用快慢指针即可；左半部分为小链表，右半部分为大链表</li>
<li>大链表反转，这里使用<code>206. 反转链表</code>当中的<code>改进版头插法</code></li>
<li>反转后的大链表与小链表合并</li>
</ol>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>141. 环形链表</title>
    <url>/2023/07/02/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>快慢指针</li>
<li>链表的环</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">			ListNode *slow = head, *fast = head;</span><br><span class="line">			<span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				slow = slow-&gt;next;</span><br><span class="line">				fast = fast-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (fast != <span class="literal">nullptr</span>) fast = fast-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast == slow) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>判断链表中是否存在环，需要用到快慢指针</p>
<p>令<code>slow</code>为慢指针，每次移动一个单位；令<code>fast</code>为快指针，每次移动两个单位</p>
<p>两个指针同时移动，若相遇且<code>fast</code>不为<code>nullptr</code>时，即存在环</p>
<h2 id="为什么快慢指针可以解决">为什么快慢指针可以解决</h2>
<p>如果不存在环，快指针肯定将慢指针远远抛在身后</p>
<img src="/2023/07/02/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/1.png" class="" title="image-20230521215040181">
<p>一旦存在环，快指针会比慢指针更早到达环内，并且在环内无限循环</p>
<img src="/2023/07/02/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/2.png" class="" title="image-20230521215625891">
<p>如果慢指针也进入环内，那么就变成追击问题了，或者俗称的<code>龟兔赛跑</code>数学题</p>
<p>如图所示，快慢指针都是顺时针移动；若两指针距离<code>X</code>，环周长为<code>C</code>，那么快指针需要移动<code>C-X</code>个相对距离长度才能相遇</p>
<img src="/2023/07/02/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/3.png" class="" title="image-20230521225650430">
<p>追击问题中，有以下常识： <span class="math display">\[
\text{相对速度}=\text{速度差}
\]</span></p>
<p><span class="math display">\[
\text{相遇时间}=\frac{\text{相对距离长度}}{\text{相对速度}}
\]</span></p>
<p>所以，再经过<span class="math display">\[
\frac{C-X}{2-1}
\]</span>次移动后，快慢指针就可以相遇了</p>
<h2 id="为什么快指针每次移动两个单位">为什么快指针每次移动两个单位</h2>
<p>正如刚才提到的相遇时间计算公式，我们必须保证相对距离长度可以被相对速度整除才能相遇</p>
<p>因为在具体的程序实现上，所谓的<code>相遇时间</code>其实就是循环次数，不可能为小数；若取两个单位，相对速度就是1，任何数都可以被1整除</p>
<p>所以，快指针每次移动也可以取三个单位，四个单位，五个单位....但是不一定可以整除相对距离长度</p>
<p>如果相遇时间是小数，说明两个指针会错过而永不相遇</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">快指针移动单位</th>
<th style="text-align: center;">慢指针移动单位</th>
<th style="text-align: center;">相对速度</th>
<th style="text-align: center;">相对距离长度</th>
<th style="text-align: center;">相遇时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">4/5</td>
<td style="text-align: center;">4/5</td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">4/5</td>
<td style="text-align: center;">2/2.5</td>
</tr>
<tr class="odd">
<td style="text-align: center;">4</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">11/15</td>
<td style="text-align: center;">3.67/5</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>137. 只出现一次的数字 II</title>
    <url>/2023/07/04/137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-II/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>状态压缩</li>
<li>排列组合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> cntArr[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;num : nums) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (num &amp; (<span class="number">1U</span> &lt;&lt; i)) cntArr[i]++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">				ans = (ans &lt;&lt; <span class="number">1</span>) | (cntArr[i] % <span class="number">3</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( n
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>根据题意<strong>除某个元素仅出现一次外，其余每个元素都恰出现三次</strong>，<code>int</code>类型的整数也都是32位</p>
<p>假设当前为第<span class="math inline">\(i\)</span>位，<span
class="math inline">\(Sum_i\)</span>代表所有元素的第<span
class="math inline">\(i\)</span>位之和，<span
class="math inline">\(r\)</span>代表只出现了一次的元素在第<span
class="math inline">\(i\)</span>位的值，必满足以下等式 <span
class="math display">\[
Sum_i=3k+r
\]</span>
所以设置一个长度为32的<code>cntArr</code>数组，依次记录所有元素各在某位上的和</p>
<p>然后再遍历<code>cntArr</code>数组，对各个元素求余3后重新拼凑，即可得到只出现了一次的元素</p>
<p>比如有<code>nums</code>数组<code>&#123;2,2,2,14&#125;</code>，映射为二进制就是<code>&#123;0010,0010,0010,1110&#125;</code></p>
<p><code>cntArr</code>数组的值则应为<code>&#123;1,1,4,0&#125;</code>，求余3后为<code>&#123;1,1,1,0&#125;</code>，就等于只出现了一次的元素<code>14</code>的二进制表达</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>状态压缩</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>146. LRU 缓存</title>
    <url>/2023/07/03/146-LRU-%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>哈希表与链表的综合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">			<span class="type">int</span> key;</span><br><span class="line">			<span class="type">int</span> value;</span><br><span class="line">			<span class="built_in">Node</span>(<span class="type">int</span> _key, <span class="type">int</span> _value) : <span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value) &#123;&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="type">int</span> capacity;</span><br><span class="line">		list&lt;Node&gt; l;</span><br><span class="line">		unordered_map&lt;<span class="type">int</span>, list&lt;Node&gt;::iterator&gt; m;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">LRUCache</span>(<span class="type">int</span> _capacity) : <span class="built_in">capacity</span>(_capacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">auto</span> it = m.<span class="built_in">find</span>(key);</span><br><span class="line">			<span class="keyword">if</span> (it == m.<span class="built_in">end</span>())	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			<span class="type">int</span> value = it-&gt;second-&gt;value;</span><br><span class="line">            <span class="comment">//先从链表中删除</span></span><br><span class="line">			l.<span class="built_in">erase</span>(it-&gt;second);</span><br><span class="line">            <span class="comment">//再添加到头部</span></span><br><span class="line">			l.<span class="built_in">emplace_front</span>(key, value);</span><br><span class="line">            <span class="comment">//更新哈希表</span></span><br><span class="line">			m[key] = l.<span class="built_in">begin</span>();</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">auto</span> it = m.<span class="built_in">find</span>(key);</span><br><span class="line">			<span class="keyword">if</span> (it == m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">//容量为0就不能插入新元素</span></span><br><span class="line">				<span class="keyword">if</span> (capacity == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">				<span class="keyword">if</span> (m.<span class="built_in">size</span>() == (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)capacity) &#123;</span><br><span class="line">					m.<span class="built_in">erase</span>(l.<span class="built_in">back</span>().key);</span><br><span class="line">					l.<span class="built_in">pop_back</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				l.<span class="built_in">erase</span>(it-&gt;second);</span><br><span class="line">			&#125;</span><br><span class="line">			l.<span class="built_in">emplace_front</span>(key, value);</span><br><span class="line">			m[key] = l.<span class="built_in">begin</span>();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>LRU又称为最近最少使用页面置换算法(Least Recently
Used)，淘汰最早访问的页面</p>
<p>题目要求查找与增删节点时均要达到常量时间复杂度，很容易想到哈希表+链表的组合</p>
<blockquote>
<p>无序哈希表在平均情况下的查找为常量时间复杂度，而有序哈希表的查找为对数时间复杂度，因为底层是红黑树</p>
</blockquote>
<p>所以有以下思路：</p>
<ol type="1">
<li><p>每次访问/更新节点时，先将其从链表中删除，再将其插入到链表头部以代表最近访问</p>
<p>这样一来链表末尾节点自然是最早访问的了</p></li>
<li><p>因为只涉及到删除链表中节点、删除链表尾部节点和插入链表头部节点，使用双向链表较为方便；这里使用<code>list</code>这一STL库来完成</p></li>
<li><p>使用哈希表来记录键与节点的映射关系，这样就能直接操控链表节点而不用去遍历寻找</p></li>
</ol>
<p>数据结构设计如图所示</p>
<img src="/2023/07/03/146-LRU-%E7%BC%93%E5%AD%98/1.png" class="" title="image-20230605162942234">
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>147. 对链表进行插入排序</title>
    <url>/2023/07/02/147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">			<span class="keyword">while</span> (head-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (head-&gt;val &gt; head-&gt;next-&gt;val) &#123;</span><br><span class="line">					ListNode *cur = dummyHead, *node = head-&gt;next;</span><br><span class="line">					<span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;val &lt; node-&gt;val ) cur = cur-&gt;next;</span><br><span class="line">					head-&gt;next = node-&gt;next;</span><br><span class="line">					node-&gt;next = cur-&gt;next;</span><br><span class="line">					cur-&gt;next = node;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					head = head-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>插入排序的精髓就在于，令当前元素之前的子数组为有序，然后判断当前元素应插入子数组的何种位置即可</p>
<p>令<code>head</code>为有序子数组末尾，<code>node</code>为<code>head</code>的下一个元素</p>
<p>按照升序顺序，若<code>node</code>大于等于<code>head</code>，说明以<code>node</code>结尾的子数组有序；那么<code>head</code>应该向下移动</p>
<img src="/2023/07/02/147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/1.png" class="" title="image-20230605204522898">
<p>若<code>node</code>大于<code>head</code>，找到子数组中第一个大于<code>node</code>节点的前一个节点，然后移动到它的后面完成插入操作</p>
<img src="/2023/07/02/147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/2.png" class="" title="image-20230605210213014">
<img src="/2023/07/02/147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/3.png" class="" title="image-20230605205859704">
<p>如此循环往复即可</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>148. 排序链表</title>
    <url>/2023/07/03/148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">MergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line">			<span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">			<span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">				l1-&gt;next = <span class="built_in">MergeList</span>(l1-&gt;next, l2);</span><br><span class="line">				<span class="keyword">return</span> l1;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				l2-&gt;next = <span class="built_in">MergeList</span>(l1, l2-&gt;next);</span><br><span class="line">				<span class="keyword">return</span> l2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">ListNode* <span class="title">MergeSort</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head), *cur = dummyHead;</span><br><span class="line">			<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				cur = cur-&gt;next;</span><br><span class="line">				len++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> subLen = <span class="number">1</span>; subLen &lt; len; subLen *= <span class="number">2</span>) &#123;</span><br><span class="line">				ListNode *curNew = dummyHead, *cur = dummyHead-&gt;next;</span><br><span class="line">				<span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">					ListNode *leftHead = cur;</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; subLen &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span>; cur = cur-&gt;next, i++);</span><br><span class="line">					ListNode *rightHead = cur-&gt;next;</span><br><span class="line">					cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">					cur = rightHead;</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; subLen &amp;&amp; cur != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span>; cur = cur-&gt;next, i++);</span><br><span class="line">					<span class="keyword">if</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">						ListNode *nextLeftHead = cur-&gt;next;</span><br><span class="line">						cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">						cur = nextLeftHead;</span><br><span class="line">					&#125;</span><br><span class="line">					curNew-&gt;next = <span class="built_in">MergeList</span>(leftHead, rightHead);</span><br><span class="line">					<span class="keyword">while</span> (curNew-&gt;next != <span class="literal">nullptr</span>) curNew = curNew-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">MergeSort</span>(head);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题目要求在<code>O(nlogn)</code>
时间复杂度和常数级空间复杂度下对链表进行排序</p>
<p>考虑时间复杂度，满足要求的有归并排序、堆排序与快速排序；后两者在链表实现上较难，所以选择归并排序</p>
<p>首先写出递归版本的归并排序，思路很简单</p>
<ol type="1">
<li>在递归的去方向中：每次找到链表的中点，并利用递归分割成左子链表和右子链表</li>
<li>在递归的回方向中：合并左右子链表；因为子链表均有序，可以参考<code>21. 合并两个有序链表</code>代码</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">MergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line">			<span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">			<span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">				l1-&gt;next = <span class="built_in">MergeList</span>(l1-&gt;next, l2);</span><br><span class="line">				<span class="keyword">return</span> l1;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				l2-&gt;next = <span class="built_in">MergeList</span>(l1, l2-&gt;next);</span><br><span class="line">				<span class="keyword">return</span> l2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">ListNode* <span class="title">MergeSort</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="comment">//很重要，否则会导致MergeSort函数死循环</span></span><br><span class="line">			<span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">			ListNode *slow = head, *fast = slow;</span><br><span class="line">			<span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				slow = slow-&gt;next;</span><br><span class="line">				fast = fast-&gt;next-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			ListNode *newHead = slow-&gt;next;</span><br><span class="line">			slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">MergeList</span>(<span class="built_in">MergeSort</span>(head), <span class="built_in">MergeSort</span>(newHead));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">MergeSort</span>(head);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但递归是自顶向下的写法，显然空间复杂度是<code>O(logn)</code>并不满足题目需求；所以需要使用自底向上的写法</p>
<p>递归的去方向不断地拆分链表，故而消耗了额外的栈空间；若用迭代来替代递归的<code>拆分</code>动作，就不会有额外的空间损耗</p>
<p>自底向上的迭代思路如图所示，其中<code>有序子链表合并</code>操作的代码直接参考<code>21. 合并两个有序链表</code>即可</p>
<img src="/2023/07/03/148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/1.png" class="" title="image-20230607174322312">
<p>编程如下，为了可读性部分逻辑有重复，简化后就是题解代码的模样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">MergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line">			<span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">			<span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">				l1-&gt;next = <span class="built_in">MergeList</span>(l1-&gt;next, l2);</span><br><span class="line">				<span class="keyword">return</span> l1;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				l2-&gt;next = <span class="built_in">MergeList</span>(l1, l2-&gt;next);</span><br><span class="line">				<span class="keyword">return</span> l2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">ListNode* <span class="title">MergeSort</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head), *cur = dummyHead;</span><br><span class="line">			<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				cur = cur-&gt;next;</span><br><span class="line">				len++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//外循环是待合并的子链表长度，初始为1，每次乘2</span></span><br><span class="line">			<span class="comment">//子链表的长度*2肯定小于等于总长度</span></span><br><span class="line">			<span class="comment">//当然，子链长度等于总长度的时候就没必要自己合并自己，所以这里只有小于号没有等于号</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> subLen = <span class="number">1</span>; subLen &lt; len; subLen *= <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="comment">//每次都从头开始更新链表</span></span><br><span class="line">				ListNode *curNew = dummyHead, *cur = dummyHead-&gt;next;</span><br><span class="line">				<span class="comment">//按照归并的规律，两个子链表一组</span></span><br><span class="line">				<span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">					<span class="comment">//记录左子链表头</span></span><br><span class="line">					ListNode *leftHead = cur;</span><br><span class="line">					<span class="comment">//寻找左子链表尾</span></span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; subLen &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span>; cur = cur-&gt;next, i++);</span><br><span class="line">					<span class="comment">//左子链表尾的下一个节点为空，说明没有右子链表，即到了整个大链表的尾部</span></span><br><span class="line">					<span class="comment">//那么合并完后直接开启新的大循环</span></span><br><span class="line">					<span class="keyword">if</span> (cur-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">						curNew-&gt;next = leftHead;</span><br><span class="line">						cur = <span class="literal">nullptr</span>;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">//若存在右子链表</span></span><br><span class="line">						<span class="comment">//记录右子链表头</span></span><br><span class="line">						ListNode *rightHead = cur-&gt;next;</span><br><span class="line">						<span class="comment">//左子链表尾部断开，使其成为单独的链表便于合并</span></span><br><span class="line">						cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">						<span class="comment">//寻找右子链表尾</span></span><br><span class="line">						cur = rightHead;</span><br><span class="line">						<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; subLen &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span>; cur = cur-&gt;next, i++);</span><br><span class="line">						ListNode *nextLeftHead = cur-&gt;next;</span><br><span class="line">						<span class="comment">//右子链表尾部断开</span></span><br><span class="line">						cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">						cur = nextLeftHead;</span><br><span class="line">						<span class="comment">//塞入左右子链表合并后的新链表</span></span><br><span class="line">						curNew-&gt;next = <span class="built_in">MergeList</span>(leftHead, rightHead);</span><br><span class="line">						<span class="keyword">while</span> (curNew-&gt;next != <span class="literal">nullptr</span>) curNew = curNew-&gt;next;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">MergeSort</span>(head);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>160. 相交链表</title>
    <url>/2023/07/02/160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的相交</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">			ListNode *curA = headA, *curB = headB;</span><br><span class="line">			<span class="keyword">while</span> (curA != curB) &#123;</span><br><span class="line">				curA = curA == <span class="literal">nullptr</span> ? headB : curA-&gt;next;</span><br><span class="line">				curB = curB == <span class="literal">nullptr</span> ? headA : curB-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> curA;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>链表的相交问题需要用到双指针</p>
<p>设链表A的节点为{a1, a2, c1, c2}，链表B的节点为{b1, b2, b3, c1,
c2}；两个链表相交于节点c1，自节点c1起为相交公共部分</p>
<img src="/2023/07/02/160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/1.png" class="" title="image-20230521170752995">
<p>假设游标指针curA和curB同时出发，并最终相交于节点c1；观察路径轨迹，可以发现有以下恒等式：
<span class="math display">\[
\underset{curA\text{遍历链表}A}{\underbrace{a1+a2+c1+c2}}+\underset{curA\text{遍历}B\text{部分}}{\underbrace{b1+b2+b3}}+c1=\underset{curB\text{遍历链表}B}{\underbrace{b1+b2+b3+c1+c2}}+\underset{curB\text{遍历}A\text{部分}}{\underbrace{a1+a2}}+c1
\]</span> 故而，若A、B两个链表存在交点，应做如下操作：</p>
<ul>
<li><p>curA遍历A链表，然后再从B链表头节点继续遍历</p></li>
<li><p>curB遍历B链表，然后再从A链表头节点继续遍历</p></li>
<li><p>curA和curB的遍历同步进行；最终会相遇在相交节点</p></li>
</ul>
<p>假如不相交呢？最终curA和curB两个指针值也是相等的，均为<code>nullptr</code></p>
<p>因为curA先遍历了A链表再遍历了B链表，curB先遍历了B链表再遍历了A链表，两个指针又是同时遍历，自然最终结果一样</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>1711. 大餐计数</title>
    <url>/2023/07/04/1711-%E5%A4%A7%E9%A4%90%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>状态压缩</li>
<li>排列组合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">countPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; deliciousnesses)</span> </span>&#123;</span><br><span class="line">			unordered_map&lt;<span class="type">int</span>, <span class="type">long</span>&gt; m;</span><br><span class="line">			<span class="type">long</span> ans = <span class="number">0</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;deliciousness : deliciousnesses) m[deliciousness]++;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[a, v] : m) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> sum = <span class="number">1</span>; sum &lt; ( <span class="number">1</span> &lt;&lt; <span class="number">22</span>); sum = sum &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="type">int</span> b = sum - a;</span><br><span class="line">					<span class="keyword">if</span> (m.<span class="built_in">count</span>(b)) &#123;</span><br><span class="line">						ans += a == b ? v * (v - <span class="number">1</span>) : v * m[b];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> (<span class="type">int</span>)((ans &gt;&gt; <span class="number">1</span>) % mod);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( n\cdot \log C
\right)\)</span>，其中<span class="math inline">\(C\)</span>为<span
class="math inline">\(2^{21}\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( n
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>若按传统暴力方法，最高的时间复杂度高达10<sup>10</sup>，是绝对不可取的</p>
<p>创建哈希表<code>m</code>记录美味程度相同的下标个数，将所有的下标分类成数个集合；运用集合运算可在常数时间内完成<code>下标两两比较</code>操作</p>
<p>假设当前<code>m</code>的值为<code>&#123;1 : 3, 3 : 3, 7 : 1&#125;</code>，意味着美味程度等于1、3、7的下标个数分别为3、3、1</p>
<p>接下来寻找<code>m</code>中满足<strong>两个键的和等于2的幂</strong>这一条件的情况个数，常规情况下双重暴力循环，时间复杂度高达平方，也不可取</p>
<p>由于美味程度不超过2<sup>20</sup>，那么两个键的和也不会超过2<sup>21</sup></p>
<p>令<code>sum</code>变量为2的幂，从1开始，即2<sup>0</sup>，每次翻倍，直到2<sup>21</sup>终止；循环过程中，用<code>sum</code>减去当前的键，判断<code>m</code>是否存在差值的记录</p>
<p>若存在差值，这里有两种情况：</p>
<ul>
<li><p><strong>差值等于当前键</strong>，那么根据集合运算规则，该条件下的答案为：
<span class="math display">\[
\frac{\left( \text{键}-1+1 \right) \cdot \left( \text{键}-1
\right)}{2}=\frac{\text{键}\cdot \left( \text{键}-1 \right)}{2}
\]</span>
假设当前<code>sum</code>为<code>2</code>，当前键为上述<code>m</code>中的<code>1</code>，有3个下标不同但美味程度均为1的元素</p>
<p>令这三个下标分别为<code>&#123;0,1,2&#125;</code>，显然该集合两两元素生成不重复的子集只有<code>&#123;0,1&#125;</code>、<code>&#123;0,2&#125;</code>和<code>&#123;1,2&#125;</code>三个</p>
<p>则答案满足等差数列求和公式： <span class="math display">\[
\frac{\left( \text{首项}+\text{末项} \right) \cdot \text{项数}}{2}
\]</span></p></li>
<li><p><strong>差值等于另一个键</strong>，那么根据集合运算规则，该条件下的答案为：
<span class="math display">\[
\text{当前键映射的值}\cdot \text{差值键映射的值}
\]</span>
假设当前<code>sum</code>为<code>4</code>，当前键为上述<code>m</code>中的<code>1</code>，三个下标分别为<code>&#123;0,1,2&#125;</code>；差值键为上述<code>m</code>中的<code>3</code>，三个下标分别为<code>&#123;3,4,5&#125;</code></p>
<p>那么<code>&#123;0,1,2&#125;</code>与<code>&#123;3,4,5&#125;</code>两集合中的元素，两两生成不重复的子集的个数为<code>3 * 3 = 9</code>，分别为：</p>
<p><code>&#123;0,3&#125;</code>、<code>&#123;0,4&#125;</code>、<code>&#123;0,5&#125;</code>、<code>&#123;1,3&#125;</code>、<code>&#123;1,4&#125;</code>、<code>&#123;1,5&#125;</code>、<code>&#123;2,3&#125;</code>、<code>&#123;2,4&#125;</code>和<code>&#123;2,5&#125;</code></p></li>
</ul>
<p>这里有一个小细节，上述的第二种情况<code>差值等于另一个键</code>在实际过程中会被计算两次</p>
<blockquote>
<p><code>sum</code>为<code>4</code>时，当前键为<code>1</code>，差值键可为<code>3</code>；同样的<code>sum</code>，当前键为<code>3</code>时，差值键也可为<code>1</code></p>
</blockquote>
<p>故而在下方代码中，<code>(v * (v - 1))/2</code>乘了2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ans += a == b ? v * (v - <span class="number">1</span>) : v * m[b];</span><br></pre></td></tr></table></figure>
<p>这样可以留到结尾一起除2处理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (<span class="type">int</span>)((ans &gt;&gt; <span class="number">1</span>) % mod);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>状态压缩</tag>
        <tag>哈希表</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>19. 删除链表的倒数第 N 个结点</title>
    <url>/2023/07/02/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>快慢指针/双指针</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">			ListNode *slow = dummyHead;</span><br><span class="line">			ListNode *fast = dummyHead;</span><br><span class="line">			<span class="keyword">while</span>(n--)&#123;</span><br><span class="line">				fast = fast-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">				slow = slow-&gt;next;</span><br><span class="line">				fast = fast-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题目要求<code>删除链表的倒数第 n 个结点</code>，这里需要使用快慢指针来完成这一操作</p>
<p>首先新建一个<code>dummyHead</code>伪节点，链表操作必备；假设我们需要删除链表{1,
2, 3, 4}的倒数第2个节点，即节点3</p>
<p>画图比划一下，用<code>fast</code>指针指向最后一个节点，用<code>slow</code>指针指向倒数第n+1个节点（因为要删除倒数第n个节点）</p>
<p>然后将它们平移到初始位置，是不是一目了然了~</p>
<img src="/2023/07/02/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/1.png" class="" title="image-20230520213521918">
<p>步骤清晰如下：</p>
<ol type="1">
<li>快慢指针都从<code>dummyHead</code>起始</li>
<li>快指针先走n步</li>
<li>快慢指针一起走，直到快指针到达最后一个节点，此时慢指针的下一个节点就是待删除节点</li>
</ol>
<p>当然也可以不用快慢指针，使用老办法递归：</p>
<ol type="1">
<li><p>子问题与返回值：每次判断本节点是否应该被删除。若要被删除，则返回<code>next</code>值；若不需要被删除，返回自身</p>
<p>实际上就是返回应该存在于链表的节点</p></li>
<li><p>递归语句顺序：递归方向分为一去一回，去方向到达临界点后返回；这里选择回方向操作，因为要计算倒数</p></li>
<li><p>临界点：节点为<code>nullptr</code>时返回，意味着<code>nullptr</code>节点存在于链表</p></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="function">ListNode* <span class="title">recursiveFunc</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">			head-&gt;next = <span class="built_in">recursiveFunc</span>(head-&gt;next);</span><br><span class="line">			<span class="keyword">if</span> (--n == <span class="number">0</span>) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> _n)</span> </span>&#123;</span><br><span class="line">			n = _n;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">recursiveFunc</span>(head);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>190. 颠倒二进制位</title>
    <url>/2023/07/04/190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>位运算与分治法的综合</li>
<li>掩码技巧</li>
<li>移位技巧</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>同下</p>
<h1 id="思路">思路</h1>
<h2 id="逐位移动">逐位移动</h2>
<p>通过循环，每次新变量向左移位后接收<code>n</code>的低位，自然<code>n</code>的低位变成新变量的高位了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; n = n &gt;&gt; <span class="number">1</span>, i++)&#123;</span><br><span class="line">            ans &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            ans |= n &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( k
\right)\)</span>，这里<span
class="math inline">\(k\)</span>等于位数32</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h2 id="分治">分治</h2>
<p>参考<code>191. 位1的个数</code>中的分治法</p>
<p>将二进制整串均分成左右两子串，每个子串同样递归地执行翻转操作，最后将左右子串交换位置完成翻转</p>
<img src="/2023/07/04/190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/1.png" class="" title="image-20230617143518000">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">			n = ((n &amp; <span class="number">0xAAAAAAAA</span>) &gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">			n = ((n &amp; <span class="number">0xCCCCCCCC</span>) &gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">			n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>);</span><br><span class="line">			n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">			n = ((n &amp; <span class="number">0xffff0000</span>) &gt;&gt; <span class="number">16</span>) | ((n &amp; <span class="number">0x0000ffff</span>) &lt;&lt; <span class="number">16</span>);</span><br><span class="line">			<span class="keyword">return</span> n;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( \log C
\right)\)</span>，这里<span
class="math inline">\(C\)</span>等于位数32</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>191. 位1的个数</title>
    <url>/2023/07/04/191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li><p><code>n &amp; (n - 1)</code>技巧，即Brian Kernighan算法</p></li>
<li><p><code>n &amp; -n</code>技巧</p></li>
<li><p>掩码技巧</p></li>
<li><p>移位技巧</p></li>
<li><p>位运算与分治法的综合</p></li>
<li><p><code>bitCount</code>的实现</p></li>
<li><p><code>lowBit</code>的实现</p></li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>同下</p>
<h1 id="思路">思路</h1>
<p>有若干方法可以实现<code>bitCount</code>，下面依次列举，便于快速熟悉位运算的各种技巧</p>
<h2 id="掩码计数">掩码计数</h2>
<p>最容易想到的办法，就是使用类似计算机网络中的<code>掩码</code>，与原数逐位比较；这里的<code>掩码</code>也必须为无符号32位类型，否则会溢出</p>
<blockquote>
<p>对于int来说，</p>
<p>正数极值用二进制表达是0111_1111_1111_1111_1111_1111_1111_1111</p>
<p>负数极值用二进制表达是1000_0000_0000_0000_0000_0000_0000_0000</p>
<p>负数以补码的形式存在，-1用二进制表达是1111_1111_1111_1111_1111_1111_1111_1111</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">			<span class="type">uint32_t</span> mask = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">31</span>; mask = mask &lt;&lt; <span class="number">1</span>, i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (n &amp; mask) cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> cnt;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( k
\right)\)</span>，其中<span
class="math inline">\(k\)</span>为<code>uint32_t</code>的位数，在这里是32位</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h2 id="右移计数">右移计数</h2>
<p>每次判断最低位是否为1，然后将原数右移一位；因为题目说明了原数是无符号32位，所以右移不会新增1的个数</p>
<blockquote>
<p>若是负数，右移时高位会补1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (n) &#123;</span><br><span class="line">				cnt += n &amp; <span class="number">1</span>;</span><br><span class="line">				n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> cnt;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( k
\right)\)</span>，其中<span
class="math inline">\(k\)</span>为<code>uint32_t</code>的位数，在这里是32位</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h2 id="brian-kernighan算法">Brian Kernighan算法</h2>
<p>对于任何一个数<code>n</code>，<code>n &amp; (n - 1)</code>能够将最低位的1变为0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (n) &#123;</span><br><span class="line">				n &amp;= n - <span class="number">1</span>;</span><br><span class="line">				cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> cnt;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( \log n
\right)\)</span>，循环次数等于<span
class="math inline">\(n\)</span>的二进制位中1的个数</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h2 id="lowbit">lowBit</h2>
<p>对于任何一个数<code>n</code>，<code>n &amp; -n</code>能够获取最低位的1的位置；假设二进制表达为<code>0110</code>，则lowBit返回<code>0010</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (n) &#123;</span><br><span class="line">				n -= n &amp; -n;</span><br><span class="line">				cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> cnt;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( \log n
\right)\)</span>，循环次数等于<span
class="math inline">\(n\)</span>的二进制位中1的个数</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h2 id="分治">分治</h2>
<p>参考JDK中<code>Integer.bitCount</code>的函数原型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">			n = (n &amp; <span class="number">0x55555555</span>) + ((n &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x33333333</span>) + ((n &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x0f0f0f0f</span>) + ((n &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x00ff00ff</span>) + ((n &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x0000ffff</span>) + ((n &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);</span><br><span class="line">			<span class="keyword">return</span> n;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原理类似归并排序的迭代版，每次按照单位长度进行归并：</p>
<ol type="1">
<li>单位长度为1时，<code>1个数</code>取决于其本身是否为1</li>
<li>单位长度为2，取<strong>相邻高低位</strong>，它们各自的<code>1个数</code>相加，达到<code>一一归并为二</code>的效果</li>
<li>单位长度为4，取<strong>相邻且单位长度为2</strong>的两部分，它们各自的<code>1个数</code>相加，达到<code>二二归并为四</code>的效果</li>
<li>单位长度为8，取<strong>相邻且单位长度为4</strong>的两部分，它们各自的<code>1个数</code>相加，达到<code>四四归并为八</code>的效果</li>
<li>循环同上</li>
</ol>
<p>假设需要统计二进制序列<code>1011101110</code>中1的总数，分治过程如下</p>
<img src="/2023/07/04/191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/1.png" class="" title="image-20230616181756580">
<p>假设有二进制<code>1110</code>，求1的个数<span
class="math inline">\(N\)</span>；设二进制位编号从左到右分别为a、b、c、d，那么有
<span class="math display">\[
N=N_a+N_b+N_c+N_d=N_{a,b}+N_{c,d}
\]</span> 初始单位长度为1，按上面的分治过程，需要一一组合为二</p>
<p>在第一步中，设计掩码<code>0101</code>，令<code>0101 &amp; 1110 = 0100</code>取出<span
class="math inline">\(N_b\)</span>和<span
class="math inline">\(N_d\)</span></p>
<p>再<code>1110 &gt;&gt; 1 = 0111</code>，<code>0101 &amp; 0111 = 0101</code>取出<span
class="math inline">\(N_a\)</span>和<span
class="math inline">\(N_c\)</span></p>
<p><code>0100 + 0101 = 1001</code>就能得到<span
class="math inline">\(N_{a,b}\)</span>与<span
class="math inline">\(N_{c,d}\)</span></p>
<p>第二步中可以设计<code>0011</code>这一掩码，<code>1001 &amp; 0011 = 0001</code>取出<span
class="math inline">\(N_{c,d}\)</span></p>
<p><code>1001 &gt;&gt; 2 = 0010</code>，<code>0010 &amp; 0011 = 0010</code>取出<span
class="math inline">\(N_{a,b}\)</span></p>
<p><code>0001 + 0010 = 0011 = 十进制的3</code>，即为 <span
class="math display">\[
N=N_{a,b}+N_{c,d}
\]</span> 那么这些掩码的功效你应该能明白了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x55555555  ‭0b01010101010101010101010101010101‬</span><br><span class="line">0x33333333  ‭0b00110011001100110011001100110011‬</span><br><span class="line">0x0f0f0f0f  ‭0b00001111000011110000111100001111‬</span><br><span class="line">0x00ff00ff  0b00000000111111110000000011111111</span><br><span class="line">0x0000ffff  ‭0b00000000000000001111111111111111‬</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( \log C
\right)\)</span>，其中<span
class="math inline">\(C\)</span>为<code>uint32_t</code>的位数，在这里是32位；大部分情况下，是所有方法中最快的一个</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>203. 移除链表元素</title>
    <url>/2023/07/02/203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的删除</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head), *cur = dummyHead;</span><br><span class="line">			<span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(cur-&gt;next-&gt;val == val) cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">				<span class="keyword">else</span> cur = cur-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>单向链表中，当前节点无法知晓前一个节点的信息；如果增删改当前节点，上一个节点的<code>next</code>就得不到更新</p>
<p>所以每次操作的节点其实是当前节点的下一个</p>
<p>要保证操作的通用性，不用去判断操作头结点时的一些特殊情况；引入了<code>dummyHead</code>一个伪结点，它的<code>next</code>指向真正的头节点</p>
<p>（实际上，只要涉及到链表的操作，<code>dummyHead</code>几乎是必须的）</p>
<p>以序列<code>&#123;7, 4, 3, 7&#125;</code>为例，需要删除值为7的节点；从伪结点开始迭代</p>
<img src="/2023/07/02/203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/1.png" class="" title="image-20230514151344511">
<p>每次判断下一个节点的值是否满足题意；若是，则将当前节点的<code>next</code>指向下下个节点（将满足题意的节点从链表踢出）</p>
<img src="/2023/07/02/203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/2.png" class="" title="image-20230514151852476">
<p>若否，则指针移至下个节点，开启新一轮判断</p>
<img src="/2023/07/02/203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/3.png" class="" title="image-20230514152922907">
<p>由于核心问题就是<strong>不同情况下修改节点的<code>next</code>值</strong>，可以将其改造为递归</p>
<p>编写递归按照四部曲即可：</p>
<ol type="1">
<li><p>子问题：更新自己的<code>next</code>值，需要下一个节点的信息</p></li>
<li><p>递归语句顺序：递归方向分为一去一回，去方向至临界点后返回；本题应在回方向操作，因为要返回值给当前节点的上一个节点</p>
<p>（当然也可以去方向操作，但那样和迭代无异，且无法处理头节点）</p></li>
<li><p>返回值：如果当前节点要被删除，则返回它的<code>next</code>值；否则返回自己（本质上是返回应该存在于链表内的节点）</p>
<p>临界点返回<code>nullptr</code>值，代表<code>nullptr</code>一定存在于链表内</p></li>
<li><p>临界点：当前节点为nullptr</p></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">			head-&gt;next = <span class="built_in">removeElements</span>(head-&gt;next, val);</span><br><span class="line">			<span class="keyword">if</span>(head-&gt;val == val) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>2. 两数相加</title>
    <url>/2023/07/02/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的合并</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">		<span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">			ListNode *cur1 = l1, *cur2 = l2, *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *curNew = dummyHead;</span><br><span class="line">			<span class="keyword">while</span> (cur1 != <span class="literal">nullptr</span> || cur2 != <span class="literal">nullptr</span> || carry) &#123;</span><br><span class="line">				cur1 = cur1 != <span class="literal">nullptr</span> ? (carry += cur1-&gt;val, cur1-&gt;next) : <span class="literal">nullptr</span>;</span><br><span class="line">				cur2 = cur2 != <span class="literal">nullptr</span> ? (carry += cur2-&gt;val, cur2-&gt;next) : <span class="literal">nullptr</span>;</span><br><span class="line">				curNew-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry % <span class="number">10</span>);</span><br><span class="line">				carry /= <span class="number">10</span>;</span><br><span class="line">				curNew = curNew-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题目要我们算两个数相加的结果，146+854=1000；但要求的存储方式是倒过来的，641+458=0001</p>
<img src="/2023/07/02/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/1.png" class="" title="image-20230524163056995">
<p>思路很简单：</p>
<ul>
<li>每次计算<code>cur1+cur2+进位的和</code>，将<code>和求余10</code>的值赋给新建的链表节点，将<code>和除10</code>的值更新进位</li>
<li>只要cur1、cur2、进位有一个不为空，就要重复上述操作新增链表节点</li>
</ul>
<p>若要将其改造成递归就稍有难度</p>
<ol type="1">
<li><p>子问题：计算步骤同上；还需要将每次新增的链表节点串起来</p></li>
<li><p>递归语句顺序：递归方向分为一去一回，去方向到达临界点后返回</p>
<p>在这里，先在去方向构造完新链表节点；在回方向更新当前节点的<code>next</code>值，从而将链表串起来</p></li>
<li><p>返回值：因为只能在回方向将新链表串起，所以每次返回新节点让上一个节点更改它的<code>next</code>值</p></li>
<li><p>临界点：cur1、cur2、进位都为空</p></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">		<span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (l1 == <span class="literal">nullptr</span> &amp;&amp; l2 == <span class="literal">nullptr</span> &amp;&amp; !carry) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">			l1 = l1 != <span class="literal">nullptr</span> ? (carry += l1-&gt;val, l1-&gt;next) : <span class="literal">nullptr</span>;</span><br><span class="line">			l2 = l2 != <span class="literal">nullptr</span> ? (carry += l2-&gt;val, l2-&gt;next) : <span class="literal">nullptr</span>;</span><br><span class="line">			ListNode *head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry % <span class="number">10</span>);</span><br><span class="line">			carry /= <span class="number">10</span>;</span><br><span class="line">			head-&gt;next = <span class="built_in">addTwoNumbers</span>(l1, l2);</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果是<code>99+9</code>，到达临界点的情况如图所示；8、0、1的新建节点并没有串起来，所以才需要回方向将它们连接起来</p>
<img src="/2023/07/02/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/2.png" class="" title="image-20230527135416750">
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>206. 反转链表</title>
    <url>/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的反转</li>
<li>掌握<strong>改进版头插法</strong></li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">			<span class="keyword">while</span> (head-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				ListNode *tmp = head-&gt;next;</span><br><span class="line">				head-&gt;next = tmp-&gt;next;</span><br><span class="line">				tmp-&gt;next = dummyHead-&gt;next;</span><br><span class="line">				dummyHead-&gt;next = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<h2 id="朴素法更改方向">朴素法：更改方向</h2>
<h3 id="迭代">迭代</h3>
<p>反转一个链表，很容易想到更改方向即可，毕竟方向是由<code>next</code>值决定的</p>
<p>比如要反转链表{1, 2, 3, 4}</p>
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/1.png" class="" title="image-20230518123951929">
<p>很自然地想到让每个节点指向前一个节点即可</p>
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2.png" class="" title="image-20230518125017994">
<p>代码实现很简单。令一个指针<code>cur</code>指向当前节点，一个指针<code>prev</code>指向前一个节点；指针<code>prev</code>初始值为<code>nullptr</code>，代表新表尾</p>
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/3.png" class="" title="image-20230518144335688">
<p>每次都令<code>cur</code>节点的<code>next</code>值指向<code>prev</code>，然后两个指针一齐向后移</p>
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/4.png" class="" title="image-20230518144521542">
<p>当<code>cur</code>节点为空时，<code>prev</code>恰好指向最后一个节点，即新方向链表的表头</p>
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/5.png" class="" title="image-20230518144742139">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *cur = head;</span><br><span class="line">			ListNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">				ListNode *tmp = cur-&gt;next;</span><br><span class="line">				cur-&gt;next = prev;</span><br><span class="line">				prev = cur;</span><br><span class="line">				cur = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> prev;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="递归">递归</h3>
<p>当然可以将其修改为递归，按照以下四部曲来</p>
<ol type="1">
<li><p>子问题：当前节点需指向前一个节点</p></li>
<li><p>递归语句顺序：递归方向分为一去一回，去方向至临界值返回；在这里两种方向都可以</p>
<p>去方向类似迭代，同样不知道上个节点的信息，所以必须通过传参记录上个节点的地址</p>
<p>回方向则可以令当前节点的下一个节点指向自己，达到改变方向的效果</p></li>
<li><p>返回值：分为去方向和回方向两种</p>
<p>由于去方向类似迭代，要获得新表头必须到达临界值，所以递归语句必须放在程序结构的最后一行再返回</p>
<p>回方向的新表头到达临界值返回即可</p></li>
<li><p>临界点：到达最后一个节点后开始回方向</p></li>
</ol>
<p>去方向的递归代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">recursiveFunc</span><span class="params">(ListNode *head, ListNode *prev)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> prev;</span><br><span class="line">			ListNode *tmp = head-&gt;next;</span><br><span class="line">			head-&gt;next = prev;</span><br><span class="line">            <span class="comment">//到达临界值，即新表头再返回</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">recursiveFunc</span>(tmp, head);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//和迭代一样，head是当前节点，prev是当前节点的前一个节点</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">recursiveFunc</span>(head, <span class="literal">nullptr</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>回方向的递归代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">//到达了临界点，即新表头开始返回</span></span><br><span class="line">			<span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">			ListNode *newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">            <span class="comment">//反转当前节点的下一个节点方向</span></span><br><span class="line">			head-&gt;next-&gt;next = head;</span><br><span class="line">            <span class="comment">//让当前节点指向nullptr；正常节点不会受影响，因为方向会在下一次修正</span></span><br><span class="line">            <span class="comment">//目的是为了让第一个节点，即新链表的尾节点闭合</span></span><br><span class="line">			head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">//所有递归子程序的返回值都是一样的，即新表头</span></span><br><span class="line">			<span class="keyword">return</span> newHead;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="头插法">头插法</h2>
<p>头插法是反转链表算法中最通用的处理方式，请务必掌握</p>
<p>我们知道，操作链表基本都会新增<code>dummyHead</code>伪节点，以避免讨论头结点的特殊情况</p>
<p>头插法则是参考了<code>dummyHead</code>的精髓，在待逆转链表的表头的前一个节点做文章</p>
<p>以链表{1, 2, 3, 4,
5}为例，若反转整个链表，则新建<code>dummyHead</code>伪节点于节点1前；若反转子链表{3,
4}，则需要节点2做配合</p>
<p>下面分别介绍市面上普通的头插法和我改进的头插法</p>
<h3 id="普通头插法">普通头插法</h3>
<p>普通头插法的局限性在于无法反转子链表；假设需要反转链表{1, 2, 3}</p>
<p>首先新增一个<code>dummyHead</code>伪节点，指向<code>nullptr</code></p>
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/6.png" class="" title="image-20230518164443126">
<p>随后，每个节点都插入到<code>dummyHead</code>后面即可完成反转链表</p>
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/7.png" class="" title="image-20230518165802774">
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/8.png" class="" title="image-20230518170241065">
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/9.png" class="" title="image-20230518170450819">
<p>代码如下，比较简单</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				ListNode *tmp = head-&gt;next;</span><br><span class="line">				head-&gt;next = dummyHead-&gt;next;</span><br><span class="line">				dummyHead-&gt;next = head;</span><br><span class="line">				head = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="改进版头插法">改进版头插法</h3>
<p>我改进后的头插法可以反转任意子链表，适用性极强</p>
<p>具体步骤如下：</p>
<blockquote>
<ol type="1">
<li>选取待反转链表头节点的前一个节点作为<code>dummyHead</code>，如果没有则新增</li>
<li>头节点是反转链表后的尾节点；故而每次将头节点的后一个节点插入至<code>dummyHead</code>后</li>
</ol>
</blockquote>
<p>以反转{1, 2, 3, 4, 5}的子链表{2, 3, 4}为例：</p>
<p>选取节点1作为<code>dummyHead</code>，节点2为子链表表头<code>head</code></p>
<p>真正需要移动的则是节点<code>cur</code>，代表节点<code>head</code>的下一个节点</p>
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/10.png" class="" title="image-20230519104358978">
<p>每次将节点<code>cur</code>插入至<code>dummyHead</code>节点之后即可</p>
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/11.png" class="" title="image-20230519110340843">
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/12.png" class="" title="image-20230519114002089">
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/13.png" class="" title="image-20230519112704137">
<p>根据上述步骤描述，很容易就能写出代码了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">			<span class="keyword">while</span> (head-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				ListNode *tmp = head-&gt;next;</span><br><span class="line">				head-&gt;next = tmp-&gt;next;</span><br><span class="line">				tmp-&gt;next = dummyHead-&gt;next;</span><br><span class="line">				dummyHead-&gt;next = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>231. 2 的幂</title>
    <url>/2023/07/04/231-2-%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li><code>n &amp; (n - 1)</code>技巧</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>若满足2的幂次，二进制位有且只有一个1</p>
<p>所以使用<code>n &amp; (n - 1)</code>技巧去掉最后一个1，判断是否为空即可</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>21. 合并两个有序链表</title>
    <url>/2023/07/02/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的合并</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">			ListNode *cur1 = list1, *cur2 = list2, *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *curNew = dummyHead;</span><br><span class="line">			<span class="keyword">while</span> (cur1 != <span class="literal">nullptr</span> &amp;&amp; cur2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				<span class="keyword">while</span> (cur1 != <span class="literal">nullptr</span> &amp;&amp; cur2 != <span class="literal">nullptr</span> &amp;&amp; cur1-&gt;val &lt;= cur2-&gt;val) &#123;</span><br><span class="line">					curNew-&gt;next = cur1;</span><br><span class="line">					curNew = curNew-&gt;next;</span><br><span class="line">					cur1 = cur1-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">while</span> (cur1 != <span class="literal">nullptr</span> &amp;&amp; cur2 != <span class="literal">nullptr</span> &amp;&amp; cur2-&gt;val &lt;= cur1-&gt;val) &#123;</span><br><span class="line">					curNew-&gt;next = cur2;</span><br><span class="line">					curNew = curNew-&gt;next;</span><br><span class="line">					cur2 = cur2-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			curNew-&gt;next = cur1 != <span class="literal">nullptr</span> ? cur1 : cur2;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>设<code>list1</code>链表的游标指针为<code>cur1</code>，<code>list2</code>链表的游标指针为<code>cur2</code></p>
<p>两个链表已经是升序，所以两个指针同时从头开始比较，每次取最小值插入新链表</p>
<p>如果某个链表提前结束，其余部分直接接入新链表即可；因为旧链表剩余部分的值肯定比新链表的值都要大</p>
<p>重点讲一下递归的做法：</p>
<ol type="1">
<li>子问题：每次记录两个指针中的最小值，然后串起来变成新链表</li>
<li>递归语句顺序：递归方向分为一去一回，去方向到达临界点后返回；在去方向判断符合条件的节点，在回方向将节点们串起来</li>
<li>返回值：返回符合条件的节点，供以上一个节点修改它的<code>next</code>值</li>
<li>临界点：两个指针均为<code>nullptr</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (list1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> list2;</span><br><span class="line">			<span class="keyword">if</span> (list2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> list1;</span><br><span class="line">			<span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;</span><br><span class="line">				list1-&gt;next = <span class="built_in">mergeTwoLists</span>(list1-&gt;next, list2);</span><br><span class="line">				<span class="keyword">return</span> list1;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				list2-&gt;next = <span class="built_in">mergeTwoLists</span>(list1, list2-&gt;next);</span><br><span class="line">				<span class="keyword">return</span> list2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>234. 回文链表</title>
    <url>/2023/07/02/234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>快慢指针/双指针</li>
<li>链表的反转</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">judgeFunc</span><span class="params">(ListNode* head, ListNode* midNode)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (ListNode *left = head, *right = midNode-&gt;next; right != <span class="literal">nullptr</span>; left = left-&gt;next, right = right-&gt;next) &#123;</span><br><span class="line">				<span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* dummyHead)</span> </span>&#123;</span><br><span class="line">			ListNode *tail = dummyHead-&gt;next;</span><br><span class="line">			<span class="keyword">while</span> (tail-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				ListNode *node = tail-&gt;next;</span><br><span class="line">				tail-&gt;next = node-&gt;next;</span><br><span class="line">				node-&gt;next = dummyHead-&gt;next;</span><br><span class="line">				dummyHead-&gt;next = node;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">ListNode* <span class="title">findMid</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *slow = head, *fast = head;</span><br><span class="line">			<span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				slow = slow-&gt;next;</span><br><span class="line">				fast = fast-&gt;next-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> slow;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">return</span> (<span class="built_in">judgeFunc</span>(head, <span class="built_in">reverseList</span>(<span class="built_in">findMid</span>(head))));</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>验证回文串，最直接的方法就是双指针，左指针从头向尾遍历，右指针从尾向头遍历，只要两个指针指向的值不一样就肯定不是回文串</p>
<ol type="1">
<li><p>子问题：两个指针反向遍历，比较两个指针指向的值</p></li>
<li><p>递归语句顺序：递归方向分为一去一回，去方向到达临界点后返回；这里只能在回方向操作，因为右指针需要从尾向头遍历</p>
<p>左指针怎么办呢？额外单独设置一个成员变量即可，待右指针开始从尾向头遍历时再做比较</p></li>
<li><p>返回值：不需要返回值</p></li>
<li><p>临界点：右指针为空</p></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">bool</span> ans;</span><br><span class="line">		ListNode *left;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">recursiveFunc</span><span class="params">(ListNode *right)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (right == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">			<span class="built_in">recursiveFunc</span>(right-&gt;next);</span><br><span class="line">			<span class="keyword">if</span>(left-&gt;val != right-&gt;val) ans = <span class="literal">false</span>;</span><br><span class="line">			left = left-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			left = head;</span><br><span class="line">			ans = <span class="literal">true</span>;</span><br><span class="line">			<span class="built_in">recursiveFunc</span>(head);</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但题目要求只能以常数空间复杂度运行，故而不能使用递归；用迭代分为以下几个步骤</p>
<ol type="1">
<li>找到链表中心点，分为左、右两个子链表</li>
<li>右子链表反转</li>
<li>即可对左、右两个子链表进行同向比较了</li>
</ol>
<p>这里有一个可有可无的Trick</p>
<blockquote>
<p>如果是奇数个链表节点，比如<code>&#123;1, 2, 3, 4, 5&#125;</code>，找到的链表中心点是<code>3</code></p>
<p>如果是偶数个链表节点，比如<code>&#123;1, 2, 3, 4&#125;</code>，则找到的链表中心点应为<code>2</code></p>
<p>这样中心点就可以作为右子链表的<code>dummyHead</code>，便于反转</p>
</blockquote>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>237. 删除链表中的节点</title>
    <url>/2023/07/03/237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>智力题</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">            node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">            node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>一道脑筋急转弯的题目</p>
<p>要求中提到<code>并且保证给定的节点</code>node<code>不是链表中的最后一个节点</code>，那么直接用下一个节点覆盖自己就行</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>24. 两两交换链表中的节点</title>
    <url>/2023/07/02/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的反转</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">			ListNode *subDummy = dummyHead;</span><br><span class="line">			<span class="keyword">while</span> (subDummy-&gt;next != <span class="literal">nullptr</span> &amp;&amp; subDummy-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				ListNode *nodeOne = subDummy-&gt;next;</span><br><span class="line">				ListNode *nodeTwo = subDummy-&gt;next-&gt;next;</span><br><span class="line">				nodeOne-&gt;next = nodeTwo-&gt;next;</span><br><span class="line">				nodeTwo-&gt;next = subDummy-&gt;next;</span><br><span class="line">				subDummy-&gt;next = nodeTwo;</span><br><span class="line">				subDummy = nodeOne;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题目说<code>两两交换其中相邻的节点</code>，我完全可以理解为：</p>
<blockquote>
<p>执行若干次反转长度为2的子链表操作</p>
</blockquote>
<p>那么就可以使用改进版头插法完成这一操作</p>
<p>设每个子链表的<code>dummyHead</code>名称为<code>subDummy</code>，子链表的第一个节点名称为<code>nodeOne</code>，第二个节点名称为<code>nodeTwo</code></p>
<img src="/2023/07/02/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/1.png" class="" title="image-20230519161147419">
<p>子链表{1,
2}反转结束后，可以发现<code>nodeOne</code>所处的位置恰好就是下一个子链表{3,
4}的<code>subDummy</code></p>
<img src="/2023/07/02/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/2.png" class="" title="image-20230519161837109">
<p>故而将<code>nodeOne</code>赋值给<code>subDummy</code>后开启下一轮反转</p>
<img src="/2023/07/02/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/3.png" class="" title="image-20230519162601816">
<p>子链表{3, 4}反转结束后，发现子链表{5}长度不等于2，结束循环</p>
<img src="/2023/07/02/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/4.png" class="" title="image-20230519162952720">
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>25. K 个一组翻转链表</title>
    <url>/2023/07/02/25-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的反转</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head), *subDummyHead = dummyHead;</span><br><span class="line">			<span class="keyword">while</span> (subDummyHead-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				ListNode *tmp = subDummyHead;</span><br><span class="line">				<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (; i &lt; k &amp;&amp; tmp != <span class="literal">nullptr</span>; i++) tmp = tmp-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) <span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">//使用改进版头插法进行反转子链表</span></span><br><span class="line">				ListNode *tail = subDummyHead-&gt;next;</span><br><span class="line">				<span class="keyword">while</span> (--i) &#123;</span><br><span class="line">					ListNode *node = tail-&gt;next;</span><br><span class="line">					tail-&gt;next = node-&gt;next;</span><br><span class="line">					node-&gt;next = subDummyHead-&gt;next;</span><br><span class="line">					subDummyHead-&gt;next = node;</span><br><span class="line">				&#125;</span><br><span class="line">				subDummyHead = tail;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>凡是链表翻转类的题目，使用<code>改进版头插法</code>就对了，详见<code>206. 反转链表</code></p>
<p>因为题目是要求每次翻转长度为K的子链表，除了要在子链表头前再找一个节点作为<code>dummyHead</code>外，每次还要先判断子链表长度是不是K</p>
<p>每次翻转结束后，当前子链表的尾节点恰好就是下一组子链表的<code>dummyHead</code>，从而开启新一轮的翻转</p>
<p>其余代码套<code>改进版头插法</code>的模板就好了</p>
<p>这里改成递归也行，但是和迭代没太大区别</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">recursiveFunc</span><span class="params">(ListNode* subDummyHead, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">			ListNode *tmp = subDummyHead;</span><br><span class="line">			<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (; i &lt; k &amp;&amp; tmp != <span class="literal">nullptr</span>; i++) tmp = tmp-&gt;next;</span><br><span class="line">			<span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">			<span class="comment">//使用改进版头插法进行反转子链表</span></span><br><span class="line">			ListNode *tail = subDummyHead-&gt;next;</span><br><span class="line">			<span class="keyword">while</span> (--i) &#123;</span><br><span class="line">				ListNode *node = tail-&gt;next;</span><br><span class="line">				tail-&gt;next = node-&gt;next;</span><br><span class="line">				node-&gt;next = subDummyHead-&gt;next;</span><br><span class="line">				subDummyHead-&gt;next = node;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">recursiveFunc</span>(tail, k);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">			<span class="built_in">recursiveFunc</span>(dummyHead, k);</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>260. 只出现一次的数字 III</title>
    <url>/2023/07/04/260-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-III/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>状态压缩</li>
<li>排列组合</li>
<li>异或技巧</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//这里使用long，避免计算lsb即最低有效位时溢出</span></span><br><span class="line">			<span class="type">long</span> xorSum = <span class="number">0</span>, lsb = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;num : nums) xorSum ^= num;</span><br><span class="line">			<span class="comment">//按最低有效位所在的比特位进行比较与分割</span></span><br><span class="line">			<span class="type">int</span> ans_1 = <span class="number">0</span>;</span><br><span class="line">			lsb = (xorSum &amp; (-xorSum));</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;num : nums) &#123;</span><br><span class="line">				<span class="keyword">if</span> (num &amp; lsb) ans_1 ^= num;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;ans_1, (<span class="type">int</span>)(xorSum ^ ans_1)&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( n
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>类似<code>136. 只出现一次的数字</code>，同样对数组的所有元素进行异或运算，得到<code>xorSum</code>；实际上就是最终两个答案的异或值，且必不为0</p>
<p>取<code>xorSum</code>任意一个值为1的比特位，记为<code>i</code>；其代表两个答案在<code>i</code>上不同，一个必为1一个必为0</p>
<p>根据在<code>i</code>上的值为0或1，将所有元素进行分组，两个答案必不在一个组；随后对每个组分别求异或和，即可得到两个答案</p>
<p>比如<code>nums</code>等于<code>&#123;1,1,2,2,3,5&#125;</code>，二进制表达为<code>&#123;001,001,010,010,011,101&#125;</code>
，<code>xorSum</code>为<code>110</code></p>
<p>这里取<code>i</code>为<code>010</code>，即<code>xorSum</code>的最低有效位</p>
<p>与<code>i</code>作与运算为0的，子集合为<code>&#123;001,001,101&#125;</code>；与<code>i</code>作与运算为1的，子集合为<code>&#123;010,010,011&#125;</code></p>
<p>任意取一个子集合作异或运算求和，即可得到其中一个答案；将这个答案与<code>xorSum</code>作异或运算，即可得到另一个答案</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>状态压缩</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>268. 丢失的数字</title>
    <url>/2023/07/04/268-%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>异或技巧</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> xorSum = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= (<span class="type">int</span>)nums.<span class="built_in">size</span>(); i++) xorSum ^= i;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;num : nums) xorSum ^= num;</span><br><span class="line">			<span class="keyword">return</span> xorSum;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( n
\right)\)</span>，其中<span
class="math inline">\(n\)</span>为数组长度</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>假设给定范围为<span
class="math inline">\(a_{0...3}\)</span>，<code>nums</code>的值为<span
class="math inline">\(\left\{ a_0,a_1,a_3
\right\}\)</span>，则需要找到<span
class="math inline">\(a_2\)</span></p>
<p>根据异或的性质<code>a ^ a = 0</code>与<code>a ^ 0 = a</code>，必有以下恒等式成立：
<span class="math display">\[
\left( a_0\oplus a_1\oplus a_2\oplus a_3 \right) \oplus \left( a_0\oplus
a_1\oplus a_3 \right) =a_2
\]</span>
故而先求出<code>0 ~ nums.size()</code>的异或和，再与<code>nums</code>的元素逐个异或即可得出缺失的元素</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>318. 最大单词长度乘积</title>
    <url>/2023/07/04/318-%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>状态压缩</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (string &amp;word : words) &#123;</span><br><span class="line">				<span class="type">int</span> hsh = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">char</span> &amp;chr : word) &#123;</span><br><span class="line">					hsh |= <span class="number">1</span> &lt;&lt; (chr - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				m[hsh] = <span class="built_in">max</span>(m[hsh], (<span class="type">int</span>)word.<span class="built_in">length</span>());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> it_1 = m.<span class="built_in">begin</span>(); it_1 != m.<span class="built_in">end</span>(); it_1++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span> it_2 = <span class="built_in">next</span>(it_1); it_2 != m.<span class="built_in">end</span>(); it_2++) &#123;</span><br><span class="line">					<span class="keyword">if</span> ((it_1-&gt;first &amp; it_2-&gt;first) == <span class="number">0</span>) &#123;</span><br><span class="line">						ans = <span class="built_in">max</span>(ans, it_1-&gt;second * it_2-&gt;second);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( \max \left(
\sum\nolimits_{0\leqslant i\leqslant n-1}^{}{words\left[ i
\right]}.length,n^2 \right) \right)\)</span>，<span
class="math inline">\(n\)</span>为<span
class="math inline">\(words\)</span>数组长度</p>
<p>其中构造哈希表的时间复杂度为<span class="math inline">\(O\left(
\sum\nolimits_{0\leqslant i\leqslant n-1}^{}{words\left[ i
\right]}.length \right)\)</span>，计算最大乘积的时间复杂度为<span
class="math inline">\(O\left( n^2 \right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( n
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>按照传统的办法，比较两个字符串的组成需要新建哈希表并遍历，耗时<span
class="math inline">\(O\left( n \right)\)</span></p>
<p>若按照题意，所有字符串两两比较，时间复杂度高达<span
class="math inline">\(O\left( n^3 \right)\)</span>，是绝对不可取的</p>
<p>题目限制了字符串只含有小写字母，可以使用一个<code>int</code>的低26位来记录字符串中的字母组成</p>
<p>该<code>int</code>可以作为哈希表的键，值则是对应字符串的长度；字母的组成肯定有雷同，所以只记录组成相同里长度最大的</p>
<p>最后再双重遍历哈希表，寻找长度乘积最大的即可</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>状态压缩</tag>
        <tag>哈希函数</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>338. 比特位计数</title>
    <url>/2023/07/04/338-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>比特位变化规律，按最高位变化、最低位变化与Brian
Kernighan算法三种角度分析</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>同下</p>
<h1 id="思路">思路</h1>
<p>假设<code>i</code>代表当前十进制数字，<code>dp[i]</code>代表十进制数字<code>i</code>的<code>1个数</code></p>
<h2 id="最高有效位">最高有效位</h2>
<p>设<code>i</code>的最高有效位保存至变量<code>highBit</code>；显然<code>110</code>是由<code>100 + 010</code>组成，<code>101</code>是由<code>100 + 001</code>组成，满足：</p>
<blockquote>
<p>i的1个数 = 1[代表highBit] + (i - highBit)的1个数</p>
</blockquote>
<p>将其转化为动态规划转移方程： <span class="math display">\[
dp\left[ i \right] =1+dp\left[ i-highBit \right]
\]</span>
遇到<code>001</code>、<code>010</code>这类2的幂次，代表有新的进位；此时更新<code>highBit</code>变量，避免后续数字重复计算<code>highBit</code></p>
<p>如果范围不大，也可以先将范围内所有的<code>highBit</code>通过打表存入数组，在许多场景都有该应用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="type">int</span> highBit = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!(i &amp; (i - <span class="number">1</span>))) highBit = i;</span><br><span class="line">				dp[i] = dp[i - highBit] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dp;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( n
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( n
\right)\)</span>，新增了<code>dp</code>数组存储结果</p>
<h2 id="最低有效位">最低有效位</h2>
<p>根据奇偶性分析</p>
<ul>
<li><p>若<code>i</code>是偶数，<code>1个数</code>肯定与<code>i/2</code>一致，因为<code>i</code>是由<code>i/2</code>的比特位向左移一位而成</p>
<p>比如<code>100</code>是<code>010</code>向左移了一位，<code>1个数</code>保持不变</p></li>
<li><p>若<code>i</code>是奇数，必满足<code>i的1个数 = i/2的1个数 + 1</code></p>
<p>比如<code>111</code>是<code>011</code>向左移一位后再加上<code>001</code></p></li>
</ul>
<p>将其转化为动态规划转移方程： <span class="math display">\[
dp\left[ i \right] =\begin{cases}
    dp\left[ i/2 \right] \text{，}i\text{为偶数}\\
    dp\left[ i/2 \right] +1\text{，}i\text{为奇数}\\
\end{cases}
\]</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">				dp[i] = i &amp; <span class="number">1</span> ? dp[i / <span class="number">2</span>] + <span class="number">1</span> : dp[i / <span class="number">2</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dp;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( n
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( n
\right)\)</span>，新增了<code>dp</code>数组存储结果</p>
<h2 id="brian-kernighan算法">Brian Kernighan算法</h2>
<p>根据<code>i &amp; (i - 1)</code>可以去掉<code>i</code>的最低有效1这一性质，满足：</p>
<blockquote>
<p>i的1个数 = 1[代表Brian Kernighan操作去掉的1] + (i &amp; (i -
1))的1个数</p>
</blockquote>
<p>将其转化为动态规划转移方程： <span class="math display">\[
dp\left[ i \right] =1+dp\left[ i\,\,\&amp; \left( i-1 \right) \right]
\]</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">				dp[i] = dp[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dp;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( n
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( n
\right)\)</span>，新增了<code>dp</code>数组存储结果</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>328. 奇偶链表</title>
    <url>/2023/07/02/328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的合并</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">			ListNode *dummyHeadA = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *curA = dummyHeadA, *dummyHeadB = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *curB = dummyHeadB;</span><br><span class="line">			<span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (cnt++ % <span class="number">2</span>) &#123;</span><br><span class="line">					curA-&gt;next = head;</span><br><span class="line">					curA = curA-&gt;next;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					curB-&gt;next = head;</span><br><span class="line">					curB = curB-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">				head = head-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			curA-&gt;next = dummyHeadB-&gt;next;</span><br><span class="line">			curB-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">return</span> dummyHeadA-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>新建两个伪节点，各用来构成奇链表与偶链表</p>
<p>遍历链表时，奇数节点插入至奇链表，偶数节点插入至偶链表；最终将偶链表接在奇链表末尾即可</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>371. 两整数之和</title>
    <url>/2023/07/04/371-%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>异或技巧</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> carry, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (carry) &#123;</span><br><span class="line">				<span class="type">int</span> tmp = sum;</span><br><span class="line">				sum = carry ^ tmp;</span><br><span class="line">				carry = (carry &amp; tmp) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> sum;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：存在异议，但个人认为不会超过32次</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>记住这个位运算小技巧就好了，假设有<code>a</code>和<code>b</code>两个整数，不限正负</p>
<ul>
<li><span class="math inline">\(a\oplus
b\)</span>可得到<code>a</code>与<code>b</code>的无进位加法结果</li>
<li><span class="math inline">\(\left( a\&amp;b \right)
&lt;&lt;1\)</span>可得到<code>a</code>与<code>b</code>的加法进位</li>
</ul>
<p>由于进位可能会溢出，比如<code>-1 + 1</code>这组数据；所以需用无符号类型保存进位</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>405. 数字转换为十六进制数</title>
    <url>/2023/07/04/405-%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>掩码技巧</li>
<li>移位技巧</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		string ans;</span><br><span class="line">		<span class="type">char</span> chr[<span class="number">16</span>] = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span></span><br><span class="line">		                , <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span></span><br><span class="line">		               &#125;;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">string <span class="title">toHex</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (!num) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">			<span class="keyword">while</span> (num) &#123;</span><br><span class="line">				ans = chr[num &amp; <span class="number">0b1111</span>] + ans;</span><br><span class="line">				num &gt;&gt;= <span class="number">4</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( k
\right)\)</span>，在这里<span
class="math inline">\(k\)</span>等于<code>32 / 4 = 8</code>，即32位整数的十六进制位数</p>
<p>空间复杂度：<span class="math inline">\(O\left( k
\right)\)</span>，同上</p>
<h1 id="思路">思路</h1>
<p>首先将整数从<code>int</code>转换为<code>unsigned int</code>，因为C++当中没有无符号运算符；倘若整数为<code>int</code>类型的负数，右移时会在高位补1</p>
<p>同时题目要求不包含前导零，所以每次循环之前需要判断整数是否为空</p>
<p>整数和掩码<code>1111</code>作与运算取出低四位，并将其倒序保存至字符串后，整数右移四位开启下一轮循环</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>432. 全 O(1) 的数据结构</title>
    <url>/2023/07/03/432-%E5%85%A8-O-1-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>哈希表与链表的综合</li>
<li>掌握迭代器、<code>pair</code>、<code>unordered_set</code>与<code>unordered_map</code>的本质</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AllOne</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		list &lt;pair&lt;<span class="type">int</span>, unordered_set&lt;string&gt; &gt; &gt; l;</span><br><span class="line">		unordered_map &lt;string, list &lt;pair&lt;<span class="type">int</span>, unordered_set&lt;string&gt; &gt; &gt;::iterator&gt; m;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">AllOne</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">(string key)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">auto</span> it = m.<span class="built_in">find</span>(key);</span><br><span class="line">			<span class="keyword">if</span> (it == m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">				<span class="comment">//如果是新字符串</span></span><br><span class="line">				<span class="comment">//链表为空，或头节点次数不为1；则需新建头节点</span></span><br><span class="line">				<span class="keyword">if</span> (l.<span class="built_in">empty</span>() || l.<span class="built_in">front</span>().first &gt; <span class="number">1</span>) &#123;</span><br><span class="line">					l.<span class="built_in">emplace_front</span>(<span class="number">1</span>, unordered_set&lt;string&gt; &#123;key&#125;);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//头节点次数为1，新字符串直接插入即可</span></span><br><span class="line">					l.<span class="built_in">front</span>().second.<span class="built_in">emplace</span>(key);</span><br><span class="line">				&#125;</span><br><span class="line">				m[key] = l.<span class="built_in">begin</span>();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">auto</span> node = it-&gt;second, nextNode = <span class="built_in">next</span>(node);</span><br><span class="line">				<span class="keyword">if</span> (nextNode == l.<span class="built_in">end</span>() || nextNode-&gt;first &gt; node-&gt;first + <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="comment">//如果字符串所在的节点是链表末尾</span></span><br><span class="line">					<span class="comment">//或者下一个节点的次数大于当前次数+1</span></span><br><span class="line">					<span class="comment">//说明需要新建节点</span></span><br><span class="line">					m[key] = l.<span class="built_in">emplace</span>(nextNode, node-&gt;first + <span class="number">1</span>, unordered_set&lt;string&gt; &#123;key&#125;);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//下一个节点次数等于当前次数+1，直接插入即可</span></span><br><span class="line">					nextNode-&gt;second.<span class="built_in">emplace</span>(key);</span><br><span class="line">					m[key] = nextNode;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//删除旧地方的字符串</span></span><br><span class="line">				node-&gt;second.<span class="built_in">erase</span>(key);</span><br><span class="line">				<span class="keyword">if</span> (node-&gt;second.<span class="built_in">empty</span>()) l.<span class="built_in">erase</span>(node);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">dec</span><span class="params">(string key)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">auto</span> node = m[key], prevNode = <span class="built_in">prev</span>(node);</span><br><span class="line">			<span class="keyword">if</span> (node-&gt;first != <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (node == l.<span class="built_in">begin</span>() || prevNode-&gt;first &lt; node-&gt;first - <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="comment">//前一个节点的次数小于当前次数-1</span></span><br><span class="line">					<span class="comment">//或者前一个节点为空</span></span><br><span class="line">					<span class="comment">//说明需要新建节点</span></span><br><span class="line">					m[key] = l.<span class="built_in">emplace</span>(node, node-&gt;first - <span class="number">1</span>, unordered_set&lt;string&gt; &#123;key&#125;);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//上一个节点次数等于当前次数-1，直接插入即可</span></span><br><span class="line">					prevNode-&gt;second.<span class="built_in">emplace</span>(key);</span><br><span class="line">					m[key] = prevNode;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//如果节点次数为1，直接删除</span></span><br><span class="line">				m.<span class="built_in">erase</span>(key);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//删除旧地方的字符串</span></span><br><span class="line">			node-&gt;second.<span class="built_in">erase</span>(key);</span><br><span class="line">			<span class="keyword">if</span> (node-&gt;second.<span class="built_in">empty</span>()) l.<span class="built_in">erase</span>(node);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">string <span class="title">getMaxKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> l.<span class="built_in">empty</span>() ? <span class="string">&quot;&quot;</span> : *(l.<span class="built_in">back</span>().second.<span class="built_in">begin</span>());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">string <span class="title">getMinKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> l.<span class="built_in">empty</span>() ? <span class="string">&quot;&quot;</span> : *(l.<span class="built_in">front</span>().second.<span class="built_in">begin</span>());</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本题难度极高，对哈希表、链表、迭代器的熟练度都是极大的考验，是非常棒的综合题！</p>
<p>在完成本题前，请先完成<code>460. LFU 缓存</code>与<code>146. LRU 缓存</code>，掌握基本的哈希表与链表的结合思路</p>
<p>题目希望给每个字符串计数，可增可减，所有操作为常数时间复杂度；并返回计数最大与最小的字符串，如果计数为0，则将其删除</p>
<ol type="1">
<li><p><strong>可以参考LFU，只使用变量来记录极值吗？</strong></p>
<p>LFU是单向操作，只增无减，统计极值用变量即可胜任</p>
<p>本题有增有减，只用变量很难记录空间的动态变化，必须依赖容器来完成这一操作</p></li>
<li><p><strong>可以参考LFU的数据结构吗？</strong></p>
<p>若参考LFU，使用<code>unordered_map</code>，则键为次数，给每个键单独新建链表作为值</p>
<p>那么只能用变量来记录键的极值，因为<code>unordered_map</code>是无序的，方才提过用变量是死路</p>
<p>若使用<code>map</code>，键虽有序但达不到常数时间复杂度</p>
<p>故而LFU的数据结构无法照搬</p></li>
</ol>
<p>联想LRU用到的有序双向链表技巧，表头是最晚访问元素，表尾是最早访问元素，极值就在两侧</p>
<p>可以设计数据结构如下：</p>
<ul>
<li><p>新建一个双向链表，链表节点为键值对，键为次数，值为<code>unordered_set</code>以存储字符串</p>
<p>次数增加，则在当前节点之后新增节点/修改下一个节点；次数减少，则在当前节点之前新增节点/修改前一个节点</p>
<p>从而保证了链表表头为次数最小值，链表表尾为次数最大值</p></li>
<li><p>新建一个哈希表，键为字符串，值为对应次数的链表节点地址</p></li>
</ul>
<img src="/2023/07/03/432-%E5%85%A8-O-1-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.png" class="" title="image-20230608215736025">
<ol start="3" type="1">
<li><p><strong>为什么设计“左小右大”？而不是像LRU一样”左大右小“？</strong></p>
<p>若是<code>左大右小</code>，每次新增的节点都将在链表表尾，返回表尾元素的迭代器则是<a
href="https://cplusplus.com/reference/list/list/rbegin/">rbegin</a>方法，且这个迭代器是<code>reverse_iterator</code>类型</p>
<blockquote>
<p><code>reverse_iterator</code>类型是对<code>iterator</code>类型的封装，可<a
href="https://cplusplus.com/reference/iterator/reverse_iterator/">参见</a></p>
</blockquote>
<p>双向链表list删除节点时，使用的是<a
href="https://cplusplus.com/reference/list/list/erase/">erase</a>方法，它只支持<code>iterator</code>类型参数</p>
<p>返回表头元素迭代器的方法<a
href="https://cplusplus.com/reference/list/list/begin/">begin</a>，满足这一条件。故而选择<code>左小右大</code></p></li>
<li><p><strong>为什么双向链表的节点不选择<code>unordered_map</code>，而选择<code>pair</code>?</strong></p>
<p>因为<code>unordered_map</code>与<code>map</code>都没有<code>取出键</code>这一个操作，哈希表的意义就是<code>通过键访问值</code></p>
<p>实际上，我们需要的是一个类似结构体的容器，第一个元素存储次数，第二个元素存储<code>unordered_set</code></p>
<p>这样一来前后节点比较次数时，直接取节点容器的第一个元素对比即可</p>
<p><code>pair</code>恰好满足，当然你乐意的话可以自写结构体</p></li>
<li><p><strong>为什么存储字符串选择<code>unordered_set</code>，而不是<code>vector</code>？</strong></p>
<p>因为字符串在不同节点之间转移时，所经历的步骤就是</p>
<ol type="1">
<li>从原节点存储删除</li>
<li>插入新节点存储</li>
</ol>
<p>知道一个值，怎么在常数时间复杂度从存储中删除呢？只有哈希表了！</p>
<p>哈希表当中键与值相等的是什么STL？当然是<code>unordered_set</code>和<code>set</code></p></li>
</ol>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>445. 两数相加 II</title>
    <url>/2023/07/02/445-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-II/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的合并</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">			stack&lt;<span class="type">int</span>&gt; list1, list2;</span><br><span class="line">			<span class="keyword">while</span> (l1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				list1.<span class="built_in">push</span>(l1-&gt;val);</span><br><span class="line">				l1 = l1-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				list2.<span class="built_in">push</span>(l2-&gt;val);</span><br><span class="line">				l2 = l2-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">while</span> (!list1.<span class="built_in">empty</span>() || !list2.<span class="built_in">empty</span>() || carry) &#123;</span><br><span class="line">				carry += !list1.<span class="built_in">empty</span>() ? list1.<span class="built_in">top</span>() : <span class="number">0</span>;</span><br><span class="line">				carry += !list2.<span class="built_in">empty</span>() ? list2.<span class="built_in">top</span>() : <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (!list1.<span class="built_in">empty</span>()) list1.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="keyword">if</span> (!list2.<span class="built_in">empty</span>()) list2.<span class="built_in">pop</span>();</span><br><span class="line">				ListNode *node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry % <span class="number">10</span>, dummyHead-&gt;next);</span><br><span class="line">				dummyHead-&gt;next = node;</span><br><span class="line">				carry /= <span class="number">10</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>按照算术逻辑，运算应该从低位到高位，同时用一个变量<code>carry</code>记录进位</p>
<p>那么新节点的值就等于<strong>(对应位之和+上一次运算的<code>carry</code>)取余10</strong>，进位<code>carry</code>的值就等于<strong>(对应位之和+上一次运算的<code>carry</code>)除以10</strong></p>
<p>故而正常思维，两个链表先反转并作运算，新的节点以头插的方式连接，这样就保证了逆序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function">ListNode* <span class="title">reverseFunc</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//头插法反转链表</span></span><br><span class="line">		ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head), *tail = head;</span><br><span class="line">		<span class="keyword">while</span> (tail-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			ListNode *node = tail-&gt;next;</span><br><span class="line">			tail-&gt;next = node-&gt;next;</span><br><span class="line">			node-&gt;next = dummyHead-&gt;next;</span><br><span class="line">			dummyHead-&gt;next = node;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">		ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">		l1 = <span class="built_in">reverseFunc</span>(l1);</span><br><span class="line">		l2 = <span class="built_in">reverseFunc</span>(l2);</span><br><span class="line">		<span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> || l2 != <span class="literal">nullptr</span> || carry) &#123;</span><br><span class="line">			carry += l1 != <span class="literal">nullptr</span> ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">			carry += l2 != <span class="literal">nullptr</span> ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//头插法新建链表即逆序</span></span><br><span class="line">			ListNode *node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry % <span class="number">10</span>, dummyHead-&gt;next);</span><br><span class="line">			dummyHead-&gt;next = node;</span><br><span class="line">			carry /= <span class="number">10</span>;</span><br><span class="line">			l1 = l1 != <span class="literal">nullptr</span> ? l1-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">			l2 = l2 != <span class="literal">nullptr</span> ? l2-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是题目竟然要求不反转链表？那就只能用栈了，代码如题解所示</p>
<p>两个链表的值先入栈，保证低位对低位；每次对应位出栈做运算，新的节点同样以头插的方式连接保证逆序</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>460. LFU 缓存</title>
    <url>/2023/07/03/460-LFU-%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>哈希表与链表的综合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">			<span class="type">int</span> key;</span><br><span class="line">			<span class="type">int</span> value;</span><br><span class="line">			<span class="type">int</span> freq;</span><br><span class="line">			<span class="built_in">Node</span>(<span class="type">int</span> _key, <span class="type">int</span> _value, <span class="type">int</span> _freq) : <span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value), <span class="built_in">freq</span>(_freq) &#123;&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="type">int</span> capacity;</span><br><span class="line">		<span class="type">int</span> minFreq;</span><br><span class="line">		unordered_map&lt;<span class="type">int</span>, list&lt;Node&gt;::iterator&gt; key2List;</span><br><span class="line">		unordered_map&lt;<span class="type">int</span>, list&lt;Node&gt;&gt; freq2List;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">LFUCache</span>(<span class="type">int</span> _capacity) : <span class="built_in">capacity</span>(_capacity), <span class="built_in">minFreq</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">auto</span> it = key2List.<span class="built_in">find</span>(key);</span><br><span class="line">			<span class="keyword">if</span> (it == key2List.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			<span class="type">int</span> value = it-&gt;second-&gt;value, freq = it-&gt;second-&gt;freq;</span><br><span class="line">			<span class="comment">//从对应的频率链表中删除节点</span></span><br><span class="line">			freq2List[freq].<span class="built_in">erase</span>(it-&gt;second);</span><br><span class="line">			<span class="comment">//删除节点后频率链表为空的情况</span></span><br><span class="line">			<span class="keyword">if</span> (freq2List[freq].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">				<span class="comment">//如果当前频率就是最小频率，说明需要更新最小频率</span></span><br><span class="line">				<span class="keyword">if</span> (minFreq == freq) minFreq++;</span><br><span class="line">				<span class="comment">//删除空频率链表</span></span><br><span class="line">				freq2List.<span class="built_in">erase</span>(freq);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//将节点插入至新频率链表</span></span><br><span class="line">			freq2List[freq + <span class="number">1</span>].<span class="built_in">emplace_front</span>(key, value, freq + <span class="number">1</span>);</span><br><span class="line">			key2List[key] = freq2List[freq + <span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">auto</span> it = key2List.<span class="built_in">find</span>(key);</span><br><span class="line">			<span class="comment">//新增节点的情况</span></span><br><span class="line">			<span class="keyword">if</span> (it == key2List.<span class="built_in">end</span>()) &#123;</span><br><span class="line">				<span class="comment">//如果没有容量，直接不作考虑</span></span><br><span class="line">				<span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">				<span class="comment">//如果容量已经满了</span></span><br><span class="line">				<span class="comment">//删除最小频率且最早访问的节点</span></span><br><span class="line">				<span class="comment">//即删除最小频率链表的尾节点</span></span><br><span class="line">				<span class="keyword">if</span> (key2List.<span class="built_in">size</span>() == (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)capacity) &#123;</span><br><span class="line">					key2List.<span class="built_in">erase</span>(freq2List[minFreq].<span class="built_in">back</span>().key);</span><br><span class="line">					freq2List[minFreq].<span class="built_in">pop_back</span>();</span><br><span class="line">				&#125;</span><br><span class="line">				freq2List[<span class="number">1</span>].<span class="built_in">emplace_front</span>(key, value, <span class="number">1</span>);</span><br><span class="line">				key2List[key] = freq2List[<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">				minFreq = <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//和get方法一样，照抄即可</span></span><br><span class="line">				<span class="type">int</span> freq = it-&gt;second-&gt;freq;</span><br><span class="line">				freq2List[freq].<span class="built_in">erase</span>(it-&gt;second);</span><br><span class="line">				<span class="keyword">if</span> (freq2List[freq].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">					<span class="keyword">if</span> (minFreq == freq) minFreq++;</span><br><span class="line">					freq2List.<span class="built_in">erase</span>(freq);</span><br><span class="line">				&#125;</span><br><span class="line">				freq2List[freq + <span class="number">1</span>].<span class="built_in">emplace_front</span>(key, value, freq + <span class="number">1</span>);</span><br><span class="line">				key2List[key] = freq2List[freq + <span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>LFU是最近最不常用页面置换算法(Least Frequently
Used)，淘汰访问次数最少的页面；若访问次数相同，淘汰同条件下最早访问的页面</p>
<p>从定义描述来看，本质上就是LRU的升级版；第一规则是访问频率，第二规则是访问时间</p>
<p>所以有如下设计思想：</p>
<ol type="1">
<li><p>设置一张<code>freq2List</code>频率哈希表，键为频率，值为双向链表的表头；其中每个频率都有自己单独的双向链表</p></li>
<li><p>与LRU一样，设置一张<code>key2List</code>哈希表记录键与链表节点的映射；键的值就是<code>freq2List</code>某个频率的双向链表中的节点</p></li>
<li><p>因为是无序哈希表，所以还需要新增一个<code>minFreq</code>变量记录最小频率</p></li>
<li><p>新节点都插入至频率为1的双向链表中，如果节点被访问/操作后，先从原频率链表中删除，再插入至新频率链表</p></li>
<li><p>如果当前频率链表为空，且频率等于<code>minFreq</code>，那么<code>minFreq++</code></p>
<p>假设有新增数据{A,
B}，A与B频率均为1，<code>minFreq</code>也为初始状态1</p>
<p>访问一次A，A的频率增为2；再访问一次A，A的频率增为3。但B频率依旧为1，<code>minFreq</code>也为1</p>
<p>只有当访问一次B后，B转移至频率为2的链表，此时<code>minFreq</code>所指的链表为空，则<code>minFreq</code>应当加1</p></li>
</ol>
<p>数据结构设计图如下。若要达成下图的情形，需经历以下步骤</p>
<blockquote>
<p>按照1、2、3的先后顺序，头插至频率为1的双向链表并同步更新两张哈希表；此时频率1的链表值为{3,
2, 1}</p>
<p>访问一次节点2，节点2从频率1链表转移至频率2链表</p>
<p>访问一次节点3，节点3从频率1链表转移至频率2链表</p>
</blockquote>
<img src="/2023/07/03/460-LFU-%E7%BC%93%E5%AD%98/1.png" class="" title="image-20230605175056397">
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>342. 4的幂</title>
    <url>/2023/07/04/342-4%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li><code>n &amp; (n - 1)</code>技巧</li>
<li>掩码技巧</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; !(n &amp; (n - <span class="number">1</span>)) &amp;&amp; (n &amp; <span class="number">0x55555555</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>4的幂，实际上就是2的幂次的平方；故而肯定大于零且只存在一个1比特位，满足这两个条件后继续找规律：</p>
<p>4的零次幂为<code>0001</code></p>
<p>4的一次幂为<code>0100</code></p>
<p>4的二次幂为<code>0001 0000</code></p>
<p>4的三次幂为<code>0100 0000</code></p>
<p>组合在一起就是<code>0101 0101</code>，十六进制表达即为<code>55</code></p>
<p>故而制作掩码<code>0x55555555</code>与原数做与运算，不为0即为4的幂次</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>461. 汉明距离</title>
    <url>/2023/07/04/461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>异或技巧</li>
<li><code>bitCount</code>的实现</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">bitCount</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">			n = (n &amp; <span class="number">0x55555555</span>) + ((n &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x33333333</span>) + ((n &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x0f0f0f0f</span>) + ((n &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x00ff00ff</span>) + ((n &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x0000ffff</span>) + ((n &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);</span><br><span class="line">			<span class="keyword">return</span> n;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">bitCount</span>(x ^ y);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( \log k
\right)\)</span>，其中<span
class="math inline">\(k\)</span>为<code>int</code>的位数，在这里是32位</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>两个数的不同位直接通过异或运算即可获得</p>
<p>计算整数<code>1个数</code>的<code>bitCount</code>实现请参见<code>191. 位1的个数</code>，这里使用耗时最短的分治法计算</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>476. 数字的补数</title>
    <url>/2023/07/04/476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>异或技巧</li>
<li>掩码技巧</li>
<li>移位技巧</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">findComplement</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> mask = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = num; i; i = i &gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">				mask = (mask &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> num ^ mask;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( \log num
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>某一个比特位要反转，直接令其<strong>异或1</strong>即可</p>
<p>假设整数去掉前导零后的真实长度为<code>n</code>，我们做一个长度也为<code>n</code>的全1掩码，然后让掩码与整数异或运算即可</p>
<blockquote>
<p>0000 0101 ^ 0000 0111 = 0000 0010</p>
</blockquote>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>477. 汉明距离总和</title>
    <url>/2023/07/04/477-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>状态压缩</li>
<li>排列组合</li>
<li>异或技巧</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">totalHammingDistance</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> ans = <span class="number">0</span>, size = nums.<span class="built_in">size</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; i++) &#123;</span><br><span class="line">				<span class="type">int</span> oneCnt = <span class="number">0</span>, mask = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (nums[j] &amp; mask) oneCnt++;</span><br><span class="line">				&#125;</span><br><span class="line">				ans += oneCnt * (size - oneCnt);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( C\cdot n
\right)\)</span>，在这里<span
class="math inline">\(C\)</span>常数等于31</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>本题是<code>461. 汉明距离</code>的升级版，如果按照普通思路，数组内的元素两两异或再计算<code>1个数</code>，时间复杂度高达<span
class="math inline">\(O\left( n^2 \right)\)</span></p>
<p>题目规定所有整数都是<code>int</code>类型的32位正数；若能求出所有元素对应的<strong>每一比特位集合的汉明距离</strong>，<strong>将它们累加求和</strong>即可得到答案</p>
<p>如下图所示，我们分别求出</p>
<ul>
<li>nums[0]、nums[1]、nums[2]三个元素的第一比特位集合，即{0,0,0}的汉明距离，在这里是0</li>
<li>nums[0]、nums[1]、nums[2]三个元素的第二比特位集合，即{0,1,1}的汉明距离，在这里是2</li>
<li>nums[0]、nums[1]、nums[2]三个元素的第三比特位集合，即{1,1,0}的汉明距离，在这里是2</li>
<li>nums[0]、nums[1]、nums[2]三个元素的第四比特位集合，即{0,1,0}的汉明距离，在这里是2</li>
<li>最后将它们累加求和，0 + 2 + 2 + 2 = 6，得到最终答案</li>
</ul>
<img src="/2023/07/04/477-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/1.png" class="" title="image-20230620125833189">
<p>如何求某一比特位集合的汉明距离呢？这里需要用到<strong>状态压缩</strong>这一思想</p>
<p>假设有比特位集合{0,1,1,1,0,0}</p>
<p>将其分成{0,0,0}和{1,1,1}两个子集合，对应元素命名为<span
class="math inline">\(\left\{ a_0,a_1,a_2 \right\}\)</span>、<span
class="math inline">\(\left\{ b_0,b_1,b_2
\right\}\)</span>，有如下算式：</p>
<img src="/2023/07/04/477-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/2.png" class="" title="image-20230620135842555">
<p>因为同一子集合内的值都相同，相互异或值恒为0，算式简化为：</p>
<img src="/2023/07/04/477-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/3.png" class="" title="image-20230620135946679">
<p>故而只需求出比特位集合中1与0的个数，并令其相乘，即可得到比特位集合的汉明距离</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>状态压缩</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>61. 旋转链表</title>
    <url>/2023/07/02/61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的裁剪</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head), *slow = dummyHead, *fast = dummyHead, *tmp = head;</span><br><span class="line">			<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (tmp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				tmp = tmp-&gt;next;</span><br><span class="line">				len++;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//链表不为空且k求余后不为空，再做操作</span></span><br><span class="line">			<span class="keyword">if</span> (len &amp;&amp; (k %= len)) &#123;</span><br><span class="line">				<span class="keyword">while</span> (k--)	fast = fast-&gt;next;</span><br><span class="line">				<span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">					slow = slow-&gt;next;</span><br><span class="line">					fast = fast-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">				ListNode *subHead = slow-&gt;next;</span><br><span class="line">				slow-&gt;next = fast-&gt;next;</span><br><span class="line">				fast-&gt;next = dummyHead-&gt;next;</span><br><span class="line">				dummyHead-&gt;next = subHead;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题意，假设链表{1, 2, 3, 4, 5}右移3个单位，很容易想到</p>
<img src="/2023/07/02/61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/1.png" class="" title="image-20230529132817573">
<p>故而先求整个链表的长度，然后让K对它取余，就能得到需要移动的子链表长度</p>
<blockquote>
<p>假设整个链表长度为5，子链表长度也为5，那么子链表就是整体链表，就不需要移动</p>
</blockquote>
<p>然后使用快慢指针找到子链表的dummyHead、头节点和尾节点后，更改位置即可</p>
<img src="/2023/07/02/61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/2.png" class="" title="image-20230529135248910">
<p>当然，你也可以把链表连接成环，同样使用快慢指针找到子链表的dummyHead与头节点并断开形成新链表，时间复杂度是一样的，你可以尝试一下~</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>693. 交替位二进制数</title>
    <url>/2023/07/04/693-%E4%BA%A4%E6%9B%BF%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>移位技巧</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>同下</p>
<h1 id="思路">思路</h1>
<h2 id="循环判断">循环判断</h2>
<p>传统办法，依次判断当前位是否与上一位相同即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">hasAlternatingBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> prev = <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">while</span> (n) &#123;</span><br><span class="line">				<span class="type">int</span> tmp = n &amp; <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (tmp == prev) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				prev = tmp;</span><br><span class="line">				n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( \log n
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h2 id="找规律">找规律</h2>
<p>若整数是交替位二进制类型，去掉多余的前导零后，实际组成类似<code>0101</code>或者<code>1010</code></p>
<p>它们向右移一位后与原数异或，可以得到<strong>全1的数</strong>；比如<code>0101 &gt;&gt; 1 = 0010，0010 ^ 0101 = 0111</code></p>
<p>全1的数再加1则会进位，故而作为判断依据</p>
<p>这里的<code>tmp</code>最大值可达<code>0x7fffffff</code>，为避免再加1后导致溢出，需要将<code>tmp</code>设置为无符号数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">hasAlternatingBits</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> tmp = n ^ (n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span> (tmp &amp; (tmp + <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>705. 设计哈希集合</title>
    <url>/2023/07/03/705-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>哈希表与链表的综合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashSet</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		vector&lt;list&lt;<span class="type">int</span>&gt;&gt; hashSet;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">getHash</span><span class="params">(<span class="type">int</span> &amp;key)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> (key ^ (key &gt;&gt; <span class="number">16</span>)) % <span class="number">13331</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">//这里必须初始化vector，否则会导致空指针错误</span></span><br><span class="line">		<span class="built_in">MyHashSet</span>(): <span class="built_in">hashSet</span>(<span class="number">13331</span>) &#123;&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> h = <span class="built_in">getHash</span>(key);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> it = hashSet[h].<span class="built_in">begin</span>(); it != hashSet[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (*it == key) <span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			hashSet[h].<span class="built_in">emplace_front</span>(key);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> h = <span class="built_in">getHash</span>(key);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> it = hashSet[h].<span class="built_in">begin</span>(); it != hashSet[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (*it == key) &#123;</span><br><span class="line">					hashSet[h].<span class="built_in">erase</span>(it);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> h = <span class="built_in">getHash</span>(key);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> it = hashSet[h].<span class="built_in">begin</span>(); it != hashSet[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (*it == key) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>C++最原生的哈希表，就是数组，下标即为键</p>
<p>参考<a
href="https://segmentfault.com/a/1190000012926722">Java的HashMap源码</a>，设置一个桶数组，每个下标即为数据的哈希值；下标对应的值为双向链表，用以存储哈希值一样的数据</p>
<img src="/2023/07/03/705-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/1.png" class="" title="image-20230609181619597">
<p>使用一个非常简陋的办法计算数据的哈希值。在学习字符串哈希的时候提到过，数据求余大质数有利于减少哈希碰撞</p>
<p>最简单的办法就是</p>
<blockquote>
<p>数据 % 大质数</p>
</blockquote>
<p>考虑到这里的数据是<code>int</code>类型，共32位；可以令高16位与低16位异或，增加混淆度。得到最终的样子</p>
<blockquote>
<p>(数据 ^ (数据 &gt;&gt; 16)) % 大质数</p>
</blockquote>
<hr />
<p>如果有位运算的基础，这道题也能使用<strong>BitMap位图</strong>来处理</p>
<p>题目的需求就是判断元素是否存在，而每种元素只有存在或不存在两种情况</p>
<p>一个<code>int</code>类型是32位，10<sup>6</sup>+1个元素只需要(10<sup>6</sup>+1)/32≈31251长度空间的<code>int</code>数组即可存储所有元素的存在状态</p>
<p>每次元素/32就是数组下标，元素%32即元素对应在该32位中的状态</p>
<blockquote>
<p>取余有小技巧，a%2<sup>n</sup> = a &amp;
(2<sup>n</sup>-1)，只有求余2的幂次才有用哟！</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashSet</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">const</span> <span class="type">static</span> <span class="type">int</span> len = <span class="number">32</span>;</span><br><span class="line">		<span class="type">int</span> bitMap[<span class="number">31251</span>];</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">MyHashSet</span>(): bitMap&#123;<span class="number">0</span>&#125; &#123;&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">			bitMap[key / len] |= <span class="number">1</span> &lt;&lt; (key &amp; (len - <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">			bitMap[key / len] &amp;= ~(<span class="number">1</span> &lt;&lt; (key &amp; (len - <span class="number">1</span>)));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> (bitMap[key / len] &amp; (<span class="number">1</span> &lt;&lt; (key &amp; (len - <span class="number">1</span>)))) != <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>哈希函数</tag>
        <tag>哈希表</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>706. 设计哈希映射</title>
    <url>/2023/07/03/706-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>哈希表与链表的综合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashMap</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">const</span> <span class="type">static</span> <span class="type">int</span> len = <span class="number">32768</span>;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">			<span class="type">int</span> key;</span><br><span class="line">			<span class="type">int</span> value;</span><br><span class="line">			<span class="built_in">Node</span>(<span class="type">int</span> _key, <span class="type">int</span> _value): <span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value) &#123;&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		vector&lt;list&lt;Node&gt; &gt; hashMap;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">getHash</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> (key ^ (key &gt;&gt; <span class="number">16</span>)) &amp; (len - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">MyHashMap</span>() : <span class="built_in">hashMap</span>(len) &#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> h = <span class="built_in">getHash</span>(key);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> it = hashMap[h].<span class="built_in">begin</span>(); it != hashMap[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (it-&gt;key == key) &#123;</span><br><span class="line">					it-&gt;value = value;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			hashMap[h].<span class="built_in">emplace_front</span>(key, value);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> h = <span class="built_in">getHash</span>(key);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> it = hashMap[h].<span class="built_in">begin</span>(); it != hashMap[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (it-&gt;key == key) &#123;</span><br><span class="line">					<span class="keyword">return</span> it-&gt;value;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> h = <span class="built_in">getHash</span>(key);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> it = hashMap[h].<span class="built_in">begin</span>(); it != hashMap[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (it-&gt;key == key) &#123;</span><br><span class="line">					hashMap[h].<span class="built_in">erase</span>(it);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>和<code>705. 设计哈希集合</code>类似，修改一下双向链表的节点结构即可</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>哈希函数</tag>
        <tag>哈希表</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>707. 设计链表</title>
    <url>/2023/07/02/707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的常用操作设计</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> size;</span><br><span class="line">		ListNode *dummyHead;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">MyLinkedList</span>() : <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">dummyHead</span>(<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			ListNode *cur = dummyHead-&gt;next;</span><br><span class="line">			<span class="keyword">while</span> (index--)	cur = cur-&gt;next;</span><br><span class="line">			<span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">			dummyHead-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val, dummyHead-&gt;next);</span><br><span class="line">			size++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">			ListNode *cur = dummyHead;</span><br><span class="line">			<span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) cur = cur-&gt;next;</span><br><span class="line">			cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val, <span class="literal">nullptr</span>);</span><br><span class="line">			size++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (index &gt; size) <span class="keyword">return</span>;</span><br><span class="line">			ListNode *cur = dummyHead;</span><br><span class="line">			<span class="keyword">while</span> (index--) cur = cur-&gt;next;</span><br><span class="line">			cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val, cur-&gt;next);</span><br><span class="line">			size++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">			ListNode *cur = dummyHead;</span><br><span class="line">			<span class="keyword">while</span> (index--) cur = cur-&gt;next;</span><br><span class="line">			ListNode *tmp = cur-&gt;next;</span><br><span class="line">			cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> tmp;</span><br><span class="line">			size--;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题目较为简单，具体实现见代码即可；主要讲几个细节：</p>
<ol type="1">
<li><p>链表类的题基本都需要新增一个<code>dummyHead</code>伪节点，指向真正的头节点；以避免考虑操作头节点时的特殊情况</p></li>
<li><p>单链表类的题涉及迭代操作某一节点时，都应定位到该节点的前一节点；因为若不修改前一节点的<code>next</code>信息，新链表串不起来</p>
<p>（使用递归或双向链表就可以自由发挥了）</p>
<p>比如需要删除节点3，我们需要定位到节点2</p>
<img src="/2023/07/02/707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/1.png" class="" title="image-20230517174741286">
<p>待处理完节点3后，需要将节点2与节点4连接起来，链表才是完整的</p></li>
</ol>
<img src="/2023/07/02/707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/2.png" class="" title="image-20230517174545353">
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>762. 二进制表示中质数个计算置位</title>
    <url>/2023/07/04/762-%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD%E8%B4%A8%E6%95%B0%E4%B8%AA%E8%AE%A1%E7%AE%97%E7%BD%AE%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li><code>bitCount</code>的实现</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		unordered_set&lt;<span class="type">int</span>&gt; primeArr = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>&#125;;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">bitCount</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">			n = (n &amp; <span class="number">0x55555555</span>) + ((n &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x33333333</span>) + ((n &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x0f0f0f0f</span>) + ((n &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x00ff00ff</span>) + ((n &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x0000ffff</span>) + ((n &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);</span><br><span class="line">			<span class="keyword">return</span> n;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">countPrimeSetBits</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (primeArr.<span class="built_in">count</span>(<span class="built_in">bitCount</span>(i))) ans++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( \left( right-left
\right) \cdot \log right \right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( C
\right)\)</span>，<span
class="math inline">\(C\)</span>等于质数打表数组的长度</p>
<h1 id="思路">思路</h1>
<p>若使用常规判断质数代码，时间复杂度就高达<span
class="math inline">\(O\left( \sqrt{right} \right)\)</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">primeJudge</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (num &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= num; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个<code>int</code>类型的整数，其比特位数肯定不超过32；所以直接用哈希表，将32以内的质数打表保存即可，这样时间复杂度可降为常数</p>
<p>这里判断整数的<code>1个数</code>使用的是<code>191. 位1的个数</code>提到的分治法，不再赘述</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>78. 子集</title>
    <url>/2023/07/04/78-%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>状态压缩</li>
<li>排列组合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">			vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">			<span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; size); i++) &#123;</span><br><span class="line">				vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                    <span class="comment">//可以发现，二进制比特位的分布规律都是对称的</span></span><br><span class="line">                    <span class="comment">//假设有数组&#123;1,2,3&#125;，此时i = 1, j = 0</span></span><br><span class="line">                    <span class="comment">//理应代表子集&#123;3&#125;，但也可以用子集&#123;1&#125;替换</span></span><br><span class="line">					<span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) tmp.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">				&#125;</span><br><span class="line">				ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( 2^n\cdot n
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( n
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>题目已经表明，数组中的元素<strong>互不相同</strong>，故而不会产生重复的子集</p>
<p>数组中的每个元素都有取与不取两种状态，使用比特位1代表取状态、比特位0代表不取状态</p>
<p>若<code>nums</code>数组长度为<code>n</code>，按照数学的组合规律则共有2<sup>n</sup>个子集，可以用<span
class="math inline">\(\left[ 0,2^n-1
\right]\)</span>范围内的十进制整数来表达</p>
<p>假设有数组<code>&#123;1,2,3&#125;</code>，子集表达如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">十进制表达</th>
<th style="text-align: center;">二进制表达</th>
<th style="text-align: center;">子集</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">000</td>
<td style="text-align: center;">{}</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">001</td>
<td style="text-align: center;">{3}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">2</td>
<td style="text-align: center;">010</td>
<td style="text-align: center;">{2}</td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: center;">011</td>
<td style="text-align: center;">{2,3}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">4</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">{1}</td>
</tr>
<tr class="even">
<td style="text-align: center;">5</td>
<td style="text-align: center;">101</td>
<td style="text-align: center;">{1,3}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">6</td>
<td style="text-align: center;">110</td>
<td style="text-align: center;">{1,2}</td>
</tr>
<tr class="even">
<td style="text-align: center;">7</td>
<td style="text-align: center;">111</td>
<td style="text-align: center;">{1,2,3}</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>状态压缩</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>82. 删除排序链表中的重复元素 II</title>
    <url>/2023/07/02/82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>双指针</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">			ListNode *dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *curNew = dummyNode;</span><br><span class="line">			ListNode *left = head, *right = head-&gt;next;</span><br><span class="line">			<span class="keyword">while</span> (left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				right = left-&gt;next;</span><br><span class="line">				<span class="keyword">while</span> (right != <span class="literal">nullptr</span> &amp;&amp; left-&gt;val == right-&gt;val)	right = right-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (left-&gt;next == right) &#123;</span><br><span class="line">					curNew-&gt;next = left;</span><br><span class="line">					left = left-&gt;next;</span><br><span class="line">					curNew = curNew-&gt;next;</span><br><span class="line">				&#125; <span class="keyword">else</span> left = right;</span><br><span class="line">			&#125;</span><br><span class="line">			curNew-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本题是<code>83. 删除排序链表中的重复元素</code>的升级版，思路一样，也是使用双指针；左指针指向需要留下的元素，右指针作为游标指针</p>
<p>分为两种情况</p>
<ol type="1">
<li>左指针指向的值和右指针指向的值不同，说明左指针需要被留下，插入新链表</li>
<li>左指针指向的值和右指针指向的值相同，说明左右指针指向的值都需要被删除；待右指针指向第一个不同值的节点时，将左指针更新为该节点，开启新一轮判定</li>
</ol>
<p>本题实际上每次比较的是两个相邻节点，所以左右指针其实可以用一个游标指针来代替，即<code>head</code>和<code>head-&gt;next</code></p>
<p>改写后代码如下，逻辑与效果是一样的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head), *curNew = dummyHead;</span><br><span class="line">			<span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span> || head-&gt;val != head-&gt;next-&gt;val) &#123;</span><br><span class="line">					curNew-&gt;next = head;</span><br><span class="line">					curNew = curNew-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">while</span> (head != <span class="literal">nullptr</span> &amp;&amp; head-&gt;next != <span class="literal">nullptr</span> &amp;&amp; head-&gt;val == head-&gt;next-&gt;val) &#123;</span><br><span class="line">					head = head-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">				head = head-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			curNew-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>83. 删除排序链表中的重复元素</title>
    <url>/2023/07/02/83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>双指针</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *left = head, *right = head;</span><br><span class="line">			<span class="keyword">while</span> (right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				<span class="keyword">while</span> (right != <span class="literal">nullptr</span> &amp;&amp; left-&gt;val == right-&gt;val)	right = right-&gt;next;</span><br><span class="line">				left-&gt;next = right;</span><br><span class="line">				left = left-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题意，链表已排序，那么重复的元素就一定是连续的；所以我们使用双指针来处理</p>
<p>左指针指向需要留下的元素，右指针作为游标指针</p>
<p>只要右指针的值等于左指针，就一直向右，遇到不同值停下，再将左右指针指向的节点连接起来即可</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>86. 分隔链表</title>
    <url>/2023/07/02/86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的裁剪</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">			ListNode *dummySmall = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *curSmall = dummySmall;</span><br><span class="line">			ListNode *dummyLarge = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *curLarge = dummyLarge;</span><br><span class="line">			<span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (head-&gt;val &lt; x) &#123;</span><br><span class="line">					curSmall-&gt;next = head;</span><br><span class="line">					curSmall = curSmall-&gt;next;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					curLarge-&gt;next = head;</span><br><span class="line">					curLarge = curLarge-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">				head = head-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			curSmall-&gt;next = dummyLarge-&gt;next;</span><br><span class="line">			curLarge-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">return</span> dummySmall-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>一个小链表按序存储值小于x的节点，一个大链表按序存储剩余节点，再将大链表接在小链表尾部即可</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>876. 链表的中间结点</title>
    <url>/2023/07/02/876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>快慢指针/双指针</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *slow = head, *fast = head;</span><br><span class="line">			<span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				slow = slow-&gt;next;</span><br><span class="line">				fast = fast-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (fast-&gt;next != <span class="literal">nullptr</span>) fast = fast-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> slow;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>同样使用快慢指针，但和以往不同，需要再往下走一格</p>
<p>可以和之前的代码作对比</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">findMid</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>92. 反转链表 II</title>
    <url>/2023/07/02/92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的反转</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head), *subDummy = dummyHead;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) subDummy = subDummy-&gt;next;</span><br><span class="line">            <span class="comment">//使用改进版头插法进行子链表反转</span></span><br><span class="line">			ListNode *tail = subDummy-&gt;next;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">				ListNode *node = tail-&gt;next;</span><br><span class="line">				tail-&gt;next = node-&gt;next;</span><br><span class="line">				node-&gt;next = subDummy-&gt;next;</span><br><span class="line">				subDummy-&gt;next = node;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>找到子链表的头节点，并将其前一个节点作为伪节点，即<code>subDummy</code>；再使用<code>206. 反转链表</code>提到的<code>改进版头插法</code>即可</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>P1042. 乒乓球</title>
    <url>/2023/09/27/P1042-%E4%B9%92%E4%B9%93%E7%90%83/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
<li>字符串</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ans</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> w_, l_;</span><br><span class="line">&#125; ans_11[LEN], ans_21[LEN];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> w_11 ans_11[idx_11].w_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l_11 ans_11[idx_11].l_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> w_21 ans_21[idx_21].w_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l_21 ans_21[idx_21].l_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> idx_11 = <span class="number">0</span>, idx_21 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; c &amp;&amp; c != <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;W&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++w_11, ++w_21;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++l_11, ++l_21;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里不能写等于11，因为分差至少为2</span></span><br><span class="line">        <span class="comment">// 比如11:11是不可以结束的，13:11才可以</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(w_11 - l_11) &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">max</span>(w_11, l_11) &gt;= <span class="number">11</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++idx_11;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(w_21 - l_21) &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">max</span>(w_21, l_21) &gt;= <span class="number">21</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++idx_21;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= idx_11; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ans_11[i].w_ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; ans_11[i].l_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= idx_21; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ans_21[i].w_ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; ans_21[i].l_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>字符串的题目，先判断处理方式：</p>
<ul>
<li>字符依次读入</li>
<li>整串读入</li>
</ul>
<p>显然这道题应该字符依次读入，因为有<code>E</code>这一个终止符号</p>
<p>每个对局都是一对数字，用结构体<code>Ans</code>进行保存</p>
<p>由于两种分制的结果需要分开输出，用两个结构体数组<code>ans_11</code>和<code>ans_21</code>各自保存11分制和21分制的情况</p>
<p><code>idx_11</code>和<code>idx_21</code>分别控制各自结构体数组的下标</p>
<p>处理对局情况时，有两点要注意：</p>
<ul>
<li>只有当对局中最大得分<code>&gt;=11</code>且双方得分的差值<code>&gt;=2</code>时才可进行下一局；比如<code>11:11</code>就不能下一局，<code>11:13</code>可以</li>
<li>哪怕当前对局的情况是<code>0:0</code>也要输出</li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>P1563. 玩具谜题</title>
    <url>/2023/09/27/P1563-%E7%8E%A9%E5%85%B7%E8%B0%9C%E9%A2%98/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    string name_;</span><br><span class="line">    <span class="type">int</span> forward_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i].forward_ &gt;&gt; arr[i].name_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>, f, len;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; f &gt;&gt; len;</span><br><span class="line">        <span class="keyword">if</span> (arr[idx].forward_ ^ f)</span><br><span class="line">        &#123;</span><br><span class="line">            idx = (idx + len) % n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            idx = (idx - len + n) % n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; arr[idx].name_;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>每个人都有朝向和名字，自然用结构体<code>Node</code>来保存</p>
<p>根据题意得知，结构体数组的下标从小到大遍历是为逆时针序，从大到小遍历是为顺时针序</p>
<p>朝内圈记为0，朝外圈记为1；向左走记为0，向右走记为1</p>
<p>接下来分析遍历走向：</p>
<ul>
<li>朝内圈的小人向左走，是为顺时针，有<code>0 ^ 0 = 0</code></li>
<li>朝内圈的小人向右走，是为逆时针，有<code>0 ^ 1 = 1</code></li>
<li>朝外圈的小人向左走，是为逆时针，有<code>1 ^ 0 = 1</code></li>
<li>朝外圈的小人向右走，是为顺时针，有<code>1 ^ 1 = 0</code></li>
</ul>
<p>所以每次判断遍历走向时，将当前所处的小人内外圈方向与左右方向异或即可；为0则从大到小遍历，为1则从小到大遍历</p>
<p>假设当前共<code>n=6</code>个数，下标<code>idx</code>范围为<code>0~5</code>，每次需要走<code>len</code>步；且题目规定<code>len</code>小于<code>n</code></p>
<p>从小到大遍历可以得到公式：<span class="math inline">\(idx=\left(
idx+len \right) \%n\)</span></p>
<p>从大到小遍历可以得到公式：<span class="math inline">\(idx=\left(
idx-len+n \right)
\%n\)</span>，之所以加上<code>n</code>是处理负数时的情况</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P2670. 扫雷游戏</title>
    <url>/2023/09/27/P2670-%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
<li>搜索</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">301</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> table[LEN][LEN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> walk[<span class="number">8</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; table[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i, cout &lt;&lt; endl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (table[i][j] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x = i + walk[k][<span class="number">0</span>], y = j + walk[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; <span class="number">300</span> || y &lt; <span class="number">1</span> || y &gt; <span class="number">300</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (table[x][y] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>逐个点进行八向搜索即可，搜索前注意判断是否越界</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>P1303. 模板题_A*B Problem</title>
    <url>/2023/09/30/P1303-%E6%A8%A1%E6%9D%BF%E9%A2%98-AB-Problem/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>高精度</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">5050</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len_;</span><br><span class="line">    <span class="type">int</span> arr_[LEN];</span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr_[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(string s = <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr_, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr_));</span><br><span class="line">        len_ = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr_[i] = s[len_ - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len_ = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr_[i + <span class="number">1</span>] += arr_[i] / <span class="number">10</span>;</span><br><span class="line">                arr_[i] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!arr_[len_])</span><br><span class="line">            --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, len_); i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; arr_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>*(BigInt a, BigInt b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.len_; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b.len_; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            c[i + j - <span class="number">1</span>] += a[i] * b[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//乘法的结果位数</span></span><br><span class="line">    c.<span class="built_in">flatten</span>(a.len_ + b.len_);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    (<span class="built_in">BigInt</span>(a) * <span class="built_in">BigInt</span>(b)).<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>与高精度加法唯一的不同点，就在于按位处理上</p>
<p>可以发现，<code>操作数a的处理位下标 + 操作数b的处理位下标 - 1 = 结果位下标</code></p>
<p>还需要牢记，乘法的结果位数不会超过两个操作数的位数之和</p>
<img src="/2023/09/30/P1303-%E6%A8%A1%E6%9D%BF%E9%A2%98-AB-Problem/1.png" class="" title="image-20230930182427581">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模板题</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>P1601. 模板题_A+B Problem</title>
    <url>/2023/09/30/P1601-%E6%A8%A1%E6%9D%BF%E9%A2%98-A-B-Problem/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>高精度</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">5050</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len_;</span><br><span class="line">    <span class="type">int</span> arr_[LEN];</span><br><span class="line">    <span class="comment">//以数组的形式访问对象</span></span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr_[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(string s = <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr_, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr_));</span><br><span class="line">        len_ = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr_[i] = s[len_ - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len_ = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr_[i + <span class="number">1</span>] += arr_[i] / <span class="number">10</span>;</span><br><span class="line">                arr_[i] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!arr_[len_])</span><br><span class="line">            --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//处理结果为0的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, len_); i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; arr_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>+(BigInt a, BigInt b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">max</span>(a.len_, b.len_);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加法结果的位数</span></span><br><span class="line">    c.<span class="built_in">flatten</span>(len + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    (<span class="built_in">BigInt</span>(a) + <span class="built_in">BigInt</span>(b)).<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>为了方便处理，先将两个操作数反转，然后再按位进行运算</p>
<p><code>BigInt</code>的构造函数就是将字符串逆序保存至数组</p>
<p><code>print</code>函数则是从尾到头输出数组，这样结果就是正序的；当然，<code>print</code>函数要处理一下数组只有0的情况</p>
<img src="/2023/09/30/P1601-%E6%A8%A1%E6%9D%BF%E9%A2%98-A-B-Problem/1.png" class="">
<p>由于存在进位，所以需要<code>flatten</code>函数处理每一位</p>
<img src="/2023/09/30/P1601-%E6%A8%A1%E6%9D%BF%E9%A2%98-A-B-Problem/2.png" class="">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模板题</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>P1480. 模板题_A/B Problem</title>
    <url>/2023/10/01/P1480-%E6%A8%A1%E6%9D%BF%E9%A2%98-A%E9%99%A4B-Problem/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>高精度</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">25000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len_;</span><br><span class="line">    <span class="type">int</span> arr_[LEN];</span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr_[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(string s = <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr_, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr_));</span><br><span class="line">        len_ = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr_[i] = s[len_ - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len_ = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_[i] &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr_[i + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">                arr_[i] += <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!arr_[len_])</span><br><span class="line">            --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, len_); i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; arr_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以lst_dg为最低有效位的a</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">greater_eq</span><span class="params">(BigInt a, <span class="type">int</span> lst_dg, BigInt b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a的位数比b的位数多</span></span><br><span class="line">    <span class="keyword">if</span> (a[lst_dg + b.len_] != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.len_ - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[lst_dg + i] &gt; b[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[lst_dg + i] &lt; b[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//a和b的值相等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>/(BigInt a, BigInt b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> lst_dg = a.len_ - b.len_ + <span class="number">1</span>; lst_dg &gt;= <span class="number">1</span>; --lst_dg)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">greater_eq</span>(a, lst_dg, b))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= b.len_ - <span class="number">1</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                a[lst_dg + i] -= b[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (a[lst_dg + i] &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[lst_dg + i + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">                    a[lst_dg + i] += <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++c[lst_dg];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.len_ = a.len_;</span><br><span class="line">    <span class="keyword">while</span>(c[c.len_] == <span class="number">0</span>)</span><br><span class="line">        --c.len_;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="function">BigInt <span class="title">a</span><span class="params">(s1)</span>, <span class="title">b</span><span class="params">(s2)</span></span>;</span><br><span class="line">    (a / b).<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>与之前的高精度加减乘法由低位到高位的运算方向不同，高精度除法是从高位到低位运算</p>
<p>以175除以5为例子：</p>
<ul>
<li>lst_dg初始位置为<code>a.len_ - b.len_ + 1</code>，确保<strong>以lst_dg为最低有效位的a</strong>长度等于b长度；随后从高位向低位遍历</li>
<li>在lst_dg的遍历过程中，结合<code>greater_eq</code>函数判断当前<strong>以lst_dg为最低有效位的a</strong>是否大于除数b</li>
<li>若大于，则执行高精减法，并更新商数组；循环这一操作，直到当前<strong>以lst_dg为最低有效位的a</strong>小于b</li>
</ul>
<img src="/2023/10/01/P1480-%E6%A8%A1%E6%9D%BF%E9%A2%98-A%E9%99%A4B-Problem/1.png" class="" title="image-20231001004045770">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模板题</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>P2142. 模板题_高精度减法</title>
    <url>/2023/09/30/P2142-%E6%A8%A1%E6%9D%BF%E9%A2%98-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>高精度</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">25000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len_;</span><br><span class="line">    <span class="type">int</span> arr_[LEN];</span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr_[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(string s = <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr_, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr_));</span><br><span class="line">        len_ = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr_[i] = s[len_ - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len_ = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_[i] &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr_[i + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">                arr_[i] += <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!arr_[len_])</span><br><span class="line">            --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, len_); i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; arr_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lst_dg代表当前a的最低有效位</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">greater_eq</span><span class="params">(BigInt a, <span class="type">int</span> lst_dg, BigInt b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a的位数比b的位数少</span></span><br><span class="line">    <span class="keyword">if</span> (a.len_ &lt; b.len_)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.len_ &gt; b.len_)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.len_ - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[lst_dg + i] &gt; b[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[lst_dg + i] &lt; b[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//a和b的值相等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>-(BigInt a, BigInt b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">int</span> len = a.len_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += a[i] - b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    c.<span class="built_in">flatten</span>(len);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="function">BigInt <span class="title">a</span><span class="params">(s1)</span>, <span class="title">b</span><span class="params">(s2)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">greater_eq</span>(a, <span class="number">1</span>, b))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        (b - a).<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        (a - b).<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>与高精度加法、乘法唯一不同的是，需要新增一个<code>greater_eq</code>函数来确保参数<code>a</code>是大于等于参数<code>b</code>的</p>
<p><code>greater_eq</code>函数的功能较简单，执行流程如下：</p>
<ul>
<li>比较<code>a</code>和<code>b</code>的长度大小</li>
<li>若<code>a</code>和<code>b</code>的长度相等，则从高位向低位逐个比较</li>
</ul>
<p>该函数的参数<code>lst_dg</code>在高精度减法中暂无作用，但在高精度除法中是关键；下述函数内的代码块</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a.len_ &gt; b.len_)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>在高精度除法中将会被替换成这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a[lst_dg + b.len_] != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>看似效果一样，但两者不可混用！！！！！</p>
<p>在高精度减法中，用<code>a[lst_dg + b.len_]</code>来判断<code>a</code>大于<code>b</code>是绝对错误的！</p>
<blockquote>
<p>比如a的值为1001，与b的值为1进行比较，上述代码块就不会返回true</p>
</blockquote>
<p>而在高精度除法中，该代码段判断以<code>lst_dg</code>为最低有效位的<code>a</code>是否大于等于<code>b</code>是可以的</p>
<blockquote>
<p><strong>高精度运算的数组都是倒序放置，且高精度除法是从高位开始运算，而加减乘法是从低位开始运算</strong></p>
<p><strong>所以被除数的某位为0，那么比它更高的位次也一定为0</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模板题</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>P1009. 模板题_阶乘之和</title>
    <url>/2023/10/01/P1009-%E9%98%B6%E4%B9%98%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>高精度</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">25050</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len_;</span><br><span class="line">    <span class="type">int</span> arr_[LEN];</span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr_[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(<span class="type">int</span> x = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr_, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr_));</span><br><span class="line">        <span class="keyword">for</span> (len_ = <span class="number">1</span>; x; ++len_)</span><br><span class="line">        &#123;</span><br><span class="line">            arr_[len_] = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len_ = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr_[i + <span class="number">1</span>] += arr_[i] / <span class="number">10</span>;</span><br><span class="line">                arr_[i] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!arr_[len_])</span><br><span class="line">            --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, len_); i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; arr_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>+(BigInt a, BigInt b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">max</span>(a.len_, b.len_);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    c.<span class="built_in">flatten</span>(len + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>*(BigInt a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">int</span> len = a.len_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += a[i] * b;</span><br><span class="line">    &#125;</span><br><span class="line">    c.<span class="built_in">flatten</span>(len + <span class="number">11</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    BigInt a, <span class="built_in">b</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        b = b * i;</span><br><span class="line">        a = a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>标准的模板题，没有坑点；只不过高精度乘高精度可以简化成下面的高精度乘低精度，一次循环即可</p>
<p>因为int类型最大也就是10位，在这里<code>len + 11</code>可以满足两数相乘的结果位数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BigInt <span class="keyword">operator</span>*(BigInt a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">int</span> len = a.len_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += a[i] * b;</span><br><span class="line">    &#125;</span><br><span class="line">    c.<span class="built_in">flatten</span>(len + <span class="number">11</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模板题</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>P1045. 麦森数</title>
    <url>/2023/10/02/P1045-%E9%BA%A6%E6%A3%AE%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>快速幂</li>
<li>高精度</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">505</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len_;</span><br><span class="line">    <span class="type">int</span> arr_[LEN];</span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr_[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(<span class="type">int</span> x = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr_, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr_));</span><br><span class="line">        <span class="keyword">for</span> (len_ = <span class="number">1</span>; x; ++len_)</span><br><span class="line">        &#123;</span><br><span class="line">            arr_[len_] = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len_ = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr_[i + <span class="number">1</span>] += arr_[i] / <span class="number">10</span>;</span><br><span class="line">                arr_[i] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!arr_[len_])</span><br><span class="line">            --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">500</span>, cnt = <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i, ++cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; arr_[i];</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">50</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>*(BigInt a, BigInt b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.len_; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b.len_; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + j - <span class="number">1</span> &gt; <span class="number">500</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            c[i + j - <span class="number">1</span>] += a[i] * b[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.<span class="built_in">flatten</span>(<span class="built_in">min</span>(<span class="number">500</span>, a.len_ + b.len_));</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>*(BigInt a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">int</span> len = a.len_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += a[i] * b;</span><br><span class="line">    &#125;</span><br><span class="line">    c.<span class="built_in">flatten</span>(<span class="built_in">min</span>(<span class="number">500</span>, len + <span class="number">11</span>));</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, p;</span><br><span class="line">    cin &gt;&gt; p;</span><br><span class="line">    n = p;</span><br><span class="line">    <span class="function">BigInt <span class="title">a</span><span class="params">(<span class="number">2</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">            b = b * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (<span class="type">int</span>)(n * <span class="built_in">log10</span>(<span class="number">2</span>)) + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    --b[<span class="number">1</span>];</span><br><span class="line">    b.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>使用快速幂的模板套高精乘低精、高精乘高精的模板即可</p>
<p>但是有如下坑点需要注意：</p>
<ul>
<li><p>因为是2的幂次，最后一位肯定不会小于1；所以减1直接操作最低位自减就行</p></li>
<li><p>10的幂次可以决定一个数的位数，比如10的2次幂有2 + 1 = 3 位</p>
<p>且2<sup>P</sup>-1的位数与2<sup>p</sup>是一样的，实际上是求2<sup>p</sup>的位数；那么可以直接通过下列等式得到
<span class="math display">\[
\log _{10}2^p+1=P\cdot \log _{10}2+1
\]</span></p></li>
<li><p>由于题目说最多只要500位，所以高精度乘法与flatten函数千万不能超过500位导致越界！</p></li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>高精度</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>P1249. 最大乘积</title>
    <url>/2023/10/01/P1249-%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>高精度</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">25050</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len_;</span><br><span class="line">    <span class="type">int</span> arr_[LEN];</span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr_[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(<span class="type">int</span> x = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr_, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr_));</span><br><span class="line">        <span class="keyword">for</span> (len_ = <span class="number">1</span>; x; ++len_)</span><br><span class="line">        &#123;</span><br><span class="line">            arr_[len_] = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len_ = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr_[i + <span class="number">1</span>] += arr_[i] / <span class="number">10</span>;</span><br><span class="line">                arr_[i] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!arr_[len_])</span><br><span class="line">            --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, len_); i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; arr_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>*(BigInt a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">int</span> len = a.len_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += a[i] * b;</span><br><span class="line">    &#125;</span><br><span class="line">    c.<span class="built_in">flatten</span>(len + <span class="number">11</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10001</span>], n, idx = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr));</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; sum &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        arr[idx++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> diff = sum - n;</span><br><span class="line">    <span class="keyword">if</span> ((diff == <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//相差1，去掉2然后最高的数字+1</span></span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        ++arr[idx - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 其他情况直接删除和差值一样的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == diff)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">BigInt <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a = a * arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题目要求将整数n分解成若干个<strong>互不相同</strong>的自然数的和，且使这些自然数的<strong>乘积最大</strong></p>
<p>若单单是乘积最大，很容易想到贪心策略——把n尽可能地拆散均匀即可；但题目要求<strong>互不相同</strong></p>
<p>以n=11为例</p>
<p>尝试从2开始枚举自然数，一直到这些自然数的和大于等于n；枚举结束时，集合应该是{2,
3, 4, 5}，集合的和为14</p>
<p>此刻，集合的和相较于n多了3；那么问题就转换为<strong>怎么让集合内的数减3，使它们的乘积最大</strong></p>
<p>显然唯一的办法就是直接从集合中移除数字3，因为要求<strong>互不相同</strong>；倘若集合内的任何一个数减1，都会有碰撞</p>
<p>再以n=13为例</p>
<p>集合的和相较于n多了1，但集合内并没有数字1；将数字2移除（必定存在），相当于减2，再将最大的数字加1即可保持平衡</p>
<p>故而总体步骤如下：</p>
<ul>
<li>从数字2开始枚举自然数集合，直到集合的和大于等于n</li>
<li>和与n的差值等于1，删除数字2（这里把数字2设置为数字1即可，因为目标只是算乘积）并将最大的数字加1</li>
<li>和与n的差值大于1，删除差值相同的数字即可</li>
<li>遍历集合，用高精乘低精的模板计算乘法结果</li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>P1591. 阶乘数码</title>
    <url>/2023/10/01/P1591-%E9%98%B6%E4%B9%98%E6%95%B0%E7%A0%81/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>高精度</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">25050</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len_;</span><br><span class="line">    <span class="type">int</span> arr_[LEN];</span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr_[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(<span class="type">int</span> x = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr_, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr_));</span><br><span class="line">        <span class="keyword">for</span> (len_ = <span class="number">1</span>; x; ++len_)</span><br><span class="line">        &#123;</span><br><span class="line">            arr_[len_] = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len_ = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr_[i + <span class="number">1</span>] += arr_[i] / <span class="number">10</span>;</span><br><span class="line">                arr_[i] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!arr_[len_])</span><br><span class="line">            --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, len_); i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; arr_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>*(BigInt a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">int</span> len = a.len_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += a[i] * b;</span><br><span class="line">    &#125;</span><br><span class="line">    c.<span class="built_in">flatten</span>(len + <span class="number">11</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cnt</span><span class="params">(BigInt a, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.len_; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == x)</span><br><span class="line">            ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t, n, x;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">        <span class="function">BigInt <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            a = a * i;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">cnt</span>(a, x) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>高精乘低精的模板题，没有坑点</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>P1226. 模板题_快速幂</title>
    <url>/2023/10/02/P1226-%E6%A8%A1%E6%9D%BF%E9%A2%98-%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>快速幂</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">binpow</span><span class="params">(ll a, ll b, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a %= p;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * a % p;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a, b, p;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld^%lld mod %lld=%lld&quot;</span>, a, b, p, <span class="built_in">binpow</span>(a, b, p));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>标准的快速幂模板题，快速幂的具体原理可以参照<a
href="https://oi-wiki.org/math/binary-exponentiation/">Wiki</a></p>
<p>答案要求我们对结果取模；由于取模操作不会对乘法运算造成影响，所以在求幂次的过程中取模操作可以并行</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模板题</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度_解题技巧</title>
    <url>/2023/10/02/%E9%AB%98%E7%B2%BE%E5%BA%A6-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>高精度的题目，一般都会涉及到多种高精度计算：高精乘高精，高精乘低精，高精除高精等等复杂运算</p>
<p>所以一般先按照高精度的模板，把<code>BigInt</code>类写好；然后根据不同需求重载运算符，这样才不易出错</p>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>P4924. 魔法少女小Scarlet</title>
    <url>/2023/10/02/P4924-%E9%AD%94%E6%B3%95%E5%B0%91%E5%A5%B3%E5%B0%8FScarlet/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">501</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, ans[LEN][LEN], tmp[LEN][LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i][j] = cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i, cout &lt;&lt; endl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; ans[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> c_x, <span class="type">int</span> c_y, <span class="type">int</span> r, <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">copy</span>(&amp;ans[<span class="number">0</span>][<span class="number">0</span>], &amp;ans[<span class="number">0</span>][<span class="number">0</span>] + LEN * LEN, &amp;tmp[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (z == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 顺时针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = -r; i &lt;= r; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = -r; j &lt;= r; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[c_x + j][c_y - i] = ans[c_x + i][c_y + j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 逆时针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = -r; i &lt;= r; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = -r; j &lt;= r; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[c_x - j][c_y + i] = ans[c_x + i][c_y + j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">copy</span>(&amp;tmp[<span class="number">0</span>][<span class="number">0</span>], &amp;tmp[<span class="number">0</span>][<span class="number">0</span>] + LEN * LEN, &amp;ans[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, c_x, c_y, r, z;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; m;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; c_x &gt;&gt; c_y &gt;&gt; r &gt;&gt; z;</span><br><span class="line">        <span class="built_in">rotate</span>(c_x, c_y, r, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>假设当前待旋转的矩阵中心c_x = 3，c_y = 3，r = 2</p>
<p>由于是围绕该中心旋转，所以不妨将子矩阵放在以该中心为原点的y -
x坐标系中分析</p>
<blockquote>
<p>数组中的上下移动与平面直角坐标系中的上下移动概念是相反的</p>
<p>若有点坐标(x, y)，要求向左走1次，向上走2次</p>
<p>在平面直角坐标系中，移动后的坐标为(x - 1, y + 2)</p>
<p>而在数组中，移动后的坐标为(x - 2, y - 1)</p>
<p>所以为了方便理解，令新的坐标系横坐标为y，即列号；纵坐标为x，即行号</p>
</blockquote>
<p>以该子矩阵的点(1, 2)为例，分析它的顺时针路径图：</p>
<img src="/2023/10/02/P4924-%E9%AD%94%E6%B3%95%E5%B0%91%E5%A5%B3%E5%B0%8FScarlet/1.png" class="" title="image-20231002182626402">
<p>若令i，j分别为横纵坐标变化，可以发现顺时针变化的规律，即： <span
class="math display">\[
\left( y+i, x+j \right) \rightarrow \left( y-j, x+i \right)
\\
\text{其中}i\in \left[ -r, r \right] , j\in \left[ -r, r \right]
\]</span> 同理逆时针规律也可以得到： <span class="math display">\[
\left( y+i, x+j \right) \rightarrow \left( y+j, x-i \right)
\\
\text{其中}i\in \left[ -r, r \right] , j\in \left[ -r, r \right]
\]</span></p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P1067. 多项式输出</title>
    <url>/2023/10/03/P1067-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
<li>字符串</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, t;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="comment">//不在头且常数大于0时，需要输出加号</span></span><br><span class="line">        <span class="keyword">if</span> (i != n &amp;&amp; t &gt; <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;+&quot;</span>;</span><br><span class="line">        <span class="comment">// 输出数字的情况：</span></span><br><span class="line">        <span class="comment">// t不等于-1、0和1，</span></span><br><span class="line">        <span class="comment">// 或者幂次为0</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(t) &gt; <span class="number">1</span> || (i == <span class="number">0</span> &amp;&amp; t != <span class="number">0</span>))</span><br><span class="line">            cout &lt;&lt; t;</span><br><span class="line">        <span class="comment">//只剩-1需要处理</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">-1</span> &amp;&amp; i != <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; t)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;x^&quot;</span> &lt;&lt; i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; t)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;x&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>字符串的问题，首先判断逐词读入还是整句读入；本题当然是逐次读入比较方便</p>
<p>得到常数项t和幂次i后，任务如下：</p>
<ol type="1">
<li>本次是否输出，直接判断常数是否为0即可</li>
<li>常数项的处理</li>
<li>自变量的处理</li>
</ol>
<p>先来看常数项的处理：</p>
<ol type="1">
<li><p>什么时候输出+号？</p>
<p>常数不在开头，且大于0</p></li>
<li><p>如何输出数？</p>
<p>只要不是-1、0和1这三个数，任何地方都可以直接输出</p>
<p>能输出-1和1的地方，只有幂次等于0的时候</p></li>
<li><p>什么时候输出-号？</p>
<p>其实第2点已经基本处理完了，只剩一种情况，-1在多项式中间，此时只要输出一个-号即可</p></li>
</ol>
<p>再来看自变量的处理：</p>
<ol type="1">
<li><p>什么时候输出x号？</p>
<p>幂次为1且常数项不为0</p></li>
<li><p>什么时候输出x^号？</p>
<p>幂次大于1且常数项不为0</p></li>
</ol>
<p>综上，即可得到代码</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>P1328. 生活大爆炸版石头剪刀布</title>
    <url>/2023/10/02/P1328-%E7%94%9F%E6%B4%BB%E5%A4%A7%E7%88%86%E7%82%B8%E7%89%88%E7%9F%B3%E5%A4%B4%E5%89%AA%E5%88%80%E5%B8%83/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0是平，1是赢，-1是输</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A[<span class="number">250</span>] = &#123;<span class="number">0</span>&#125;, B[<span class="number">250</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, a, b, ans_a = <span class="number">0</span>, ans_b = <span class="number">0</span>, idx_a = <span class="number">0</span>, idx_b = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a; ++i)</span><br><span class="line">        cin &gt;&gt; A[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b; ++i)</span><br><span class="line">        cin &gt;&gt; B[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[A[idx_a]][B[idx_b]] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++ans_b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[A[idx_a]][B[idx_b]] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++ans_a;</span><br><span class="line">        &#125;</span><br><span class="line">        ++idx_a, ++idx_b;</span><br><span class="line">        idx_a %= a, idx_b %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans_a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans_b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>通过二维数组，打表两个人的输赢关系即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P1518. 两只塔姆沃斯牛</title>
    <url>/2023/10/02/P1518-%E4%B8%A4%E5%8F%AA%E5%A1%94%E5%A7%86%E6%B2%83%E6%96%AF%E7%89%9B/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> arr[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> walk[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//dir_ 0向右，1向下，2向左，3向上</span></span><br><span class="line">    <span class="type">int</span> x_, y_, dir_;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>, <span class="type">int</span> dir = <span class="number">3</span>) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y), <span class="built_in">dir_</span>(dir) &#123;&#125;</span><br><span class="line">&#125; f, c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; arr[i][j];</span><br><span class="line">            <span class="keyword">if</span> (arr[i][j] == <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f.x_ = i, f.y_ = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i][j] == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                c.x_ = i, c.y_ = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hsh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f.dir_ * <span class="built_in">pow</span>(P, <span class="number">5</span>) + c.dir_ * <span class="built_in">pow</span>(P, <span class="number">4</span>) +</span><br><span class="line">           f.x_ * <span class="built_in">pow</span>(P, <span class="number">3</span>) + f.y_ * <span class="built_in">pow</span>(P, <span class="number">2</span>) +</span><br><span class="line">           +c.x_ * P + c.y_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= <span class="number">10</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= <span class="number">10</span> &amp;&amp; arr[x][y] != <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> h, t = <span class="number">0</span>, f_x, f_y, c_x, c_y;</span><br><span class="line">    <span class="keyword">while</span> (!m.<span class="built_in">count</span>(h = <span class="built_in">hsh</span>()) &amp;&amp; (f.x_ != c.x_ || f.y_ != c.y_))</span><br><span class="line">    &#123;</span><br><span class="line">        m[h] = <span class="literal">true</span>;</span><br><span class="line">        f_x = f.x_ + walk[f.dir_][<span class="number">0</span>], f_y = f.y_ + walk[f.dir_][<span class="number">1</span>];</span><br><span class="line">        c_x = c.x_ + walk[c.dir_][<span class="number">0</span>], c_y = c.y_ + walk[c.dir_][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">valid</span>(f_x, f_y))</span><br><span class="line">        &#123;</span><br><span class="line">            f.dir_ = (f.dir_ + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            f.x_ = f_x, f.y_ = f_y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">valid</span>(c_x, c_y))</span><br><span class="line">        &#123;</span><br><span class="line">            c.dir_ = (c.dir_ + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            c.x_ = c_x, c.y_ = c_y;</span><br><span class="line">        &#125;</span><br><span class="line">        ++t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (f.x_ == c.x_ &amp;&amp; f.y_ == c.y_ ? t : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">chase</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本题唯一的难点就在于如何确定系统的临界状态，从而跳出死循环</p>
<p>人与牛如果不可能碰面，即出现死循环现象，那么某一时刻的系统状态一定会出现两次</p>
<blockquote>
<p>类比绕着圆形田径场一直慢跑，某路段一定会至少跑过两次</p>
</blockquote>
<p>本题的系统状态是由人的横纵坐标、人的方向、牛的横纵坐标和牛的方向六个因素决定，如何记录它们呢？</p>
<p>采用<strong>字符串哈希</strong>类似的做法，用一个多项式将六个因素串起来作为哈希值，并在多项式内用<strong>幂次</strong>来代表<strong>影响因子的权重</strong></p>
<p>在本题中，人与牛的方向是最能影响系统状态的，所以人与牛的方向这两个影响因子的幂次应该最高</p>
<blockquote>
<p>由于只有100个坐标，假若将人、牛的坐标作为高权重的影响因子，极其容易发生哈希碰撞；即不同系统状态，但哈希值相同</p>
</blockquote>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P1065. 作业调度方案</title>
    <url>/2023/10/03/P1065-%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//m为机器数，n为工件数</span></span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录每个机器的时间轴</span></span><br><span class="line"><span class="type">bool</span> machine_timeline[<span class="number">30</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录当前工件的工序状态</span></span><br><span class="line"><span class="type">int</span> project_record[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录任务执行顺序</span></span><br><span class="line"><span class="type">int</span> project_list[<span class="number">550</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个工件的上一次的最长耗时线</span></span><br><span class="line"><span class="type">int</span> project_timeline[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录工件号及其工序指定的机器与时间开销</span></span><br><span class="line"><span class="comment">//first为指定的机器号，second为时间开销</span></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; project_table[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m * n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; project_list[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; project_table[i][j].first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; project_table[i][j].second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, cost = <span class="number">0</span>, project_id, machine_id, machine_cost;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m * n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        project_id = project_list[i], ++project_record[project_id];</span><br><span class="line">        machine_id = project_table[project_id][project_record[project_id]].first;</span><br><span class="line">        machine_cost = project_table[project_id][project_record[project_id]].second;</span><br><span class="line">        cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = project_timeline[project_id] + <span class="number">1</span>;; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!machine_timeline[machine_id][j])</span><br><span class="line">            &#123;</span><br><span class="line">                ++cost;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cost = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cost == machine_cost)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j; k &gt; j - machine_cost; --k)</span><br><span class="line">                &#123;</span><br><span class="line">                    machine_timeline[machine_id][k] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, j);</span><br><span class="line">                project_timeline[project_id] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>使用一个二维数组，来模拟每台机器的时间轴；这样一来，就知道某台机器在某个时间点的状态了</p>
<p>工序只能按序进行，所以使用一个数组<code>project_timeline</code>来记录每个工件的上一次耗时；下一次该工件的耗时应该接着上一次继续</p>
<p>那么就剩最后一个问题：如何插入某台机器的时间空挡？</p>
<p>令工件从其上一次的耗时开始，沿着机器的时间轴判断哪些连续的时间点是空闲的</p>
<p>若连续的空闲时间点满足工序的时间开支，则代表可以插入，可以回头将这一段空闲时间点设置为繁忙</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P1786. 帮贡排序</title>
    <url>/2023/10/04/P1786-%E5%B8%AE%E8%B4%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>哈希函数</li>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string offer[<span class="number">7</span>] = &#123;<span class="string">&quot;BangZhu&quot;</span>, <span class="string">&quot;FuBangZhu&quot;</span>, <span class="string">&quot;HuFa&quot;</span>, <span class="string">&quot;ZhangLao&quot;</span>, <span class="string">&quot;TangZhu&quot;</span>, <span class="string">&quot;JingYing&quot;</span>, <span class="string">&quot;BangZhong&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> offer_cnts[<span class="number">7</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">25</span>, <span class="number">500</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="comment">//题目提到“原来靠前的现在也要靠前”，所以还需要idx_记录相对位置</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Member</span></span><br><span class="line">&#123;</span><br><span class="line">    string name_, offer_;</span><br><span class="line">    <span class="type">int</span> contri_, rank_, idx_;</span><br><span class="line">&#125; mem[<span class="number">550</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//精髓就在这里，字符串的优先级映射为数字，即可排序啦！</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hsh</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&quot;BangZhu&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;FuBangZhu&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;HuFa&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;ZhangLao&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;TangZhu&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;JingYing&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(Member a, Member b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.contri_ != b.contri_)</span><br><span class="line">        <span class="keyword">return</span> a.contri_ &gt; b.contri_;</span><br><span class="line">    <span class="comment">//非常恶心的坑点！帮贡相同则按原来顺序</span></span><br><span class="line">    <span class="keyword">return</span> a.idx_ &lt; b.idx_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(Member a, Member b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.offer_ != b.offer_)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hsh</span>(a.offer_) &gt; <span class="built_in">hsh</span>(b.offer_);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.rank_ != b.rank_)</span><br><span class="line">        <span class="keyword">return</span> a.rank_ &gt; b.rank_;</span><br><span class="line">    <span class="keyword">return</span> a.idx_ &lt; b.idx_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; mem[i].name_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mem[i].offer_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mem[i].rank_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; mem[i].name_ &gt;&gt; mem[i].offer_ &gt;&gt; mem[i].contri_ &gt;&gt; mem[i].rank_;</span><br><span class="line">        mem[i].idx_ = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为题目给的数据已经是按职位和等级排序了</span></span><br><span class="line">    <span class="comment">// 所以帮主和副帮主的位置不能动！哪怕帮贡有差别</span></span><br><span class="line">    <span class="built_in">sort</span>(mem + <span class="number">3</span>, mem + N, cmp1);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>, idx = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (offer_cnts[idx] &amp;&amp; i &lt; N)</span><br><span class="line">        &#123;</span><br><span class="line">            mem[i++].offer_ = offer[idx];</span><br><span class="line">            --offer_cnts[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        ++idx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(mem + <span class="number">3</span>, mem + N, cmp2);</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>这道题是授权题，但是质量真的不好....因为立意实在过于模糊</p>
<h2 id="第一个难点">第一个难点</h2>
<p>题目说<code>输出结果中，职位第一关键字，等级第二关键字</code></p>
<p>第一反应肯定是一次排序：先按帮贡优先，再按等级优先，然后修改他们的职位即可</p>
<p>然而，最终结果有很多相同的职位！比如有数据<code>A&#123;帮贡100, 等级4&#125;</code>,<code>B&#123;帮贡50，等级8&#125;</code>，且最终A与B职位一样</p>
<p>按照上述排序的优先级，结果是先A后B；但实际上应该先B后A，因为A与B最终职位一样，但B的等级大于A</p>
<p>所以需要两次排序！！！！！</p>
<p>第二次排序先根据职位排序，再根据等级排序，最后按照输入顺序排序</p>
<h2 id="第二个难点">第二个难点</h2>
<p>刚才提到按职位排序，可职位是字符串，怎么排序呢？</p>
<p>编写一个哈希函数，将其转化为数字就可以</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//精髓就在这里，字符串的优先级映射为数字，即可排序啦！</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hsh</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&quot;BangZhu&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;FuBangZhu&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;HuFa&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;ZhangLao&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;TangZhu&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;JingYing&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第一个坑点">第一个坑点</h2>
<p>因为题目说了帮主和副帮主不能动，所以排序的时候要避开这三个人</p>
<h2 id="第二个坑点">第二个坑点</h2>
<p>第一次排序的代码中，还需要再加一条输入顺序的优先才能AC...百思不得其解</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(Member a, Member b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.contri_ != b.contri_)</span><br><span class="line">        <span class="keyword">return</span> a.contri_ &gt; b.contri_;</span><br><span class="line">    <span class="comment">//非常恶心的坑点！帮贡相同则按原来顺序</span></span><br><span class="line">    <span class="keyword">return</span> a.idx_ &lt; b.idx_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>哈希函数</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P1098. 字符串的展开</title>
    <url>/2023/10/03/P1098-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B1%95%E5%BC%80/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
<li>字符串</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p1, p2, p3;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回-1，删除-</span></span><br><span class="line"><span class="comment">//返回0，不变</span></span><br><span class="line"><span class="comment">//返回1，换新</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[b] - s[a] == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s[a] &gt;= s[b])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">filling</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c = s[a] + <span class="number">1</span>; c &lt; s[b]; ++c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> chr;</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="number">1</span>)</span><br><span class="line">            chr = (<span class="type">char</span>)c;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p1 == <span class="number">2</span>)</span><br><span class="line">            chr = <span class="built_in">toupper</span>((<span class="type">char</span>)c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            chr = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">1</span>; cnt &lt;= p2; ++cnt)</span><br><span class="line">            res += chr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p3 == <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; p3;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> idx = <span class="number">0</span>; idx &lt; s.<span class="built_in">length</span>(); ++idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> head = idx - <span class="number">1</span>, tail = idx + <span class="number">1</span>, j;</span><br><span class="line">        <span class="keyword">if</span> (s[idx] != <span class="string">&#x27;-&#x27;</span> ||</span><br><span class="line">            head &lt; <span class="number">0</span> || tail == s.<span class="built_in">length</span>() ||</span><br><span class="line">            !(<span class="built_in">isdigit</span>(s[head]) &amp;&amp; <span class="built_in">isdigit</span>(s[tail]) || <span class="built_in">isalpha</span>(s[head]) &amp;&amp; <span class="built_in">isalpha</span>(s[tail])))</span><br><span class="line">        &#123;</span><br><span class="line">            ans += s[idx];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((j = <span class="built_in">judge</span>(head, tail)) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">            ans += s[idx];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans += <span class="built_in">filling</span>(head, tail);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>字符串的题，先思考是逐个读入方便还是整串处理方便；这道题显然只能选择整串读入，因为要处理-号的前后</p>
<p>每次判断-号的前一位和后一位，如果同时为数字或者同时为字母就进行下一步的扩展操作即可</p>
<p>唯一的坑点在于-号可能出现在开头和结尾，所以要特判范围防止越界</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>P1012. 模板题_拼数</title>
    <url>/2023/10/06/P1012-%E6%A8%A1%E6%9D%BF%E9%A2%98-%E6%8B%BC%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string arr[LEN];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + n, [](string a, string b) -&gt; <span class="type">bool</span></span><br><span class="line">         &#123; <span class="keyword">return</span> a + b &gt; b + a; &#125;);</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cout &lt;&lt; arr[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>一道非常经典的排序模板题</p>
<p>要让字符串a与字符串b拼接的字符串最大，很容易想到贪心规则——只要让a的每一位都比b大就可以了</p>
<p>但事实并不如此；比如<code>391</code>与<code>39</code>拼接，若单纯只以每一位的大小比较，结果是<code>39139</code>，但实际应该为<code>39391</code></p>
<p>在这里，思路要转变过来！排序问题不仅仅是“比大小”，更是“比优先级”</p>
<p>相邻两个元素a与b，谁的位置更应该靠前呢？如果a在前b在后组合的字符串，大于b在前a在后组合的字符串，a应该更靠前；反之亦然</p>
<p>所以最终的排序规则应该是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> a + b &gt; b + a;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>模板题</tag>
      </tags>
  </entry>
  <entry>
    <title>P1093. 奖学金</title>
    <url>/2023/10/05/P1093-%E5%A5%96%E5%AD%A6%E9%87%91/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stu</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cn_, mt_, en_, sum_, idx_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Stu a, Stu b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.sum_ != b.sum_)</span><br><span class="line">        <span class="keyword">return</span> a.sum_ &gt; b.sum_;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.cn_ != b.cn_)</span><br><span class="line">        <span class="keyword">return</span> a.cn_ &gt; b.cn_;</span><br><span class="line">    <span class="keyword">return</span> a.idx_ &lt; b.idx_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i].cn_ &gt;&gt; arr[i].mt_ &gt;&gt; arr[i].en_;</span><br><span class="line">        arr[i].sum_ = arr[i].cn_ + arr[i].mt_ + arr[i].en_;</span><br><span class="line">        arr[i].idx_ = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + n, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i, cout &lt;&lt; endl)</span><br><span class="line">        cout &lt;&lt; arr[i].idx_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr[i].sum_;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>没有别的坑点，用<code>sort</code>函数按照题意排序就行</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1068. 分数线划定</title>
    <url>/2023/10/06/P1068-%E5%88%86%E6%95%B0%E7%BA%BF%E5%88%92%E5%AE%9A/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">5001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id_, score_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i].id_ &gt;&gt; arr[i].score_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + n, [](Node a, Node b) -&gt; <span class="type">bool</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span> (a.score_ != b.score_)</span><br><span class="line">                 <span class="keyword">return</span> a.score_ &gt; b.score_;</span><br><span class="line">             <span class="keyword">return</span> a.id_ &lt; b.id_;</span><br><span class="line">         &#125;);</span><br><span class="line">    <span class="type">int</span> average = arr[(<span class="type">int</span>)(m * <span class="number">1.5</span>) - <span class="number">1</span>].score_, idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (arr[idx].score_ &gt;= average &amp;&amp; idx &lt; n)</span><br><span class="line">        ++idx;</span><br><span class="line">    cout &lt;&lt; average &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; idx &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; ++i, cout &lt;&lt; endl)</span><br><span class="line">        cout &lt;&lt; arr[i].id_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr[i].score_;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>没有别的坑，按要求排序即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1059. 明明的随机数</title>
    <url>/2023/10/05/P1059-%E6%98%8E%E6%98%8E%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[LEN], ans[LEN], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, in;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; in;</span><br><span class="line">        ++arr[in];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN; ++i)</span><br><span class="line">        <span class="keyword">if</span> (arr[i])</span><br><span class="line">            ans[idx++] = i;</span><br><span class="line">    cout &lt;&lt; idx &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; ++i)</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>数字最大也才到1000，直接使用计数排序就行</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1104. 生日</title>
    <url>/2023/10/06/P1104-%E7%94%9F%E6%97%A5/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">250</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    string s_;</span><br><span class="line">    <span class="type">int</span> idx_, y_, m_, d_;</span><br><span class="line">&#125; stu[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Student a, Student b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.y_ != b.y_)</span><br><span class="line">        <span class="keyword">return</span> a.y_ &lt; b.y_;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.m_ != b.m_)</span><br><span class="line">        <span class="keyword">return</span> a.m_ &lt; b.m_;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.d_ != b.d_)</span><br><span class="line">        <span class="keyword">return</span> a.d_ &lt; b.d_;</span><br><span class="line">    <span class="keyword">return</span> a.idx_ &gt; b.idx_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; stu[i].s_ &gt;&gt; stu[i].y_ &gt;&gt; stu[i].m_ &gt;&gt; stu[i].d_;</span><br><span class="line">        stu[i].idx_ = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(stu, stu + n, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cout &lt;&lt; stu[i].s_ &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>没有坑点，按照要求编写sort函数即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1152 欢乐的跳</title>
    <url>/2023/10/05/P1152-%E6%AC%A2%E4%B9%90%E7%9A%84%E8%B7%B3/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, arr[LEN], ans[LEN];</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        arr[i] = <span class="built_in">abs</span>(arr[i + <span class="number">1</span>] - arr[i]);</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, diff = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i, ++diff)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != diff)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Not jolly&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Jolly&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>n个元素共有n-1个相邻元素差，而题目刚好问你元素差是否都在<code>[1, n-1]</code>范围内</p>
<p>所以先求出差分数组，共n-1个元素；然后对差分数组进行排序，最后以下标从低到高的顺序逐位判断即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1116. 车厢重组</title>
    <url>/2023/10/05/P1116-%E8%BD%A6%E5%8E%A2%E9%87%8D%E7%BB%84/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bubble_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, arr[LEN];</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bubble_sort</span>(arr, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据<strong>两两交换</strong>的题面，很明显就是冒泡排序，要你求内部元素一共交换了多少次</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1177. 模板题_排序</title>
    <url>/2023/10/04/P1177-%E6%A8%A1%E6%9D%BF%E9%A2%98-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = len;</span><br><span class="line">    <span class="type">int</span> pivot = arr[<span class="built_in">rand</span>() % len];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot)</span><br><span class="line">            <span class="built_in">swap</span>(arr[i++], arr[j++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; pivot)</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[--k]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr + k, len - k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, arr[LEN];</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr));</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>由于是模板题，所以来系统地整理一下快速排序的相关问题；所有的模板均来源于<a
href="https://oi-wiki.org/basic/sort-intro/">OIWiki</a></p>
<h2 id="普通快排">普通快排</h2>
<p>普通快排的迭代版模板如下，来源于上述的OIWiki</p>
<p>其中对区间的分治操作需要熟练掌握，未来会经常用到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> start, end;</span><br><span class="line">    <span class="built_in">Range</span>(<span class="type">int</span> s = <span class="number">0</span>, <span class="type">int</span> e = <span class="number">0</span>) &#123; start = s, end = e; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(T arr[], <span class="type">const</span> <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Range r[len];</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    r[p++] = <span class="built_in">Range</span>(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        Range range = r[--p];</span><br><span class="line">        <span class="keyword">if</span> (range.start &gt;= range.end)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        T mid = arr[range.end];</span><br><span class="line">        <span class="type">int</span> left = range.start, right = range.end - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right)</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right)</span><br><span class="line">                right--;</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[left], arr[right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[left] &gt;= arr[range.end])</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[left], arr[range.end]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left++;</span><br><span class="line">        r[p++] = <span class="built_in">Range</span>(range.start, left - <span class="number">1</span>);</span><br><span class="line">        r[p++] = <span class="built_in">Range</span>(left + <span class="number">1</span>, range.end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当然也可以将其改造为递归，就变成广为流传的样子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> bg, <span class="type">int</span> ed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bg &gt;= ed)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> l = bg, r = ed - <span class="number">1</span>, pivot = arr[ed];</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[l] &lt; pivot &amp;&amp; l &lt; r)</span><br><span class="line">            ++l;</span><br><span class="line">        <span class="keyword">while</span> (arr[r] &gt;= pivot &amp;&amp; l &lt; r)</span><br><span class="line">            --r;</span><br><span class="line">        <span class="built_in">swap</span>(arr[l], arr[r]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[l] &gt;= arr[ed])</span><br><span class="line">        <span class="built_in">swap</span>(arr[l], arr[ed]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ++l;</span><br><span class="line">    <span class="built_in">quick_sort</span>(bg, l - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quick_sort</span>(l + <span class="number">1</span>, ed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">quick_sort</span>(<span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三路快速排序">三路快速排序</h2>
<p>普通快排效率并不高，上面的代码本题就会超时，就需要用到三路快排；模板同样来自OIWiki</p>
<p>顺带提一嘴，rand函数的用法可以简单记为<code>a + rand() % b</code>；即从a开始（包括a）共b个连续整数的生成范围</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板的 T 参数表示元素的类型，此类型需要定义小于（&lt;）运算</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// arr 为需要被排序的数组，len 为数组长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(T arr[], <span class="type">const</span> <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 随机选择基准（pivot）</span></span><br><span class="line">    <span class="type">const</span> T pivot = arr[<span class="built_in">rand</span>() % len];</span><br><span class="line">    <span class="comment">// i：当前操作的元素下标</span></span><br><span class="line">    <span class="comment">// arr[0, j)：存储小于 pivot 的元素</span></span><br><span class="line">    <span class="comment">// arr[k, len)：存储大于 pivot 的元素</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = len;</span><br><span class="line">    <span class="comment">// 完成一趟三路快排，将序列分为：</span></span><br><span class="line">    <span class="comment">// 小于 pivot 的元素 | 等于 pivot 的元素 | 大于 pivot 的元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot)</span><br><span class="line">            <span class="built_in">swap</span>(arr[i++], arr[j++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pivot &lt; arr[i])</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[--k]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归完成对于两个子序列的快速排序</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr + k, len - k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>模板题</tag>
      </tags>
  </entry>
  <entry>
    <title>P1781. 宇宙总统</title>
    <url>/2023/10/05/P1781-%E5%AE%87%E5%AE%99%E6%80%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx_;</span><br><span class="line">    string votes_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.votes_.<span class="built_in">length</span>() != b.votes_.<span class="built_in">length</span>())</span><br><span class="line">        <span class="keyword">return</span> a.votes_.<span class="built_in">length</span>() &gt; b.votes_.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.votes_.<span class="built_in">length</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.votes_[i] &gt; b.votes_[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a.votes_[i] &lt; b.votes_[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i].votes_;</span><br><span class="line">        arr[i].idx_ = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + n, cmp);</span><br><span class="line">    cout &lt;&lt; arr[<span class="number">0</span>].idx_ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; arr[<span class="number">0</span>].votes_;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本题实际上是比较以字符串形式存储的数字大小；先比较长度，更长的肯定更大，若长度相同再逐位比较</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1271. 选举学生会</title>
    <url>/2023/10/04/P1271-%E9%80%89%E4%B8%BE%E5%AD%A6%E7%94%9F%E4%BC%9A/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>计数排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, M, arr[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">counting_sort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; ++i)</span><br><span class="line">        <span class="keyword">while</span> (arr[i]--)</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">        ++arr[num];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">counting_sort</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本质上是根据每种数字出现的个数来输出，故而使用计数排序即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>计数排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1923. 模板题_求第 k 小的数</title>
    <url>/2023/10/05/P1923-%E6%A8%A1%E6%9D%BF%E9%A2%98-%E6%B1%82%E7%AC%AC-k-%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">5e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> K, arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">k_th</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = len, pivot = arr[<span class="built_in">rand</span>() % len];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot)</span><br><span class="line">            <span class="built_in">swap</span>(arr[i++], arr[j++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; pivot)</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[--k]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (K &lt; j)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">k_th</span>(arr, j);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (K &gt;= k)</span><br><span class="line">    &#123;</span><br><span class="line">        K -= k;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">k_th</span>(arr + k, len - k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> pivot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这行必须加，加快cin的读取速度</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">k_th</span>(arr, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>不同题目对<strong>第K大</strong>和<strong>第K小</strong>都有不同的定义；就本题而言，是求升序数列中的第K个元素，K从0开始</p>
<p>可以联想到三路快排算法：每次都以<code>pivot</code>为标准，左半部分均小于<code>pivot</code>，中间部分等于<code>pivot</code>，右半部分大于<code>pivot</code></p>
<p>所以只需要判断K处在哪一个部分：</p>
<ul>
<li>K在左半部分，向左半部分递归</li>
<li>K在中间部分，直接返回结果，因为中间部分的值都是相同的</li>
<li>K在右半部分，K先减去左半部分加中间部分的长度，以转换为右半部分子数组的下标，再向右半部分递归</li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>模板题</tag>
      </tags>
  </entry>
  <entry>
    <title>P2676. Bookshelf B</title>
    <url>/2023/10/05/P2676-Bookshelf-B/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">20050</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n, b, cnt = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + n, [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">bool</span></span><br><span class="line">         &#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; sum &lt; b; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>没有别的坑点，排序结束后累加即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P5143. 攀爬者</title>
    <url>/2023/10/06/P5143-%E6%94%80%E7%88%AC%E8%80%85/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">5e4</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x_, y_, z_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i].x_ &gt;&gt; arr[i].y_ &gt;&gt; arr[i].z_;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + n, [](Node a, Node b) -&gt; <span class="type">bool</span></span><br><span class="line">         &#123; <span class="keyword">return</span> a.z_ &lt; b.z_; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(arr[i].x_ - arr[i + <span class="number">1</span>].x_, <span class="number">2</span>) +</span><br><span class="line">                    <span class="built_in">pow</span>(arr[i].y_ - arr[i + <span class="number">1</span>].y_, <span class="number">2</span>) +</span><br><span class="line">                    <span class="built_in">pow</span>(arr[i].z_ - arr[i + <span class="number">1</span>].z_, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>没有坑点，根据高度z排序后，按序统计相邻节点的欧几里得距离即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1036. 模板题_选数</title>
    <url>/2023/10/07/P1036-%E6%A8%A1%E6%9D%BF%E9%A2%98-%E9%80%89%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">20</span>], ans, K, N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isprime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(x); ++i)</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cnt, <span class="type">int</span> idx, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt; K)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isprime</span>(sum))</span><br><span class="line">            ++ans;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = idx; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(cnt + <span class="number">1</span>, i + <span class="number">1</span>, sum + arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>一道DFS的模板题</p>
<p>为取数不重复，规定每次取数时的初始下标至少大于上一次的取数下标，就可以保证“永不回头”</p>
<p>由于每次只能取K个数，所以需要设立一个变量cnt来计数；如果当前cnt大于K，说明已经取够K个了，就进行质数判断然后返回</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模板题</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1088. 火星人</title>
    <url>/2023/10/07/P1088-%E7%81%AB%E6%98%9F%E4%BA%BA/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[LEN], N, M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="keyword">while</span> (M-- &amp;&amp; <span class="built_in">next_permutation</span>(arr, arr + N))</span><br><span class="line">        ;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题意其实就是给了一个序列，将这个序列全排列若干次后再输出</p>
<p>不会真有人尝试10000的阶乘吧！不会吧不会吧不会吧不会吧不会吧！！</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1149. 火柴棒等式</title>
    <url>/2023/10/08/P1149-%E7%81%AB%E6%9F%B4%E6%A3%92%E7%AD%89%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> table[<span class="number">10</span>] = &#123;<span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>&#125;, arr[<span class="number">2</span>], N, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cnt</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        res += table[x % <span class="number">10</span>];</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (x);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; N - <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cnt</span>(arr[<span class="number">0</span>]) + <span class="built_in">cnt</span>(arr[<span class="number">1</span>]) + <span class="built_in">cnt</span>(arr[<span class="number">0</span>] + arr[<span class="number">1</span>]) == N - <span class="number">4</span>)</span><br><span class="line">            ++ans;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1111</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[idx] = i;</span><br><span class="line">        <span class="built_in">dfs</span>(idx + <span class="number">1</span>, sum + <span class="built_in">cnt</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题意实际上是问，两个数字及其和的组成火柴总数要等于N-4</p>
<p>除去加号与等号的四根火柴后，还剩20根；那么每个数字极限也只能到1111</p>
<p>当然上亿次的暴力搜索还是太大了，如果遍历过程中火柴数已经大于N-4就可以直接剪枝</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1706. 全排列问题</title>
    <url>/2023/10/07/P1706-%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>], vis[<span class="number">10</span>], N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27; &#x27;</span>) &lt;&lt; <span class="built_in">setw</span>(<span class="number">5</span>) &lt;&lt; arr[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx == N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        arr[idx] = i;</span><br><span class="line">        vis[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(idx + <span class="number">1</span>);</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>用vis数组记录元素是否用过；每次元素的可能性都从1遍历到N（因为不同序列的元素组成可以相同）</p>
<p>只要没有被访问就纳入答案数组内，并在vis记录已用；当本次可能性的递归结束后，vis记录恢复为未用，避免影响其他情况</p>
<p>当然，全排列也可以直接调用STL函数<code>next_permutation</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>], vis[<span class="number">10</span>], N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27; &#x27;</span>) &lt;&lt; <span class="built_in">setw</span>(<span class="number">5</span>) &lt;&lt; arr[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        arr[i - <span class="number">1</span>] = i;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(arr, arr + N));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1618. 模板题_三连击（升级版）</title>
    <url>/2023/10/07/P1618-%E6%A8%A1%E6%9D%BF%E9%A2%98-%E4%B8%89%E8%BF%9E%E5%87%BB%EF%BC%88%E5%8D%87%E7%BA%A7%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>枚举</li>
<li>排列组合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">9</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="type">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        sum = sum * <span class="number">10</span> + arr[idx + i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c, flag = <span class="literal">false</span>;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num_1 = <span class="built_in">num</span>(<span class="number">0</span>), num_2 = <span class="built_in">num</span>(<span class="number">3</span>), num_3 = <span class="built_in">num</span>(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">if</span> (num_1 * b == num_2 * a &amp;&amp; num_1 * c == num_3 * a &amp;&amp; num_2 * c == num_3 * b)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num_3 &lt;&lt; endl;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(arr, arr + <span class="number">9</span>));</span><br><span class="line">    <span class="keyword">if</span> (!flag)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No!!!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题意，三个数的数字均不可能重复</p>
<p>实际上就可以视作为数字1-9的全排列，每次按序取前三位，中三位和后三位组成的数进行比较</p>
<p>STL中有函数<code>next_permutation</code>专门实现这一操作</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
        <tag>模板题</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>P1217. Prime Palindromes</title>
    <url>/2023/10/08/P1217-Prime-Palindromes/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>枚举</li>
<li>质数</li>
<li>回文数</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">11</span>], idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        arr[idx++] = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = idx - <span class="number">1</span>; i &lt; j; ++i, --j)</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != arr[j])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(x); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; <span class="number">9999999</span>)</span><br><span class="line">        b = <span class="number">9999999</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (a % <span class="number">2</span> ? a : a + <span class="number">1</span>); i &lt;= b; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(i) &amp;&amp; <span class="built_in">isPrime</span>(i))</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本题更多地是考验数论的能力.....</p>
<ul>
<li><p>如果一个数是11的倍数，那么奇数位置的和等于偶数位置的和；也就是说，11的倍数其实都是长度为偶数的回文数</p>
<p>所以可以提前剪枝，大于9999999的数都可以不用判断，因为就算是回文数也绝对不可能是质数</p></li>
<li><p>如果一个数是偶数，自然也不可能是质数，也可以借助这个特性再次剪枝</p></li>
<li><p>还有一个优化点，回文数的个数肯定是远小于质数的个数；所以判断回文数的操作应该放在判断质数之前，大幅减少时间开销</p></li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>质数</tag>
        <tag>回文数</tag>
      </tags>
  </entry>
  <entry>
    <title>P2036. PERKET</title>
    <url>/2023/10/08/P2036-PERKET/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sour_, bitter_;</span><br><span class="line">&#125; arr[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = INT_MAX, N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> sum_sour, <span class="type">int</span> sum_bitter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum_sour != <span class="number">1</span> &amp;&amp; sum_bitter != <span class="number">0</span>)</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(sum_sour - sum_bitter));</span><br><span class="line">    <span class="keyword">if</span> (idx == N)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(idx + <span class="number">1</span>, sum_sour, sum_bitter);</span><br><span class="line">    <span class="built_in">dfs</span>(idx + <span class="number">1</span>, sum_sour * arr[idx].sour_, sum_bitter + arr[idx].bitter_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i].sour_ &gt;&gt; arr[i].bitter_;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>每种配料都有选与不选两种情况，且最多只有10个配料，即2<sup>10</sup>的复杂度，可以直接暴力DFS</p>
<p>题目说<strong>至少选一种配料</strong>，且<strong>酸度和苦度不同时为1和0</strong></p>
<p>也就是说，只有初始状态，和所有配料都没选这两种特殊情况才有可能出现酸度为1且苦度为0</p>
<p>所以直接屏蔽<strong>酸度为1且苦度为0</strong>时的情况即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sum_sour != <span class="number">1</span> &amp;&amp; sum_bitter != <span class="number">0</span>)</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(sum_sour - sum_bitter));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1157. 组合的输出</title>
    <url>/2023/10/07/P1157-%E7%BB%84%E5%90%88%E7%9A%84%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">20</span>], N, R;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; R; ++i)</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27; &#x27;</span>) &lt;&lt; <span class="built_in">setw</span>(<span class="number">3</span>) &lt;&lt; arr[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cnt, <span class="type">int</span> idx, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt; R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = num; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[idx] = i;</span><br><span class="line">        <span class="built_in">dfs</span>(cnt + <span class="number">1</span>, idx + <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; R;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据升序且不重复的要求，每次取数都应比上一次取的数要大</p>
<p>又因为限定了只取R个数，所以需要额外设定一个cnt变量来计数；当cnt大于R时，说明已取够，应当输出</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P2241 统计方形</title>
    <url>/2023/10/07/P2241-%E7%BB%9F%E8%AE%A1%E6%96%B9%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>枚举</li>
<li>排列组合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ll sum = ((n + <span class="number">1</span>) * n * (m + <span class="number">1</span>) * m) / <span class="number">4</span>;</span><br><span class="line">    ll square = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">min</span>(n, m); ++i)</span><br><span class="line">        square += (n - i + <span class="number">1</span>) * (m - i + <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; square &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; sum - square;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>长方形的个数不好求，秉持着“正难则反”的原则，可以先求出一共有多少个矩形，再用矩形的数量减去正方形的数量即可</p>
<p>题意是说<code>n*m个格子的棋盘</code>，那么就有<code>(n + 1) * (m + 1)</code>个点</p>
<p>而矩形实际上就是行方向取两个点之间的长度作为宽，列方向取两个点之间的长度作为长；根据排列组合原理，有如下等式：
<span class="math display">\[
C_{n+1}^{2}\times C_{m+1}^{2}=\frac{\left( n+1 \right) !}{2!\times
\left( n-1 \right) !}\times \frac{\left( m+1 \right) !}{2!\times \left(
m-1 \right) !}=\frac{\left( n+1 \right) \times n\times \left( m+1
\right) \times m}{4}=\text{矩阵个数}
\]</span>
正方形的个数也很容易计算，边长为1的正方形个数+边长为2的正方形个数+...+边长为<code>min(n, m)</code>的正方形个数，也有如下等式
<span class="math display">\[
\left( n-1+1 \right) \times \left( m-1+1 \right) +\left( n-2+1 \right)
\times \left( m-2+1 \right) +...+\left( n-\min \left( n,m \right) +1
\right) \times \left( m-\min \left( n,m \right) +1 \right)
\]</span></p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>P3654. First Step</title>
    <url>/2023/10/08/P3654-First-Step/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>枚举</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> arr[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> R, C, K, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> walk[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cnt</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= R &amp;&amp; y &lt;= C &amp;&amp; arr[x][y] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; res &lt; K)</span><br><span class="line">    &#123;</span><br><span class="line">        x += walk[idx][<span class="number">0</span>], y += walk[idx][<span class="number">1</span>];</span><br><span class="line">        ++res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res == K)</span><br><span class="line">        ++ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; R &gt;&gt; C &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= R; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= C; ++j)</span><br><span class="line">            cin &gt;&gt; arr[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= R; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= C; ++j)</span><br><span class="line">            <span class="built_in">cnt</span>(i, j, <span class="number">0</span>), <span class="built_in">cnt</span>(i, j, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// K等于1的时候会重复</span></span><br><span class="line">    cout &lt;&lt; (K == <span class="number">1</span> ? ans &gt;&gt; <span class="number">1</span> : ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>枚举所有点，每次判断从当前位置向右走或向下走是否满足连续K个空位即可（向右走和向下走可以保证情况不重复）</p>
<p>坑点在于，当K等于1时结果要除2，因为此时向右和向下走情况是重复的</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>P3799. 妖梦拼木棒</title>
    <url>/2023/10/08/P3799-%E5%A6%96%E6%A2%A6%E6%8B%BC%E6%9C%A8%E6%A3%92/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>枚举</li>
<li>排列组合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5050</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求组合数，限定取2或1</span></span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(ll a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> ((a % mod) * ((a - <span class="number">1</span>) % mod) / <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, in;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; in;</span><br><span class="line">        ++arr[in];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5000</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ll a = <span class="built_in">calc</span>(arr[i], <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!arr[j] || !arr[i - j])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//两个短边相等的时候</span></span><br><span class="line">            <span class="keyword">if</span> (j == i - j &amp;&amp; arr[j] &gt;= <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ll b = <span class="built_in">calc</span>(arr[j], <span class="number">2</span>);</span><br><span class="line">                ans = (ans + (a * b) % mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j != i - j)</span><br><span class="line">            &#123;</span><br><span class="line">                ll b = <span class="built_in">calc</span>(arr[j], <span class="number">1</span>), c = <span class="built_in">calc</span>(arr[i - j], <span class="number">1</span>);</span><br><span class="line">                ans = (ans + (a * b * c) % mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>用一个数组arr记录各类长度的个数；如果双重循环枚举短边的话，是绝对会超时的</p>
<p>由于其中一条短边一定小于等于长边的一半；那么外循环就枚举长边，内循环枚举小于等于长边一半的短边，复杂度就降到了<span
class="math inline">\(n^2/2\)</span></p>
<blockquote>
<p>假设长边为a，一个短边为b，另一个短边为c，有以下等式成立： <span
class="math display">\[
\frac{a}{2}=\frac{\left( b+c \right)}{2}
\]</span>
映射到数轴上看，显然有一个短边必小于等于长边一半，而另一个短边必大于等于长边一半</p>
</blockquote>
<p>找到了符合条件的三种边后，使用排列乘法原理即可：</p>
<ul>
<li><p>如果短边b等于短边c，相当于从长度等于b的火柴中取2根，再从长度等于a长边的火柴中取2根，即：
<span class="math display">\[
C_{a}^{2}\times C_{b}^{2}
\]</span></p></li>
<li><p>如果短边b不等于短边c，分别从长度b、长度c两堆各取1根，从长度a取2根
<span class="math display">\[
C_{a}^{2}\times C_{b}^{1}\times C_{c}^{1}
\]</span></p></li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>P2089. 烤鸡</title>
    <url>/2023/10/07/P2089-%E7%83%A4%E9%B8%A1/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>], ans[<span class="number">55000</span>][<span class="number">10</span>], cnt = <span class="number">-1</span>, N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; cnt + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cnt; ++i, cout &lt;&lt; endl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j)</span><br><span class="line">            cout &lt;&lt; ans[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt; <span class="number">10</span> || sum &gt; N)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">10</span> &amp;&amp; sum == N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">copy</span>(arr, arr + <span class="number">10</span>, ans[++cnt]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[idx] = i;</span><br><span class="line">        <span class="built_in">dfs</span>(idx + <span class="number">1</span>, sum + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">if</span> (N &gt; <span class="number">30</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">-1</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>一道基础的DFS题目</p>
<p>每类配料都有3种选择，一共10类，按道理一共有3<sup>10</sup>种选法，绝对会超时；好在题目只是要求所有类别的配料质量之和</p>
<p>那么只要输入N大于<code>3 * 10 = 30</code>就是无效的；同时DFS的过程中，和大于N也可以直接退出。两种剪枝操作大大降低了时间复杂度</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P2392. kkksc03考前临时抱佛脚</title>
    <url>/2023/10/08/P2392-kkksc03%E8%80%83%E5%89%8D%E4%B8%B4%E6%97%B6%E6%8A%B1%E4%BD%9B%E8%84%9A/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">4</span>][<span class="number">20</span>], ans[<span class="number">4</span>], res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> idx, <span class="type">int</span> lbrain, <span class="type">int</span> rbrain, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx == n)</span><br><span class="line">    &#123;</span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">max</span>(lbrain, rbrain));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(arr, idx + <span class="number">1</span>, lbrain + arr[idx], rbrain, n);</span><br><span class="line">    <span class="built_in">dfs</span>(arr, idx + <span class="number">1</span>, lbrain, rbrain + arr[idx], n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        cin &gt;&gt; ans[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        <span class="built_in">read</span>(arr[i], ans[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        res = INT_MAX, <span class="built_in">dfs</span>(arr[i], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ans[i]), ans[i] = res;</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        res += ans[i];</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>每次都有两种情况，给左脑还是给右脑，每科最多20次，也就是4<sup>10</sup>的时间复杂度，暴力DFS是可以过的</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P3392. 涂国旗</title>
    <url>/2023/10/08/P3392-%E6%B6%82%E5%9B%BD%E6%97%97/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>枚举</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> arr[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cost</span><span class="params">(<span class="type">int</span> bg, <span class="type">int</span> ed, <span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = bg; i &lt;= ed; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i][j] != c)</span><br><span class="line">                ++res;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">            cin &gt;&gt; arr[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum_w = <span class="built_in">cost</span>(<span class="number">1</span>, i, <span class="string">&#x27;W&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = N - <span class="number">2</span>; j &gt;= <span class="number">1</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum_r = <span class="built_in">cost</span>(N - j + <span class="number">1</span>, N, <span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">            <span class="type">int</span> sum_b = <span class="built_in">cost</span>(i + <span class="number">1</span>, N - j, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, sum_w + sum_r + sum_b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>假设一共有N行</p>
<p>白色的行最少有1行，最多有N-2行；红色的行最少也有1行，最多也有N-2行；白色与红色确认行数后，蓝色的行数也可以确认</p>
<p>所以直接令白色行数与红色行数执行双重循环的枚举，对比不同情况下的开销即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>P1002. 过河卒</title>
    <url>/2023/10/09/P1002-%E8%BF%87%E6%B2%B3%E5%8D%92/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线性动态规划</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll f[<span class="number">25</span>][<span class="number">25</span>], ctrl[<span class="number">25</span>][<span class="number">25</span>], n, m, hx, hy;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ctrl[hx][hy] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-2</span>; i &lt;= <span class="number">2</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-2</span>; j &lt;= <span class="number">2</span>; ++j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(i) + <span class="built_in">abs</span>(j) == <span class="number">3</span> &amp;&amp;</span><br><span class="line">                (hx + i) &gt;= <span class="number">0</span> &amp;&amp; (hx + i) &lt;= n &amp;&amp;</span><br><span class="line">                (hy + j) &gt;= <span class="number">0</span> &amp;&amp; (hy + j) &lt;= m)</span><br><span class="line">                ctrl[hx + i][hy + j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctrl[i][j])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; i - <span class="number">1</span> &lt;= n)</span><br><span class="line">                f[i][j] += f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; j - <span class="number">1</span> &lt;= m)</span><br><span class="line">                f[i][j] += f[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; hx &gt;&gt; hy;</span><br><span class="line">    <span class="built_in">init</span>(), <span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>每次只能向右和向下走，那么每个新的状态就只能由上面一个点和左边一个点共同组成，很容易得到递推式：
<span class="math display">\[
f\left( x,y \right) =f\left( x-1,y \right) +f\left( x,y-1 \right)
\]</span>
由于需要避开马的控制范围，所以单独开一个数组ctrl，记录哪些点不能走即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>线性动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>P1028. 数的计算</title>
    <url>/2023/10/10/P1028-%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线性动态规划</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll mem[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mem[x])</span><br><span class="line">        <span class="keyword">return</span> mem[x];</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> || x == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> mem[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= x / <span class="number">2</span>; ++i)</span><br><span class="line">        mem[x] += <span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="keyword">return</span> mem[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>设<code>mem[n]</code>为数字<code>n</code>的合法数列个数；令<code>mem[0] = 1</code>，意为数字<code>n</code>本身构成的序列，数列末尾什么也不加</p>
<p>显然能得到状态转移方程： <span class="math display">\[
mem\left[ 0 \right] +mem\left[ 1 \right] +...mem\left[ n/2 \right]
\rightarrow mem\left[ n \right]
\]</span> 题解是递归编写的，将其改为递推也是可以的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll dp[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i / <span class="number">2</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] += dp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>线性动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>P1010. 幂次方</title>
    <url>/2023/10/11/P1010-%E5%B9%82%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
<li>分治</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;2(0)&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;2&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;2(&quot;</span>, <span class="built_in">f</span>(i), cout &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            x ^= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="keyword">if</span> (x)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;+&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">f</span>(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>简单的分治题，最终的子问题实际上就是：</p>
<ul>
<li><p>什么时候往下分</p>
<p>幂次大于1的时候继续往下分</p></li>
<li><p>什么时候输出括号</p>
<p>幂次等于1和0的时候直接输出<code>2</code>和<code>2(0)</code></p>
<p>其余幂次先输出<code>2(</code>，等内部递归结束后再输出<code>)</code></p></li>
<li><p>什么时候输出加号</p>
<p>还需要往下分的时候</p></li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P1044. 模板题_栈</title>
    <url>/2023/10/10/P1044-%E6%A8%A1%E6%9D%BF%E9%A2%98-%E6%A0%88/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>卡特兰数</li>
<li>线性动态规划</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<h2 id="卡特兰数">卡特兰数</h2>
<p>卡特兰数本身并不难理解，可以直接看这篇<a
href="https://leetcode.cn/circle/discuss/lWYCzv/">链接</a>进行学习</p>
<p>这里提醒一下，在《深基》与《算法导论》中非法序列的个数为<span
class="math inline">\(C_{2n}^{n-1}\)</span>，在上面的链接中则是<span
class="math inline">\(C_{2n}^{n+1}\)</span>；但结果是一样的，只是角度不同</p>
<p>因为组合数本来就有这个性质： <span class="math display">\[
C_{n}^{m}=C_{n}^{n-m}
\]</span> 故而本题可以直接按照卡特兰数的通项输出即可，不再赘述</p>
<h2 id="递推">递推</h2>
<p>思路来源于kkksc03</p>
<p>假设i个元素一共有h[i]种出栈方式，那么要求的就是n个元素的出栈方式，即h[n]</p>
<p>n个元素下标为从1到n，每个元素都有可能是最后一个出栈的，即输出序列的最后一位</p>
<p>假设第k个数是最后一个出栈的，情况会是这样：</p>
<ol type="1">
<li><p>前面有k-1个数先入栈，然后出栈，即h[k-1]</p></li>
<li><p>第k个数入栈</p></li>
<li><p>n-k个数入栈，然后出栈，即h[n-k]</p></li>
</ol>
<p>所以当第k个数是最后一个出栈时，情况共有<code>h[k-1] * h[n-k]</code>种</p>
<p>那么就能得到递推式： <span class="math display">\[
h\left( n \right) =h\left( 0 \right) \times h\left( n-1 \right) +h\left(
1 \right) \times h\left( n-2 \right) +...+h\left( n-1 \right) \times
h\left( 0 \right)
\]</span></p>
<p><span class="math display">\[
h\left( 0 \right) =h\left( 1 \right) =1
\]</span></p>
<p>这样就能写出极简代码了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, h[<span class="number">20</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            h[i] += h[j] * h[i - j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; h[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线性动态规划-记忆化搜索">线性动态规划 记忆化搜索</h2>
<p>以输出序列的元素个数qe，栈的元素个数st为状态分析对象，建立二维数组<code>mem[qe][st]</code></p>
<p>根据栈的性质，要么从栈顶弹出一个元素给输出序列，要么就继续入栈新元素不弹出；易得状态转移方程如下：
<span class="math display">\[
\underset{\text{栈顶弹出给输出序列}}{\underbrace{mem\left[ qe-1 \right]
\left[ st+1 \right]
}}+\underset{\text{入栈新元素不弹出}}{\underbrace{mem\left[ qe \right]
\left[ st-1 \right] }}\rightarrow mem\left[ qe \right] \left[ st \right]
\]</span>
那么临界值呢？很显然，当输出序列qe为0的时候不可再分，此时令<code>mem[qe][st] = 1</code>；如果越界的话令<code>mem[qe][st] = 0</code>即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">ll mem[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> qe, <span class="type">int</span> st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mem[qe][st])</span><br><span class="line">        <span class="keyword">return</span> mem[qe][st];</span><br><span class="line">    <span class="keyword">if</span> (qe &lt; <span class="number">0</span> || qe &gt; n || st &lt; <span class="number">0</span> || st &gt; n)</span><br><span class="line">        <span class="keyword">return</span> mem[qe][st] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (qe == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> mem[qe][st] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> mem[qe][st] = <span class="built_in">dfs</span>(qe - <span class="number">1</span>, st + <span class="number">1</span>) + <span class="built_in">dfs</span>(qe, st - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(n, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线性动态规划-递推">线性动态规划 递推</h2>
<p>将上面的递归改成迭代即可，不再赘述</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> st = <span class="number">0</span>; st &lt;= n; ++st)</span><br><span class="line">        dp[<span class="number">0</span>][st] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> qe = <span class="number">1</span>; qe &lt;= n; ++qe)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> st = <span class="number">0</span>; st &lt;= n; ++st)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[qe][st] = dp[qe - <span class="number">1</span>][st + <span class="number">1</span>] + dp[qe][st - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模板题</tag>
        <tag>线性动态规划</tag>
        <tag>卡特兰数</tag>
      </tags>
  </entry>
  <entry>
    <title>P1164. 模板题_小A点菜</title>
    <url>/2023/10/11/P1164-%E6%A8%A1%E6%9D%BF%E9%A2%98-%E5%B0%8FA%E7%82%B9%E8%8F%9C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>01背包</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<h2 id="二维数组实现">二维数组实现</h2>
<p>经典的01背包问题，每种元素只有一个，且只有选或不选两种状态；题目要求多少种选法能刚好花光m元</p>
<p>可以设<code>dp[i][j]</code>为<strong>前i个元素花了j元</strong>，显然有动态转移方程如下：
<span class="math display">\[
\underset{\text{前}i-1\text{个元素花}j\text{元}}{\underbrace{dp\left[
i-1 \right] \left[ j \right]
}}+\underset{\text{选第}i\text{个元素，前}i-1\text{个元素应花}j-\cos
t\left[ i \right] \text{元}}{\underbrace{dp\left[ i-1 \right] \left[
j-\cos t\left[ i \right] \right] }}\rightarrow dp\left[ i \right] \left[
j \right]
\]</span>
我们最终要计算的就是<code>dp[n][m]</code>，即前n个元素花了m元的情况</p>
<p>本题的临界值应该在<code>j == 0</code>的时候，也就是当预算刚好等于当前物品的价格，只有选自己一种选法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">101</span>][<span class="number">10050</span>], cost[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; cost[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] += dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= cost[i])</span><br><span class="line">                dp[i][j] += dp[i - <span class="number">1</span>][j - cost[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="滚动数组实现">滚动数组实现</h2>
<p>由于每次只需要前一个状态，可以去掉第一维的元素计数，只记录开销；但开销的遍历要变成逆序，不能和上述的二维数组一样正序</p>
<p>二维数组是按照不同情况分别记录，正序遍历并不会覆盖旧状态</p>
<p>而浓缩成一维后，若正序遍历，后续状态用到的旧状态都被你覆盖更新完了...</p>
<p>逆序遍历就能保证，每次状态转移方程用到的旧状态是原始的旧状态，并没有被覆盖更新</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">10050</span>], cost[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; cost[i];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= cost[i]; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] += dp[j - cost[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模板题</tag>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>P1255. 数楼梯</title>
    <url>/2023/10/09/P1255-%E6%95%B0%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>斐波那契</li>
<li>递推</li>
<li>高精度</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len_;</span><br><span class="line">    <span class="type">int</span> arr_[<span class="number">2500</span>];</span><br><span class="line">    <span class="built_in">BigInt</span>(string s = <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr_, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr_));</span><br><span class="line">        len_ = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">            arr_[i] += s[len_ - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr_[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len_ = x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr_[i + <span class="number">1</span>] += arr_[i] / <span class="number">10</span>;</span><br><span class="line">                arr_[i] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!arr_[len_])</span><br><span class="line">            --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, len_); i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">            cout &lt;&lt; arr_[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>+(BigInt a, BigInt b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">max</span>(a.len_, b.len_);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    c.<span class="built_in">flatten</span>(len + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">BigInt <span class="title">a</span><span class="params">(<span class="string">&quot;1&quot;</span>)</span>, <span class="title">b</span><span class="params">(<span class="string">&quot;2&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        a.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        b.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            BigInt c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        b.<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>每个状态都是由前状态和前前状态相加而成，典型的斐波那契数列呀！配合高精度直接递推计算即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>高精度</tag>
        <tag>斐波那契</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>P1228. 地毯填补问题</title>
    <url>/2023/10/11/P1228-%E5%9C%B0%E6%AF%AF%E5%A1%AB%E8%A1%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>分治</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> board[<span class="number">1025</span>][<span class="number">1025</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x_bg, <span class="type">int</span> x_ed, <span class="type">int</span> y_bg, <span class="type">int</span> y_ed, <span class="type">int</span> princess_x, <span class="type">int</span> princess_y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x_mid = (x_bg + x_ed) / <span class="number">2</span>, y_mid = (y_bg + y_ed) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (princess_x &lt;= x_mid &amp;&amp; princess_y &lt;= y_mid)</span><br><span class="line">    &#123; <span class="comment">// 公主在左上方</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, x_mid + <span class="number">1</span>, y_mid + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (x_bg == x_mid &amp;&amp; y_bg == y_mid)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//左上，右上，左下，右下四个方向更新各自的公主位置后，继续递归</span></span><br><span class="line">        <span class="built_in">f</span>(x_bg, x_mid, y_bg, y_mid, princess_x, princess_y);</span><br><span class="line">        <span class="built_in">f</span>(x_bg, x_mid, y_mid + <span class="number">1</span>, y_ed, x_mid, y_mid + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">f</span>(x_mid + <span class="number">1</span>, x_ed, y_bg, y_mid, x_mid + <span class="number">1</span>, y_mid);</span><br><span class="line">        <span class="built_in">f</span>(x_mid + <span class="number">1</span>, x_ed, y_mid + <span class="number">1</span>, y_ed, x_mid + <span class="number">1</span>, y_mid + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (princess_x &lt;= x_mid &amp;&amp; princess_y &gt; y_mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 公主在右上方</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, x_mid + <span class="number">1</span>, y_mid, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (x_bg == x_mid &amp;&amp; y_bg == y_mid)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">f</span>(x_bg, x_mid, y_bg, y_mid, x_mid, y_mid);</span><br><span class="line">        <span class="built_in">f</span>(x_bg, x_mid, y_mid + <span class="number">1</span>, y_ed, princess_x, princess_y);</span><br><span class="line">        <span class="built_in">f</span>(x_mid + <span class="number">1</span>, x_ed, y_bg, y_mid, x_mid + <span class="number">1</span>, y_mid);</span><br><span class="line">        <span class="built_in">f</span>(x_mid + <span class="number">1</span>, x_ed, y_mid + <span class="number">1</span>, y_ed, x_mid + <span class="number">1</span>, y_mid + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (princess_x &gt; x_mid &amp;&amp; princess_y &lt;= y_mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 公主在左下方</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, x_mid, y_mid + <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (x_bg == x_mid &amp;&amp; y_bg == y_mid)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">f</span>(x_bg, x_mid, y_bg, y_mid, x_mid, y_mid);</span><br><span class="line">        <span class="built_in">f</span>(x_bg, x_mid, y_mid + <span class="number">1</span>, y_ed, x_mid, y_mid + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">f</span>(x_mid + <span class="number">1</span>, x_ed, y_bg, y_mid, princess_x, princess_y);</span><br><span class="line">        <span class="built_in">f</span>(x_mid + <span class="number">1</span>, x_ed, y_mid + <span class="number">1</span>, y_ed, x_mid + <span class="number">1</span>, y_mid + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 公主在右下方</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, x_mid, y_mid, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (x_bg == x_mid &amp;&amp; y_bg == y_mid)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">f</span>(x_bg, x_mid, y_bg, y_mid, x_mid, y_mid);</span><br><span class="line">        <span class="built_in">f</span>(x_bg, x_mid, y_mid + <span class="number">1</span>, y_ed, x_mid, y_mid + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">f</span>(x_mid + <span class="number">1</span>, x_ed, y_bg, y_mid, x_mid + <span class="number">1</span>, y_mid);</span><br><span class="line">        <span class="built_in">f</span>(x_mid + <span class="number">1</span>, x_ed, y_mid + <span class="number">1</span>, y_ed, princess_x, princess_y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, princess_x, princess_y;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; princess_x &gt;&gt; princess_y;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>, <span class="built_in">pow</span>(<span class="number">2</span>, n), <span class="number">1</span>, <span class="built_in">pow</span>(<span class="number">2</span>, n), princess_x, princess_y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>经典的分治题</p>
<p>公主必出现在当前大正方形的左上，右上，左下，右下四个方位；那么大正方形中心填充的地毯缺口就会正对公主那个方位</p>
<p>因此，每一次都只需要填充当前大正方形的中心，然后分别向四个方位的四个小正方形递归</p>
<p>假设当前公主出现在左上方，那么填充中心的应当是1，随后向四个方位递归：</p>
<ul>
<li>公主坐标不变，向左上方递归，边界收缩；</li>
<li>公主坐标改为大正方形中心填充地毯的右上角部分，向右上方递归，边界收缩；</li>
<li>公主坐标改为大正方形中心填充地毯的左下角部分，向左下方递归，边界收缩；</li>
<li>公主坐标改为大正方形中心填充地毯的右下角部分，向右下方递归，边界收缩；</li>
</ul>
<p>循环往复，直到当前大正方形是<code>2 * 2</code>的规格，无法再分</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P1464. Function</title>
    <url>/2023/10/10/P1464-Function/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线性动态规划</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">ll mem[LEN][LEN][LEN];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">w</span><span class="params">(ll a, ll b, ll c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= <span class="number">0</span> || b &lt;= <span class="number">0</span> || c &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; <span class="number">20</span> || b &gt; <span class="number">20</span> || c &gt; <span class="number">20</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">w</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mem[a][b][c])</span><br><span class="line">        <span class="keyword">return</span> mem[a][b][c];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; b &amp;&amp; b &lt; c)</span><br><span class="line">        <span class="keyword">return</span> mem[a][b][c] = <span class="built_in">w</span>(a, b, c - <span class="number">1</span>) + <span class="built_in">w</span>(a, b - <span class="number">1</span>, c - <span class="number">1</span>) - <span class="built_in">w</span>(a, b - <span class="number">1</span>, c);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> mem[a][b][c] = <span class="built_in">w</span>(a - <span class="number">1</span>, b, c) + <span class="built_in">w</span>(a - <span class="number">1</span>, b - <span class="number">1</span>, c) + <span class="built_in">w</span>(a - <span class="number">1</span>, b, c - <span class="number">1</span>) - <span class="built_in">w</span>(a - <span class="number">1</span>, b - <span class="number">1</span>, c - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a, b, c;</span><br><span class="line">    <span class="keyword">while</span> ((cin &gt;&gt; a &gt;&gt; b &gt;&gt; c) &amp;&amp; (a != <span class="number">-1</span> || b != <span class="number">-1</span> || c != <span class="number">-1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;w(%lld, %lld, %lld) = %lld\n&quot;</span>, a, b, c, <span class="built_in">w</span>(a, b, c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>没有坑点，按照题意分配好记忆化搜索的语句即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>线性动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>P1498. 南蛮图腾</title>
    <url>/2023/10/11/P1498-%E5%8D%97%E8%9B%AE%E5%9B%BE%E8%85%BE/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>分治</li>
<li>字符串</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大长度为2048，高度为长度的一半</span></span><br><span class="line"><span class="type">char</span> table[<span class="number">1024</span>][<span class="number">2048</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2048</span>; ++j)</span><br><span class="line">            table[i][j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    table[<span class="number">1023</span>][<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>, table[<span class="number">1023</span>][<span class="number">1</span>] = table[<span class="number">1023</span>][<span class="number">2</span>] = <span class="string">&#x27;_&#x27;</span>, table[<span class="number">1023</span>][<span class="number">3</span>] = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line">    table[<span class="number">1022</span>][<span class="number">1</span>] = <span class="string">&#x27;/&#x27;</span>, table[<span class="number">1022</span>][<span class="number">2</span>] = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1024</span> - height; i &lt; <span class="number">1024</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; width; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; table[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, cnt = <span class="number">2</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> width = <span class="number">4</span>, height = width &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1024</span> - height; i &lt; <span class="number">1024</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; width; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//				向右复制</span></span><br><span class="line">                table[i][j + width] = table[i][j];</span><br><span class="line">                <span class="comment">//				向上复制</span></span><br><span class="line">                table[i - height][j + height] = table[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++cnt, width *= <span class="number">2</span>, height *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(width, height);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>划分子问题，每次把图腾向右复制和向上复制即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P1928. 外星密码</title>
    <url>/2023/10/10/P1928-%E5%A4%96%E6%98%9F%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
<li>字符串</li>
<li>分治</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            cin &gt;&gt; n;</span><br><span class="line">            string t = <span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">while</span> (n--)</span><br><span class="line">                s += t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">read</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>字符串的模拟题，先考虑逐个字符读入还是整行读入；很显然，本题应该选择逐字符读入</p>
<ul>
<li><p>由于每个闭合的<code>[]</code>实际上就是一个字符串，很容易联想到递归，每次处理完后返回结果字符串</p></li>
<li><p><code>[数字</code>就可以视作递归开始符，只要遇到了<code>[数字</code>就开启新的递归</p></li>
<li><p><code>]</code>可以视作递归结束符，只要遇到了它就返回当前递归的结果字符串</p></li>
<li><p>正常字母接在当前递归的结果字符串即可</p></li>
</ul>
<p>根据上述思路，就可以编写题解啦</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P1259. 黑白棋子的移动</title>
    <url>/2023/10/11/P1259-%E9%BB%91%E7%99%BD%E6%A3%8B%E5%AD%90%E7%9A%84%E7%A7%BB%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">550</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= N; ++i)</span><br><span class="line">        str[i] = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= <span class="number">2</span> * N; ++i)</span><br><span class="line">        str[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    str[i++] = <span class="string">&#x27;-&#x27;</span>, str[i] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * N + <span class="number">2</span>; ++i)</span><br><span class="line">        cout &lt;&lt; str[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> blank_idx = <span class="number">2</span> * N + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = N; i &gt; <span class="number">4</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(str[i], str[blank_idx]), <span class="built_in">swap</span>(str[i + <span class="number">1</span>], str[blank_idx + <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">print</span>();</span><br><span class="line">        <span class="built_in">swap</span>(str[i], str[blank_idx - <span class="number">2</span>]), <span class="built_in">swap</span>(str[i + <span class="number">1</span>], str[blank_idx - <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">print</span>();</span><br><span class="line">        blank_idx -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    单独处理只剩4个的时候</span></span><br><span class="line">    <span class="built_in">swap</span>(str[<span class="number">4</span>], str[blank_idx]), <span class="built_in">swap</span>(str[<span class="number">5</span>], str[blank_idx + <span class="number">1</span>]);</span><br><span class="line">    --blank_idx;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="built_in">swap</span>(str[<span class="number">4</span>], str[blank_idx]), <span class="built_in">swap</span>(str[<span class="number">5</span>], str[blank_idx + <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="built_in">swap</span>(str[<span class="number">2</span>], str[blank_idx]), <span class="built_in">swap</span>(str[<span class="number">3</span>], str[blank_idx + <span class="number">1</span>]);</span><br><span class="line">    --blank_idx;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="built_in">swap</span>(str[<span class="number">2</span>], str[blank_idx]), <span class="built_in">swap</span>(str[<span class="number">3</span>], str[blank_idx + <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="built_in">swap</span>(str[<span class="number">1</span>], str[blank_idx]), <span class="built_in">swap</span>(str[<span class="number">2</span>], str[blank_idx + <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">deal</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>纯粹的模拟题</p>
<p>每次两个空白格子和一对相邻的白黑棋子交换位置，然后两个空白格子的指针向前移，再换两个黑子即可，循环往复</p>
<p>只剩4个的时候单独处理即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P2437. 蜜蜂路线</title>
    <url>/2023/10/10/P2437-%E8%9C%9C%E8%9C%82%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>斐波那契</li>
<li>高精度</li>
<li>线性动态规划</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len_;</span><br><span class="line">    <span class="type">int</span> arr_[<span class="number">2500</span>];</span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr_[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(string s = <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr_, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr_));</span><br><span class="line">        len_ = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">            arr_[i] = s[len_ - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len_ = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr_[i + <span class="number">1</span>] += arr_[i] / <span class="number">10</span>;</span><br><span class="line">                arr_[i] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!arr_[len_])</span><br><span class="line">            --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, len_); i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">            cout &lt;&lt; arr_[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>+(BigInt a, BigInt b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">max</span>(a.len_, b.len_);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">        c[i] += a[i] + b[i];</span><br><span class="line">    c.<span class="built_in">flatten</span>(len + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="function">BigInt <span class="title">a</span><span class="params">(<span class="string">&quot;1&quot;</span>)</span>, <span class="title">b</span><span class="params">(<span class="string">&quot;1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n - m + <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        BigInt c;</span><br><span class="line">        c = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    b.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题目描述<strong>只能从标号小的蜂房爬到标号大的相邻蜂房</strong>，设<code>f[n]</code>为从1走到n的爬行路线，显然有状态转移方程：
<span class="math display">\[
f\left( n-1 \right) +f\left( n-2 \right) \rightarrow f\left( n \right)
\]</span>
典型的斐波那契数列！但题目是要求从m走到n，而斐波那契数列是从1开始的</p>
<p>所以应该从3执行到n-m+1（斐波那契数列的第1、第2已经设置为1了）</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>高精度</tag>
        <tag>线性动态规划</tag>
        <tag>斐波那契</tag>
      </tags>
  </entry>
  <entry>
    <title>P3612. Secret Cow Code S</title>
    <url>/2023/10/11/P3612-Secret-Cow-Code-S/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>分治</li>
<li>字符串</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    ll n, len;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; n;</span><br><span class="line">    len = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">while</span> (len &lt; n)</span><br><span class="line">        len *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &gt; s.<span class="built_in">length</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; len / <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == len / <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">                n = len / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                n -= len / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>典型的分治题</p>
<p>题目大意是说，每次Copy一份当前字符串，把它最后一个字母挪到最前面，再接到原字符串后面，循环往复</p>
<p>假设原字符串为a，复制的字符串为b，那么每个字符串都是由a+b的格式组成的</p>
<p>先求出n所在字符串的长度len，然后进行以下判断：</p>
<ul>
<li>n的位置在len/2及以内，说明是在原字符串a，那么n不变</li>
<li>n的位置大于len/2，将其位置映射到a中</li>
<li>len除以2</li>
<li>循环往复，直到len等于最初始的字符串长度</li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P1990. 覆盖墙壁</title>
    <url>/2023/10/11/P1990-%E8%A6%86%E7%9B%96%E5%A2%99%E5%A3%81/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>递推</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, prefix[LEN], dp[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>, prefix[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = (prefix[i - <span class="number">1</span>] + (i &lt; <span class="number">3</span> ? <span class="number">0</span> : prefix[i - <span class="number">3</span>])) % <span class="number">10000</span>;</span><br><span class="line">        prefix[i] = (prefix[i - <span class="number">1</span>] + dp[i]) % <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>看这篇大佬的<a
href="https://www.luogu.com.cn/blog/222223/solution-p1990">思路</a></p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
</search>
