<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1178. 猜字谜</title>
    <url>/2023/07/04/1178-%E7%8C%9C%E5%AD%97%E8%B0%9C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>状态压缩</li>
<li>求二进制数表示的集合的全部子集</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">		unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; wordMap;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findNumOfValidWords</span><span class="params">(vector&lt;string&gt;&amp; words, vector&lt;string&gt;&amp; puzzles)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (string &amp;word : words) &#123;</span><br><span class="line">				<span class="type">int</span> hsh = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">char</span> &amp;chr : word) &#123;</span><br><span class="line">					hsh |= <span class="number">1</span> &lt;&lt; (chr - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				wordMap[hsh]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (string &amp;puzzle : puzzles) &#123;</span><br><span class="line">				<span class="type">int</span> hsh = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">char</span> &amp;chr : puzzle) &#123;</span><br><span class="line">					hsh |= <span class="number">1</span> &lt;&lt; (chr - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> subSet = hsh;; subSet = (subSet - <span class="number">1</span>) &amp; hsh) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!subSet) <span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">if</span> (wordMap.<span class="built_in">count</span>(subSet) &amp;&amp; (subSet &amp; (<span class="number">1</span> &lt;&lt; (puzzle[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>)))) &#123;</span><br><span class="line">						cnt += wordMap[subSet];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				ans.<span class="built_in">push_back</span>(cnt);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( m\cdot w+n\cdot
\left( p+2^{bitCount\left( p \right)} \right) \right)\)</span></p>
<p>其中<span
class="math inline">\(m\)</span>为<code>words</code>数组长度，<span
class="math inline">\(w\)</span>为<code>word</code>的长度且最大为50；<span
class="math inline">\(n\)</span>为<code>puzzles</code>数组长度，<span
class="math inline">\(p\)</span>为<code>puzzle</code>的长度且限定为7</p>
<p><span class="math inline">\(bitCount\left( p
\right)\)</span>代表十进制整数<span
class="math inline">\(p\)</span>的二进制表达中的<code>1个数</code>；<span
class="math inline">\(2^{bitCount\left( p
\right)}\)</span>这一时间复杂度，是求<span
class="math inline">\(p\)</span>二进制表达集合的所有子集</p>
<p>由于<span
class="math inline">\(p\)</span>在这里限定为7，可视为常数；故而时间复杂度也可表达为<span
class="math inline">\(O\left( m\cdot w+n\cdot 2^{bitCount\left( p
\right)} \right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( m
\right)\)</span>，新增了哈希表</p>
<h1 id="思路">思路</h1>
<p>按照传统思路，比较两个字符串的组成至少需要线性时间复杂度；若两个数组内的字符串两两比较，则时间复杂度高达3次方</p>
<p>由于题目说所有字符串只包含小写字母，且需求是对比两个字符串的组成，字符串内部的重复字符并不影响最终结果</p>
<p>所以使用一个32位的<code>int</code>类型变量的低26位，来表达字符串内的字符组成；该<code>int</code>变量也可视作该字符串的<strong>哈希值</strong></p>
<blockquote>
<p>比如字符串为abd，那么用二进制表达为1011</p>
</blockquote>
<p>具体步骤设计如下：</p>
<ul>
<li><p>遍历<code>words</code>数组，计算内部所有<code>word</code>字符串的哈希值</p>
<p>并新建一个哈希表<code>wordMap</code>记录相同哈希值的字符串个数</p></li>
<li><p>遍历<code>puzzles</code>数组，计算内部所有<code>puzzle</code>字符串的哈希值的子集</p>
<p>如果<code>wordMap</code>存在对应子集的记录，且子集包含<code>puzzle</code>的第一个字母</p>
<p>说明该子集代表的<code>word</code>可以作为当前<code>puzzle</code>的谜底</p></li>
</ul>
<p>按照上述步骤即可轻松解题，但需牢记求<strong>二进制数表示的集合的全部子集</strong>模板，来源于<a
href="https://oi-wiki.org/math/binary-set/#%E5%AD%90%E9%9B%86%E9%81%8D%E5%8E%86">网址</a>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 降序遍历 m 的子集</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = m;; s = (s - <span class="number">1</span>) &amp; m) &#123;</span><br><span class="line">    <span class="comment">// s 是 m 的一个子集</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>状态压缩</tag>
        <tag>哈希函数</tag>
      </tags>
  </entry>
  <entry>
    <title>1252. 奇数值单元格的数目</title>
    <url>/2023/07/04/1252-%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>状态压缩</li>
<li>排列组合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>同下</p>
<h1 id="思路">思路</h1>
<p>已知二维数组<code>M</code>有<code>m</code>行，<code>n</code>列；<code>indices</code>数组有<code>l</code>个元素，且每个元素都是长度为2的一维数组</p>
<p>比如某元素值为<code>[0,1]</code>，代表<strong>二维数组中行序号为0的单元格</strong>先加一、<strong>列序号为1的单元格</strong>再加一</p>
<p>正常的暴力方式如下：</p>
<ol type="1">
<li><p>开辟<code>m * n</code>大小的二维数组空间</p></li>
<li><p>遍历<code>indices</code>数组每个元素的同时，每次分别按行、按列地对二维数组进行批量修改</p>
<p>时间复杂度高达<span class="math inline">\(O\left( l\cdot \left( m+n
\right) \right)\)</span></p></li>
<li><p>遍历二维数组的所有单元格，判断有多少个奇数</p>
<p>时间复杂度<span class="math inline">\(O\left( m\cdot n
\right)\)</span></p></li>
</ol>
<p>组合拳下来，时间复杂度高达<span class="math inline">\(O\left( l\cdot
\left( m+n \right) +\left( m\cdot n \right)
\right)\)</span>，空间复杂度高达<span class="math inline">\(O\left(
m\cdot n \right)\)</span></p>
<h2 id="空间优化">空间优化</h2>
<p>由于每次都是对某行或某列的所有单元格进行批量加1，可以做如下优化：</p>
<ul>
<li><p>设置一个长度为<code>m</code>的<code>rows</code>数组，下标映射为二维数组<code>M</code>的行序号，值映射为二维数组对应行的增量</p></li>
<li><p>设置一个长度为<code>n</code>的<code>cols</code>数组，下标映射为二维数组<code>M</code>的列序号，值映射为二维数组对应列的增量</p></li>
</ul>
<p>那么有： <span class="math display">\[
M\left[ i \right] \left[ j \right] =rows\left[ i \right] +cols\left[ j
\right]
\]</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">oddCells</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">			<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rows</span><span class="params">(m, <span class="number">0</span>)</span>, <span class="title">cols</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;indice : indices) &#123;</span><br><span class="line">				rows[indice[<span class="number">0</span>]]++;</span><br><span class="line">				cols[indice[<span class="number">1</span>]]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span> ((rows[i] + cols[j]) &amp; <span class="number">1</span>) ans++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( l+m\cdot n
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( m+n
\right)\)</span></p>
<h2 id="计数优化-集合运算">计数优化 &amp; 集合运算</h2>
<p>根据数学性质，<code>奇数 = 奇数 + 偶数</code></p>
<ul>
<li><p>假设有<code>rows = &#123;1,1&#125;</code>，<code>cols = &#123;0,2,0&#125;</code></p>
<p>从两个集合中各取任意一个元素，都可求和为奇数；可行的组合数为<code>2 * 3 = 6</code></p>
<p>意味着整个二维数组都是奇数，共有6个奇数</p></li>
<li><p>假设有<code>rows = &#123;1,1,0&#125;</code>，<code>cols = &#123;1,0,1&#125;</code></p>
<p><code>rows</code>取<code>&#123;1,1&#125;</code>时，<code>cols</code>取<code>&#123;0&#125;</code>才可为奇数，此时可行的组合数为<code>2 * 1 = 2</code></p>
<p><code>rows</code>取<code>&#123;0&#125;</code>时，<code>cols</code>取<code>&#123;1,1&#125;</code>才可为奇数，此时可行的组合数为<code>1 * 2 = 2</code></p>
<p>意味着整个二维数组中，共有<code>2 + 2 = 4</code>个奇数</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">oddCells</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">			<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rows</span><span class="params">(m, <span class="number">0</span>)</span>, <span class="title">cols</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;indice : indices) &#123;</span><br><span class="line">				rows[indice[<span class="number">0</span>]]++;</span><br><span class="line">				cols[indice[<span class="number">1</span>]]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> rowOdd = <span class="number">0</span>, colOdd = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">				rowOdd += rows[i] &amp; <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">				colOdd += cols[i] &amp; <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> rowOdd * (n - colOdd) + (m - rowOdd) * colOdd;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( l+m+n
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( m+n
\right)\)</span></p>
<h2 id="位运算-状态压缩-集合运算">位运算 &amp; 状态压缩 &amp;
集合运算</h2>
<p>题目限定了<code>m</code>与<code>n</code>均不超过50，使用两个<code>long</code>类型的变量来替代<code>rows</code>与<code>cols</code>数组</p>
<p>用比特位1代表增量为奇数，用比特位0代表增量为偶数</p>
<p>各统计两个变量的<code>1个数</code>，即各自拥有的奇数个数，再做上述的集合运算即可</p>
<p><code>bitCount</code>实现请参见<code>191. 位1的个数</code>，不再赘述</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">bitCount</span><span class="params">(<span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="comment">//--------分治法--------</span></span><br><span class="line">			n = (n &amp; <span class="number">0x5555555555555555</span>) + ((n &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x5555555555555555</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x3333333333333333</span>) + ((n &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3333333333333333</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x0f0f0f0f0f0f0f0f</span>) + ((n &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f0f0f0f0f</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x00ff00ff00ff00ff</span>) + ((n &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00ff00ff00ff00ff</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x0000ffff0000ffff</span>) + ((n &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff0000ffff</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x00000000ffffffff</span>) + ((n &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0x00000000ffffffff</span>);</span><br><span class="line">			<span class="keyword">return</span> n;</span><br><span class="line">			<span class="comment">//--------分治法--------</span></span><br><span class="line">			<span class="comment">//--------Brian Kernighan法--------</span></span><br><span class="line"><span class="comment">//			int cnt = 0;</span></span><br><span class="line"><span class="comment">//			while (n) &#123;</span></span><br><span class="line"><span class="comment">//				n &amp;= n - 1;</span></span><br><span class="line"><span class="comment">//				cnt++;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//			return cnt;</span></span><br><span class="line">			<span class="comment">//--------Brian Kernighan法--------</span></span><br><span class="line">			<span class="comment">//--------lowBit--------</span></span><br><span class="line"><span class="comment">//			int cnt = 0;</span></span><br><span class="line"><span class="comment">//			while (n) &#123;</span></span><br><span class="line"><span class="comment">//				n -= (n &amp; -n);</span></span><br><span class="line"><span class="comment">//				cnt++;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//			return cnt;</span></span><br><span class="line">			<span class="comment">//--------lowBit--------</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">oddCells</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">			<span class="type">long</span> rows = <span class="number">0</span>, cols = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;indice : indices) &#123;</span><br><span class="line">				rows ^= <span class="number">1L</span> &lt;&lt; indice[<span class="number">0</span>];</span><br><span class="line">				cols ^= <span class="number">1L</span> &lt;&lt; indice[<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> rowOdd = <span class="built_in">bitCount</span>(rows), colOdd = <span class="built_in">bitCount</span>(cols);</span><br><span class="line">			<span class="keyword">return</span> rowOdd * (n - colOdd) + (m - rowOdd) * colOdd;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( l+\log C
\right)\)</span>，这里<span
class="math inline">\(C\)</span>等于<code>long</code>的位数64</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>状态压缩</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>138. 复制带随机指针的链表</title>
    <url>/2023/07/03/138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>哈希表与链表的综合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		unordered_map&lt;Node*, Node*&gt; m;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">			Node *cur = head, *dummyHead = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>), *curNew = dummyHead;</span><br><span class="line">			<span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				Node *node = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">				curNew-&gt;next = node;</span><br><span class="line">				curNew = curNew-&gt;next;</span><br><span class="line">				m[cur] = node;</span><br><span class="line">				cur = cur-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			curNew-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">			cur = head;</span><br><span class="line">			<span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				m[cur]-&gt;random = m[cur-&gt;random];</span><br><span class="line">				cur = cur-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本题难点就在于，如何保证新链表的<code>random</code>结构与旧链表的<code>random</code>结构完全一样</p>
<p>假设已知旧链表节点A指向节点B，新链表中对应的节点分别为C与D，如何记录C与D的关系？</p>
<img src="/2023/07/03/138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/1.png" class="" title="image-20230602200206991">
<p>显然需要使用哈希表来记录新旧节点之间的映射，新节点才可以根据映射来获悉旧节点的指向关系</p>
<img src="/2023/07/03/138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/2.png" class="" title="image-20230602200953233">
<p>当然，算法也可以修改为递归</p>
<ol type="1">
<li><p>子问题：创造新节点，连接起来，修改<code>random</code>三个操作</p></li>
<li><p>递归语句顺序：递归方向分为一去一回，去方向到达临界点时返回</p>
<p>创造新节点可以在去方向完成</p>
<p>节点连接，修改<code>random</code>必须在回方向完成；因为前者操作需要更新上一个节点的<code>next</code>，后者操作须等待哈希表记录映射关系后</p></li>
<li><p>临界点：当前节点为空</p></li>
<li><p>返回值：当前新节点地址，用以更新上一个节点的<code>next</code></p></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		unordered_map&lt;Node*, Node*&gt; m;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">			Node *node = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">			m[head] = node;</span><br><span class="line">			node-&gt;next = <span class="built_in">copyRandomList</span>(head-&gt;next);</span><br><span class="line">			node-&gt;random = m[head-&gt;random];</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>136. 只出现一次的数字</title>
    <url>/2023/07/04/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>异或技巧</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">				ans ^= nums[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( n
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>异或有以下性质，摘选自<a
href="https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677">百度百科</a>：</p>
<ul>
<li><p><strong>归零律</strong></p>
<img src="/2023/07/04/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/1.png" class="" title="image-20230621143031540"></li>
<li><p><strong>恒等律</strong></p>
<img src="/2023/07/04/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/2.png" class="" title="image-20230621143110296"></li>
<li><p><strong>交换律</strong></p>
<img src="/2023/07/04/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/3.png" class="" title="image-20230621143154698"></li>
<li><p><strong>结合律</strong></p>
<img src="/2023/07/04/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/4.png" class="" title="image-20230621143305054"></li>
</ul>
<p>值相同的数作异或运算为空，那么数组内所有元素的异或运算结果即可得到数组中只出现一次的数字</p>
<p>比如<code>nums</code>为<code>&#123;1,1,2,2,3&#125;</code>，二进制表达为<code>&#123;001,001,010,010,011&#125;</code></p>
<p>那么<code>001 ^ 001 ^ 010 ^ 010 ^ 011 = 011</code>，即为十进制数字3</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>142. 环形链表 II</title>
    <url>/2023/07/02/142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>快慢指针/双指针</li>
<li>链表的环</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">			ListNode *slow = head, *fast = head;</span><br><span class="line">			<span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				slow = slow-&gt;next;</span><br><span class="line">				fast = fast-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (fast != <span class="literal">nullptr</span>) fast = fast-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (fast != <span class="literal">nullptr</span> &amp;&amp; slow == fast) &#123;</span><br><span class="line">					ListNode *slow = head;</span><br><span class="line">					<span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">						slow = slow-&gt;next;</span><br><span class="line">						fast = fast-&gt;next;</span><br><span class="line">					&#125;</span><br><span class="line">                    <span class="comment">//这里换成slow是一样的</span></span><br><span class="line">					<span class="keyword">return</span> fast;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>我曾在<code>141. 环形链表</code>的题解中阐述了如何用快慢指针判断链表是否存在环，本题是其升级版，要寻找环的入口</p>
<p>我们已知链表头，能求得相遇点，现在要找到环入口，绘图如下</p>
<img src="/2023/07/02/142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/1.png" class="" title="image-20230522160752871">
<h2 id="通式">通式</h2>
<p>根据<code>快指针移动速度是慢指针移动速度的两倍</code>这一性质，可以得到以下通式
<span class="math display">\[
\underset{\text{慢指针到达相遇点所需时间}}{\underbrace{\frac{L+m\times
C+X}{1}}}=\underset{\text{快指针到达相遇点所需时间}}{\underbrace{\frac{L+n\times
C+X}{2}}}
\]</span> 解释如下</p>
<blockquote>
<p>L：链表头到环入口的距离</p>
<p>X：环入口到相遇点的距离</p>
<p>C：环的周长</p>
<p>m，n：未知数，各指针绕环次数</p>
</blockquote>
<p>两个未知数是无法编程的，可以优化一下</p>
<h2
id="慢指针在环内第一圈就能与快指针重合">慢指针在环内第一圈就能与快指针重合</h2>
<p>慢指针达到环入口时，假设快指针与慢指针的相对距离长度为<code>M</code></p>
<img src="/2023/07/02/142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/2.png" class="" title="image-20230522162507163">
<p>显然，<code>M</code>必小于周长<code>C</code></p>
<p>根据<code>141. 环形链表</code>的题解中提到的相遇时间公式，能得到下面不等式；代表慢指针在进入环内的第一圈就与快指针相遇了
<span class="math display">\[
\underset{\text{相遇时间}}{\underbrace{\frac{M}{2-1}}}&lt;\underset{\text{慢指针绕环一次的时间}}{\underbrace{C=\frac{C}{1}}}
\]</span> 所以，通式可以优化为 <span class="math display">\[
\underset{\text{慢指针到达相遇点所需时间}}{\underbrace{\frac{L+X}{1}}}=\underset{\text{快指针到达相遇点所需时间}}{\underbrace{\frac{L+n\times
C+X}{2}}}
\]</span></p>
<h2 id="实现">实现</h2>
<p>通式变形，可以得到 <span class="math display">\[
2\times \left( L+X \right) =L+n\times C+X
\]</span></p>
<p><span class="math display">\[
L=n\times C-X
\]</span></p>
<p><span class="math display">\[
L=\left( n-1 \right) \times C+\left( C-X \right)
\]</span></p>
<p>最终通式的含义可以这么理解</p>
<blockquote>
<p>某指针A从链表头出发</p>
<p>某指针B同时从相遇点出发，先走过C-X个单位到达环入口，再绕环n-1次</p>
<p>最终两个指针将在环入口相遇</p>
</blockquote>
<p>再结合题解的源码看，就一目了然了</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>143. 重排链表</title>
    <url>/2023/07/02/143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>快慢指针</li>
<li>链表的反转</li>
<li>链表的合并</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">mergeList</span><span class="params">(ListNode* smallList, ListNode* largeList)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (largeList == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">			ListNode *largeNext = largeList-&gt;next;</span><br><span class="line">			largeList-&gt;next = smallList-&gt;next;</span><br><span class="line">			smallList-&gt;next = largeList;</span><br><span class="line">			<span class="built_in">mergeList</span>(largeList-&gt;next, largeNext);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">			ListNode *tail = head;</span><br><span class="line">			<span class="keyword">while</span> (tail != <span class="literal">nullptr</span> &amp;&amp; tail-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				ListNode *node = tail-&gt;next;</span><br><span class="line">				tail-&gt;next = node-&gt;next;</span><br><span class="line">				node-&gt;next = dummyHead-&gt;next;</span><br><span class="line">				dummyHead-&gt;next = node;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">ListNode* <span class="title">splitList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *slow = head, *fast = head;</span><br><span class="line">			<span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				slow = slow-&gt;next;</span><br><span class="line">				fast = fast-&gt;next-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			ListNode *newHead = slow-&gt;next;</span><br><span class="line">			slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">return</span> newHead;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="built_in">mergeList</span>(head, <span class="built_in">reverseList</span>(<span class="built_in">splitList</span>(head)));</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本题主要考察链表的常用操作，共分为以下三个步骤：</p>
<ol type="1">
<li>找到链表的中点并拆分，使用快慢指针即可；左半部分为小链表，右半部分为大链表</li>
<li>大链表反转，这里使用<code>206. 反转链表</code>当中的<code>改进版头插法</code></li>
<li>反转后的大链表与小链表合并</li>
</ol>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>141. 环形链表</title>
    <url>/2023/07/02/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>快慢指针</li>
<li>链表的环</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">			ListNode *slow = head, *fast = head;</span><br><span class="line">			<span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				slow = slow-&gt;next;</span><br><span class="line">				fast = fast-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (fast != <span class="literal">nullptr</span>) fast = fast-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast == slow) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>判断链表中是否存在环，需要用到快慢指针</p>
<p>令<code>slow</code>为慢指针，每次移动一个单位；令<code>fast</code>为快指针，每次移动两个单位</p>
<p>两个指针同时移动，若相遇且<code>fast</code>不为<code>nullptr</code>时，即存在环</p>
<h2 id="为什么快慢指针可以解决">为什么快慢指针可以解决</h2>
<p>如果不存在环，快指针肯定将慢指针远远抛在身后</p>
<img src="/2023/07/02/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/1.png" class="" title="image-20230521215040181">
<p>一旦存在环，快指针会比慢指针更早到达环内，并且在环内无限循环</p>
<img src="/2023/07/02/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/2.png" class="" title="image-20230521215625891">
<p>如果慢指针也进入环内，那么就变成追击问题了，或者俗称的<code>龟兔赛跑</code>数学题</p>
<p>如图所示，快慢指针都是顺时针移动；若两指针距离<code>X</code>，环周长为<code>C</code>，那么快指针需要移动<code>C-X</code>个相对距离长度才能相遇</p>
<img src="/2023/07/02/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/3.png" class="" title="image-20230521225650430">
<p>追击问题中，有以下常识： <span class="math display">\[
\text{相对速度}=\text{速度差}
\]</span></p>
<p><span class="math display">\[
\text{相遇时间}=\frac{\text{相对距离长度}}{\text{相对速度}}
\]</span></p>
<p>所以，再经过<span class="math display">\[
\frac{C-X}{2-1}
\]</span>次移动后，快慢指针就可以相遇了</p>
<h2 id="为什么快指针每次移动两个单位">为什么快指针每次移动两个单位</h2>
<p>正如刚才提到的相遇时间计算公式，我们必须保证相对距离长度可以被相对速度整除才能相遇</p>
<p>因为在具体的程序实现上，所谓的<code>相遇时间</code>其实就是循环次数，不可能为小数；若取两个单位，相对速度就是1，任何数都可以被1整除</p>
<p>所以，快指针每次移动也可以取三个单位，四个单位，五个单位....但是不一定可以整除相对距离长度</p>
<p>如果相遇时间是小数，说明两个指针会错过而永不相遇</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">快指针移动单位</th>
<th style="text-align: center;">慢指针移动单位</th>
<th style="text-align: center;">相对速度</th>
<th style="text-align: center;">相对距离长度</th>
<th style="text-align: center;">相遇时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">4/5</td>
<td style="text-align: center;">4/5</td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">4/5</td>
<td style="text-align: center;">2/2.5</td>
</tr>
<tr class="odd">
<td style="text-align: center;">4</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">11/15</td>
<td style="text-align: center;">3.67/5</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>137. 只出现一次的数字 II</title>
    <url>/2023/07/04/137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-II/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>状态压缩</li>
<li>排列组合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> cntArr[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;num : nums) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (num &amp; (<span class="number">1U</span> &lt;&lt; i)) cntArr[i]++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">				ans = (ans &lt;&lt; <span class="number">1</span>) | (cntArr[i] % <span class="number">3</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( n
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>根据题意<strong>除某个元素仅出现一次外，其余每个元素都恰出现三次</strong>，<code>int</code>类型的整数也都是32位</p>
<p>假设当前为第<span class="math inline">\(i\)</span>位，<span
class="math inline">\(Sum_i\)</span>代表所有元素的第<span
class="math inline">\(i\)</span>位之和，<span
class="math inline">\(r\)</span>代表只出现了一次的元素在第<span
class="math inline">\(i\)</span>位的值，必满足以下等式 <span
class="math display">\[
Sum_i=3k+r
\]</span>
所以设置一个长度为32的<code>cntArr</code>数组，依次记录所有元素各在某位上的和</p>
<p>然后再遍历<code>cntArr</code>数组，对各个元素求余3后重新拼凑，即可得到只出现了一次的元素</p>
<p>比如有<code>nums</code>数组<code>&#123;2,2,2,14&#125;</code>，映射为二进制就是<code>&#123;0010,0010,0010,1110&#125;</code></p>
<p><code>cntArr</code>数组的值则应为<code>&#123;1,1,4,0&#125;</code>，求余3后为<code>&#123;1,1,1,0&#125;</code>，就等于只出现了一次的元素<code>14</code>的二进制表达</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>状态压缩</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>146. LRU 缓存</title>
    <url>/2023/07/03/146-LRU-%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>哈希表与链表的综合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">			<span class="type">int</span> key;</span><br><span class="line">			<span class="type">int</span> value;</span><br><span class="line">			<span class="built_in">Node</span>(<span class="type">int</span> _key, <span class="type">int</span> _value) : <span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value) &#123;&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="type">int</span> capacity;</span><br><span class="line">		list&lt;Node&gt; l;</span><br><span class="line">		unordered_map&lt;<span class="type">int</span>, list&lt;Node&gt;::iterator&gt; m;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">LRUCache</span>(<span class="type">int</span> _capacity) : <span class="built_in">capacity</span>(_capacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">auto</span> it = m.<span class="built_in">find</span>(key);</span><br><span class="line">			<span class="keyword">if</span> (it == m.<span class="built_in">end</span>())	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			<span class="type">int</span> value = it-&gt;second-&gt;value;</span><br><span class="line">            <span class="comment">//先从链表中删除</span></span><br><span class="line">			l.<span class="built_in">erase</span>(it-&gt;second);</span><br><span class="line">            <span class="comment">//再添加到头部</span></span><br><span class="line">			l.<span class="built_in">emplace_front</span>(key, value);</span><br><span class="line">            <span class="comment">//更新哈希表</span></span><br><span class="line">			m[key] = l.<span class="built_in">begin</span>();</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">auto</span> it = m.<span class="built_in">find</span>(key);</span><br><span class="line">			<span class="keyword">if</span> (it == m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">//容量为0就不能插入新元素</span></span><br><span class="line">				<span class="keyword">if</span> (capacity == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">				<span class="keyword">if</span> (m.<span class="built_in">size</span>() == (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)capacity) &#123;</span><br><span class="line">					m.<span class="built_in">erase</span>(l.<span class="built_in">back</span>().key);</span><br><span class="line">					l.<span class="built_in">pop_back</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				l.<span class="built_in">erase</span>(it-&gt;second);</span><br><span class="line">			&#125;</span><br><span class="line">			l.<span class="built_in">emplace_front</span>(key, value);</span><br><span class="line">			m[key] = l.<span class="built_in">begin</span>();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>LRU又称为最近最少使用页面置换算法(Least Recently
Used)，淘汰最早访问的页面</p>
<p>题目要求查找与增删节点时均要达到常量时间复杂度，很容易想到哈希表+链表的组合</p>
<blockquote>
<p>无序哈希表在平均情况下的查找为常量时间复杂度，而有序哈希表的查找为对数时间复杂度，因为底层是红黑树</p>
</blockquote>
<p>所以有以下思路：</p>
<ol type="1">
<li><p>每次访问/更新节点时，先将其从链表中删除，再将其插入到链表头部以代表最近访问</p>
<p>这样一来链表末尾节点自然是最早访问的了</p></li>
<li><p>因为只涉及到删除链表中节点、删除链表尾部节点和插入链表头部节点，使用双向链表较为方便；这里使用<code>list</code>这一STL库来完成</p></li>
<li><p>使用哈希表来记录键与节点的映射关系，这样就能直接操控链表节点而不用去遍历寻找</p></li>
</ol>
<p>数据结构设计如图所示</p>
<img src="/2023/07/03/146-LRU-%E7%BC%93%E5%AD%98/1.png" class="" title="image-20230605162942234">
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>147. 对链表进行插入排序</title>
    <url>/2023/07/02/147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">			<span class="keyword">while</span> (head-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (head-&gt;val &gt; head-&gt;next-&gt;val) &#123;</span><br><span class="line">					ListNode *cur = dummyHead, *node = head-&gt;next;</span><br><span class="line">					<span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;val &lt; node-&gt;val ) cur = cur-&gt;next;</span><br><span class="line">					head-&gt;next = node-&gt;next;</span><br><span class="line">					node-&gt;next = cur-&gt;next;</span><br><span class="line">					cur-&gt;next = node;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					head = head-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>插入排序的精髓就在于，令当前元素之前的子数组为有序，然后判断当前元素应插入子数组的何种位置即可</p>
<p>令<code>head</code>为有序子数组末尾，<code>node</code>为<code>head</code>的下一个元素</p>
<p>按照升序顺序，若<code>node</code>大于等于<code>head</code>，说明以<code>node</code>结尾的子数组有序；那么<code>head</code>应该向下移动</p>
<img src="/2023/07/02/147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/1.png" class="" title="image-20230605204522898">
<p>若<code>node</code>大于<code>head</code>，找到子数组中第一个大于<code>node</code>节点的前一个节点，然后移动到它的后面完成插入操作</p>
<img src="/2023/07/02/147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/2.png" class="" title="image-20230605210213014">
<img src="/2023/07/02/147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/3.png" class="" title="image-20230605205859704">
<p>如此循环往复即可</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>148. 排序链表</title>
    <url>/2023/07/03/148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">MergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line">			<span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">			<span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">				l1-&gt;next = <span class="built_in">MergeList</span>(l1-&gt;next, l2);</span><br><span class="line">				<span class="keyword">return</span> l1;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				l2-&gt;next = <span class="built_in">MergeList</span>(l1, l2-&gt;next);</span><br><span class="line">				<span class="keyword">return</span> l2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">ListNode* <span class="title">MergeSort</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head), *cur = dummyHead;</span><br><span class="line">			<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				cur = cur-&gt;next;</span><br><span class="line">				len++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> subLen = <span class="number">1</span>; subLen &lt; len; subLen *= <span class="number">2</span>) &#123;</span><br><span class="line">				ListNode *curNew = dummyHead, *cur = dummyHead-&gt;next;</span><br><span class="line">				<span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">					ListNode *leftHead = cur;</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; subLen &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span>; cur = cur-&gt;next, i++);</span><br><span class="line">					ListNode *rightHead = cur-&gt;next;</span><br><span class="line">					cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">					cur = rightHead;</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; subLen &amp;&amp; cur != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span>; cur = cur-&gt;next, i++);</span><br><span class="line">					<span class="keyword">if</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">						ListNode *nextLeftHead = cur-&gt;next;</span><br><span class="line">						cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">						cur = nextLeftHead;</span><br><span class="line">					&#125;</span><br><span class="line">					curNew-&gt;next = <span class="built_in">MergeList</span>(leftHead, rightHead);</span><br><span class="line">					<span class="keyword">while</span> (curNew-&gt;next != <span class="literal">nullptr</span>) curNew = curNew-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">MergeSort</span>(head);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题目要求在<code>O(nlogn)</code>
时间复杂度和常数级空间复杂度下对链表进行排序</p>
<p>考虑时间复杂度，满足要求的有归并排序、堆排序与快速排序；后两者在链表实现上较难，所以选择归并排序</p>
<p>首先写出递归版本的归并排序，思路很简单</p>
<ol type="1">
<li>在递归的去方向中：每次找到链表的中点，并利用递归分割成左子链表和右子链表</li>
<li>在递归的回方向中：合并左右子链表；因为子链表均有序，可以参考<code>21. 合并两个有序链表</code>代码</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">MergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line">			<span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">			<span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">				l1-&gt;next = <span class="built_in">MergeList</span>(l1-&gt;next, l2);</span><br><span class="line">				<span class="keyword">return</span> l1;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				l2-&gt;next = <span class="built_in">MergeList</span>(l1, l2-&gt;next);</span><br><span class="line">				<span class="keyword">return</span> l2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">ListNode* <span class="title">MergeSort</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="comment">//很重要，否则会导致MergeSort函数死循环</span></span><br><span class="line">			<span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">			ListNode *slow = head, *fast = slow;</span><br><span class="line">			<span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				slow = slow-&gt;next;</span><br><span class="line">				fast = fast-&gt;next-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			ListNode *newHead = slow-&gt;next;</span><br><span class="line">			slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">MergeList</span>(<span class="built_in">MergeSort</span>(head), <span class="built_in">MergeSort</span>(newHead));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">MergeSort</span>(head);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但递归是自顶向下的写法，显然空间复杂度是<code>O(logn)</code>并不满足题目需求；所以需要使用自底向上的写法</p>
<p>递归的去方向不断地拆分链表，故而消耗了额外的栈空间；若用迭代来替代递归的<code>拆分</code>动作，就不会有额外的空间损耗</p>
<p>自底向上的迭代思路如图所示，其中<code>有序子链表合并</code>操作的代码直接参考<code>21. 合并两个有序链表</code>即可</p>
<img src="/2023/07/03/148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/1.png" class="" title="image-20230607174322312">
<p>编程如下，为了可读性部分逻辑有重复，简化后就是题解代码的模样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">MergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line">			<span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">			<span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">				l1-&gt;next = <span class="built_in">MergeList</span>(l1-&gt;next, l2);</span><br><span class="line">				<span class="keyword">return</span> l1;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				l2-&gt;next = <span class="built_in">MergeList</span>(l1, l2-&gt;next);</span><br><span class="line">				<span class="keyword">return</span> l2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">ListNode* <span class="title">MergeSort</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head), *cur = dummyHead;</span><br><span class="line">			<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				cur = cur-&gt;next;</span><br><span class="line">				len++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//外循环是待合并的子链表长度，初始为1，每次乘2</span></span><br><span class="line">			<span class="comment">//子链表的长度*2肯定小于等于总长度</span></span><br><span class="line">			<span class="comment">//当然，子链长度等于总长度的时候就没必要自己合并自己，所以这里只有小于号没有等于号</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> subLen = <span class="number">1</span>; subLen &lt; len; subLen *= <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="comment">//每次都从头开始更新链表</span></span><br><span class="line">				ListNode *curNew = dummyHead, *cur = dummyHead-&gt;next;</span><br><span class="line">				<span class="comment">//按照归并的规律，两个子链表一组</span></span><br><span class="line">				<span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">					<span class="comment">//记录左子链表头</span></span><br><span class="line">					ListNode *leftHead = cur;</span><br><span class="line">					<span class="comment">//寻找左子链表尾</span></span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; subLen &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span>; cur = cur-&gt;next, i++);</span><br><span class="line">					<span class="comment">//左子链表尾的下一个节点为空，说明没有右子链表，即到了整个大链表的尾部</span></span><br><span class="line">					<span class="comment">//那么合并完后直接开启新的大循环</span></span><br><span class="line">					<span class="keyword">if</span> (cur-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">						curNew-&gt;next = leftHead;</span><br><span class="line">						cur = <span class="literal">nullptr</span>;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">//若存在右子链表</span></span><br><span class="line">						<span class="comment">//记录右子链表头</span></span><br><span class="line">						ListNode *rightHead = cur-&gt;next;</span><br><span class="line">						<span class="comment">//左子链表尾部断开，使其成为单独的链表便于合并</span></span><br><span class="line">						cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">						<span class="comment">//寻找右子链表尾</span></span><br><span class="line">						cur = rightHead;</span><br><span class="line">						<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; subLen &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span>; cur = cur-&gt;next, i++);</span><br><span class="line">						ListNode *nextLeftHead = cur-&gt;next;</span><br><span class="line">						<span class="comment">//右子链表尾部断开</span></span><br><span class="line">						cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">						cur = nextLeftHead;</span><br><span class="line">						<span class="comment">//塞入左右子链表合并后的新链表</span></span><br><span class="line">						curNew-&gt;next = <span class="built_in">MergeList</span>(leftHead, rightHead);</span><br><span class="line">						<span class="keyword">while</span> (curNew-&gt;next != <span class="literal">nullptr</span>) curNew = curNew-&gt;next;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">MergeSort</span>(head);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>160. 相交链表</title>
    <url>/2023/07/02/160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的相交</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">			ListNode *curA = headA, *curB = headB;</span><br><span class="line">			<span class="keyword">while</span> (curA != curB) &#123;</span><br><span class="line">				curA = curA == <span class="literal">nullptr</span> ? headB : curA-&gt;next;</span><br><span class="line">				curB = curB == <span class="literal">nullptr</span> ? headA : curB-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> curA;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>链表的相交问题需要用到双指针</p>
<p>设链表A的节点为{a1, a2, c1, c2}，链表B的节点为{b1, b2, b3, c1,
c2}；两个链表相交于节点c1，自节点c1起为相交公共部分</p>
<img src="/2023/07/02/160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/1.png" class="" title="image-20230521170752995">
<p>假设游标指针curA和curB同时出发，并最终相交于节点c1；观察路径轨迹，可以发现有以下恒等式：
<span class="math display">\[
\underset{curA\text{遍历链表}A}{\underbrace{a1+a2+c1+c2}}+\underset{curA\text{遍历}B\text{部分}}{\underbrace{b1+b2+b3}}+c1=\underset{curB\text{遍历链表}B}{\underbrace{b1+b2+b3+c1+c2}}+\underset{curB\text{遍历}A\text{部分}}{\underbrace{a1+a2}}+c1
\]</span> 故而，若A、B两个链表存在交点，应做如下操作：</p>
<ul>
<li><p>curA遍历A链表，然后再从B链表头节点继续遍历</p></li>
<li><p>curB遍历B链表，然后再从A链表头节点继续遍历</p></li>
<li><p>curA和curB的遍历同步进行；最终会相遇在相交节点</p></li>
</ul>
<p>假如不相交呢？最终curA和curB两个指针值也是相等的，均为<code>nullptr</code></p>
<p>因为curA先遍历了A链表再遍历了B链表，curB先遍历了B链表再遍历了A链表，两个指针又是同时遍历，自然最终结果一样</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>1711. 大餐计数</title>
    <url>/2023/07/04/1711-%E5%A4%A7%E9%A4%90%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>状态压缩</li>
<li>排列组合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">countPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; deliciousnesses)</span> </span>&#123;</span><br><span class="line">			unordered_map&lt;<span class="type">int</span>, <span class="type">long</span>&gt; m;</span><br><span class="line">			<span class="type">long</span> ans = <span class="number">0</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;deliciousness : deliciousnesses) m[deliciousness]++;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[a, v] : m) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> sum = <span class="number">1</span>; sum &lt; ( <span class="number">1</span> &lt;&lt; <span class="number">22</span>); sum = sum &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="type">int</span> b = sum - a;</span><br><span class="line">					<span class="keyword">if</span> (m.<span class="built_in">count</span>(b)) &#123;</span><br><span class="line">						ans += a == b ? v * (v - <span class="number">1</span>) : v * m[b];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> (<span class="type">int</span>)((ans &gt;&gt; <span class="number">1</span>) % mod);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( n\cdot \log C
\right)\)</span>，其中<span class="math inline">\(C\)</span>为<span
class="math inline">\(2^{21}\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( n
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>若按传统暴力方法，最高的时间复杂度高达10<sup>10</sup>，是绝对不可取的</p>
<p>创建哈希表<code>m</code>记录美味程度相同的下标个数，将所有的下标分类成数个集合；运用集合运算可在常数时间内完成<code>下标两两比较</code>操作</p>
<p>假设当前<code>m</code>的值为<code>&#123;1 : 3, 3 : 3, 7 : 1&#125;</code>，意味着美味程度等于1、3、7的下标个数分别为3、3、1</p>
<p>接下来寻找<code>m</code>中满足<strong>两个键的和等于2的幂</strong>这一条件的情况个数，常规情况下双重暴力循环，时间复杂度高达平方，也不可取</p>
<p>由于美味程度不超过2<sup>20</sup>，那么两个键的和也不会超过2<sup>21</sup></p>
<p>令<code>sum</code>变量为2的幂，从1开始，即2<sup>0</sup>，每次翻倍，直到2<sup>21</sup>终止；循环过程中，用<code>sum</code>减去当前的键，判断<code>m</code>是否存在差值的记录</p>
<p>若存在差值，这里有两种情况：</p>
<ul>
<li><p><strong>差值等于当前键</strong>，那么根据集合运算规则，该条件下的答案为：
<span class="math display">\[
\frac{\left( \text{键}-1+1 \right) \cdot \left( \text{键}-1
\right)}{2}=\frac{\text{键}\cdot \left( \text{键}-1 \right)}{2}
\]</span>
假设当前<code>sum</code>为<code>2</code>，当前键为上述<code>m</code>中的<code>1</code>，有3个下标不同但美味程度均为1的元素</p>
<p>令这三个下标分别为<code>&#123;0,1,2&#125;</code>，显然该集合两两元素生成不重复的子集只有<code>&#123;0,1&#125;</code>、<code>&#123;0,2&#125;</code>和<code>&#123;1,2&#125;</code>三个</p>
<p>则答案满足等差数列求和公式： <span class="math display">\[
\frac{\left( \text{首项}+\text{末项} \right) \cdot \text{项数}}{2}
\]</span></p></li>
<li><p><strong>差值等于另一个键</strong>，那么根据集合运算规则，该条件下的答案为：
<span class="math display">\[
\text{当前键映射的值}\cdot \text{差值键映射的值}
\]</span>
假设当前<code>sum</code>为<code>4</code>，当前键为上述<code>m</code>中的<code>1</code>，三个下标分别为<code>&#123;0,1,2&#125;</code>；差值键为上述<code>m</code>中的<code>3</code>，三个下标分别为<code>&#123;3,4,5&#125;</code></p>
<p>那么<code>&#123;0,1,2&#125;</code>与<code>&#123;3,4,5&#125;</code>两集合中的元素，两两生成不重复的子集的个数为<code>3 * 3 = 9</code>，分别为：</p>
<p><code>&#123;0,3&#125;</code>、<code>&#123;0,4&#125;</code>、<code>&#123;0,5&#125;</code>、<code>&#123;1,3&#125;</code>、<code>&#123;1,4&#125;</code>、<code>&#123;1,5&#125;</code>、<code>&#123;2,3&#125;</code>、<code>&#123;2,4&#125;</code>和<code>&#123;2,5&#125;</code></p></li>
</ul>
<p>这里有一个小细节，上述的第二种情况<code>差值等于另一个键</code>在实际过程中会被计算两次</p>
<blockquote>
<p><code>sum</code>为<code>4</code>时，当前键为<code>1</code>，差值键可为<code>3</code>；同样的<code>sum</code>，当前键为<code>3</code>时，差值键也可为<code>1</code></p>
</blockquote>
<p>故而在下方代码中，<code>(v * (v - 1))/2</code>乘了2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ans += a == b ? v * (v - <span class="number">1</span>) : v * m[b];</span><br></pre></td></tr></table></figure>
<p>这样可以留到结尾一起除2处理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (<span class="type">int</span>)((ans &gt;&gt; <span class="number">1</span>) % mod);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>状态压缩</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>19. 删除链表的倒数第 N 个结点</title>
    <url>/2023/07/02/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>快慢指针/双指针</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">			ListNode *slow = dummyHead;</span><br><span class="line">			ListNode *fast = dummyHead;</span><br><span class="line">			<span class="keyword">while</span>(n--)&#123;</span><br><span class="line">				fast = fast-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">				slow = slow-&gt;next;</span><br><span class="line">				fast = fast-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题目要求<code>删除链表的倒数第 n 个结点</code>，这里需要使用快慢指针来完成这一操作</p>
<p>首先新建一个<code>dummyHead</code>伪节点，链表操作必备；假设我们需要删除链表{1,
2, 3, 4}的倒数第2个节点，即节点3</p>
<p>画图比划一下，用<code>fast</code>指针指向最后一个节点，用<code>slow</code>指针指向倒数第n+1个节点（因为要删除倒数第n个节点）</p>
<p>然后将它们平移到初始位置，是不是一目了然了~</p>
<img src="/2023/07/02/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/1.png" class="" title="image-20230520213521918">
<p>步骤清晰如下：</p>
<ol type="1">
<li>快慢指针都从<code>dummyHead</code>起始</li>
<li>快指针先走n步</li>
<li>快慢指针一起走，直到快指针到达最后一个节点，此时慢指针的下一个节点就是待删除节点</li>
</ol>
<p>当然也可以不用快慢指针，使用老办法递归：</p>
<ol type="1">
<li><p>子问题与返回值：每次判断本节点是否应该被删除。若要被删除，则返回<code>next</code>值；若不需要被删除，返回自身</p>
<p>实际上就是返回应该存在于链表的节点</p></li>
<li><p>递归语句顺序：递归方向分为一去一回，去方向到达临界点后返回；这里选择回方向操作，因为要计算倒数</p></li>
<li><p>临界点：节点为<code>nullptr</code>时返回，意味着<code>nullptr</code>节点存在于链表</p></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="function">ListNode* <span class="title">recursiveFunc</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">			head-&gt;next = <span class="built_in">recursiveFunc</span>(head-&gt;next);</span><br><span class="line">			<span class="keyword">if</span> (--n == <span class="number">0</span>) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> _n)</span> </span>&#123;</span><br><span class="line">			n = _n;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">recursiveFunc</span>(head);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>190. 颠倒二进制位</title>
    <url>/2023/07/04/190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>位运算与分治法的综合</li>
<li>掩码技巧</li>
<li>移位技巧</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>同下</p>
<h1 id="思路">思路</h1>
<h2 id="逐位移动">逐位移动</h2>
<p>通过循环，每次新变量向左移位后接收<code>n</code>的低位，自然<code>n</code>的低位变成新变量的高位了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; n = n &gt;&gt; <span class="number">1</span>, i++)&#123;</span><br><span class="line">            ans &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            ans |= n &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( k
\right)\)</span>，这里<span
class="math inline">\(k\)</span>等于位数32</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h2 id="分治">分治</h2>
<p>参考<code>191. 位1的个数</code>中的分治法</p>
<p>将二进制整串均分成左右两子串，每个子串同样递归地执行翻转操作，最后将左右子串交换位置完成翻转</p>
<img src="/2023/07/04/190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/1.png" class="" title="image-20230617143518000">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">			n = ((n &amp; <span class="number">0xAAAAAAAA</span>) &gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">			n = ((n &amp; <span class="number">0xCCCCCCCC</span>) &gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">			n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>);</span><br><span class="line">			n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">			n = ((n &amp; <span class="number">0xffff0000</span>) &gt;&gt; <span class="number">16</span>) | ((n &amp; <span class="number">0x0000ffff</span>) &lt;&lt; <span class="number">16</span>);</span><br><span class="line">			<span class="keyword">return</span> n;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( \log C
\right)\)</span>，这里<span
class="math inline">\(C\)</span>等于位数32</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>191. 位1的个数</title>
    <url>/2023/07/04/191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li><p><code>n &amp; (n - 1)</code>技巧，即Brian Kernighan算法</p></li>
<li><p><code>n &amp; -n</code>技巧</p></li>
<li><p>掩码技巧</p></li>
<li><p>移位技巧</p></li>
<li><p>位运算与分治法的综合</p></li>
<li><p><code>bitCount</code>的实现</p></li>
<li><p><code>lowBit</code>的实现</p></li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>同下</p>
<h1 id="思路">思路</h1>
<p>有若干方法可以实现<code>bitCount</code>，下面依次列举，便于快速熟悉位运算的各种技巧</p>
<h2 id="掩码计数">掩码计数</h2>
<p>最容易想到的办法，就是使用类似计算机网络中的<code>掩码</code>，与原数逐位比较；这里的<code>掩码</code>也必须为无符号32位类型，否则会溢出</p>
<blockquote>
<p>对于int来说，</p>
<p>正数极值用二进制表达是0111_1111_1111_1111_1111_1111_1111_1111</p>
<p>负数极值用二进制表达是1000_0000_0000_0000_0000_0000_0000_0000</p>
<p>负数以补码的形式存在，-1用二进制表达是1111_1111_1111_1111_1111_1111_1111_1111</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">			<span class="type">uint32_t</span> mask = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">31</span>; mask = mask &lt;&lt; <span class="number">1</span>, i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (n &amp; mask) cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> cnt;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( k
\right)\)</span>，其中<span
class="math inline">\(k\)</span>为<code>uint32_t</code>的位数，在这里是32位</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h2 id="右移计数">右移计数</h2>
<p>每次判断最低位是否为1，然后将原数右移一位；因为题目说明了原数是无符号32位，所以右移不会新增1的个数</p>
<blockquote>
<p>若是负数，右移时高位会补1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (n) &#123;</span><br><span class="line">				cnt += n &amp; <span class="number">1</span>;</span><br><span class="line">				n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> cnt;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( k
\right)\)</span>，其中<span
class="math inline">\(k\)</span>为<code>uint32_t</code>的位数，在这里是32位</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h2 id="brian-kernighan算法">Brian Kernighan算法</h2>
<p>对于任何一个数<code>n</code>，<code>n &amp; (n - 1)</code>能够将最低位的1变为0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (n) &#123;</span><br><span class="line">				n &amp;= n - <span class="number">1</span>;</span><br><span class="line">				cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> cnt;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( \log n
\right)\)</span>，循环次数等于<span
class="math inline">\(n\)</span>的二进制位中1的个数</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h2 id="lowbit">lowBit</h2>
<p>对于任何一个数<code>n</code>，<code>n &amp; -n</code>能够获取最低位的1的位置；假设二进制表达为<code>0110</code>，则lowBit返回<code>0010</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (n) &#123;</span><br><span class="line">				n -= n &amp; -n;</span><br><span class="line">				cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> cnt;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( \log n
\right)\)</span>，循环次数等于<span
class="math inline">\(n\)</span>的二进制位中1的个数</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h2 id="分治">分治</h2>
<p>参考JDK中<code>Integer.bitCount</code>的函数原型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">			n = (n &amp; <span class="number">0x55555555</span>) + ((n &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x33333333</span>) + ((n &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x0f0f0f0f</span>) + ((n &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x00ff00ff</span>) + ((n &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x0000ffff</span>) + ((n &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);</span><br><span class="line">			<span class="keyword">return</span> n;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原理类似归并排序的迭代版，每次按照单位长度进行归并：</p>
<ol type="1">
<li>单位长度为1时，<code>1个数</code>取决于其本身是否为1</li>
<li>单位长度为2，取<strong>相邻高低位</strong>，它们各自的<code>1个数</code>相加，达到<code>一一归并为二</code>的效果</li>
<li>单位长度为4，取<strong>相邻且单位长度为2</strong>的两部分，它们各自的<code>1个数</code>相加，达到<code>二二归并为四</code>的效果</li>
<li>单位长度为8，取<strong>相邻且单位长度为4</strong>的两部分，它们各自的<code>1个数</code>相加，达到<code>四四归并为八</code>的效果</li>
<li>循环同上</li>
</ol>
<p>假设需要统计二进制序列<code>1011101110</code>中1的总数，分治过程如下</p>
<img src="/2023/07/04/191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/1.png" class="" title="image-20230616181756580">
<p>假设有二进制<code>1110</code>，求1的个数<span
class="math inline">\(N\)</span>；设二进制位编号从左到右分别为a、b、c、d，那么有
<span class="math display">\[
N=N_a+N_b+N_c+N_d=N_{a,b}+N_{c,d}
\]</span> 初始单位长度为1，按上面的分治过程，需要一一组合为二</p>
<p>在第一步中，设计掩码<code>0101</code>，令<code>0101 &amp; 1110 = 0100</code>取出<span
class="math inline">\(N_b\)</span>和<span
class="math inline">\(N_d\)</span></p>
<p>再<code>1110 &gt;&gt; 1 = 0111</code>，<code>0101 &amp; 0111 = 0101</code>取出<span
class="math inline">\(N_a\)</span>和<span
class="math inline">\(N_c\)</span></p>
<p><code>0100 + 0101 = 1001</code>就能得到<span
class="math inline">\(N_{a,b}\)</span>与<span
class="math inline">\(N_{c,d}\)</span></p>
<p>第二步中可以设计<code>0011</code>这一掩码，<code>1001 &amp; 0011 = 0001</code>取出<span
class="math inline">\(N_{c,d}\)</span></p>
<p><code>1001 &gt;&gt; 2 = 0010</code>，<code>0010 &amp; 0011 = 0010</code>取出<span
class="math inline">\(N_{a,b}\)</span></p>
<p><code>0001 + 0010 = 0011 = 十进制的3</code>，即为 <span
class="math display">\[
N=N_{a,b}+N_{c,d}
\]</span> 那么这些掩码的功效你应该能明白了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x55555555  ‭0b01010101010101010101010101010101‬</span><br><span class="line">0x33333333  ‭0b00110011001100110011001100110011‬</span><br><span class="line">0x0f0f0f0f  ‭0b00001111000011110000111100001111‬</span><br><span class="line">0x00ff00ff  0b00000000111111110000000011111111</span><br><span class="line">0x0000ffff  ‭0b00000000000000001111111111111111‬</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( \log C
\right)\)</span>，其中<span
class="math inline">\(C\)</span>为<code>uint32_t</code>的位数，在这里是32位；大部分情况下，是所有方法中最快的一个</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>203. 移除链表元素</title>
    <url>/2023/07/02/203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的删除</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head), *cur = dummyHead;</span><br><span class="line">			<span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(cur-&gt;next-&gt;val == val) cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">				<span class="keyword">else</span> cur = cur-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>单向链表中，当前节点无法知晓前一个节点的信息；如果增删改当前节点，上一个节点的<code>next</code>就得不到更新</p>
<p>所以每次操作的节点其实是当前节点的下一个</p>
<p>要保证操作的通用性，不用去判断操作头结点时的一些特殊情况；引入了<code>dummyHead</code>一个伪结点，它的<code>next</code>指向真正的头节点</p>
<p>（实际上，只要涉及到链表的操作，<code>dummyHead</code>几乎是必须的）</p>
<p>以序列<code>&#123;7, 4, 3, 7&#125;</code>为例，需要删除值为7的节点；从伪结点开始迭代</p>
<img src="/2023/07/02/203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/1.png" class="" title="image-20230514151344511">
<p>每次判断下一个节点的值是否满足题意；若是，则将当前节点的<code>next</code>指向下下个节点（将满足题意的节点从链表踢出）</p>
<img src="/2023/07/02/203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/2.png" class="" title="image-20230514151852476">
<p>若否，则指针移至下个节点，开启新一轮判断</p>
<img src="/2023/07/02/203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/3.png" class="" title="image-20230514152922907">
<p>由于核心问题就是<strong>不同情况下修改节点的<code>next</code>值</strong>，可以将其改造为递归</p>
<p>编写递归按照四部曲即可：</p>
<ol type="1">
<li><p>子问题：更新自己的<code>next</code>值，需要下一个节点的信息</p></li>
<li><p>递归语句顺序：递归方向分为一去一回，去方向至临界点后返回；本题应在回方向操作，因为要返回值给当前节点的上一个节点</p>
<p>（当然也可以去方向操作，但那样和迭代无异，且无法处理头节点）</p></li>
<li><p>返回值：如果当前节点要被删除，则返回它的<code>next</code>值；否则返回自己（本质上是返回应该存在于链表内的节点）</p>
<p>临界点返回<code>nullptr</code>值，代表<code>nullptr</code>一定存在于链表内</p></li>
<li><p>临界点：当前节点为nullptr</p></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">			head-&gt;next = <span class="built_in">removeElements</span>(head-&gt;next, val);</span><br><span class="line">			<span class="keyword">if</span>(head-&gt;val == val) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>2. 两数相加</title>
    <url>/2023/07/02/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的合并</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">		<span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">			ListNode *cur1 = l1, *cur2 = l2, *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *curNew = dummyHead;</span><br><span class="line">			<span class="keyword">while</span> (cur1 != <span class="literal">nullptr</span> || cur2 != <span class="literal">nullptr</span> || carry) &#123;</span><br><span class="line">				cur1 = cur1 != <span class="literal">nullptr</span> ? (carry += cur1-&gt;val, cur1-&gt;next) : <span class="literal">nullptr</span>;</span><br><span class="line">				cur2 = cur2 != <span class="literal">nullptr</span> ? (carry += cur2-&gt;val, cur2-&gt;next) : <span class="literal">nullptr</span>;</span><br><span class="line">				curNew-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry % <span class="number">10</span>);</span><br><span class="line">				carry /= <span class="number">10</span>;</span><br><span class="line">				curNew = curNew-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题目要我们算两个数相加的结果，146+854=1000；但要求的存储方式是倒过来的，641+458=0001</p>
<img src="/2023/07/02/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/1.png" class="" title="image-20230524163056995">
<p>思路很简单：</p>
<ul>
<li>每次计算<code>cur1+cur2+进位的和</code>，将<code>和求余10</code>的值赋给新建的链表节点，将<code>和除10</code>的值更新进位</li>
<li>只要cur1、cur2、进位有一个不为空，就要重复上述操作新增链表节点</li>
</ul>
<p>若要将其改造成递归就稍有难度</p>
<ol type="1">
<li><p>子问题：计算步骤同上；还需要将每次新增的链表节点串起来</p></li>
<li><p>递归语句顺序：递归方向分为一去一回，去方向到达临界点后返回</p>
<p>在这里，先在去方向构造完新链表节点；在回方向更新当前节点的<code>next</code>值，从而将链表串起来</p></li>
<li><p>返回值：因为只能在回方向将新链表串起，所以每次返回新节点让上一个节点更改它的<code>next</code>值</p></li>
<li><p>临界点：cur1、cur2、进位都为空</p></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">		<span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (l1 == <span class="literal">nullptr</span> &amp;&amp; l2 == <span class="literal">nullptr</span> &amp;&amp; !carry) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">			l1 = l1 != <span class="literal">nullptr</span> ? (carry += l1-&gt;val, l1-&gt;next) : <span class="literal">nullptr</span>;</span><br><span class="line">			l2 = l2 != <span class="literal">nullptr</span> ? (carry += l2-&gt;val, l2-&gt;next) : <span class="literal">nullptr</span>;</span><br><span class="line">			ListNode *head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry % <span class="number">10</span>);</span><br><span class="line">			carry /= <span class="number">10</span>;</span><br><span class="line">			head-&gt;next = <span class="built_in">addTwoNumbers</span>(l1, l2);</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果是<code>99+9</code>，到达临界点的情况如图所示；8、0、1的新建节点并没有串起来，所以才需要回方向将它们连接起来</p>
<img src="/2023/07/02/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/2.png" class="" title="image-20230527135416750">
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>206. 反转链表</title>
    <url>/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的反转</li>
<li>掌握<strong>改进版头插法</strong></li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">			<span class="keyword">while</span> (head-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				ListNode *tmp = head-&gt;next;</span><br><span class="line">				head-&gt;next = tmp-&gt;next;</span><br><span class="line">				tmp-&gt;next = dummyHead-&gt;next;</span><br><span class="line">				dummyHead-&gt;next = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<h2 id="朴素法更改方向">朴素法：更改方向</h2>
<h3 id="迭代">迭代</h3>
<p>反转一个链表，很容易想到更改方向即可，毕竟方向是由<code>next</code>值决定的</p>
<p>比如要反转链表{1, 2, 3, 4}</p>
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/1.png" class="" title="image-20230518123951929">
<p>很自然地想到让每个节点指向前一个节点即可</p>
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2.png" class="" title="image-20230518125017994">
<p>代码实现很简单。令一个指针<code>cur</code>指向当前节点，一个指针<code>prev</code>指向前一个节点；指针<code>prev</code>初始值为<code>nullptr</code>，代表新表尾</p>
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/3.png" class="" title="image-20230518144335688">
<p>每次都令<code>cur</code>节点的<code>next</code>值指向<code>prev</code>，然后两个指针一齐向后移</p>
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/4.png" class="" title="image-20230518144521542">
<p>当<code>cur</code>节点为空时，<code>prev</code>恰好指向最后一个节点，即新方向链表的表头</p>
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/5.png" class="" title="image-20230518144742139">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *cur = head;</span><br><span class="line">			ListNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">				ListNode *tmp = cur-&gt;next;</span><br><span class="line">				cur-&gt;next = prev;</span><br><span class="line">				prev = cur;</span><br><span class="line">				cur = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> prev;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="递归">递归</h3>
<p>当然可以将其修改为递归，按照以下四部曲来</p>
<ol type="1">
<li><p>子问题：当前节点需指向前一个节点</p></li>
<li><p>递归语句顺序：递归方向分为一去一回，去方向至临界值返回；在这里两种方向都可以</p>
<p>去方向类似迭代，同样不知道上个节点的信息，所以必须通过传参记录上个节点的地址</p>
<p>回方向则可以令当前节点的下一个节点指向自己，达到改变方向的效果</p></li>
<li><p>返回值：分为去方向和回方向两种</p>
<p>由于去方向类似迭代，要获得新表头必须到达临界值，所以递归语句必须放在程序结构的最后一行再返回</p>
<p>回方向的新表头到达临界值返回即可</p></li>
<li><p>临界点：到达最后一个节点后开始回方向</p></li>
</ol>
<p>去方向的递归代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">recursiveFunc</span><span class="params">(ListNode *head, ListNode *prev)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> prev;</span><br><span class="line">			ListNode *tmp = head-&gt;next;</span><br><span class="line">			head-&gt;next = prev;</span><br><span class="line">            <span class="comment">//到达临界值，即新表头再返回</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">recursiveFunc</span>(tmp, head);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//和迭代一样，head是当前节点，prev是当前节点的前一个节点</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">recursiveFunc</span>(head, <span class="literal">nullptr</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>回方向的递归代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">//到达了临界点，即新表头开始返回</span></span><br><span class="line">			<span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">			ListNode *newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">            <span class="comment">//反转当前节点的下一个节点方向</span></span><br><span class="line">			head-&gt;next-&gt;next = head;</span><br><span class="line">            <span class="comment">//让当前节点指向nullptr；正常节点不会受影响，因为方向会在下一次修正</span></span><br><span class="line">            <span class="comment">//目的是为了让第一个节点，即新链表的尾节点闭合</span></span><br><span class="line">			head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">//所有递归子程序的返回值都是一样的，即新表头</span></span><br><span class="line">			<span class="keyword">return</span> newHead;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="头插法">头插法</h2>
<p>头插法是反转链表算法中最通用的处理方式，请务必掌握</p>
<p>我们知道，操作链表基本都会新增<code>dummyHead</code>伪节点，以避免讨论头结点的特殊情况</p>
<p>头插法则是参考了<code>dummyHead</code>的精髓，在待逆转链表的表头的前一个节点做文章</p>
<p>以链表{1, 2, 3, 4,
5}为例，若反转整个链表，则新建<code>dummyHead</code>伪节点于节点1前；若反转子链表{3,
4}，则需要节点2做配合</p>
<p>下面分别介绍市面上普通的头插法和我改进的头插法</p>
<h3 id="普通头插法">普通头插法</h3>
<p>普通头插法的局限性在于无法反转子链表；假设需要反转链表{1, 2, 3}</p>
<p>首先新增一个<code>dummyHead</code>伪节点，指向<code>nullptr</code></p>
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/6.png" class="" title="image-20230518164443126">
<p>随后，每个节点都插入到<code>dummyHead</code>后面即可完成反转链表</p>
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/7.png" class="" title="image-20230518165802774">
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/8.png" class="" title="image-20230518170241065">
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/9.png" class="" title="image-20230518170450819">
<p>代码如下，比较简单</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				ListNode *tmp = head-&gt;next;</span><br><span class="line">				head-&gt;next = dummyHead-&gt;next;</span><br><span class="line">				dummyHead-&gt;next = head;</span><br><span class="line">				head = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="改进版头插法">改进版头插法</h3>
<p>我改进后的头插法可以反转任意子链表，适用性极强</p>
<p>具体步骤如下：</p>
<blockquote>
<ol type="1">
<li>选取待反转链表头节点的前一个节点作为<code>dummyHead</code>，如果没有则新增</li>
<li>头节点是反转链表后的尾节点；故而每次将头节点的后一个节点插入至<code>dummyHead</code>后</li>
</ol>
</blockquote>
<p>以反转{1, 2, 3, 4, 5}的子链表{2, 3, 4}为例：</p>
<p>选取节点1作为<code>dummyHead</code>，节点2为子链表表头<code>head</code></p>
<p>真正需要移动的则是节点<code>cur</code>，代表节点<code>head</code>的下一个节点</p>
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/10.png" class="" title="image-20230519104358978">
<p>每次将节点<code>cur</code>插入至<code>dummyHead</code>节点之后即可</p>
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/11.png" class="" title="image-20230519110340843">
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/12.png" class="" title="image-20230519114002089">
<img src="/2023/07/02/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/13.png" class="" title="image-20230519112704137">
<p>根据上述步骤描述，很容易就能写出代码了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">			<span class="keyword">while</span> (head-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				ListNode *tmp = head-&gt;next;</span><br><span class="line">				head-&gt;next = tmp-&gt;next;</span><br><span class="line">				tmp-&gt;next = dummyHead-&gt;next;</span><br><span class="line">				dummyHead-&gt;next = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>231. 2 的幂</title>
    <url>/2023/07/04/231-2-%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li><code>n &amp; (n - 1)</code>技巧</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>若满足2的幂次，二进制位有且只有一个1</p>
<p>所以使用<code>n &amp; (n - 1)</code>技巧去掉最后一个1，判断是否为空即可</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>21. 合并两个有序链表</title>
    <url>/2023/07/02/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的合并</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">			ListNode *cur1 = list1, *cur2 = list2, *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *curNew = dummyHead;</span><br><span class="line">			<span class="keyword">while</span> (cur1 != <span class="literal">nullptr</span> &amp;&amp; cur2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				<span class="keyword">while</span> (cur1 != <span class="literal">nullptr</span> &amp;&amp; cur2 != <span class="literal">nullptr</span> &amp;&amp; cur1-&gt;val &lt;= cur2-&gt;val) &#123;</span><br><span class="line">					curNew-&gt;next = cur1;</span><br><span class="line">					curNew = curNew-&gt;next;</span><br><span class="line">					cur1 = cur1-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">while</span> (cur1 != <span class="literal">nullptr</span> &amp;&amp; cur2 != <span class="literal">nullptr</span> &amp;&amp; cur2-&gt;val &lt;= cur1-&gt;val) &#123;</span><br><span class="line">					curNew-&gt;next = cur2;</span><br><span class="line">					curNew = curNew-&gt;next;</span><br><span class="line">					cur2 = cur2-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			curNew-&gt;next = cur1 != <span class="literal">nullptr</span> ? cur1 : cur2;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>设<code>list1</code>链表的游标指针为<code>cur1</code>，<code>list2</code>链表的游标指针为<code>cur2</code></p>
<p>两个链表已经是升序，所以两个指针同时从头开始比较，每次取最小值插入新链表</p>
<p>如果某个链表提前结束，其余部分直接接入新链表即可；因为旧链表剩余部分的值肯定比新链表的值都要大</p>
<p>重点讲一下递归的做法：</p>
<ol type="1">
<li>子问题：每次记录两个指针中的最小值，然后串起来变成新链表</li>
<li>递归语句顺序：递归方向分为一去一回，去方向到达临界点后返回；在去方向判断符合条件的节点，在回方向将节点们串起来</li>
<li>返回值：返回符合条件的节点，供以上一个节点修改它的<code>next</code>值</li>
<li>临界点：两个指针均为<code>nullptr</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (list1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> list2;</span><br><span class="line">			<span class="keyword">if</span> (list2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> list1;</span><br><span class="line">			<span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;</span><br><span class="line">				list1-&gt;next = <span class="built_in">mergeTwoLists</span>(list1-&gt;next, list2);</span><br><span class="line">				<span class="keyword">return</span> list1;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				list2-&gt;next = <span class="built_in">mergeTwoLists</span>(list1, list2-&gt;next);</span><br><span class="line">				<span class="keyword">return</span> list2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>234. 回文链表</title>
    <url>/2023/07/02/234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>快慢指针/双指针</li>
<li>链表的反转</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">judgeFunc</span><span class="params">(ListNode* head, ListNode* midNode)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (ListNode *left = head, *right = midNode-&gt;next; right != <span class="literal">nullptr</span>; left = left-&gt;next, right = right-&gt;next) &#123;</span><br><span class="line">				<span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* dummyHead)</span> </span>&#123;</span><br><span class="line">			ListNode *tail = dummyHead-&gt;next;</span><br><span class="line">			<span class="keyword">while</span> (tail-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				ListNode *node = tail-&gt;next;</span><br><span class="line">				tail-&gt;next = node-&gt;next;</span><br><span class="line">				node-&gt;next = dummyHead-&gt;next;</span><br><span class="line">				dummyHead-&gt;next = node;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">ListNode* <span class="title">findMid</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *slow = head, *fast = head;</span><br><span class="line">			<span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				slow = slow-&gt;next;</span><br><span class="line">				fast = fast-&gt;next-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> slow;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">return</span> (<span class="built_in">judgeFunc</span>(head, <span class="built_in">reverseList</span>(<span class="built_in">findMid</span>(head))));</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>验证回文串，最直接的方法就是双指针，左指针从头向尾遍历，右指针从尾向头遍历，只要两个指针指向的值不一样就肯定不是回文串</p>
<ol type="1">
<li><p>子问题：两个指针反向遍历，比较两个指针指向的值</p></li>
<li><p>递归语句顺序：递归方向分为一去一回，去方向到达临界点后返回；这里只能在回方向操作，因为右指针需要从尾向头遍历</p>
<p>左指针怎么办呢？额外单独设置一个成员变量即可，待右指针开始从尾向头遍历时再做比较</p></li>
<li><p>返回值：不需要返回值</p></li>
<li><p>临界点：右指针为空</p></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">bool</span> ans;</span><br><span class="line">		ListNode *left;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">recursiveFunc</span><span class="params">(ListNode *right)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (right == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">			<span class="built_in">recursiveFunc</span>(right-&gt;next);</span><br><span class="line">			<span class="keyword">if</span>(left-&gt;val != right-&gt;val) ans = <span class="literal">false</span>;</span><br><span class="line">			left = left-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			left = head;</span><br><span class="line">			ans = <span class="literal">true</span>;</span><br><span class="line">			<span class="built_in">recursiveFunc</span>(head);</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但题目要求只能以常数空间复杂度运行，故而不能使用递归；用迭代分为以下几个步骤</p>
<ol type="1">
<li>找到链表中心点，分为左、右两个子链表</li>
<li>右子链表反转</li>
<li>即可对左、右两个子链表进行同向比较了</li>
</ol>
<p>这里有一个可有可无的Trick</p>
<blockquote>
<p>如果是奇数个链表节点，比如<code>&#123;1, 2, 3, 4, 5&#125;</code>，找到的链表中心点是<code>3</code></p>
<p>如果是偶数个链表节点，比如<code>&#123;1, 2, 3, 4&#125;</code>，则找到的链表中心点应为<code>2</code></p>
<p>这样中心点就可以作为右子链表的<code>dummyHead</code>，便于反转</p>
</blockquote>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>237. 删除链表中的节点</title>
    <url>/2023/07/03/237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>智力题</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">            node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">            node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>一道脑筋急转弯的题目</p>
<p>要求中提到<code>并且保证给定的节点</code>node<code>不是链表中的最后一个节点</code>，那么直接用下一个节点覆盖自己就行</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>24. 两两交换链表中的节点</title>
    <url>/2023/07/02/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的反转</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">			ListNode *subDummy = dummyHead;</span><br><span class="line">			<span class="keyword">while</span> (subDummy-&gt;next != <span class="literal">nullptr</span> &amp;&amp; subDummy-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				ListNode *nodeOne = subDummy-&gt;next;</span><br><span class="line">				ListNode *nodeTwo = subDummy-&gt;next-&gt;next;</span><br><span class="line">				nodeOne-&gt;next = nodeTwo-&gt;next;</span><br><span class="line">				nodeTwo-&gt;next = subDummy-&gt;next;</span><br><span class="line">				subDummy-&gt;next = nodeTwo;</span><br><span class="line">				subDummy = nodeOne;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题目说<code>两两交换其中相邻的节点</code>，我完全可以理解为：</p>
<blockquote>
<p>执行若干次反转长度为2的子链表操作</p>
</blockquote>
<p>那么就可以使用改进版头插法完成这一操作</p>
<p>设每个子链表的<code>dummyHead</code>名称为<code>subDummy</code>，子链表的第一个节点名称为<code>nodeOne</code>，第二个节点名称为<code>nodeTwo</code></p>
<img src="/2023/07/02/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/1.png" class="" title="image-20230519161147419">
<p>子链表{1,
2}反转结束后，可以发现<code>nodeOne</code>所处的位置恰好就是下一个子链表{3,
4}的<code>subDummy</code></p>
<img src="/2023/07/02/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/2.png" class="" title="image-20230519161837109">
<p>故而将<code>nodeOne</code>赋值给<code>subDummy</code>后开启下一轮反转</p>
<img src="/2023/07/02/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/3.png" class="" title="image-20230519162601816">
<p>子链表{3, 4}反转结束后，发现子链表{5}长度不等于2，结束循环</p>
<img src="/2023/07/02/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/4.png" class="" title="image-20230519162952720">
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>25. K 个一组翻转链表</title>
    <url>/2023/07/02/25-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的反转</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head), *subDummyHead = dummyHead;</span><br><span class="line">			<span class="keyword">while</span> (subDummyHead-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				ListNode *tmp = subDummyHead;</span><br><span class="line">				<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (; i &lt; k &amp;&amp; tmp != <span class="literal">nullptr</span>; i++) tmp = tmp-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) <span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">//使用改进版头插法进行反转子链表</span></span><br><span class="line">				ListNode *tail = subDummyHead-&gt;next;</span><br><span class="line">				<span class="keyword">while</span> (--i) &#123;</span><br><span class="line">					ListNode *node = tail-&gt;next;</span><br><span class="line">					tail-&gt;next = node-&gt;next;</span><br><span class="line">					node-&gt;next = subDummyHead-&gt;next;</span><br><span class="line">					subDummyHead-&gt;next = node;</span><br><span class="line">				&#125;</span><br><span class="line">				subDummyHead = tail;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>凡是链表翻转类的题目，使用<code>改进版头插法</code>就对了，详见<code>206. 反转链表</code></p>
<p>因为题目是要求每次翻转长度为K的子链表，除了要在子链表头前再找一个节点作为<code>dummyHead</code>外，每次还要先判断子链表长度是不是K</p>
<p>每次翻转结束后，当前子链表的尾节点恰好就是下一组子链表的<code>dummyHead</code>，从而开启新一轮的翻转</p>
<p>其余代码套<code>改进版头插法</code>的模板就好了</p>
<p>这里改成递归也行，但是和迭代没太大区别</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">recursiveFunc</span><span class="params">(ListNode* subDummyHead, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">			ListNode *tmp = subDummyHead;</span><br><span class="line">			<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (; i &lt; k &amp;&amp; tmp != <span class="literal">nullptr</span>; i++) tmp = tmp-&gt;next;</span><br><span class="line">			<span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">			<span class="comment">//使用改进版头插法进行反转子链表</span></span><br><span class="line">			ListNode *tail = subDummyHead-&gt;next;</span><br><span class="line">			<span class="keyword">while</span> (--i) &#123;</span><br><span class="line">				ListNode *node = tail-&gt;next;</span><br><span class="line">				tail-&gt;next = node-&gt;next;</span><br><span class="line">				node-&gt;next = subDummyHead-&gt;next;</span><br><span class="line">				subDummyHead-&gt;next = node;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">recursiveFunc</span>(tail, k);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">			<span class="built_in">recursiveFunc</span>(dummyHead, k);</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>260. 只出现一次的数字 III</title>
    <url>/2023/07/04/260-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-III/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>状态压缩</li>
<li>排列组合</li>
<li>异或技巧</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//这里使用long，避免计算lsb即最低有效位时溢出</span></span><br><span class="line">			<span class="type">long</span> xorSum = <span class="number">0</span>, lsb = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;num : nums) xorSum ^= num;</span><br><span class="line">			<span class="comment">//按最低有效位所在的比特位进行比较与分割</span></span><br><span class="line">			<span class="type">int</span> ans_1 = <span class="number">0</span>;</span><br><span class="line">			lsb = (xorSum &amp; (-xorSum));</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;num : nums) &#123;</span><br><span class="line">				<span class="keyword">if</span> (num &amp; lsb) ans_1 ^= num;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;ans_1, (<span class="type">int</span>)(xorSum ^ ans_1)&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( n
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>类似<code>136. 只出现一次的数字</code>，同样对数组的所有元素进行异或运算，得到<code>xorSum</code>；实际上就是最终两个答案的异或值，且必不为0</p>
<p>取<code>xorSum</code>任意一个值为1的比特位，记为<code>i</code>；其代表两个答案在<code>i</code>上不同，一个必为1一个必为0</p>
<p>根据在<code>i</code>上的值为0或1，将所有元素进行分组，两个答案必不在一个组；随后对每个组分别求异或和，即可得到两个答案</p>
<p>比如<code>nums</code>等于<code>&#123;1,1,2,2,3,5&#125;</code>，二进制表达为<code>&#123;001,001,010,010,011,101&#125;</code>
，<code>xorSum</code>为<code>110</code></p>
<p>这里取<code>i</code>为<code>010</code>，即<code>xorSum</code>的最低有效位</p>
<p>与<code>i</code>作与运算为0的，子集合为<code>&#123;001,001,101&#125;</code>；与<code>i</code>作与运算为1的，子集合为<code>&#123;010,010,011&#125;</code></p>
<p>任意取一个子集合作异或运算求和，即可得到其中一个答案；将这个答案与<code>xorSum</code>作异或运算，即可得到另一个答案</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>状态压缩</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>268. 丢失的数字</title>
    <url>/2023/07/04/268-%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>异或技巧</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> xorSum = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= (<span class="type">int</span>)nums.<span class="built_in">size</span>(); i++) xorSum ^= i;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;num : nums) xorSum ^= num;</span><br><span class="line">			<span class="keyword">return</span> xorSum;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( n
\right)\)</span>，其中<span
class="math inline">\(n\)</span>为数组长度</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>假设给定范围为<span
class="math inline">\(a_{0...3}\)</span>，<code>nums</code>的值为<span
class="math inline">\(\left\{ a_0,a_1,a_3
\right\}\)</span>，则需要找到<span
class="math inline">\(a_2\)</span></p>
<p>根据异或的性质<code>a ^ a = 0</code>与<code>a ^ 0 = a</code>，必有以下恒等式成立：
<span class="math display">\[
\left( a_0\oplus a_1\oplus a_2\oplus a_3 \right) \oplus \left( a_0\oplus
a_1\oplus a_3 \right) =a_2
\]</span>
故而先求出<code>0 ~ nums.size()</code>的异或和，再与<code>nums</code>的元素逐个异或即可得出缺失的元素</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>318. 最大单词长度乘积</title>
    <url>/2023/07/04/318-%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>状态压缩</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (string &amp;word : words) &#123;</span><br><span class="line">				<span class="type">int</span> hsh = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">char</span> &amp;chr : word) &#123;</span><br><span class="line">					hsh |= <span class="number">1</span> &lt;&lt; (chr - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				m[hsh] = <span class="built_in">max</span>(m[hsh], (<span class="type">int</span>)word.<span class="built_in">length</span>());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> it_1 = m.<span class="built_in">begin</span>(); it_1 != m.<span class="built_in">end</span>(); it_1++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span> it_2 = <span class="built_in">next</span>(it_1); it_2 != m.<span class="built_in">end</span>(); it_2++) &#123;</span><br><span class="line">					<span class="keyword">if</span> ((it_1-&gt;first &amp; it_2-&gt;first) == <span class="number">0</span>) &#123;</span><br><span class="line">						ans = <span class="built_in">max</span>(ans, it_1-&gt;second * it_2-&gt;second);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( \max \left(
\sum\nolimits_{0\leqslant i\leqslant n-1}^{}{words\left[ i
\right]}.length,n^2 \right) \right)\)</span>，<span
class="math inline">\(n\)</span>为<span
class="math inline">\(words\)</span>数组长度</p>
<p>其中构造哈希表的时间复杂度为<span class="math inline">\(O\left(
\sum\nolimits_{0\leqslant i\leqslant n-1}^{}{words\left[ i
\right]}.length \right)\)</span>，计算最大乘积的时间复杂度为<span
class="math inline">\(O\left( n^2 \right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( n
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>按照传统的办法，比较两个字符串的组成需要新建哈希表并遍历，耗时<span
class="math inline">\(O\left( n \right)\)</span></p>
<p>若按照题意，所有字符串两两比较，时间复杂度高达<span
class="math inline">\(O\left( n^3 \right)\)</span>，是绝对不可取的</p>
<p>题目限制了字符串只含有小写字母，可以使用一个<code>int</code>的低26位来记录字符串中的字母组成</p>
<p>该<code>int</code>可以作为哈希表的键，值则是对应字符串的长度；字母的组成肯定有雷同，所以只记录组成相同里长度最大的</p>
<p>最后再双重遍历哈希表，寻找长度乘积最大的即可</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>状态压缩</tag>
        <tag>哈希函数</tag>
      </tags>
  </entry>
  <entry>
    <title>338. 比特位计数</title>
    <url>/2023/07/04/338-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>比特位变化规律，按最高位变化、最低位变化与Brian
Kernighan算法三种角度分析</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>同下</p>
<h1 id="思路">思路</h1>
<p>假设<code>i</code>代表当前十进制数字，<code>dp[i]</code>代表十进制数字<code>i</code>的<code>1个数</code></p>
<h2 id="最高有效位">最高有效位</h2>
<p>设<code>i</code>的最高有效位保存至变量<code>highBit</code>；显然<code>110</code>是由<code>100 + 010</code>组成，<code>101</code>是由<code>100 + 001</code>组成，满足：</p>
<blockquote>
<p>i的1个数 = 1[代表highBit] + (i - highBit)的1个数</p>
</blockquote>
<p>将其转化为动态规划转移方程： <span class="math display">\[
dp\left[ i \right] =1+dp\left[ i-highBit \right]
\]</span>
遇到<code>001</code>、<code>010</code>这类2的幂次，代表有新的进位；此时更新<code>highBit</code>变量，避免后续数字重复计算<code>highBit</code></p>
<p>如果范围不大，也可以先将范围内所有的<code>highBit</code>通过打表存入数组，在许多场景都有该应用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="type">int</span> highBit = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!(i &amp; (i - <span class="number">1</span>))) highBit = i;</span><br><span class="line">				dp[i] = dp[i - highBit] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dp;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( n
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( n
\right)\)</span>，新增了<code>dp</code>数组存储结果</p>
<h2 id="最低有效位">最低有效位</h2>
<p>根据奇偶性分析</p>
<ul>
<li><p>若<code>i</code>是偶数，<code>1个数</code>肯定与<code>i/2</code>一致，因为<code>i</code>是由<code>i/2</code>的比特位向左移一位而成</p>
<p>比如<code>100</code>是<code>010</code>向左移了一位，<code>1个数</code>保持不变</p></li>
<li><p>若<code>i</code>是奇数，必满足<code>i的1个数 = i/2的1个数 + 1</code></p>
<p>比如<code>111</code>是<code>011</code>向左移一位后再加上<code>001</code></p></li>
</ul>
<p>将其转化为动态规划转移方程： <span class="math display">\[
dp\left[ i \right] =\begin{cases}
    dp\left[ i/2 \right] \text{，}i\text{为偶数}\\
    dp\left[ i/2 \right] +1\text{，}i\text{为奇数}\\
\end{cases}
\]</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">				dp[i] = i &amp; <span class="number">1</span> ? dp[i / <span class="number">2</span>] + <span class="number">1</span> : dp[i / <span class="number">2</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dp;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( n
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( n
\right)\)</span>，新增了<code>dp</code>数组存储结果</p>
<h2 id="brian-kernighan算法">Brian Kernighan算法</h2>
<p>根据<code>i &amp; (i - 1)</code>可以去掉<code>i</code>的最低有效1这一性质，满足：</p>
<blockquote>
<p>i的1个数 = 1[代表Brian Kernighan操作去掉的1] + (i &amp; (i -
1))的1个数</p>
</blockquote>
<p>将其转化为动态规划转移方程： <span class="math display">\[
dp\left[ i \right] =1+dp\left[ i\,\,\&amp; \left( i-1 \right) \right]
\]</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">				dp[i] = dp[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dp;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( n
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( n
\right)\)</span>，新增了<code>dp</code>数组存储结果</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>328. 奇偶链表</title>
    <url>/2023/07/02/328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的合并</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">			ListNode *dummyHeadA = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *curA = dummyHeadA, *dummyHeadB = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *curB = dummyHeadB;</span><br><span class="line">			<span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (cnt++ % <span class="number">2</span>) &#123;</span><br><span class="line">					curA-&gt;next = head;</span><br><span class="line">					curA = curA-&gt;next;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					curB-&gt;next = head;</span><br><span class="line">					curB = curB-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">				head = head-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			curA-&gt;next = dummyHeadB-&gt;next;</span><br><span class="line">			curB-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">return</span> dummyHeadA-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>新建两个伪节点，各用来构成奇链表与偶链表</p>
<p>遍历链表时，奇数节点插入至奇链表，偶数节点插入至偶链表；最终将偶链表接在奇链表末尾即可</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>371. 两整数之和</title>
    <url>/2023/07/04/371-%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>异或技巧</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> carry, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (carry) &#123;</span><br><span class="line">				<span class="type">int</span> tmp = sum;</span><br><span class="line">				sum = carry ^ tmp;</span><br><span class="line">				carry = (carry &amp; tmp) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> sum;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：存在异议，但个人认为不会超过32次</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>记住这个位运算小技巧就好了，假设有<code>a</code>和<code>b</code>两个整数，不限正负</p>
<ul>
<li><span class="math inline">\(a\oplus
b\)</span>可得到<code>a</code>与<code>b</code>的无进位加法结果</li>
<li><span class="math inline">\(\left( a\&amp;b \right)
&lt;&lt;1\)</span>可得到<code>a</code>与<code>b</code>的加法进位</li>
</ul>
<p>由于进位可能会溢出，比如<code>-1 + 1</code>这组数据；所以需用无符号类型保存进位</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>405. 数字转换为十六进制数</title>
    <url>/2023/07/04/405-%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>掩码技巧</li>
<li>移位技巧</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		string ans;</span><br><span class="line">		<span class="type">char</span> chr[<span class="number">16</span>] = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span></span><br><span class="line">		                , <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span></span><br><span class="line">		               &#125;;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">string <span class="title">toHex</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (!num) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">			<span class="keyword">while</span> (num) &#123;</span><br><span class="line">				ans = chr[num &amp; <span class="number">0b1111</span>] + ans;</span><br><span class="line">				num &gt;&gt;= <span class="number">4</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( k
\right)\)</span>，在这里<span
class="math inline">\(k\)</span>等于<code>32 / 4 = 8</code>，即32位整数的十六进制位数</p>
<p>空间复杂度：<span class="math inline">\(O\left( k
\right)\)</span>，同上</p>
<h1 id="思路">思路</h1>
<p>首先将整数从<code>int</code>转换为<code>unsigned int</code>，因为C++当中没有无符号运算符；倘若整数为<code>int</code>类型的负数，右移时会在高位补1</p>
<p>同时题目要求不包含前导零，所以每次循环之前需要判断整数是否为空</p>
<p>整数和掩码<code>1111</code>作与运算取出低四位，并将其倒序保存至字符串后，整数右移四位开启下一轮循环</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>432. 全 O(1) 的数据结构</title>
    <url>/2023/07/03/432-%E5%85%A8-O-1-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>哈希表与链表的综合</li>
<li>掌握迭代器、<code>pair</code>、<code>unordered_set</code>与<code>unordered_map</code>的本质</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AllOne</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		list &lt;pair&lt;<span class="type">int</span>, unordered_set&lt;string&gt; &gt; &gt; l;</span><br><span class="line">		unordered_map &lt;string, list &lt;pair&lt;<span class="type">int</span>, unordered_set&lt;string&gt; &gt; &gt;::iterator&gt; m;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">AllOne</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">(string key)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">auto</span> it = m.<span class="built_in">find</span>(key);</span><br><span class="line">			<span class="keyword">if</span> (it == m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">				<span class="comment">//如果是新字符串</span></span><br><span class="line">				<span class="comment">//链表为空，或头节点次数不为1；则需新建头节点</span></span><br><span class="line">				<span class="keyword">if</span> (l.<span class="built_in">empty</span>() || l.<span class="built_in">front</span>().first &gt; <span class="number">1</span>) &#123;</span><br><span class="line">					l.<span class="built_in">emplace_front</span>(<span class="number">1</span>, unordered_set&lt;string&gt; &#123;key&#125;);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//头节点次数为1，新字符串直接插入即可</span></span><br><span class="line">					l.<span class="built_in">front</span>().second.<span class="built_in">emplace</span>(key);</span><br><span class="line">				&#125;</span><br><span class="line">				m[key] = l.<span class="built_in">begin</span>();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">auto</span> node = it-&gt;second, nextNode = <span class="built_in">next</span>(node);</span><br><span class="line">				<span class="keyword">if</span> (nextNode == l.<span class="built_in">end</span>() || nextNode-&gt;first &gt; node-&gt;first + <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="comment">//如果字符串所在的节点是链表末尾</span></span><br><span class="line">					<span class="comment">//或者下一个节点的次数大于当前次数+1</span></span><br><span class="line">					<span class="comment">//说明需要新建节点</span></span><br><span class="line">					m[key] = l.<span class="built_in">emplace</span>(nextNode, node-&gt;first + <span class="number">1</span>, unordered_set&lt;string&gt; &#123;key&#125;);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//下一个节点次数等于当前次数+1，直接插入即可</span></span><br><span class="line">					nextNode-&gt;second.<span class="built_in">emplace</span>(key);</span><br><span class="line">					m[key] = nextNode;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//删除旧地方的字符串</span></span><br><span class="line">				node-&gt;second.<span class="built_in">erase</span>(key);</span><br><span class="line">				<span class="keyword">if</span> (node-&gt;second.<span class="built_in">empty</span>()) l.<span class="built_in">erase</span>(node);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">dec</span><span class="params">(string key)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">auto</span> node = m[key], prevNode = <span class="built_in">prev</span>(node);</span><br><span class="line">			<span class="keyword">if</span> (node-&gt;first != <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (node == l.<span class="built_in">begin</span>() || prevNode-&gt;first &lt; node-&gt;first - <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="comment">//前一个节点的次数小于当前次数-1</span></span><br><span class="line">					<span class="comment">//或者前一个节点为空</span></span><br><span class="line">					<span class="comment">//说明需要新建节点</span></span><br><span class="line">					m[key] = l.<span class="built_in">emplace</span>(node, node-&gt;first - <span class="number">1</span>, unordered_set&lt;string&gt; &#123;key&#125;);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//上一个节点次数等于当前次数-1，直接插入即可</span></span><br><span class="line">					prevNode-&gt;second.<span class="built_in">emplace</span>(key);</span><br><span class="line">					m[key] = prevNode;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//如果节点次数为1，直接删除</span></span><br><span class="line">				m.<span class="built_in">erase</span>(key);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//删除旧地方的字符串</span></span><br><span class="line">			node-&gt;second.<span class="built_in">erase</span>(key);</span><br><span class="line">			<span class="keyword">if</span> (node-&gt;second.<span class="built_in">empty</span>()) l.<span class="built_in">erase</span>(node);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">string <span class="title">getMaxKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> l.<span class="built_in">empty</span>() ? <span class="string">&quot;&quot;</span> : *(l.<span class="built_in">back</span>().second.<span class="built_in">begin</span>());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">string <span class="title">getMinKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> l.<span class="built_in">empty</span>() ? <span class="string">&quot;&quot;</span> : *(l.<span class="built_in">front</span>().second.<span class="built_in">begin</span>());</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本题难度极高，对哈希表、链表、迭代器的熟练度都是极大的考验，是非常棒的综合题！</p>
<p>在完成本题前，请先完成<code>460. LFU 缓存</code>与<code>146. LRU 缓存</code>，掌握基本的哈希表与链表的结合思路</p>
<p>题目希望给每个字符串计数，可增可减，所有操作为常数时间复杂度；并返回计数最大与最小的字符串，如果计数为0，则将其删除</p>
<ol type="1">
<li><p><strong>可以参考LFU，只使用变量来记录极值吗？</strong></p>
<p>LFU是单向操作，只增无减，统计极值用变量即可胜任</p>
<p>本题有增有减，只用变量很难记录空间的动态变化，必须依赖容器来完成这一操作</p></li>
<li><p><strong>可以参考LFU的数据结构吗？</strong></p>
<p>若参考LFU，使用<code>unordered_map</code>，则键为次数，给每个键单独新建链表作为值</p>
<p>那么只能用变量来记录键的极值，因为<code>unordered_map</code>是无序的，方才提过用变量是死路</p>
<p>若使用<code>map</code>，键虽有序但达不到常数时间复杂度</p>
<p>故而LFU的数据结构无法照搬</p></li>
</ol>
<p>联想LRU用到的有序双向链表技巧，表头是最晚访问元素，表尾是最早访问元素，极值就在两侧</p>
<p>可以设计数据结构如下：</p>
<ul>
<li><p>新建一个双向链表，链表节点为键值对，键为次数，值为<code>unordered_set</code>以存储字符串</p>
<p>次数增加，则在当前节点之后新增节点/修改下一个节点；次数减少，则在当前节点之前新增节点/修改前一个节点</p>
<p>从而保证了链表表头为次数最小值，链表表尾为次数最大值</p></li>
<li><p>新建一个哈希表，键为字符串，值为对应次数的链表节点地址</p></li>
</ul>
<img src="/2023/07/03/432-%E5%85%A8-O-1-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.png" class="" title="image-20230608215736025">
<ol start="3" type="1">
<li><p><strong>为什么设计“左小右大”？而不是像LRU一样”左大右小“？</strong></p>
<p>若是<code>左大右小</code>，每次新增的节点都将在链表表尾，返回表尾元素的迭代器则是<a
href="https://cplusplus.com/reference/list/list/rbegin/">rbegin</a>方法，且这个迭代器是<code>reverse_iterator</code>类型</p>
<blockquote>
<p><code>reverse_iterator</code>类型是对<code>iterator</code>类型的封装，可<a
href="https://cplusplus.com/reference/iterator/reverse_iterator/">参见</a></p>
</blockquote>
<p>双向链表list删除节点时，使用的是<a
href="https://cplusplus.com/reference/list/list/erase/">erase</a>方法，它只支持<code>iterator</code>类型参数</p>
<p>返回表头元素迭代器的方法<a
href="https://cplusplus.com/reference/list/list/begin/">begin</a>，满足这一条件。故而选择<code>左小右大</code></p></li>
<li><p><strong>为什么双向链表的节点不选择<code>unordered_map</code>，而选择<code>pair</code>?</strong></p>
<p>因为<code>unordered_map</code>与<code>map</code>都没有<code>取出键</code>这一个操作，哈希表的意义就是<code>通过键访问值</code></p>
<p>实际上，我们需要的是一个类似结构体的容器，第一个元素存储次数，第二个元素存储<code>unordered_set</code></p>
<p>这样一来前后节点比较次数时，直接取节点容器的第一个元素对比即可</p>
<p><code>pair</code>恰好满足，当然你乐意的话可以自写结构体</p></li>
<li><p><strong>为什么存储字符串选择<code>unordered_set</code>，而不是<code>vector</code>？</strong></p>
<p>因为字符串在不同节点之间转移时，所经历的步骤就是</p>
<ol type="1">
<li>从原节点存储删除</li>
<li>插入新节点存储</li>
</ol>
<p>知道一个值，怎么在常数时间复杂度从存储中删除呢？只有哈希表了！</p>
<p>哈希表当中键与值相等的是什么STL？当然是<code>unordered_set</code>和<code>set</code></p></li>
</ol>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>445. 两数相加 II</title>
    <url>/2023/07/02/445-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-II/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的合并</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">			stack&lt;<span class="type">int</span>&gt; list1, list2;</span><br><span class="line">			<span class="keyword">while</span> (l1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				list1.<span class="built_in">push</span>(l1-&gt;val);</span><br><span class="line">				l1 = l1-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				list2.<span class="built_in">push</span>(l2-&gt;val);</span><br><span class="line">				l2 = l2-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">while</span> (!list1.<span class="built_in">empty</span>() || !list2.<span class="built_in">empty</span>() || carry) &#123;</span><br><span class="line">				carry += !list1.<span class="built_in">empty</span>() ? list1.<span class="built_in">top</span>() : <span class="number">0</span>;</span><br><span class="line">				carry += !list2.<span class="built_in">empty</span>() ? list2.<span class="built_in">top</span>() : <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (!list1.<span class="built_in">empty</span>()) list1.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="keyword">if</span> (!list2.<span class="built_in">empty</span>()) list2.<span class="built_in">pop</span>();</span><br><span class="line">				ListNode *node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry % <span class="number">10</span>, dummyHead-&gt;next);</span><br><span class="line">				dummyHead-&gt;next = node;</span><br><span class="line">				carry /= <span class="number">10</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>按照算术逻辑，运算应该从低位到高位，同时用一个变量<code>carry</code>记录进位</p>
<p>那么新节点的值就等于<strong>(对应位之和+上一次运算的<code>carry</code>)取余10</strong>，进位<code>carry</code>的值就等于<strong>(对应位之和+上一次运算的<code>carry</code>)除以10</strong></p>
<p>故而正常思维，两个链表先反转并作运算，新的节点以头插的方式连接，这样就保证了逆序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function">ListNode* <span class="title">reverseFunc</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//头插法反转链表</span></span><br><span class="line">		ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head), *tail = head;</span><br><span class="line">		<span class="keyword">while</span> (tail-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			ListNode *node = tail-&gt;next;</span><br><span class="line">			tail-&gt;next = node-&gt;next;</span><br><span class="line">			node-&gt;next = dummyHead-&gt;next;</span><br><span class="line">			dummyHead-&gt;next = node;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">		ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">		l1 = <span class="built_in">reverseFunc</span>(l1);</span><br><span class="line">		l2 = <span class="built_in">reverseFunc</span>(l2);</span><br><span class="line">		<span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> || l2 != <span class="literal">nullptr</span> || carry) &#123;</span><br><span class="line">			carry += l1 != <span class="literal">nullptr</span> ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">			carry += l2 != <span class="literal">nullptr</span> ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//头插法新建链表即逆序</span></span><br><span class="line">			ListNode *node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry % <span class="number">10</span>, dummyHead-&gt;next);</span><br><span class="line">			dummyHead-&gt;next = node;</span><br><span class="line">			carry /= <span class="number">10</span>;</span><br><span class="line">			l1 = l1 != <span class="literal">nullptr</span> ? l1-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">			l2 = l2 != <span class="literal">nullptr</span> ? l2-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是题目竟然要求不反转链表？那就只能用栈了，代码如题解所示</p>
<p>两个链表的值先入栈，保证低位对低位；每次对应位出栈做运算，新的节点同样以头插的方式连接保证逆序</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>460. LFU 缓存</title>
    <url>/2023/07/03/460-LFU-%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>哈希表与链表的综合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">			<span class="type">int</span> key;</span><br><span class="line">			<span class="type">int</span> value;</span><br><span class="line">			<span class="type">int</span> freq;</span><br><span class="line">			<span class="built_in">Node</span>(<span class="type">int</span> _key, <span class="type">int</span> _value, <span class="type">int</span> _freq) : <span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value), <span class="built_in">freq</span>(_freq) &#123;&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="type">int</span> capacity;</span><br><span class="line">		<span class="type">int</span> minFreq;</span><br><span class="line">		unordered_map&lt;<span class="type">int</span>, list&lt;Node&gt;::iterator&gt; key2List;</span><br><span class="line">		unordered_map&lt;<span class="type">int</span>, list&lt;Node&gt;&gt; freq2List;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">LFUCache</span>(<span class="type">int</span> _capacity) : <span class="built_in">capacity</span>(_capacity), <span class="built_in">minFreq</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">auto</span> it = key2List.<span class="built_in">find</span>(key);</span><br><span class="line">			<span class="keyword">if</span> (it == key2List.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			<span class="type">int</span> value = it-&gt;second-&gt;value, freq = it-&gt;second-&gt;freq;</span><br><span class="line">			<span class="comment">//从对应的频率链表中删除节点</span></span><br><span class="line">			freq2List[freq].<span class="built_in">erase</span>(it-&gt;second);</span><br><span class="line">			<span class="comment">//删除节点后频率链表为空的情况</span></span><br><span class="line">			<span class="keyword">if</span> (freq2List[freq].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">				<span class="comment">//如果当前频率就是最小频率，说明需要更新最小频率</span></span><br><span class="line">				<span class="keyword">if</span> (minFreq == freq) minFreq++;</span><br><span class="line">				<span class="comment">//删除空频率链表</span></span><br><span class="line">				freq2List.<span class="built_in">erase</span>(freq);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//将节点插入至新频率链表</span></span><br><span class="line">			freq2List[freq + <span class="number">1</span>].<span class="built_in">emplace_front</span>(key, value, freq + <span class="number">1</span>);</span><br><span class="line">			key2List[key] = freq2List[freq + <span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">auto</span> it = key2List.<span class="built_in">find</span>(key);</span><br><span class="line">			<span class="comment">//新增节点的情况</span></span><br><span class="line">			<span class="keyword">if</span> (it == key2List.<span class="built_in">end</span>()) &#123;</span><br><span class="line">				<span class="comment">//如果没有容量，直接不作考虑</span></span><br><span class="line">				<span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">				<span class="comment">//如果容量已经满了</span></span><br><span class="line">				<span class="comment">//删除最小频率且最早访问的节点</span></span><br><span class="line">				<span class="comment">//即删除最小频率链表的尾节点</span></span><br><span class="line">				<span class="keyword">if</span> (key2List.<span class="built_in">size</span>() == (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)capacity) &#123;</span><br><span class="line">					key2List.<span class="built_in">erase</span>(freq2List[minFreq].<span class="built_in">back</span>().key);</span><br><span class="line">					freq2List[minFreq].<span class="built_in">pop_back</span>();</span><br><span class="line">				&#125;</span><br><span class="line">				freq2List[<span class="number">1</span>].<span class="built_in">emplace_front</span>(key, value, <span class="number">1</span>);</span><br><span class="line">				key2List[key] = freq2List[<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">				minFreq = <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//和get方法一样，照抄即可</span></span><br><span class="line">				<span class="type">int</span> freq = it-&gt;second-&gt;freq;</span><br><span class="line">				freq2List[freq].<span class="built_in">erase</span>(it-&gt;second);</span><br><span class="line">				<span class="keyword">if</span> (freq2List[freq].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">					<span class="keyword">if</span> (minFreq == freq) minFreq++;</span><br><span class="line">					freq2List.<span class="built_in">erase</span>(freq);</span><br><span class="line">				&#125;</span><br><span class="line">				freq2List[freq + <span class="number">1</span>].<span class="built_in">emplace_front</span>(key, value, freq + <span class="number">1</span>);</span><br><span class="line">				key2List[key] = freq2List[freq + <span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>LFU是最近最不常用页面置换算法(Least Frequently
Used)，淘汰访问次数最少的页面；若访问次数相同，淘汰同条件下最早访问的页面</p>
<p>从定义描述来看，本质上就是LRU的升级版；第一规则是访问频率，第二规则是访问时间</p>
<p>所以有如下设计思想：</p>
<ol type="1">
<li><p>设置一张<code>freq2List</code>频率哈希表，键为频率，值为双向链表的表头；其中每个频率都有自己单独的双向链表</p></li>
<li><p>与LRU一样，设置一张<code>key2List</code>哈希表记录键与链表节点的映射；键的值就是<code>freq2List</code>某个频率的双向链表中的节点</p></li>
<li><p>因为是无序哈希表，所以还需要新增一个<code>minFreq</code>变量记录最小频率</p></li>
<li><p>新节点都插入至频率为1的双向链表中，如果节点被访问/操作后，先从原频率链表中删除，再插入至新频率链表</p></li>
<li><p>如果当前频率链表为空，且频率等于<code>minFreq</code>，那么<code>minFreq++</code></p>
<p>假设有新增数据{A,
B}，A与B频率均为1，<code>minFreq</code>也为初始状态1</p>
<p>访问一次A，A的频率增为2；再访问一次A，A的频率增为3。但B频率依旧为1，<code>minFreq</code>也为1</p>
<p>只有当访问一次B后，B转移至频率为2的链表，此时<code>minFreq</code>所指的链表为空，则<code>minFreq</code>应当加1</p></li>
</ol>
<p>数据结构设计图如下。若要达成下图的情形，需经历以下步骤</p>
<blockquote>
<p>按照1、2、3的先后顺序，头插至频率为1的双向链表并同步更新两张哈希表；此时频率1的链表值为{3,
2, 1}</p>
<p>访问一次节点2，节点2从频率1链表转移至频率2链表</p>
<p>访问一次节点3，节点3从频率1链表转移至频率2链表</p>
</blockquote>
<img src="/2023/07/03/460-LFU-%E7%BC%93%E5%AD%98/1.png" class="" title="image-20230605175056397">
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>342. 4的幂</title>
    <url>/2023/07/04/342-4%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li><code>n &amp; (n - 1)</code>技巧</li>
<li>掩码技巧</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; !(n &amp; (n - <span class="number">1</span>)) &amp;&amp; (n &amp; <span class="number">0x55555555</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>4的幂，实际上就是2的幂次的平方；故而肯定大于零且只存在一个1比特位，满足这两个条件后继续找规律：</p>
<p>4的零次幂为<code>0001</code></p>
<p>4的一次幂为<code>0100</code></p>
<p>4的二次幂为<code>0001 0000</code></p>
<p>4的三次幂为<code>0100 0000</code></p>
<p>组合在一起就是<code>0101 0101</code>，十六进制表达即为<code>55</code></p>
<p>故而制作掩码<code>0x55555555</code>与原数做与运算，不为0即为4的幂次</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>461. 汉明距离</title>
    <url>/2023/07/04/461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>异或技巧</li>
<li><code>bitCount</code>的实现</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">bitCount</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">			n = (n &amp; <span class="number">0x55555555</span>) + ((n &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x33333333</span>) + ((n &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x0f0f0f0f</span>) + ((n &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x00ff00ff</span>) + ((n &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x0000ffff</span>) + ((n &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);</span><br><span class="line">			<span class="keyword">return</span> n;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">bitCount</span>(x ^ y);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( \log k
\right)\)</span>，其中<span
class="math inline">\(k\)</span>为<code>int</code>的位数，在这里是32位</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>两个数的不同位直接通过异或运算即可获得</p>
<p>计算整数<code>1个数</code>的<code>bitCount</code>实现请参见<code>191. 位1的个数</code>，这里使用耗时最短的分治法计算</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>476. 数字的补数</title>
    <url>/2023/07/04/476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>异或技巧</li>
<li>掩码技巧</li>
<li>移位技巧</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">findComplement</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> mask = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = num; i; i = i &gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">				mask = (mask &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> num ^ mask;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( \log num
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>某一个比特位要反转，直接令其<strong>异或1</strong>即可</p>
<p>假设整数去掉前导零后的真实长度为<code>n</code>，我们做一个长度也为<code>n</code>的全1掩码，然后让掩码与整数异或运算即可</p>
<blockquote>
<p>0000 0101 ^ 0000 0111 = 0000 0010</p>
</blockquote>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>477. 汉明距离总和</title>
    <url>/2023/07/04/477-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>状态压缩</li>
<li>排列组合</li>
<li>异或技巧</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">totalHammingDistance</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> ans = <span class="number">0</span>, size = nums.<span class="built_in">size</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; i++) &#123;</span><br><span class="line">				<span class="type">int</span> oneCnt = <span class="number">0</span>, mask = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (nums[j] &amp; mask) oneCnt++;</span><br><span class="line">				&#125;</span><br><span class="line">				ans += oneCnt * (size - oneCnt);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( C\cdot n
\right)\)</span>，在这里<span
class="math inline">\(C\)</span>常数等于31</p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>本题是<code>461. 汉明距离</code>的升级版，如果按照普通思路，数组内的元素两两异或再计算<code>1个数</code>，时间复杂度高达<span
class="math inline">\(O\left( n^2 \right)\)</span></p>
<p>题目规定所有整数都是<code>int</code>类型的32位正数；若能求出所有元素对应的<strong>每一比特位集合的汉明距离</strong>，<strong>将它们累加求和</strong>即可得到答案</p>
<p>如下图所示，我们分别求出</p>
<ul>
<li>nums[0]、nums[1]、nums[2]三个元素的第一比特位集合，即{0,0,0}的汉明距离，在这里是0</li>
<li>nums[0]、nums[1]、nums[2]三个元素的第二比特位集合，即{0,1,1}的汉明距离，在这里是2</li>
<li>nums[0]、nums[1]、nums[2]三个元素的第三比特位集合，即{1,1,0}的汉明距离，在这里是2</li>
<li>nums[0]、nums[1]、nums[2]三个元素的第四比特位集合，即{0,1,0}的汉明距离，在这里是2</li>
<li>最后将它们累加求和，0 + 2 + 2 + 2 = 6，得到最终答案</li>
</ul>
<img src="/2023/07/04/477-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/1.png" class="" title="image-20230620125833189">
<p>如何求某一比特位集合的汉明距离呢？这里需要用到<strong>状态压缩</strong>这一思想</p>
<p>假设有比特位集合{0,1,1,1,0,0}</p>
<p>将其分成{0,0,0}和{1,1,1}两个子集合，对应元素命名为<span
class="math inline">\(\left\{ a_0,a_1,a_2 \right\}\)</span>、<span
class="math inline">\(\left\{ b_0,b_1,b_2
\right\}\)</span>，有如下算式：</p>
<img src="/2023/07/04/477-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/2.png" class="" title="image-20230620135842555">
<p>因为同一子集合内的值都相同，相互异或值恒为0，算式简化为：</p>
<img src="/2023/07/04/477-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/3.png" class="" title="image-20230620135946679">
<p>故而只需求出比特位集合中1与0的个数，并令其相乘，即可得到比特位集合的汉明距离</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>状态压缩</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>61. 旋转链表</title>
    <url>/2023/07/02/61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的裁剪</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head), *slow = dummyHead, *fast = dummyHead, *tmp = head;</span><br><span class="line">			<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (tmp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				tmp = tmp-&gt;next;</span><br><span class="line">				len++;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//链表不为空且k求余后不为空，再做操作</span></span><br><span class="line">			<span class="keyword">if</span> (len &amp;&amp; (k %= len)) &#123;</span><br><span class="line">				<span class="keyword">while</span> (k--)	fast = fast-&gt;next;</span><br><span class="line">				<span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">					slow = slow-&gt;next;</span><br><span class="line">					fast = fast-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">				ListNode *subHead = slow-&gt;next;</span><br><span class="line">				slow-&gt;next = fast-&gt;next;</span><br><span class="line">				fast-&gt;next = dummyHead-&gt;next;</span><br><span class="line">				dummyHead-&gt;next = subHead;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题意，假设链表{1, 2, 3, 4, 5}右移3个单位，很容易想到</p>
<img src="/2023/07/02/61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/1.png" class="" title="image-20230529132817573">
<p>故而先求整个链表的长度，然后让K对它取余，就能得到需要移动的子链表长度</p>
<blockquote>
<p>假设整个链表长度为5，子链表长度也为5，那么子链表就是整体链表，就不需要移动</p>
</blockquote>
<p>然后使用快慢指针找到子链表的dummyHead、头节点和尾节点后，更改位置即可</p>
<img src="/2023/07/02/61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/2.png" class="" title="image-20230529135248910">
<p>当然，你也可以把链表连接成环，同样使用快慢指针找到子链表的dummyHead与头节点并断开形成新链表，时间复杂度是一样的，你可以尝试一下~</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>693. 交替位二进制数</title>
    <url>/2023/07/04/693-%E4%BA%A4%E6%9B%BF%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>移位技巧</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>同下</p>
<h1 id="思路">思路</h1>
<h2 id="循环判断">循环判断</h2>
<p>传统办法，依次判断当前位是否与上一位相同即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">hasAlternatingBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> prev = <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">while</span> (n) &#123;</span><br><span class="line">				<span class="type">int</span> tmp = n &amp; <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (tmp == prev) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				prev = tmp;</span><br><span class="line">				n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( \log n
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<h2 id="找规律">找规律</h2>
<p>若整数是交替位二进制类型，去掉多余的前导零后，实际组成类似<code>0101</code>或者<code>1010</code></p>
<p>它们向右移一位后与原数异或，可以得到<strong>全1的数</strong>；比如<code>0101 &gt;&gt; 1 = 0010，0010 ^ 0101 = 0111</code></p>
<p>全1的数再加1则会进位，故而作为判断依据</p>
<p>这里的<code>tmp</code>最大值可达<code>0x7fffffff</code>，为避免再加1后导致溢出，需要将<code>tmp</code>设置为无符号数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">hasAlternatingBits</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> tmp = n ^ (n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span> (tmp &amp; (tmp + <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( 1
\right)\)</span></p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>705. 设计哈希集合</title>
    <url>/2023/07/03/705-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>哈希表与链表的综合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashSet</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		vector&lt;list&lt;<span class="type">int</span>&gt;&gt; hashSet;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">getHash</span><span class="params">(<span class="type">int</span> &amp;key)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> (key ^ (key &gt;&gt; <span class="number">16</span>)) % <span class="number">13331</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">//这里必须初始化vector，否则会导致空指针错误</span></span><br><span class="line">		<span class="built_in">MyHashSet</span>(): <span class="built_in">hashSet</span>(<span class="number">13331</span>) &#123;&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> h = <span class="built_in">getHash</span>(key);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> it = hashSet[h].<span class="built_in">begin</span>(); it != hashSet[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (*it == key) <span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			hashSet[h].<span class="built_in">emplace_front</span>(key);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> h = <span class="built_in">getHash</span>(key);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> it = hashSet[h].<span class="built_in">begin</span>(); it != hashSet[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (*it == key) &#123;</span><br><span class="line">					hashSet[h].<span class="built_in">erase</span>(it);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> h = <span class="built_in">getHash</span>(key);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> it = hashSet[h].<span class="built_in">begin</span>(); it != hashSet[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (*it == key) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>C++最原生的哈希表，就是数组，下标即为键</p>
<p>参考<a
href="https://segmentfault.com/a/1190000012926722">Java的HashMap源码</a>，设置一个桶数组，每个下标即为数据的哈希值；下标对应的值为双向链表，用以存储哈希值一样的数据</p>
<img src="/2023/07/03/705-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/1.png" class="" title="image-20230609181619597">
<p>使用一个非常简陋的办法计算数据的哈希值。在学习字符串哈希的时候提到过，数据求余大质数有利于减少哈希碰撞</p>
<p>最简单的办法就是</p>
<blockquote>
<p>数据 % 大质数</p>
</blockquote>
<p>考虑到这里的数据是<code>int</code>类型，共32位；可以令高16位与低16位异或，增加混淆度。得到最终的样子</p>
<blockquote>
<p>(数据 ^ (数据 &gt;&gt; 16)) % 大质数</p>
</blockquote>
<hr />
<p>如果有位运算的基础，这道题也能使用<strong>BitMap位图</strong>来处理</p>
<p>题目的需求就是判断元素是否存在，而每种元素只有存在或不存在两种情况</p>
<p>一个<code>int</code>类型是32位，10<sup>6</sup>+1个元素只需要(10<sup>6</sup>+1)/32≈31251长度空间的<code>int</code>数组即可存储所有元素的存在状态</p>
<p>每次元素/32就是数组下标，元素%32即元素对应在该32位中的状态</p>
<blockquote>
<p>取余有小技巧，a%2<sup>n</sup> = a &amp;
(2<sup>n</sup>-1)，只有求余2的幂次才有用哟！</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashSet</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">const</span> <span class="type">static</span> <span class="type">int</span> len = <span class="number">32</span>;</span><br><span class="line">		<span class="type">int</span> bitMap[<span class="number">31251</span>];</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">MyHashSet</span>(): bitMap&#123;<span class="number">0</span>&#125; &#123;&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">			bitMap[key / len] |= <span class="number">1</span> &lt;&lt; (key &amp; (len - <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">			bitMap[key / len] &amp;= ~(<span class="number">1</span> &lt;&lt; (key &amp; (len - <span class="number">1</span>)));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> (bitMap[key / len] &amp; (<span class="number">1</span> &lt;&lt; (key &amp; (len - <span class="number">1</span>)))) != <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>哈希函数</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>706. 设计哈希映射</title>
    <url>/2023/07/03/706-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>哈希表与链表的综合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashMap</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">const</span> <span class="type">static</span> <span class="type">int</span> len = <span class="number">32768</span>;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">			<span class="type">int</span> key;</span><br><span class="line">			<span class="type">int</span> value;</span><br><span class="line">			<span class="built_in">Node</span>(<span class="type">int</span> _key, <span class="type">int</span> _value): <span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value) &#123;&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		vector&lt;list&lt;Node&gt; &gt; hashMap;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">getHash</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> (key ^ (key &gt;&gt; <span class="number">16</span>)) &amp; (len - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">MyHashMap</span>() : <span class="built_in">hashMap</span>(len) &#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> h = <span class="built_in">getHash</span>(key);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> it = hashMap[h].<span class="built_in">begin</span>(); it != hashMap[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (it-&gt;key == key) &#123;</span><br><span class="line">					it-&gt;value = value;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			hashMap[h].<span class="built_in">emplace_front</span>(key, value);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> h = <span class="built_in">getHash</span>(key);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> it = hashMap[h].<span class="built_in">begin</span>(); it != hashMap[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (it-&gt;key == key) &#123;</span><br><span class="line">					<span class="keyword">return</span> it-&gt;value;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> h = <span class="built_in">getHash</span>(key);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> it = hashMap[h].<span class="built_in">begin</span>(); it != hashMap[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (it-&gt;key == key) &#123;</span><br><span class="line">					hashMap[h].<span class="built_in">erase</span>(it);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>和<code>705. 设计哈希集合</code>类似，修改一下双向链表的节点结构即可</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>哈希函数</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>707. 设计链表</title>
    <url>/2023/07/02/707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的常用操作设计</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> size;</span><br><span class="line">		ListNode *dummyHead;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">MyLinkedList</span>() : <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">dummyHead</span>(<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			ListNode *cur = dummyHead-&gt;next;</span><br><span class="line">			<span class="keyword">while</span> (index--)	cur = cur-&gt;next;</span><br><span class="line">			<span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">			dummyHead-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val, dummyHead-&gt;next);</span><br><span class="line">			size++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">			ListNode *cur = dummyHead;</span><br><span class="line">			<span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) cur = cur-&gt;next;</span><br><span class="line">			cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val, <span class="literal">nullptr</span>);</span><br><span class="line">			size++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (index &gt; size) <span class="keyword">return</span>;</span><br><span class="line">			ListNode *cur = dummyHead;</span><br><span class="line">			<span class="keyword">while</span> (index--) cur = cur-&gt;next;</span><br><span class="line">			cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val, cur-&gt;next);</span><br><span class="line">			size++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">			ListNode *cur = dummyHead;</span><br><span class="line">			<span class="keyword">while</span> (index--) cur = cur-&gt;next;</span><br><span class="line">			ListNode *tmp = cur-&gt;next;</span><br><span class="line">			cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> tmp;</span><br><span class="line">			size--;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题目较为简单，具体实现见代码即可；主要讲几个细节：</p>
<ol type="1">
<li><p>链表类的题基本都需要新增一个<code>dummyHead</code>伪节点，指向真正的头节点；以避免考虑操作头节点时的特殊情况</p></li>
<li><p>单链表类的题涉及迭代操作某一节点时，都应定位到该节点的前一节点；因为若不修改前一节点的<code>next</code>信息，新链表串不起来</p>
<p>（使用递归或双向链表就可以自由发挥了）</p>
<p>比如需要删除节点3，我们需要定位到节点2</p>
<img src="/2023/07/02/707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/1.png" class="" title="image-20230517174741286">
<p>待处理完节点3后，需要将节点2与节点4连接起来，链表才是完整的</p></li>
</ol>
<img src="/2023/07/02/707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/2.png" class="" title="image-20230517174545353">
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>762. 二进制表示中质数个计算置位</title>
    <url>/2023/07/04/762-%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD%E8%B4%A8%E6%95%B0%E4%B8%AA%E8%AE%A1%E7%AE%97%E7%BD%AE%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li><code>bitCount</code>的实现</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		unordered_set&lt;<span class="type">int</span>&gt; primeArr = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>&#125;;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">bitCount</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">			n = (n &amp; <span class="number">0x55555555</span>) + ((n &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x33333333</span>) + ((n &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x0f0f0f0f</span>) + ((n &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x00ff00ff</span>) + ((n &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>);</span><br><span class="line">			n = (n &amp; <span class="number">0x0000ffff</span>) + ((n &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);</span><br><span class="line">			<span class="keyword">return</span> n;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">countPrimeSetBits</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (primeArr.<span class="built_in">count</span>(<span class="built_in">bitCount</span>(i))) ans++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( \left( right-left
\right) \cdot \log right \right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( C
\right)\)</span>，<span
class="math inline">\(C\)</span>等于质数打表数组的长度</p>
<h1 id="思路">思路</h1>
<p>若使用常规判断质数代码，时间复杂度就高达<span
class="math inline">\(O\left( \sqrt{right} \right)\)</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">primeJudge</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (num &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= num; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个<code>int</code>类型的整数，其比特位数肯定不超过32；所以直接用哈希表，将32以内的质数打表保存即可，这样时间复杂度可降为常数</p>
<p>这里判断整数的<code>1个数</code>使用的是<code>191. 位1的个数</code>提到的分治法，不再赘述</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>78. 子集</title>
    <url>/2023/07/04/78-%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>状态压缩</li>
<li>排列组合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">			vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">			<span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; size); i++) &#123;</span><br><span class="line">				vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                    <span class="comment">//可以发现，二进制比特位的分布规律都是对称的</span></span><br><span class="line">                    <span class="comment">//假设有数组&#123;1,2,3&#125;，此时i = 1, j = 0</span></span><br><span class="line">                    <span class="comment">//理应代表子集&#123;3&#125;，但也可以用子集&#123;1&#125;替换</span></span><br><span class="line">					<span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) tmp.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">				&#125;</span><br><span class="line">				ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left( 2^n\cdot n
\right)\)</span></p>
<p>空间复杂度：<span class="math inline">\(O\left( n
\right)\)</span></p>
<h1 id="思路">思路</h1>
<p>题目已经表明，数组中的元素<strong>互不相同</strong>，故而不会产生重复的子集</p>
<p>数组中的每个元素都有取与不取两种状态，使用比特位1代表取状态、比特位0代表不取状态</p>
<p>若<code>nums</code>数组长度为<code>n</code>，按照数学的组合规律则共有2<sup>n</sup>个子集，可以用<span
class="math inline">\(\left[ 0,2^n-1
\right]\)</span>范围内的十进制整数来表达</p>
<p>假设有数组<code>&#123;1,2,3&#125;</code>，子集表达如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">十进制表达</th>
<th style="text-align: center;">二进制表达</th>
<th style="text-align: center;">子集</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">000</td>
<td style="text-align: center;">{}</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">001</td>
<td style="text-align: center;">{3}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">2</td>
<td style="text-align: center;">010</td>
<td style="text-align: center;">{2}</td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: center;">011</td>
<td style="text-align: center;">{2,3}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">4</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">{1}</td>
</tr>
<tr class="even">
<td style="text-align: center;">5</td>
<td style="text-align: center;">101</td>
<td style="text-align: center;">{1,3}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">6</td>
<td style="text-align: center;">110</td>
<td style="text-align: center;">{1,2}</td>
</tr>
<tr class="even">
<td style="text-align: center;">7</td>
<td style="text-align: center;">111</td>
<td style="text-align: center;">{1,2,3}</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>状态压缩</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>82. 删除排序链表中的重复元素 II</title>
    <url>/2023/07/02/82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>双指针</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">			ListNode *dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *curNew = dummyNode;</span><br><span class="line">			ListNode *left = head, *right = head-&gt;next;</span><br><span class="line">			<span class="keyword">while</span> (left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				right = left-&gt;next;</span><br><span class="line">				<span class="keyword">while</span> (right != <span class="literal">nullptr</span> &amp;&amp; left-&gt;val == right-&gt;val)	right = right-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (left-&gt;next == right) &#123;</span><br><span class="line">					curNew-&gt;next = left;</span><br><span class="line">					left = left-&gt;next;</span><br><span class="line">					curNew = curNew-&gt;next;</span><br><span class="line">				&#125; <span class="keyword">else</span> left = right;</span><br><span class="line">			&#125;</span><br><span class="line">			curNew-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本题是<code>83. 删除排序链表中的重复元素</code>的升级版，思路一样，也是使用双指针；左指针指向需要留下的元素，右指针作为游标指针</p>
<p>分为两种情况</p>
<ol type="1">
<li>左指针指向的值和右指针指向的值不同，说明左指针需要被留下，插入新链表</li>
<li>左指针指向的值和右指针指向的值相同，说明左右指针指向的值都需要被删除；待右指针指向第一个不同值的节点时，将左指针更新为该节点，开启新一轮判定</li>
</ol>
<p>本题实际上每次比较的是两个相邻节点，所以左右指针其实可以用一个游标指针来代替，即<code>head</code>和<code>head-&gt;next</code></p>
<p>改写后代码如下，逻辑与效果是一样的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head), *curNew = dummyHead;</span><br><span class="line">			<span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span> || head-&gt;val != head-&gt;next-&gt;val) &#123;</span><br><span class="line">					curNew-&gt;next = head;</span><br><span class="line">					curNew = curNew-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">while</span> (head != <span class="literal">nullptr</span> &amp;&amp; head-&gt;next != <span class="literal">nullptr</span> &amp;&amp; head-&gt;val == head-&gt;next-&gt;val) &#123;</span><br><span class="line">					head = head-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">				head = head-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			curNew-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>83. 删除排序链表中的重复元素</title>
    <url>/2023/07/02/83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>双指针</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *left = head, *right = head;</span><br><span class="line">			<span class="keyword">while</span> (right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				<span class="keyword">while</span> (right != <span class="literal">nullptr</span> &amp;&amp; left-&gt;val == right-&gt;val)	right = right-&gt;next;</span><br><span class="line">				left-&gt;next = right;</span><br><span class="line">				left = left-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题意，链表已排序，那么重复的元素就一定是连续的；所以我们使用双指针来处理</p>
<p>左指针指向需要留下的元素，右指针作为游标指针</p>
<p>只要右指针的值等于左指针，就一直向右，遇到不同值停下，再将左右指针指向的节点连接起来即可</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>86. 分隔链表</title>
    <url>/2023/07/02/86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的裁剪</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">			ListNode *dummySmall = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *curSmall = dummySmall;</span><br><span class="line">			ListNode *dummyLarge = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *curLarge = dummyLarge;</span><br><span class="line">			<span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (head-&gt;val &lt; x) &#123;</span><br><span class="line">					curSmall-&gt;next = head;</span><br><span class="line">					curSmall = curSmall-&gt;next;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					curLarge-&gt;next = head;</span><br><span class="line">					curLarge = curLarge-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">				head = head-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			curSmall-&gt;next = dummyLarge-&gt;next;</span><br><span class="line">			curLarge-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">return</span> dummySmall-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>一个小链表按序存储值小于x的节点，一个大链表按序存储剩余节点，再将大链表接在小链表尾部即可</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>876. 链表的中间结点</title>
    <url>/2023/07/02/876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>快慢指针/双指针</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">			ListNode *slow = head, *fast = head;</span><br><span class="line">			<span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				slow = slow-&gt;next;</span><br><span class="line">				fast = fast-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (fast-&gt;next != <span class="literal">nullptr</span>) fast = fast-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> slow;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>同样使用快慢指针，但和以往不同，需要再往下走一格</p>
<p>可以和之前的代码作对比</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">findMid</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>92. 反转链表 II</title>
    <url>/2023/07/02/92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表的反转</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">			ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head), *subDummy = dummyHead;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) subDummy = subDummy-&gt;next;</span><br><span class="line">            <span class="comment">//使用改进版头插法进行子链表反转</span></span><br><span class="line">			ListNode *tail = subDummy-&gt;next;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">				ListNode *node = tail-&gt;next;</span><br><span class="line">				tail-&gt;next = node-&gt;next;</span><br><span class="line">				node-&gt;next = subDummy-&gt;next;</span><br><span class="line">				subDummy-&gt;next = node;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>找到子链表的头节点，并将其前一个节点作为伪节点，即<code>subDummy</code>；再使用<code>206. 反转链表</code>提到的<code>改进版头插法</code>即可</p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>P1042. 乒乓球</title>
    <url>/2023/09/27/P1042-%E4%B9%92%E4%B9%93%E7%90%83/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
<li>字符串</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ans</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> w_, l_;</span><br><span class="line">&#125; ans_11[LEN], ans_21[LEN];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> w_11 ans_11[idx_11].w_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l_11 ans_11[idx_11].l_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> w_21 ans_21[idx_21].w_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l_21 ans_21[idx_21].l_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> idx_11 = <span class="number">0</span>, idx_21 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; c &amp;&amp; c != <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;W&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++w_11, ++w_21;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++l_11, ++l_21;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里不能写等于11，因为分差至少为2</span></span><br><span class="line">        <span class="comment">// 比如11:11是不可以结束的，13:11才可以</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(w_11 - l_11) &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">max</span>(w_11, l_11) &gt;= <span class="number">11</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++idx_11;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(w_21 - l_21) &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">max</span>(w_21, l_21) &gt;= <span class="number">21</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++idx_21;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= idx_11; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ans_11[i].w_ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; ans_11[i].l_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= idx_21; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ans_21[i].w_ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; ans_21[i].l_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>字符串的题目，先判断处理方式：</p>
<ul>
<li>字符依次读入</li>
<li>整串读入</li>
</ul>
<p>显然这道题应该字符依次读入，因为有<code>E</code>这一个终止符号</p>
<p>每个对局都是一对数字，用结构体<code>Ans</code>进行保存</p>
<p>由于两种分制的结果需要分开输出，用两个结构体数组<code>ans_11</code>和<code>ans_21</code>各自保存11分制和21分制的情况</p>
<p><code>idx_11</code>和<code>idx_21</code>分别控制各自结构体数组的下标</p>
<p>处理对局情况时，有两点要注意：</p>
<ul>
<li>只有当对局中最大得分<code>&gt;=11</code>且双方得分的差值<code>&gt;=2</code>时才可进行下一局；比如<code>11:11</code>就不能下一局，<code>11:13</code>可以</li>
<li>哪怕当前对局的情况是<code>0:0</code>也要输出</li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>P1563. 玩具谜题</title>
    <url>/2023/09/27/P1563-%E7%8E%A9%E5%85%B7%E8%B0%9C%E9%A2%98/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    string name_;</span><br><span class="line">    <span class="type">int</span> forward_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i].forward_ &gt;&gt; arr[i].name_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>, f, len;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; f &gt;&gt; len;</span><br><span class="line">        <span class="keyword">if</span> (arr[idx].forward_ ^ f)</span><br><span class="line">        &#123;</span><br><span class="line">            idx = (idx + len) % n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            idx = (idx - len + n) % n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; arr[idx].name_;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>每个人都有朝向和名字，自然用结构体<code>Node</code>来保存</p>
<p>根据题意得知，结构体数组的下标从小到大遍历是为逆时针序，从大到小遍历是为顺时针序</p>
<p>朝内圈记为0，朝外圈记为1；向左走记为0，向右走记为1</p>
<p>接下来分析遍历走向：</p>
<ul>
<li>朝内圈的小人向左走，是为顺时针，有<code>0 ^ 0 = 0</code></li>
<li>朝内圈的小人向右走，是为逆时针，有<code>0 ^ 1 = 1</code></li>
<li>朝外圈的小人向左走，是为逆时针，有<code>1 ^ 0 = 1</code></li>
<li>朝外圈的小人向右走，是为顺时针，有<code>1 ^ 1 = 0</code></li>
</ul>
<p>所以每次判断遍历走向时，将当前所处的小人内外圈方向与左右方向异或即可；为0则从大到小遍历，为1则从小到大遍历</p>
<p>假设当前共<code>n=6</code>个数，下标<code>idx</code>范围为<code>0~5</code>，每次需要走<code>len</code>步；且题目规定<code>len</code>小于<code>n</code></p>
<p>从小到大遍历可以得到公式：<span class="math inline">\(idx=\left(
idx+len \right) \%n\)</span></p>
<p>从大到小遍历可以得到公式：<span class="math inline">\(idx=\left(
idx-len+n \right)
\%n\)</span>，之所以加上<code>n</code>是处理负数时的情况</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P2670. 扫雷游戏</title>
    <url>/2023/09/27/P2670-%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">301</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> table[LEN][LEN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> walk[<span class="number">8</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; table[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i, cout &lt;&lt; endl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (table[i][j] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x = i + walk[k][<span class="number">0</span>], y = j + walk[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; <span class="number">300</span> || y &lt; <span class="number">1</span> || y &gt; <span class="number">300</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (table[x][y] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>逐个点进行八向搜索即可，搜索前注意判断是否越界</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P1303. A*B Problem</title>
    <url>/2023/09/30/P1303-%E6%A8%A1%E6%9D%BF%E9%A2%98-AB-Problem/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>高精度</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">5050</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len_;</span><br><span class="line">    <span class="type">int</span> arr_[LEN];</span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr_[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(string s = <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr_, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr_));</span><br><span class="line">        len_ = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr_[i] = s[len_ - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len_ = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr_[i + <span class="number">1</span>] += arr_[i] / <span class="number">10</span>;</span><br><span class="line">                arr_[i] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!arr_[len_])</span><br><span class="line">            --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, len_); i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; arr_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>*(BigInt a, BigInt b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.len_; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b.len_; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            c[i + j - <span class="number">1</span>] += a[i] * b[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//乘法的结果位数</span></span><br><span class="line">    c.<span class="built_in">flatten</span>(a.len_ + b.len_);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    (<span class="built_in">BigInt</span>(a) * <span class="built_in">BigInt</span>(b)).<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>与高精度加法唯一的不同点，就在于按位处理上</p>
<p>可以发现，<code>操作数a的处理位下标 + 操作数b的处理位下标 - 1 = 结果位下标</code></p>
<p>还需要牢记，乘法的结果位数不会超过两个操作数的位数之和</p>
<img src="/2023/09/30/P1303-%E6%A8%A1%E6%9D%BF%E9%A2%98-AB-Problem/1.png" class="" title="image-20230930182427581">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>P1601. A+B Problem</title>
    <url>/2023/09/30/P1601-%E6%A8%A1%E6%9D%BF%E9%A2%98-A-B-Problem/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>高精度</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">5050</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len_;</span><br><span class="line">    <span class="type">int</span> arr_[LEN];</span><br><span class="line">    <span class="comment">//以数组的形式访问对象</span></span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr_[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(string s = <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr_, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr_));</span><br><span class="line">        len_ = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr_[i] = s[len_ - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len_ = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr_[i + <span class="number">1</span>] += arr_[i] / <span class="number">10</span>;</span><br><span class="line">                arr_[i] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!arr_[len_])</span><br><span class="line">            --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//处理结果为0的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, len_); i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; arr_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>+(BigInt a, BigInt b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">max</span>(a.len_, b.len_);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加法结果的位数</span></span><br><span class="line">    c.<span class="built_in">flatten</span>(len + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    (<span class="built_in">BigInt</span>(a) + <span class="built_in">BigInt</span>(b)).<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>为了方便处理，先将两个操作数反转，然后再按位进行运算</p>
<p><code>BigInt</code>的构造函数就是将字符串逆序保存至数组</p>
<p><code>print</code>函数则是从尾到头输出数组，这样结果就是正序的；当然，<code>print</code>函数要处理一下数组只有0的情况</p>
<img src="/2023/09/30/P1601-%E6%A8%A1%E6%9D%BF%E9%A2%98-A-B-Problem/1.png" class="">
<p>由于存在进位，所以需要<code>flatten</code>函数处理每一位</p>
<img src="/2023/09/30/P1601-%E6%A8%A1%E6%9D%BF%E9%A2%98-A-B-Problem/2.png" class="">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>P1480. A/B Problem</title>
    <url>/2023/10/01/P1480-%E6%A8%A1%E6%9D%BF%E9%A2%98-A%E9%99%A4B-Problem/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>高精度</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">25000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len_;</span><br><span class="line">    <span class="type">int</span> arr_[LEN];</span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr_[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(string s = <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr_, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr_));</span><br><span class="line">        len_ = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr_[i] = s[len_ - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len_ = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_[i] &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr_[i + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">                arr_[i] += <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!arr_[len_])</span><br><span class="line">            --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, len_); i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; arr_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以lst_dg为最低有效位的a</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">greater_eq</span><span class="params">(BigInt a, <span class="type">int</span> lst_dg, BigInt b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a的位数比b的位数多</span></span><br><span class="line">    <span class="keyword">if</span> (a[lst_dg + b.len_] != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.len_ - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[lst_dg + i] &gt; b[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[lst_dg + i] &lt; b[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//a和b的值相等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>/(BigInt a, BigInt b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> lst_dg = a.len_ - b.len_ + <span class="number">1</span>; lst_dg &gt;= <span class="number">1</span>; --lst_dg)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">greater_eq</span>(a, lst_dg, b))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= b.len_ - <span class="number">1</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                a[lst_dg + i] -= b[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (a[lst_dg + i] &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[lst_dg + i + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">                    a[lst_dg + i] += <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++c[lst_dg];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.len_ = a.len_;</span><br><span class="line">    <span class="keyword">while</span>(c[c.len_] == <span class="number">0</span>)</span><br><span class="line">        --c.len_;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="function">BigInt <span class="title">a</span><span class="params">(s1)</span>, <span class="title">b</span><span class="params">(s2)</span></span>;</span><br><span class="line">    (a / b).<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>与之前的高精度加减乘法由低位到高位的运算方向不同，高精度除法是从高位到低位运算</p>
<p>以175除以5为例子：</p>
<ul>
<li>lst_dg初始位置为<code>a.len_ - b.len_ + 1</code>，确保<strong>以lst_dg为最低有效位的a</strong>长度等于b长度；随后从高位向低位遍历</li>
<li>在lst_dg的遍历过程中，结合<code>greater_eq</code>函数判断当前<strong>以lst_dg为最低有效位的a</strong>是否大于除数b</li>
<li>若大于，则执行高精减法，并更新商数组；循环这一操作，直到当前<strong>以lst_dg为最低有效位的a</strong>小于b</li>
</ul>
<img src="/2023/10/01/P1480-%E6%A8%A1%E6%9D%BF%E9%A2%98-A%E9%99%A4B-Problem/1.png" class="" title="image-20231001004045770">
<hr />
<p>这里提一嘴高精度除低精度，非常简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BigInt <span class="keyword">operator</span>/(BigInt a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.len_; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += (r * <span class="number">10</span> + a[i]) / b;</span><br><span class="line">        r = (r * <span class="number">10</span> + a[i]) % b;</span><br><span class="line">    &#125;</span><br><span class="line">    c.<span class="built_in">flatten</span>(a.len_);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次将上一次的余数乘10后加上当前的低位，再做除法即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>P2142. 高精度减法</title>
    <url>/2023/09/30/P2142-%E6%A8%A1%E6%9D%BF%E9%A2%98-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>高精度</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">25000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len_;</span><br><span class="line">    <span class="type">int</span> arr_[LEN];</span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr_[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(string s = <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr_, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr_));</span><br><span class="line">        len_ = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr_[i] = s[len_ - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len_ = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_[i] &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr_[i + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">                arr_[i] += <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!arr_[len_])</span><br><span class="line">            --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, len_); i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; arr_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lst_dg代表当前a的最低有效位</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">greater_eq</span><span class="params">(BigInt a, <span class="type">int</span> lst_dg, BigInt b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a的位数比b的位数少</span></span><br><span class="line">    <span class="keyword">if</span> (a.len_ &lt; b.len_)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.len_ &gt; b.len_)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.len_ - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[lst_dg + i] &gt; b[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[lst_dg + i] &lt; b[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//a和b的值相等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>-(BigInt a, BigInt b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">int</span> len = a.len_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += a[i] - b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    c.<span class="built_in">flatten</span>(len);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="function">BigInt <span class="title">a</span><span class="params">(s1)</span>, <span class="title">b</span><span class="params">(s2)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">greater_eq</span>(a, <span class="number">1</span>, b))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        (b - a).<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        (a - b).<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>与高精度加法、乘法唯一不同的是，需要新增一个<code>greater_eq</code>函数来确保参数<code>a</code>是大于等于参数<code>b</code>的</p>
<p><code>greater_eq</code>函数的功能较简单，执行流程如下：</p>
<ul>
<li>比较<code>a</code>和<code>b</code>的长度大小</li>
<li>若<code>a</code>和<code>b</code>的长度相等，则从高位向低位逐个比较</li>
</ul>
<p>该函数的参数<code>lst_dg</code>在高精度减法中暂无作用，但在高精度除法中是关键；下述函数内的代码块</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a.len_ &gt; b.len_)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>在高精度除法中将会被替换成这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a[lst_dg + b.len_] != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>看似效果一样，但两者不可混用！！！！！</p>
<p>在高精度减法中，用<code>a[lst_dg + b.len_]</code>来判断<code>a</code>大于<code>b</code>是绝对错误的！</p>
<blockquote>
<p>比如a的值为1001，与b的值为1进行比较，上述代码块就不会返回true</p>
</blockquote>
<p>而在高精度除法中，该代码段判断以<code>lst_dg</code>为最低有效位的<code>a</code>是否大于等于<code>b</code>是可以的</p>
<blockquote>
<p><strong>高精度运算的数组都是倒序放置，且高精度除法是从高位开始运算，而加减乘法是从低位开始运算</strong></p>
<p><strong>所以被除数的某位为0，那么比它更高的位次也一定为0</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>P1009. 模板题_阶乘之和</title>
    <url>/2023/10/01/P1009-%E9%98%B6%E4%B9%98%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>高精度</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">25050</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len_;</span><br><span class="line">    <span class="type">int</span> arr_[LEN];</span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr_[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(<span class="type">int</span> x = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr_, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr_));</span><br><span class="line">        <span class="keyword">for</span> (len_ = <span class="number">1</span>; x; ++len_)</span><br><span class="line">        &#123;</span><br><span class="line">            arr_[len_] = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len_ = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr_[i + <span class="number">1</span>] += arr_[i] / <span class="number">10</span>;</span><br><span class="line">                arr_[i] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!arr_[len_])</span><br><span class="line">            --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, len_); i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; arr_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>+(BigInt a, BigInt b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">max</span>(a.len_, b.len_);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    c.<span class="built_in">flatten</span>(len + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>*(BigInt a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">int</span> len = a.len_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += a[i] * b;</span><br><span class="line">    &#125;</span><br><span class="line">    c.<span class="built_in">flatten</span>(len + <span class="number">11</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    BigInt a, <span class="built_in">b</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        b = b * i;</span><br><span class="line">        a = a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>标准的模板题，没有坑点；只不过高精度乘高精度可以简化成下面的高精度乘低精度，一次循环即可</p>
<p>因为int类型最大也就是10位，在这里<code>len + 11</code>可以满足两数相乘的结果位数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BigInt <span class="keyword">operator</span>*(BigInt a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">int</span> len = a.len_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += a[i] * b;</span><br><span class="line">    &#125;</span><br><span class="line">    c.<span class="built_in">flatten</span>(len + <span class="number">11</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>P1045. 麦森数</title>
    <url>/2023/10/02/P1045-%E9%BA%A6%E6%A3%AE%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>快速幂</li>
<li>高精度</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">505</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len_;</span><br><span class="line">    <span class="type">int</span> arr_[LEN];</span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr_[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(<span class="type">int</span> x = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr_, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr_));</span><br><span class="line">        <span class="keyword">for</span> (len_ = <span class="number">1</span>; x; ++len_)</span><br><span class="line">        &#123;</span><br><span class="line">            arr_[len_] = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len_ = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr_[i + <span class="number">1</span>] += arr_[i] / <span class="number">10</span>;</span><br><span class="line">                arr_[i] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!arr_[len_])</span><br><span class="line">            --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">500</span>, cnt = <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i, ++cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; arr_[i];</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">50</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>*(BigInt a, BigInt b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.len_; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b.len_; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + j - <span class="number">1</span> &gt; <span class="number">500</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            c[i + j - <span class="number">1</span>] += a[i] * b[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.<span class="built_in">flatten</span>(<span class="built_in">min</span>(<span class="number">500</span>, a.len_ + b.len_));</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>*(BigInt a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">int</span> len = a.len_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += a[i] * b;</span><br><span class="line">    &#125;</span><br><span class="line">    c.<span class="built_in">flatten</span>(<span class="built_in">min</span>(<span class="number">500</span>, len + <span class="number">11</span>));</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, p;</span><br><span class="line">    cin &gt;&gt; p;</span><br><span class="line">    n = p;</span><br><span class="line">    <span class="function">BigInt <span class="title">a</span><span class="params">(<span class="number">2</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">            b = b * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (<span class="type">int</span>)(n * <span class="built_in">log10</span>(<span class="number">2</span>)) + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    --b[<span class="number">1</span>];</span><br><span class="line">    b.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>使用快速幂的模板套高精乘低精、高精乘高精的模板即可</p>
<p>但是有如下坑点需要注意：</p>
<ul>
<li><p>因为是2的幂次，最后一位肯定不会小于1；所以减1直接操作最低位自减就行</p></li>
<li><p>10的幂次可以决定一个数的位数，比如10的2次幂有2 + 1 = 3 位</p>
<p>且2<sup>P</sup>-1的位数与2<sup>p</sup>是一样的，实际上是求2<sup>p</sup>的位数；那么可以直接通过下列等式得到
<span class="math display">\[
\log _{10}2^p+1=P\cdot \log _{10}2+1
\]</span></p></li>
<li><p>由于题目说最多只要500位，所以高精度乘法与flatten函数千万不能超过500位导致越界！</p></li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>高精度</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>P1249. 最大乘积</title>
    <url>/2023/10/01/P1249-%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>高精度</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">25050</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len_;</span><br><span class="line">    <span class="type">int</span> arr_[LEN];</span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr_[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(<span class="type">int</span> x = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr_, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr_));</span><br><span class="line">        <span class="keyword">for</span> (len_ = <span class="number">1</span>; x; ++len_)</span><br><span class="line">        &#123;</span><br><span class="line">            arr_[len_] = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len_ = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr_[i + <span class="number">1</span>] += arr_[i] / <span class="number">10</span>;</span><br><span class="line">                arr_[i] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!arr_[len_])</span><br><span class="line">            --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, len_); i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; arr_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>*(BigInt a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">int</span> len = a.len_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += a[i] * b;</span><br><span class="line">    &#125;</span><br><span class="line">    c.<span class="built_in">flatten</span>(len + <span class="number">11</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10001</span>], n, idx = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr));</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; sum &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        arr[idx++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> diff = sum - n;</span><br><span class="line">    <span class="keyword">if</span> ((diff == <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//相差1，去掉2然后最高的数字+1</span></span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        ++arr[idx - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 其他情况直接删除和差值一样的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == diff)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">BigInt <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a = a * arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题目要求将整数n分解成若干个<strong>互不相同</strong>的自然数的和，且使这些自然数的<strong>乘积最大</strong></p>
<p>若单单是乘积最大，很容易想到贪心策略——把n尽可能地拆散均匀即可；但题目要求<strong>互不相同</strong></p>
<p>以n=11为例</p>
<p>尝试从2开始枚举自然数，一直到这些自然数的和大于等于n；枚举结束时，集合应该是{2,
3, 4, 5}，集合的和为14</p>
<p>此刻，集合的和相较于n多了3；那么问题就转换为<strong>怎么让集合内的数减3，使它们的乘积最大</strong></p>
<p>显然唯一的办法就是直接从集合中移除数字3，因为要求<strong>互不相同</strong>；倘若集合内的任何一个数减1，都会有碰撞</p>
<p>再以n=13为例</p>
<p>集合的和相较于n多了1，但集合内并没有数字1；将数字2移除（必定存在），相当于减2，再将最大的数字加1即可保持平衡</p>
<p>故而总体步骤如下：</p>
<ul>
<li>从数字2开始枚举自然数集合，直到集合的和大于等于n</li>
<li>和与n的差值等于1，删除数字2（这里把数字2设置为数字1即可，因为目标只是算乘积）并将最大的数字加1</li>
<li>和与n的差值大于1，删除差值相同的数字即可</li>
<li>遍历集合，用高精乘低精的模板计算乘法结果</li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>P1591. 阶乘数码</title>
    <url>/2023/10/01/P1591-%E9%98%B6%E4%B9%98%E6%95%B0%E7%A0%81/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>高精度</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">25050</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len_;</span><br><span class="line">    <span class="type">int</span> arr_[LEN];</span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr_[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(<span class="type">int</span> x = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr_, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr_));</span><br><span class="line">        <span class="keyword">for</span> (len_ = <span class="number">1</span>; x; ++len_)</span><br><span class="line">        &#123;</span><br><span class="line">            arr_[len_] = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len_ = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr_[i + <span class="number">1</span>] += arr_[i] / <span class="number">10</span>;</span><br><span class="line">                arr_[i] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!arr_[len_])</span><br><span class="line">            --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, len_); i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; arr_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>*(BigInt a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">int</span> len = a.len_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += a[i] * b;</span><br><span class="line">    &#125;</span><br><span class="line">    c.<span class="built_in">flatten</span>(len + <span class="number">11</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cnt</span><span class="params">(BigInt a, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.len_; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == x)</span><br><span class="line">            ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t, n, x;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">        <span class="function">BigInt <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            a = a * i;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">cnt</span>(a, x) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>高精乘低精的模板题，没有坑点</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>P1226. 模板题_快速幂</title>
    <url>/2023/10/02/P1226-%E6%A8%A1%E6%9D%BF%E9%A2%98-%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>快速幂</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">binpow</span><span class="params">(ll a, ll b, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a %= p;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * a % p;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a, b, p;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld^%lld mod %lld=%lld&quot;</span>, a, b, p, <span class="built_in">binpow</span>(a, b, p));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>标准的快速幂模板题，快速幂的具体原理可以参照<a
href="https://oi-wiki.org/math/binary-exponentiation/">Wiki</a></p>
<p>答案要求我们对结果取模；由于取模操作不会对乘法运算造成影响，所以在求幂次的过程中取模操作可以并行</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度_解题技巧</title>
    <url>/2023/10/02/%E9%AB%98%E7%B2%BE%E5%BA%A6-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>高精度的题目，一般都会涉及到多种高精度计算：高精乘高精，高精乘低精，高精除高精，高精除低精等等复杂运算</p>
<p>所以一般先按照高精度的模板，把<code>BigInt</code>类写好；然后根据不同需求重载运算符，这样才不易出错</p>
<p>高精加模板题：<a
href="https://www.luogu.com.cn/problem/P1601">P1601</a></p>
<p>高精减模板题：<a
href="https://www.luogu.com.cn/problem/P2142">P2142</a></p>
<p>高精乘模板题：<a
href="https://www.luogu.com.cn/problem/P1303">P1303</a>，同时掌握高精乘低精与高精乘高精</p>
<p>高精除模板题：<a
href="https://www.luogu.com.cn/problem/P1480">P1480</a>，同时掌握高精除低精与高精除高精</p>
<p>综合：<a href="https://www.luogu.com.cn/problem/P1009">P1009</a></p>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>P4924. 魔法少女小Scarlet</title>
    <url>/2023/10/02/P4924-%E9%AD%94%E6%B3%95%E5%B0%91%E5%A5%B3%E5%B0%8FScarlet/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">501</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, ans[LEN][LEN], tmp[LEN][LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i][j] = cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i, cout &lt;&lt; endl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; ans[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> c_x, <span class="type">int</span> c_y, <span class="type">int</span> r, <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">copy</span>(&amp;ans[<span class="number">0</span>][<span class="number">0</span>], &amp;ans[<span class="number">0</span>][<span class="number">0</span>] + LEN * LEN, &amp;tmp[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (z == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 顺时针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = -r; i &lt;= r; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = -r; j &lt;= r; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[c_x + j][c_y - i] = ans[c_x + i][c_y + j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 逆时针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = -r; i &lt;= r; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = -r; j &lt;= r; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[c_x - j][c_y + i] = ans[c_x + i][c_y + j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">copy</span>(&amp;tmp[<span class="number">0</span>][<span class="number">0</span>], &amp;tmp[<span class="number">0</span>][<span class="number">0</span>] + LEN * LEN, &amp;ans[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, c_x, c_y, r, z;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; m;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; c_x &gt;&gt; c_y &gt;&gt; r &gt;&gt; z;</span><br><span class="line">        <span class="built_in">rotate</span>(c_x, c_y, r, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>假设当前待旋转的矩阵中心c_x = 3，c_y = 3，r = 2</p>
<p>由于是围绕该中心旋转，所以不妨将子矩阵放在以该中心为原点的y -
x坐标系中分析</p>
<blockquote>
<p>数组中的上下移动与平面直角坐标系中的上下移动概念是相反的</p>
<p>若有点坐标(x, y)，要求向左走1次，向上走2次</p>
<p>在平面直角坐标系中，移动后的坐标为(x - 1, y + 2)</p>
<p>而在数组中，移动后的坐标为(x - 2, y - 1)</p>
<p>所以为了方便理解，令新的坐标系横坐标为y，即列号；纵坐标为x，即行号</p>
</blockquote>
<p>以该子矩阵的点(1, 2)为例，分析它的顺时针路径图：</p>
<img src="/2023/10/02/P4924-%E9%AD%94%E6%B3%95%E5%B0%91%E5%A5%B3%E5%B0%8FScarlet/1.png" class="" title="image-20231002182626402">
<p>若令i，j分别为横纵坐标变化，可以发现顺时针变化的规律，即： <span
class="math display">\[
\left( y+i, x+j \right) \rightarrow \left( y-j, x+i \right)
\\
\text{其中}i\in \left[ -r, r \right] , j\in \left[ -r, r \right]
\]</span> 同理逆时针规律也可以得到： <span class="math display">\[
\left( y+i, x+j \right) \rightarrow \left( y+j, x-i \right)
\\
\text{其中}i\in \left[ -r, r \right] , j\in \left[ -r, r \right]
\]</span></p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P1067. 多项式输出</title>
    <url>/2023/10/03/P1067-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
<li>字符串</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, t;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="comment">//不在头且常数大于0时，需要输出加号</span></span><br><span class="line">        <span class="keyword">if</span> (i != n &amp;&amp; t &gt; <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;+&quot;</span>;</span><br><span class="line">        <span class="comment">// 输出数字的情况：</span></span><br><span class="line">        <span class="comment">// t不等于-1、0和1，</span></span><br><span class="line">        <span class="comment">// 或者幂次为0</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(t) &gt; <span class="number">1</span> || (i == <span class="number">0</span> &amp;&amp; t != <span class="number">0</span>))</span><br><span class="line">            cout &lt;&lt; t;</span><br><span class="line">        <span class="comment">//只剩-1需要处理</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">-1</span> &amp;&amp; i != <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; t)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;x^&quot;</span> &lt;&lt; i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; t)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;x&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>字符串的问题，首先判断逐词读入还是整句读入；本题当然是逐次读入比较方便</p>
<p>得到常数项t和幂次i后，任务如下：</p>
<ol type="1">
<li>本次是否输出，直接判断常数是否为0即可</li>
<li>常数项的处理</li>
<li>自变量的处理</li>
</ol>
<p>先来看常数项的处理：</p>
<ol type="1">
<li><p>什么时候输出+号？</p>
<p>常数不在开头，且大于0</p></li>
<li><p>如何输出数？</p>
<p>只要不是-1、0和1这三个数，任何地方都可以直接输出</p>
<p>能输出-1和1的地方，只有幂次等于0的时候</p></li>
<li><p>什么时候输出-号？</p>
<p>其实第2点已经基本处理完了，只剩一种情况，-1在多项式中间，此时只要输出一个-号即可</p></li>
</ol>
<p>再来看自变量的处理：</p>
<ol type="1">
<li><p>什么时候输出x号？</p>
<p>幂次为1且常数项不为0</p></li>
<li><p>什么时候输出x^号？</p>
<p>幂次大于1且常数项不为0</p></li>
</ol>
<p>综上，即可得到代码</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>P1328. 生活大爆炸版石头剪刀布</title>
    <url>/2023/10/02/P1328-%E7%94%9F%E6%B4%BB%E5%A4%A7%E7%88%86%E7%82%B8%E7%89%88%E7%9F%B3%E5%A4%B4%E5%89%AA%E5%88%80%E5%B8%83/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0是平，1是赢，-1是输</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A[<span class="number">250</span>] = &#123;<span class="number">0</span>&#125;, B[<span class="number">250</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, a, b, ans_a = <span class="number">0</span>, ans_b = <span class="number">0</span>, idx_a = <span class="number">0</span>, idx_b = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a; ++i)</span><br><span class="line">        cin &gt;&gt; A[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b; ++i)</span><br><span class="line">        cin &gt;&gt; B[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[A[idx_a]][B[idx_b]] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++ans_b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[A[idx_a]][B[idx_b]] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++ans_a;</span><br><span class="line">        &#125;</span><br><span class="line">        ++idx_a, ++idx_b;</span><br><span class="line">        idx_a %= a, idx_b %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans_a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans_b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>通过二维数组，打表两个人的输赢关系即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P1518. 两只塔姆沃斯牛</title>
    <url>/2023/10/02/P1518-%E4%B8%A4%E5%8F%AA%E5%A1%94%E5%A7%86%E6%B2%83%E6%96%AF%E7%89%9B/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
<li>哈希函数</li>
<li>哈希表</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> arr[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> walk[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//dir_ 0向右，1向下，2向左，3向上</span></span><br><span class="line">    <span class="type">int</span> x_, y_, dir_;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>, <span class="type">int</span> dir = <span class="number">3</span>) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y), <span class="built_in">dir_</span>(dir) &#123;&#125;</span><br><span class="line">&#125; f, c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; arr[i][j];</span><br><span class="line">            <span class="keyword">if</span> (arr[i][j] == <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f.x_ = i, f.y_ = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i][j] == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                c.x_ = i, c.y_ = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hsh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f.dir_ * <span class="built_in">pow</span>(P, <span class="number">5</span>) + c.dir_ * <span class="built_in">pow</span>(P, <span class="number">4</span>) +</span><br><span class="line">           f.x_ * <span class="built_in">pow</span>(P, <span class="number">3</span>) + f.y_ * <span class="built_in">pow</span>(P, <span class="number">2</span>) +</span><br><span class="line">           +c.x_ * P + c.y_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= <span class="number">10</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= <span class="number">10</span> &amp;&amp; arr[x][y] != <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> h, t = <span class="number">0</span>, f_x, f_y, c_x, c_y;</span><br><span class="line">    <span class="keyword">while</span> (!m.<span class="built_in">count</span>(h = <span class="built_in">hsh</span>()) &amp;&amp; (f.x_ != c.x_ || f.y_ != c.y_))</span><br><span class="line">    &#123;</span><br><span class="line">        m[h] = <span class="literal">true</span>;</span><br><span class="line">        f_x = f.x_ + walk[f.dir_][<span class="number">0</span>], f_y = f.y_ + walk[f.dir_][<span class="number">1</span>];</span><br><span class="line">        c_x = c.x_ + walk[c.dir_][<span class="number">0</span>], c_y = c.y_ + walk[c.dir_][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">valid</span>(f_x, f_y))</span><br><span class="line">        &#123;</span><br><span class="line">            f.dir_ = (f.dir_ + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            f.x_ = f_x, f.y_ = f_y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">valid</span>(c_x, c_y))</span><br><span class="line">        &#123;</span><br><span class="line">            c.dir_ = (c.dir_ + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            c.x_ = c_x, c.y_ = c_y;</span><br><span class="line">        &#125;</span><br><span class="line">        ++t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (f.x_ == c.x_ &amp;&amp; f.y_ == c.y_ ? t : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">chase</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本题唯一的难点就在于如何确定系统的临界状态，从而跳出死循环</p>
<p>人与牛如果不可能碰面，即出现死循环现象，那么某一时刻的系统状态一定会出现两次</p>
<blockquote>
<p>类比绕着圆形田径场一直慢跑，某路段一定会至少跑过两次</p>
</blockquote>
<p>本题的系统状态是由人的横纵坐标、人的方向、牛的横纵坐标和牛的方向六个因素决定，如何记录它们呢？</p>
<p>采用<strong>字符串哈希</strong>类似的做法，用一个多项式将六个因素串起来作为哈希值，并在多项式内用<strong>幂次</strong>来代表<strong>影响因子的权重</strong></p>
<p>在本题中，人与牛的方向是最能影响系统状态的，所以人与牛的方向这两个影响因子的幂次应该最高</p>
<blockquote>
<p>由于只有100个坐标，假若将人、牛的坐标作为高权重的影响因子，极其容易发生哈希碰撞；即不同系统状态，但哈希值相同</p>
</blockquote>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>哈希函数</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P1065. 作业调度方案</title>
    <url>/2023/10/03/P1065-%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//m为机器数，n为工件数</span></span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录每个机器的时间轴</span></span><br><span class="line"><span class="type">bool</span> machine_timeline[<span class="number">30</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录当前工件的工序状态</span></span><br><span class="line"><span class="type">int</span> project_record[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录任务执行顺序</span></span><br><span class="line"><span class="type">int</span> project_list[<span class="number">550</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个工件的上一次的最长耗时线</span></span><br><span class="line"><span class="type">int</span> project_timeline[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录工件号及其工序指定的机器与时间开销</span></span><br><span class="line"><span class="comment">//first为指定的机器号，second为时间开销</span></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; project_table[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m * n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; project_list[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; project_table[i][j].first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; project_table[i][j].second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, cost = <span class="number">0</span>, project_id, machine_id, machine_cost;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m * n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        project_id = project_list[i], ++project_record[project_id];</span><br><span class="line">        machine_id = project_table[project_id][project_record[project_id]].first;</span><br><span class="line">        machine_cost = project_table[project_id][project_record[project_id]].second;</span><br><span class="line">        cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = project_timeline[project_id] + <span class="number">1</span>;; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!machine_timeline[machine_id][j])</span><br><span class="line">            &#123;</span><br><span class="line">                ++cost;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cost = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cost == machine_cost)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j; k &gt; j - machine_cost; --k)</span><br><span class="line">                &#123;</span><br><span class="line">                    machine_timeline[machine_id][k] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, j);</span><br><span class="line">                project_timeline[project_id] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>使用一个二维数组，来模拟每台机器的时间轴；这样一来，就知道某台机器在某个时间点的状态了</p>
<p>工序只能按序进行，所以使用一个数组<code>project_timeline</code>来记录每个工件的上一次耗时；下一次该工件的耗时应该接着上一次继续</p>
<p>那么就剩最后一个问题：如何插入某台机器的时间空挡？</p>
<p>令工件从其上一次的耗时开始，沿着机器的时间轴判断哪些连续的时间点是空闲的</p>
<p>若连续的空闲时间点满足工序的时间开支，则代表可以插入，可以回头将这一段空闲时间点设置为繁忙</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P1786. 帮贡排序</title>
    <url>/2023/10/04/P1786-%E5%B8%AE%E8%B4%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>哈希函数</li>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string offer[<span class="number">7</span>] = &#123;<span class="string">&quot;BangZhu&quot;</span>, <span class="string">&quot;FuBangZhu&quot;</span>, <span class="string">&quot;HuFa&quot;</span>, <span class="string">&quot;ZhangLao&quot;</span>, <span class="string">&quot;TangZhu&quot;</span>, <span class="string">&quot;JingYing&quot;</span>, <span class="string">&quot;BangZhong&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> offer_cnts[<span class="number">7</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">25</span>, <span class="number">500</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="comment">//题目提到“原来靠前的现在也要靠前”，所以还需要idx_记录相对位置</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Member</span></span><br><span class="line">&#123;</span><br><span class="line">    string name_, offer_;</span><br><span class="line">    <span class="type">int</span> contri_, rank_, idx_;</span><br><span class="line">&#125; mem[<span class="number">550</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//精髓就在这里，字符串的优先级映射为数字，即可排序啦！</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hsh</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&quot;BangZhu&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;FuBangZhu&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;HuFa&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;ZhangLao&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;TangZhu&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;JingYing&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(Member a, Member b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.contri_ != b.contri_)</span><br><span class="line">        <span class="keyword">return</span> a.contri_ &gt; b.contri_;</span><br><span class="line">    <span class="comment">//非常恶心的坑点！帮贡相同则按原来顺序</span></span><br><span class="line">    <span class="keyword">return</span> a.idx_ &lt; b.idx_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(Member a, Member b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.offer_ != b.offer_)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hsh</span>(a.offer_) &gt; <span class="built_in">hsh</span>(b.offer_);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.rank_ != b.rank_)</span><br><span class="line">        <span class="keyword">return</span> a.rank_ &gt; b.rank_;</span><br><span class="line">    <span class="keyword">return</span> a.idx_ &lt; b.idx_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; mem[i].name_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mem[i].offer_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mem[i].rank_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; mem[i].name_ &gt;&gt; mem[i].offer_ &gt;&gt; mem[i].contri_ &gt;&gt; mem[i].rank_;</span><br><span class="line">        mem[i].idx_ = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为题目给的数据已经是按职位和等级排序了</span></span><br><span class="line">    <span class="comment">// 所以帮主和副帮主的位置不能动！哪怕帮贡有差别</span></span><br><span class="line">    <span class="built_in">sort</span>(mem + <span class="number">3</span>, mem + N, cmp1);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>, idx = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (offer_cnts[idx] &amp;&amp; i &lt; N)</span><br><span class="line">        &#123;</span><br><span class="line">            mem[i++].offer_ = offer[idx];</span><br><span class="line">            --offer_cnts[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        ++idx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(mem + <span class="number">3</span>, mem + N, cmp2);</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>这道题是授权题，但是质量真的不好....因为立意实在过于模糊</p>
<h2 id="第一个难点">第一个难点</h2>
<p>题目说<code>输出结果中，职位第一关键字，等级第二关键字</code></p>
<p>第一反应肯定是一次排序：先按帮贡优先，再按等级优先，然后修改他们的职位即可</p>
<p>然而，最终结果有很多相同的职位！比如有数据<code>A&#123;帮贡100, 等级4&#125;</code>,<code>B&#123;帮贡50，等级8&#125;</code>，且最终A与B职位一样</p>
<p>按照上述排序的优先级，结果是先A后B；但实际上应该先B后A，因为A与B最终职位一样，但B的等级大于A</p>
<p>所以需要两次排序！！！！！</p>
<p>第二次排序先根据职位排序，再根据等级排序，最后按照输入顺序排序</p>
<h2 id="第二个难点">第二个难点</h2>
<p>刚才提到按职位排序，可职位是字符串，怎么排序呢？</p>
<p>编写一个哈希函数，将其转化为数字就可以</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//精髓就在这里，字符串的优先级映射为数字，即可排序啦！</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hsh</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&quot;BangZhu&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;FuBangZhu&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;HuFa&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;ZhangLao&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;TangZhu&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;JingYing&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第一个坑点">第一个坑点</h2>
<p>因为题目说了帮主和副帮主不能动，所以排序的时候要避开这三个人</p>
<h2 id="第二个坑点">第二个坑点</h2>
<p>第一次排序的代码中，还需要再加一条输入顺序的优先才能AC...百思不得其解</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(Member a, Member b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.contri_ != b.contri_)</span><br><span class="line">        <span class="keyword">return</span> a.contri_ &gt; b.contri_;</span><br><span class="line">    <span class="comment">//非常恶心的坑点！帮贡相同则按原来顺序</span></span><br><span class="line">    <span class="keyword">return</span> a.idx_ &lt; b.idx_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>哈希函数</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P1098. 字符串的展开</title>
    <url>/2023/10/03/P1098-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B1%95%E5%BC%80/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
<li>字符串</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p1, p2, p3;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回-1，删除-</span></span><br><span class="line"><span class="comment">//返回0，不变</span></span><br><span class="line"><span class="comment">//返回1，换新</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[b] - s[a] == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s[a] &gt;= s[b])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">filling</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c = s[a] + <span class="number">1</span>; c &lt; s[b]; ++c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> chr;</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="number">1</span>)</span><br><span class="line">            chr = (<span class="type">char</span>)c;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p1 == <span class="number">2</span>)</span><br><span class="line">            chr = <span class="built_in">toupper</span>((<span class="type">char</span>)c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            chr = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">1</span>; cnt &lt;= p2; ++cnt)</span><br><span class="line">            res += chr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p3 == <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; p3;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> idx = <span class="number">0</span>; idx &lt; s.<span class="built_in">length</span>(); ++idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> head = idx - <span class="number">1</span>, tail = idx + <span class="number">1</span>, j;</span><br><span class="line">        <span class="keyword">if</span> (s[idx] != <span class="string">&#x27;-&#x27;</span> ||</span><br><span class="line">            head &lt; <span class="number">0</span> || tail == s.<span class="built_in">length</span>() ||</span><br><span class="line">            !(<span class="built_in">isdigit</span>(s[head]) &amp;&amp; <span class="built_in">isdigit</span>(s[tail]) || <span class="built_in">isalpha</span>(s[head]) &amp;&amp; <span class="built_in">isalpha</span>(s[tail])))</span><br><span class="line">        &#123;</span><br><span class="line">            ans += s[idx];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((j = <span class="built_in">judge</span>(head, tail)) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">            ans += s[idx];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans += <span class="built_in">filling</span>(head, tail);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>字符串的题，先思考是逐个读入方便还是整串处理方便；这道题显然只能选择整串读入，因为要处理-号的前后</p>
<p>每次判断-号的前一位和后一位，如果同时为数字或者同时为字母就进行下一步的扩展操作即可</p>
<p>唯一的坑点在于-号可能出现在开头和结尾，所以要特判范围防止越界</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>P1012. 模板题_拼数</title>
    <url>/2023/10/06/P1012-%E6%A8%A1%E6%9D%BF%E9%A2%98-%E6%8B%BC%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string arr[LEN];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + n, [](string a, string b) -&gt; <span class="type">bool</span></span><br><span class="line">         &#123; <span class="keyword">return</span> a + b &gt; b + a; &#125;);</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cout &lt;&lt; arr[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>一道非常经典的排序模板题</p>
<p>要让字符串a与字符串b拼接的字符串最大，很容易想到贪心规则——只要让a的每一位都比b大就可以了</p>
<p>但事实并不如此；比如<code>391</code>与<code>39</code>拼接，若单纯只以每一位的大小比较，结果是<code>39139</code>，但实际应该为<code>39391</code></p>
<p>在这里，思路要转变过来！排序问题不仅仅是“比大小”，更是“比优先级”</p>
<p>相邻两个元素a与b，谁的位置更应该靠前呢？如果a在前b在后组合的字符串，大于b在前a在后组合的字符串，a应该更靠前；反之亦然</p>
<p>所以最终的排序规则应该是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> a + b &gt; b + a;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1093. 奖学金</title>
    <url>/2023/10/05/P1093-%E5%A5%96%E5%AD%A6%E9%87%91/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stu</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cn_, mt_, en_, sum_, idx_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Stu a, Stu b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.sum_ != b.sum_)</span><br><span class="line">        <span class="keyword">return</span> a.sum_ &gt; b.sum_;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.cn_ != b.cn_)</span><br><span class="line">        <span class="keyword">return</span> a.cn_ &gt; b.cn_;</span><br><span class="line">    <span class="keyword">return</span> a.idx_ &lt; b.idx_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i].cn_ &gt;&gt; arr[i].mt_ &gt;&gt; arr[i].en_;</span><br><span class="line">        arr[i].sum_ = arr[i].cn_ + arr[i].mt_ + arr[i].en_;</span><br><span class="line">        arr[i].idx_ = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + n, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i, cout &lt;&lt; endl)</span><br><span class="line">        cout &lt;&lt; arr[i].idx_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr[i].sum_;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>没有别的坑点，用<code>sort</code>函数按照题意排序就行</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1068. 分数线划定</title>
    <url>/2023/10/06/P1068-%E5%88%86%E6%95%B0%E7%BA%BF%E5%88%92%E5%AE%9A/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">5001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id_, score_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i].id_ &gt;&gt; arr[i].score_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + n, [](Node a, Node b) -&gt; <span class="type">bool</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span> (a.score_ != b.score_)</span><br><span class="line">                 <span class="keyword">return</span> a.score_ &gt; b.score_;</span><br><span class="line">             <span class="keyword">return</span> a.id_ &lt; b.id_;</span><br><span class="line">         &#125;);</span><br><span class="line">    <span class="type">int</span> average = arr[(<span class="type">int</span>)(m * <span class="number">1.5</span>) - <span class="number">1</span>].score_, idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (arr[idx].score_ &gt;= average &amp;&amp; idx &lt; n)</span><br><span class="line">        ++idx;</span><br><span class="line">    cout &lt;&lt; average &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; idx &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; ++i, cout &lt;&lt; endl)</span><br><span class="line">        cout &lt;&lt; arr[i].id_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr[i].score_;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>没有别的坑，按要求排序即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1059. 明明的随机数</title>
    <url>/2023/10/05/P1059-%E6%98%8E%E6%98%8E%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[LEN], ans[LEN], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, in;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; in;</span><br><span class="line">        ++arr[in];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN; ++i)</span><br><span class="line">        <span class="keyword">if</span> (arr[i])</span><br><span class="line">            ans[idx++] = i;</span><br><span class="line">    cout &lt;&lt; idx &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; ++i)</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>数字最大也才到1000，直接使用计数排序就行</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1104. 生日</title>
    <url>/2023/10/06/P1104-%E7%94%9F%E6%97%A5/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">250</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    string s_;</span><br><span class="line">    <span class="type">int</span> idx_, y_, m_, d_;</span><br><span class="line">&#125; stu[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Student a, Student b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.y_ != b.y_)</span><br><span class="line">        <span class="keyword">return</span> a.y_ &lt; b.y_;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.m_ != b.m_)</span><br><span class="line">        <span class="keyword">return</span> a.m_ &lt; b.m_;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.d_ != b.d_)</span><br><span class="line">        <span class="keyword">return</span> a.d_ &lt; b.d_;</span><br><span class="line">    <span class="keyword">return</span> a.idx_ &gt; b.idx_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; stu[i].s_ &gt;&gt; stu[i].y_ &gt;&gt; stu[i].m_ &gt;&gt; stu[i].d_;</span><br><span class="line">        stu[i].idx_ = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(stu, stu + n, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cout &lt;&lt; stu[i].s_ &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>没有坑点，按照要求编写sort函数即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1152 欢乐的跳</title>
    <url>/2023/10/05/P1152-%E6%AC%A2%E4%B9%90%E7%9A%84%E8%B7%B3/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, arr[LEN], ans[LEN];</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        arr[i] = <span class="built_in">abs</span>(arr[i + <span class="number">1</span>] - arr[i]);</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, diff = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i, ++diff)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != diff)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Not jolly&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Jolly&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>n个元素共有n-1个相邻元素差，而题目刚好问你元素差是否都在<code>[1, n-1]</code>范围内</p>
<p>所以先求出差分数组，共n-1个元素；然后对差分数组进行排序，最后以下标从低到高的顺序逐位判断即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1116. 车厢重组</title>
    <url>/2023/10/05/P1116-%E8%BD%A6%E5%8E%A2%E9%87%8D%E7%BB%84/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bubble_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, arr[LEN];</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bubble_sort</span>(arr, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据<strong>两两交换</strong>的题面，很明显就是冒泡排序，要你求内部元素一共交换了多少次</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1177. 模板题_排序</title>
    <url>/2023/10/04/P1177-%E6%A8%A1%E6%9D%BF%E9%A2%98-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = len;</span><br><span class="line">    <span class="type">int</span> pivot = arr[<span class="built_in">rand</span>() % len];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot)</span><br><span class="line">            <span class="built_in">swap</span>(arr[i++], arr[j++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; pivot)</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[--k]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr + k, len - k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, arr[LEN];</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr));</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>部分模板来源于<a
href="https://oi-wiki.org/basic/sort-intro/">OIWiki</a></p>
<h2 id="普通快排">普通快排</h2>
<p>普通快排的迭代版模板如下，来源于上述的OIWiki</p>
<p>其中对区间的分治操作需要熟练掌握，未来会经常用到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> start, end;</span><br><span class="line">    <span class="built_in">Range</span>(<span class="type">int</span> s = <span class="number">0</span>, <span class="type">int</span> e = <span class="number">0</span>) &#123; start = s, end = e; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(T arr[], <span class="type">const</span> <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Range r[len];</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    r[p++] = <span class="built_in">Range</span>(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        Range range = r[--p];</span><br><span class="line">        <span class="keyword">if</span> (range.start &gt;= range.end)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        T mid = arr[range.end];</span><br><span class="line">        <span class="type">int</span> left = range.start, right = range.end - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right)</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right)</span><br><span class="line">                right--;</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[left], arr[right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[left] &gt;= arr[range.end])</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[left], arr[range.end]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left++;</span><br><span class="line">        r[p++] = <span class="built_in">Range</span>(range.start, left - <span class="number">1</span>);</span><br><span class="line">        r[p++] = <span class="built_in">Range</span>(left + <span class="number">1</span>, range.end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当然也可以将其改造为递归，就变成广为流传的样子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> bg, <span class="type">int</span> ed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bg &gt;= ed)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> l = bg, r = ed - <span class="number">1</span>, pivot = arr[ed];</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[l] &lt; pivot &amp;&amp; l &lt; r)</span><br><span class="line">            ++l;</span><br><span class="line">        <span class="keyword">while</span> (arr[r] &gt;= pivot &amp;&amp; l &lt; r)</span><br><span class="line">            --r;</span><br><span class="line">        <span class="built_in">swap</span>(arr[l], arr[r]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[l] &gt;= arr[ed])</span><br><span class="line">        <span class="built_in">swap</span>(arr[l], arr[ed]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ++l;</span><br><span class="line">    <span class="built_in">quick_sort</span>(bg, l - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quick_sort</span>(l + <span class="number">1</span>, ed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">quick_sort</span>(<span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三路快速排序">三路快速排序</h2>
<p>普通快排效率并不高，上面的代码本题就会超时，就需要用到三路快排；模板同样来自OIWiki</p>
<p>顺带提一嘴，rand函数的用法可以简单记为<code>a + rand() % b</code>；即从a开始（包括a）共b个连续整数的生成范围</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板的 T 参数表示元素的类型，此类型需要定义小于（&lt;）运算</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// arr 为需要被排序的数组，len 为数组长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(T arr[], <span class="type">const</span> <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 随机选择基准（pivot）</span></span><br><span class="line">    <span class="type">const</span> T pivot = arr[<span class="built_in">rand</span>() % len];</span><br><span class="line">    <span class="comment">// i：当前操作的元素下标</span></span><br><span class="line">    <span class="comment">// arr[0, j)：存储小于 pivot 的元素</span></span><br><span class="line">    <span class="comment">// arr[k, len)：存储大于 pivot 的元素</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = len;</span><br><span class="line">    <span class="comment">// 完成一趟三路快排，将序列分为：</span></span><br><span class="line">    <span class="comment">// 小于 pivot 的元素 | 等于 pivot 的元素 | 大于 pivot 的元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot)</span><br><span class="line">            <span class="built_in">swap</span>(arr[i++], arr[j++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pivot &lt; arr[i])</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[--k]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归完成对于两个子序列的快速排序</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr + k, len - k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="归并排序">归并排序</h2>
<p>直接上图~</p>
<img src="/2023/10/04/P1177-%E6%A8%A1%E6%9D%BF%E9%A2%98-%E6%8E%92%E5%BA%8F/1.png" class="" title="image-20240302194323915">
<img src="/2023/10/04/P1177-%E6%A8%A1%E6%9D%BF%E9%A2%98-%E6%8E%92%E5%BA%8F/2.png" class="" title="image-20240302194421345">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, a[maxn], t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> i = l, j = l, mid = (l + r) / <span class="number">2</span>, k = mid + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">merge</span>(l, mid), <span class="built_in">merge</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= mid &amp;&amp; k &lt;= r) t[i++] = a[j] &lt;= a[k] ? a[j++] : a[k++];</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= mid) t[i++] = a[j++];</span><br><span class="line">  <span class="keyword">while</span> (k &lt;= r) t[i++] = a[k++];</span><br><span class="line">  <span class="keyword">for</span> (i = l; i &lt;= r; ++i) a[i] = t[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="built_in">merge</span>(<span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1781. 宇宙总统</title>
    <url>/2023/10/05/P1781-%E5%AE%87%E5%AE%99%E6%80%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx_;</span><br><span class="line">    string votes_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.votes_.<span class="built_in">length</span>() != b.votes_.<span class="built_in">length</span>())</span><br><span class="line">        <span class="keyword">return</span> a.votes_.<span class="built_in">length</span>() &gt; b.votes_.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.votes_.<span class="built_in">length</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.votes_[i] &gt; b.votes_[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a.votes_[i] &lt; b.votes_[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i].votes_;</span><br><span class="line">        arr[i].idx_ = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + n, cmp);</span><br><span class="line">    cout &lt;&lt; arr[<span class="number">0</span>].idx_ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; arr[<span class="number">0</span>].votes_;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本题实际上是比较以字符串形式存储的数字大小；先比较长度，更长的肯定更大，若长度相同再逐位比较</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1271. 选举学生会</title>
    <url>/2023/10/04/P1271-%E9%80%89%E4%B8%BE%E5%AD%A6%E7%94%9F%E4%BC%9A/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>计数排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, M, arr[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">counting_sort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; ++i)</span><br><span class="line">        <span class="keyword">while</span> (arr[i]--)</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">        ++arr[num];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">counting_sort</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本质上是根据每种数字出现的个数来输出，故而使用计数排序即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>计数排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1923. 模板题_求第 k 小的数</title>
    <url>/2023/10/05/P1923-%E6%A8%A1%E6%9D%BF%E9%A2%98-%E6%B1%82%E7%AC%AC-k-%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">5e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> K, arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">k_th</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = len, pivot = arr[<span class="built_in">rand</span>() % len];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot)</span><br><span class="line">            <span class="built_in">swap</span>(arr[i++], arr[j++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; pivot)</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[--k]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (K &lt; j)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">k_th</span>(arr, j);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (K &gt;= k)</span><br><span class="line">    &#123;</span><br><span class="line">        K -= k;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">k_th</span>(arr + k, len - k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> pivot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这行必须加，加快cin的读取速度</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">k_th</span>(arr, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>不同题目对<strong>第K大</strong>和<strong>第K小</strong>都有不同的定义；就本题而言，是求升序数列中的第K个元素，K从0开始</p>
<p>可以联想到三路快排算法：每次都以<code>pivot</code>为标准，左半部分均小于<code>pivot</code>，中间部分等于<code>pivot</code>，右半部分大于<code>pivot</code></p>
<p>所以只需要判断K处在哪一个部分：</p>
<ul>
<li>K在左半部分，向左半部分递归</li>
<li>K在中间部分，直接返回结果，因为中间部分的值都是相同的</li>
<li>K在右半部分，K先减去左半部分加中间部分的长度，以转换为右半部分子数组的下标，再向右半部分递归</li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P2676. Bookshelf B</title>
    <url>/2023/10/05/P2676-Bookshelf-B/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">20050</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n, b, cnt = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + n, [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">bool</span></span><br><span class="line">         &#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; sum &lt; b; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>没有别的坑点，排序结束后累加即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P5143. 攀爬者</title>
    <url>/2023/10/06/P5143-%E6%94%80%E7%88%AC%E8%80%85/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">5e4</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x_, y_, z_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i].x_ &gt;&gt; arr[i].y_ &gt;&gt; arr[i].z_;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + n, [](Node a, Node b) -&gt; <span class="type">bool</span></span><br><span class="line">         &#123; <span class="keyword">return</span> a.z_ &lt; b.z_; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(arr[i].x_ - arr[i + <span class="number">1</span>].x_, <span class="number">2</span>) +</span><br><span class="line">                    <span class="built_in">pow</span>(arr[i].y_ - arr[i + <span class="number">1</span>].y_, <span class="number">2</span>) +</span><br><span class="line">                    <span class="built_in">pow</span>(arr[i].z_ - arr[i + <span class="number">1</span>].z_, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>没有坑点，根据高度z排序后，按序统计相邻节点的欧几里得距离即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1036. 模板题_选数</title>
    <url>/2023/10/07/P1036-%E6%A8%A1%E6%9D%BF%E9%A2%98-%E9%80%89%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">20</span>], ans, K, N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isprime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(x); ++i)</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cnt, <span class="type">int</span> idx, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt; K)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isprime</span>(sum))</span><br><span class="line">            ++ans;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = idx; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(cnt + <span class="number">1</span>, i + <span class="number">1</span>, sum + arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>一道DFS的模板题</p>
<p>为取数不重复，规定每次取数时的初始下标至少大于上一次的取数下标，就可以保证“永不回头”</p>
<p>由于每次只能取K个数，所以需要设立一个变量cnt来计数；如果当前cnt大于K，说明已经取够K个了，就进行质数判断然后返回</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1088. 火星人</title>
    <url>/2023/10/07/P1088-%E7%81%AB%E6%98%9F%E4%BA%BA/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[LEN], N, M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="keyword">while</span> (M-- &amp;&amp; <span class="built_in">next_permutation</span>(arr, arr + N))</span><br><span class="line">        ;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题意其实就是给了一个序列，将这个序列全排列若干次后再输出</p>
<p>不会真有人尝试10000的阶乘吧！不会吧不会吧不会吧不会吧不会吧！！</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1149. 火柴棒等式</title>
    <url>/2023/10/08/P1149-%E7%81%AB%E6%9F%B4%E6%A3%92%E7%AD%89%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> table[<span class="number">10</span>] = &#123;<span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>&#125;, arr[<span class="number">2</span>], N, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cnt</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        res += table[x % <span class="number">10</span>];</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (x);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; N - <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cnt</span>(arr[<span class="number">0</span>]) + <span class="built_in">cnt</span>(arr[<span class="number">1</span>]) + <span class="built_in">cnt</span>(arr[<span class="number">0</span>] + arr[<span class="number">1</span>]) == N - <span class="number">4</span>)</span><br><span class="line">            ++ans;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1111</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[idx] = i;</span><br><span class="line">        <span class="built_in">dfs</span>(idx + <span class="number">1</span>, sum + <span class="built_in">cnt</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题意实际上是问，两个数字及其和的组成火柴总数要等于N-4</p>
<p>除去加号与等号的四根火柴后，还剩20根；那么每个数字极限也只能到1111</p>
<p>当然上亿次的暴力搜索还是太大了，如果遍历过程中火柴数已经大于N-4就可以直接剪枝</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1706. 全排列问题</title>
    <url>/2023/10/07/P1706-%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>], vis[<span class="number">10</span>], N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27; &#x27;</span>) &lt;&lt; <span class="built_in">setw</span>(<span class="number">5</span>) &lt;&lt; arr[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx == N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        arr[idx] = i;</span><br><span class="line">        vis[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(idx + <span class="number">1</span>);</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>用vis数组记录元素是否用过；每次元素的可能性都从1遍历到N（因为不同序列的元素组成可以相同）</p>
<p>只要没有被访问就纳入答案数组内，并在vis记录已用；当本次可能性的递归结束后，vis记录恢复为未用，避免影响其他情况</p>
<p>当然，全排列也可以直接调用STL函数<code>next_permutation</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>], vis[<span class="number">10</span>], N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27; &#x27;</span>) &lt;&lt; <span class="built_in">setw</span>(<span class="number">5</span>) &lt;&lt; arr[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        arr[i - <span class="number">1</span>] = i;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(arr, arr + N));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1618. 模板题_三连击（升级版）</title>
    <url>/2023/10/07/P1618-%E6%A8%A1%E6%9D%BF%E9%A2%98-%E4%B8%89%E8%BF%9E%E5%87%BB%EF%BC%88%E5%8D%87%E7%BA%A7%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>枚举</li>
<li>排列组合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">9</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="type">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        sum = sum * <span class="number">10</span> + arr[idx + i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c, flag = <span class="literal">false</span>;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num_1 = <span class="built_in">num</span>(<span class="number">0</span>), num_2 = <span class="built_in">num</span>(<span class="number">3</span>), num_3 = <span class="built_in">num</span>(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">if</span> (num_1 * b == num_2 * a &amp;&amp; num_1 * c == num_3 * a &amp;&amp; num_2 * c == num_3 * b)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num_3 &lt;&lt; endl;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(arr, arr + <span class="number">9</span>));</span><br><span class="line">    <span class="keyword">if</span> (!flag)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No!!!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题意，三个数的数字均不可能重复</p>
<p>实际上就可以视作为数字1-9的全排列，每次按序取前三位，中三位和后三位组成的数进行比较</p>
<p>STL中有函数<code>next_permutation</code>专门实现这一操作</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>P1217. Prime Palindromes</title>
    <url>/2023/10/08/P1217-Prime-Palindromes/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>枚举</li>
<li>质数</li>
<li>回文数</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">11</span>], idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        arr[idx++] = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = idx - <span class="number">1</span>; i &lt; j; ++i, --j)</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != arr[j])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(x); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; <span class="number">9999999</span>)</span><br><span class="line">        b = <span class="number">9999999</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (a % <span class="number">2</span> ? a : a + <span class="number">1</span>); i &lt;= b; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(i) &amp;&amp; <span class="built_in">isPrime</span>(i))</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本题更多地是考验数论的能力.....</p>
<ul>
<li><p>如果一个数是11的倍数，那么奇数位置的和等于偶数位置的和；也就是说，11的倍数其实都是长度为偶数的回文数</p>
<p>所以可以提前剪枝，大于9999999的数都可以不用判断，因为就算是回文数也绝对不可能是质数</p></li>
<li><p>如果一个数是偶数，自然也不可能是质数，也可以借助这个特性再次剪枝</p></li>
<li><p>还有一个优化点，回文数的个数肯定是远小于质数的个数；所以判断回文数的操作应该放在判断质数之前，大幅减少时间开销</p></li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>质数</tag>
        <tag>回文数</tag>
      </tags>
  </entry>
  <entry>
    <title>P2036. PERKET</title>
    <url>/2023/10/08/P2036-PERKET/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sour_, bitter_;</span><br><span class="line">&#125; arr[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = INT_MAX, N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> sum_sour, <span class="type">int</span> sum_bitter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum_sour != <span class="number">1</span> &amp;&amp; sum_bitter != <span class="number">0</span>)</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(sum_sour - sum_bitter));</span><br><span class="line">    <span class="keyword">if</span> (idx == N)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(idx + <span class="number">1</span>, sum_sour, sum_bitter);</span><br><span class="line">    <span class="built_in">dfs</span>(idx + <span class="number">1</span>, sum_sour * arr[idx].sour_, sum_bitter + arr[idx].bitter_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i].sour_ &gt;&gt; arr[i].bitter_;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>每种配料都有选与不选两种情况，且最多只有10个配料，即2<sup>10</sup>的复杂度，可以直接暴力DFS</p>
<p>题目说<strong>至少选一种配料</strong>，且<strong>酸度和苦度不同时为1和0</strong></p>
<p>也就是说，只有初始状态，和所有配料都没选这两种特殊情况才有可能出现酸度为1且苦度为0</p>
<p>所以直接屏蔽<strong>酸度为1且苦度为0</strong>时的情况即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sum_sour != <span class="number">1</span> &amp;&amp; sum_bitter != <span class="number">0</span>)</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(sum_sour - sum_bitter));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>P1157. 组合的输出</title>
    <url>/2023/10/07/P1157-%E7%BB%84%E5%90%88%E7%9A%84%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">20</span>], N, R;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; R; ++i)</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27; &#x27;</span>) &lt;&lt; <span class="built_in">setw</span>(<span class="number">3</span>) &lt;&lt; arr[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cnt, <span class="type">int</span> idx, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt; R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = num; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[idx] = i;</span><br><span class="line">        <span class="built_in">dfs</span>(cnt + <span class="number">1</span>, idx + <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; R;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据升序且不重复的要求，每次取数都应比上一次取的数要大</p>
<p>又因为限定了只取R个数，所以需要额外设定一个cnt变量来计数；当cnt大于R时，说明已取够，应当输出</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P2241 统计方形</title>
    <url>/2023/10/07/P2241-%E7%BB%9F%E8%AE%A1%E6%96%B9%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>枚举</li>
<li>排列组合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ll sum = ((n + <span class="number">1</span>) * n * (m + <span class="number">1</span>) * m) / <span class="number">4</span>;</span><br><span class="line">    ll square = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">min</span>(n, m); ++i)</span><br><span class="line">        square += (n - i + <span class="number">1</span>) * (m - i + <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; square &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; sum - square;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>长方形的个数不好求，秉持着“正难则反”的原则，可以先求出一共有多少个矩形，再用矩形的数量减去正方形的数量即可</p>
<p>题意是说<code>n*m个格子的棋盘</code>，那么就有<code>(n + 1) * (m + 1)</code>个点</p>
<p>而矩形实际上就是行方向取两个点之间的长度作为宽，列方向取两个点之间的长度作为长；根据排列组合原理，有如下等式：
<span class="math display">\[
C_{n+1}^{2}\times C_{m+1}^{2}=\frac{\left( n+1 \right) !}{2!\times
\left( n-1 \right) !}\times \frac{\left( m+1 \right) !}{2!\times \left(
m-1 \right) !}=\frac{\left( n+1 \right) \times n\times \left( m+1
\right) \times m}{4}=\text{矩阵个数}
\]</span>
正方形的个数也很容易计算，边长为1的正方形个数+边长为2的正方形个数+...+边长为<code>min(n, m)</code>的正方形个数，也有如下等式
<span class="math display">\[
\left( n-1+1 \right) \times \left( m-1+1 \right) +\left( n-2+1 \right)
\times \left( m-2+1 \right) +...+\left( n-\min \left( n,m \right) +1
\right) \times \left( m-\min \left( n,m \right) +1 \right)
\]</span></p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>P3654. First Step</title>
    <url>/2023/10/08/P3654-First-Step/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>枚举</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> arr[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> R, C, K, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> walk[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cnt</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= R &amp;&amp; y &lt;= C &amp;&amp; arr[x][y] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; res &lt; K)</span><br><span class="line">    &#123;</span><br><span class="line">        x += walk[idx][<span class="number">0</span>], y += walk[idx][<span class="number">1</span>];</span><br><span class="line">        ++res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res == K)</span><br><span class="line">        ++ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; R &gt;&gt; C &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= R; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= C; ++j)</span><br><span class="line">            cin &gt;&gt; arr[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= R; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= C; ++j)</span><br><span class="line">            <span class="built_in">cnt</span>(i, j, <span class="number">0</span>), <span class="built_in">cnt</span>(i, j, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// K等于1的时候会重复</span></span><br><span class="line">    cout &lt;&lt; (K == <span class="number">1</span> ? ans &gt;&gt; <span class="number">1</span> : ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>枚举所有点，每次判断从当前位置向右走或向下走是否满足连续K个空位即可（向右走和向下走可以保证情况不重复）</p>
<p>坑点在于，当K等于1时结果要除2，因为此时向右和向下走情况是重复的</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>P3799. 妖梦拼木棒</title>
    <url>/2023/10/08/P3799-%E5%A6%96%E6%A2%A6%E6%8B%BC%E6%9C%A8%E6%A3%92/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>枚举</li>
<li>排列组合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5050</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求组合数，限定取2或1</span></span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(ll a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> ((a % mod) * ((a - <span class="number">1</span>) % mod) / <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, in;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; in;</span><br><span class="line">        ++arr[in];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5000</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ll a = <span class="built_in">calc</span>(arr[i], <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!arr[j] || !arr[i - j])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//两个短边相等的时候</span></span><br><span class="line">            <span class="keyword">if</span> (j == i - j &amp;&amp; arr[j] &gt;= <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ll b = <span class="built_in">calc</span>(arr[j], <span class="number">2</span>);</span><br><span class="line">                ans = (ans + (a * b) % mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j != i - j)</span><br><span class="line">            &#123;</span><br><span class="line">                ll b = <span class="built_in">calc</span>(arr[j], <span class="number">1</span>), c = <span class="built_in">calc</span>(arr[i - j], <span class="number">1</span>);</span><br><span class="line">                ans = (ans + (a * b * c) % mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>用一个数组arr记录各类长度的个数；如果双重循环枚举短边的话，是绝对会超时的</p>
<p>由于其中一条短边一定小于等于长边的一半；那么外循环就枚举长边，内循环枚举小于等于长边一半的短边，复杂度就降到了<span
class="math inline">\(n^2/2\)</span></p>
<blockquote>
<p>假设长边为a，一个短边为b，另一个短边为c，有以下等式成立： <span
class="math display">\[
\frac{a}{2}=\frac{\left( b+c \right)}{2}
\]</span>
映射到数轴上看，显然有一个短边必小于等于长边一半，而另一个短边必大于等于长边一半</p>
</blockquote>
<p>找到了符合条件的三种边后，使用排列乘法原理即可：</p>
<ul>
<li><p>如果短边b等于短边c，相当于从长度等于b的火柴中取2根，再从长度等于a长边的火柴中取2根，即：
<span class="math display">\[
C_{a}^{2}\times C_{b}^{2}
\]</span></p></li>
<li><p>如果短边b不等于短边c，分别从长度b、长度c两堆各取1根，从长度a取2根
<span class="math display">\[
C_{a}^{2}\times C_{b}^{1}\times C_{c}^{1}
\]</span></p></li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>P2089. 烤鸡</title>
    <url>/2023/10/07/P2089-%E7%83%A4%E9%B8%A1/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>], ans[<span class="number">55000</span>][<span class="number">10</span>], cnt = <span class="number">-1</span>, N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; cnt + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cnt; ++i, cout &lt;&lt; endl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j)</span><br><span class="line">            cout &lt;&lt; ans[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt; <span class="number">10</span> || sum &gt; N)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">10</span> &amp;&amp; sum == N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">copy</span>(arr, arr + <span class="number">10</span>, ans[++cnt]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[idx] = i;</span><br><span class="line">        <span class="built_in">dfs</span>(idx + <span class="number">1</span>, sum + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">if</span> (N &gt; <span class="number">30</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">-1</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>一道基础的DFS题目</p>
<p>每类配料都有3种选择，一共10类，按道理一共有3<sup>10</sup>种选法，绝对会超时；好在题目只是要求所有类别的配料质量之和</p>
<p>那么只要输入N大于<code>3 * 10 = 30</code>就是无效的；同时DFS的过程中，和大于N也可以直接退出。两种剪枝操作大大降低了时间复杂度</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>P2392. kkksc03考前临时抱佛脚</title>
    <url>/2023/10/08/P2392-kkksc03%E8%80%83%E5%89%8D%E4%B8%B4%E6%97%B6%E6%8A%B1%E4%BD%9B%E8%84%9A/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">4</span>][<span class="number">20</span>], ans[<span class="number">4</span>], res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> idx, <span class="type">int</span> lbrain, <span class="type">int</span> rbrain, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx == n)</span><br><span class="line">    &#123;</span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">max</span>(lbrain, rbrain));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(arr, idx + <span class="number">1</span>, lbrain + arr[idx], rbrain, n);</span><br><span class="line">    <span class="built_in">dfs</span>(arr, idx + <span class="number">1</span>, lbrain, rbrain + arr[idx], n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        cin &gt;&gt; ans[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        <span class="built_in">read</span>(arr[i], ans[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        res = INT_MAX, <span class="built_in">dfs</span>(arr[i], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ans[i]), ans[i] = res;</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        res += ans[i];</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>每次都有两种情况，给左脑还是给右脑，每科最多20次，也就是4<sup>10</sup>的时间复杂度，暴力DFS是可以过的</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P3392. 涂国旗</title>
    <url>/2023/10/08/P3392-%E6%B6%82%E5%9B%BD%E6%97%97/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>枚举</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> arr[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cost</span><span class="params">(<span class="type">int</span> bg, <span class="type">int</span> ed, <span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = bg; i &lt;= ed; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i][j] != c)</span><br><span class="line">                ++res;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">            cin &gt;&gt; arr[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum_w = <span class="built_in">cost</span>(<span class="number">1</span>, i, <span class="string">&#x27;W&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = N - <span class="number">2</span>; j &gt;= <span class="number">1</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum_r = <span class="built_in">cost</span>(N - j + <span class="number">1</span>, N, <span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">            <span class="type">int</span> sum_b = <span class="built_in">cost</span>(i + <span class="number">1</span>, N - j, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, sum_w + sum_r + sum_b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>假设一共有N行</p>
<p>白色的行最少有1行，最多有N-2行；红色的行最少也有1行，最多也有N-2行；白色与红色确认行数后，蓝色的行数也可以确认</p>
<p>所以直接令白色行数与红色行数执行双重循环的枚举，对比不同情况下的开销即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>P1002. 过河卒</title>
    <url>/2023/10/09/P1002-%E8%BF%87%E6%B2%B3%E5%8D%92/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线性动态规划</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll f[<span class="number">25</span>][<span class="number">25</span>], ctrl[<span class="number">25</span>][<span class="number">25</span>], n, m, hx, hy;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ctrl[hx][hy] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-2</span>; i &lt;= <span class="number">2</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-2</span>; j &lt;= <span class="number">2</span>; ++j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(i) + <span class="built_in">abs</span>(j) == <span class="number">3</span> &amp;&amp;</span><br><span class="line">                (hx + i) &gt;= <span class="number">0</span> &amp;&amp; (hx + i) &lt;= n &amp;&amp;</span><br><span class="line">                (hy + j) &gt;= <span class="number">0</span> &amp;&amp; (hy + j) &lt;= m)</span><br><span class="line">                ctrl[hx + i][hy + j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctrl[i][j])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; i - <span class="number">1</span> &lt;= n)</span><br><span class="line">                f[i][j] += f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; j - <span class="number">1</span> &lt;= m)</span><br><span class="line">                f[i][j] += f[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; hx &gt;&gt; hy;</span><br><span class="line">    <span class="built_in">init</span>(), <span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>每次只能向右和向下走，那么每个新的状态就只能由上面一个点和左边一个点共同组成，很容易得到递推式：
<span class="math display">\[
f\left( x,y \right) =f\left( x-1,y \right) +f\left( x,y-1 \right)
\]</span>
由于需要避开马的控制范围，所以单独开一个数组ctrl，记录哪些点不能走即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P1028. 数的计算</title>
    <url>/2023/10/10/P1028-%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线性动态规划</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll mem[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mem[x])</span><br><span class="line">        <span class="keyword">return</span> mem[x];</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> || x == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> mem[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= x / <span class="number">2</span>; ++i)</span><br><span class="line">        mem[x] += <span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="keyword">return</span> mem[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>设<code>mem[n]</code>为数字<code>n</code>的合法数列个数；令<code>mem[0] = 1</code>，意为数字<code>n</code>本身构成的序列，数列末尾什么也不加</p>
<p>显然能得到状态转移方程： <span class="math display">\[
mem\left[ 0 \right] +mem\left[ 1 \right] +...mem\left[ n/2 \right]
\rightarrow mem\left[ n \right]
\]</span> 题解是递归编写的，将其改为递推也是可以的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll dp[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i / <span class="number">2</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] += dp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P1010. 幂次方</title>
    <url>/2023/10/11/P1010-%E5%B9%82%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
<li>分治</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;2(0)&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;2&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;2(&quot;</span>, <span class="built_in">f</span>(i), cout &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            x ^= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="keyword">if</span> (x)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;+&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">f</span>(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>简单的分治题，最终的子问题实际上就是：</p>
<ul>
<li><p>什么时候往下分</p>
<p>幂次大于1的时候继续往下分</p></li>
<li><p>什么时候输出括号</p>
<p>幂次等于1和0的时候直接输出<code>2</code>和<code>2(0)</code></p>
<p>其余幂次先输出<code>2(</code>，等内部递归结束后再输出<code>)</code></p></li>
<li><p>什么时候输出加号</p>
<p>还需要往下分的时候</p></li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P1044. 模板题_栈</title>
    <url>/2023/10/10/P1044-%E6%A8%A1%E6%9D%BF%E9%A2%98-%E6%A0%88/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>卡特兰数</li>
<li>线性动态规划</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<h2 id="卡特兰数">卡特兰数</h2>
<p>卡特兰数本身并不难理解，可以直接看这篇<a
href="https://leetcode.cn/circle/discuss/lWYCzv/">链接</a>进行学习</p>
<p>这里提醒一下，在《深基》与《算法导论》中非法序列的个数为<span
class="math inline">\(C_{2n}^{n-1}\)</span>，在上面的链接中则是<span
class="math inline">\(C_{2n}^{n+1}\)</span>；但结果是一样的，只是角度不同</p>
<p>因为组合数本来就有这个性质： <span class="math display">\[
C_{n}^{m}=C_{n}^{n-m}
\]</span> 故而本题可以直接按照卡特兰数的通项输出即可，不再赘述</p>
<h2 id="递推">递推</h2>
<p>思路来源于kkksc03</p>
<p>假设i个元素一共有h[i]种出栈方式，那么要求的就是n个元素的出栈方式，即h[n]</p>
<p>n个元素下标为从1到n，每个元素都有可能是最后一个出栈的，即输出序列的最后一位</p>
<p>假设第k个数是最后一个出栈的，情况会是这样：</p>
<ol type="1">
<li><p>前面有k-1个数先入栈，然后出栈，即h[k-1]</p></li>
<li><p>第k个数入栈</p></li>
<li><p>n-k个数入栈，然后出栈，即h[n-k]</p></li>
</ol>
<p>所以当第k个数是最后一个出栈时，情况共有<code>h[k-1] * h[n-k]</code>种</p>
<p>那么就能得到递推式： <span class="math display">\[
h\left( n \right) =h\left( 0 \right) \times h\left( n-1 \right) +h\left(
1 \right) \times h\left( n-2 \right) +...+h\left( n-1 \right) \times
h\left( 0 \right)
\]</span></p>
<p><span class="math display">\[
h\left( 0 \right) =h\left( 1 \right) =1
\]</span></p>
<p>这样就能写出极简代码了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, h[<span class="number">20</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            h[i] += h[j] * h[i - j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; h[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线性动态规划-记忆化搜索">线性动态规划 记忆化搜索</h2>
<p>以输出序列的元素个数qe，栈的元素个数st为状态分析对象，建立二维数组<code>mem[qe][st]</code></p>
<p>根据栈的性质，要么从栈顶弹出一个元素给输出序列，要么就继续入栈新元素不弹出；易得状态转移方程如下：
<span class="math display">\[
\underset{\text{栈顶弹出给输出序列}}{\underbrace{mem\left[ qe-1 \right]
\left[ st+1 \right]
}}+\underset{\text{入栈新元素不弹出}}{\underbrace{mem\left[ qe \right]
\left[ st-1 \right] }}\rightarrow mem\left[ qe \right] \left[ st \right]
\]</span>
那么临界值呢？很显然，当输出序列qe为0的时候不可再分，此时令<code>mem[qe][st] = 1</code>；如果越界的话令<code>mem[qe][st] = 0</code>即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">ll mem[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> qe, <span class="type">int</span> st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mem[qe][st])</span><br><span class="line">        <span class="keyword">return</span> mem[qe][st];</span><br><span class="line">    <span class="keyword">if</span> (qe &lt; <span class="number">0</span> || qe &gt; n || st &lt; <span class="number">0</span> || st &gt; n)</span><br><span class="line">        <span class="keyword">return</span> mem[qe][st] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (qe == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> mem[qe][st] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> mem[qe][st] = <span class="built_in">dfs</span>(qe - <span class="number">1</span>, st + <span class="number">1</span>) + <span class="built_in">dfs</span>(qe, st - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(n, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线性动态规划-递推">线性动态规划 递推</h2>
<p>将上面的递归改成迭代即可，不再赘述</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> st = <span class="number">0</span>; st &lt;= n; ++st)</span><br><span class="line">        dp[<span class="number">0</span>][st] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> qe = <span class="number">1</span>; qe &lt;= n; ++qe)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> st = <span class="number">0</span>; st &lt;= n; ++st)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[qe][st] = dp[qe - <span class="number">1</span>][st + <span class="number">1</span>] + dp[qe][st - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>卡特兰数</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P1164. 模板题_小A点菜</title>
    <url>/2023/10/11/P1164-%E6%A8%A1%E6%9D%BF%E9%A2%98-%E5%B0%8FA%E7%82%B9%E8%8F%9C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>01背包</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<h2 id="二维数组实现">二维数组实现</h2>
<p>经典的01背包问题，每种元素只有一个，且只有选或不选两种状态；题目要求多少种选法能刚好花光m元</p>
<p>可以设<code>dp[i][j]</code>为<strong>前i个元素花了j元</strong>，显然有动态转移方程如下：
<span class="math display">\[
\underset{\text{前}i-1\text{个元素花}j\text{元}}{\underbrace{dp\left[
i-1 \right] \left[ j \right]
}}+\underset{\text{选第}i\text{个元素，前}i-1\text{个元素应花}j-\cos
t\left[ i \right] \text{元}}{\underbrace{dp\left[ i-1 \right] \left[
j-\cos t\left[ i \right] \right] }}\rightarrow dp\left[ i \right] \left[
j \right]
\]</span>
我们最终要计算的就是<code>dp[n][m]</code>，即前n个元素花了m元的情况</p>
<p>本题的临界值应该在<code>j == 0</code>的时候，也就是当预算刚好等于当前物品的价格，只有选自己一种选法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">101</span>][<span class="number">10050</span>], cost[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; cost[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] += dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= cost[i])</span><br><span class="line">                dp[i][j] += dp[i - <span class="number">1</span>][j - cost[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="滚动数组实现">滚动数组实现</h2>
<p>由于每次只需要前一个状态，可以去掉第一维的元素计数，只记录开销；但开销的遍历要变成逆序，不能和上述的二维数组一样正序</p>
<p>二维数组是按照不同情况分别记录，正序遍历并不会覆盖旧状态</p>
<p>而浓缩成一维后，若正序遍历，后续状态用到的旧状态都被你覆盖更新完了...</p>
<p>逆序遍历就能保证，每次状态转移方程用到的旧状态是原始的旧状态，并没有被覆盖更新</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">10050</span>], cost[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; cost[i];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= cost[i]; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] += dp[j - cost[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>P1255. 数楼梯</title>
    <url>/2023/10/09/P1255-%E6%95%B0%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>斐波那契</li>
<li>递推</li>
<li>高精度</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len_;</span><br><span class="line">    <span class="type">int</span> arr_[<span class="number">2500</span>];</span><br><span class="line">    <span class="built_in">BigInt</span>(string s = <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr_, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr_));</span><br><span class="line">        len_ = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">            arr_[i] += s[len_ - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr_[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len_ = x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr_[i + <span class="number">1</span>] += arr_[i] / <span class="number">10</span>;</span><br><span class="line">                arr_[i] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!arr_[len_])</span><br><span class="line">            --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, len_); i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">            cout &lt;&lt; arr_[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>+(BigInt a, BigInt b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">max</span>(a.len_, b.len_);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    c.<span class="built_in">flatten</span>(len + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">BigInt <span class="title">a</span><span class="params">(<span class="string">&quot;1&quot;</span>)</span>, <span class="title">b</span><span class="params">(<span class="string">&quot;2&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        a.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        b.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            BigInt c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        b.<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>每个状态都是由前状态和前前状态相加而成，典型的斐波那契数列呀！配合高精度直接递推计算即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>高精度</tag>
        <tag>斐波那契</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>P1228. 地毯填补问题</title>
    <url>/2023/10/11/P1228-%E5%9C%B0%E6%AF%AF%E5%A1%AB%E8%A1%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>分治</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> board[<span class="number">1025</span>][<span class="number">1025</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x_bg, <span class="type">int</span> x_ed, <span class="type">int</span> y_bg, <span class="type">int</span> y_ed, <span class="type">int</span> princess_x, <span class="type">int</span> princess_y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x_mid = (x_bg + x_ed) / <span class="number">2</span>, y_mid = (y_bg + y_ed) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (princess_x &lt;= x_mid &amp;&amp; princess_y &lt;= y_mid)</span><br><span class="line">    &#123; <span class="comment">// 公主在左上方</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, x_mid + <span class="number">1</span>, y_mid + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (x_bg == x_mid &amp;&amp; y_bg == y_mid)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//左上，右上，左下，右下四个方向更新各自的公主位置后，继续递归</span></span><br><span class="line">        <span class="built_in">f</span>(x_bg, x_mid, y_bg, y_mid, princess_x, princess_y);</span><br><span class="line">        <span class="built_in">f</span>(x_bg, x_mid, y_mid + <span class="number">1</span>, y_ed, x_mid, y_mid + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">f</span>(x_mid + <span class="number">1</span>, x_ed, y_bg, y_mid, x_mid + <span class="number">1</span>, y_mid);</span><br><span class="line">        <span class="built_in">f</span>(x_mid + <span class="number">1</span>, x_ed, y_mid + <span class="number">1</span>, y_ed, x_mid + <span class="number">1</span>, y_mid + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (princess_x &lt;= x_mid &amp;&amp; princess_y &gt; y_mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 公主在右上方</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, x_mid + <span class="number">1</span>, y_mid, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (x_bg == x_mid &amp;&amp; y_bg == y_mid)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">f</span>(x_bg, x_mid, y_bg, y_mid, x_mid, y_mid);</span><br><span class="line">        <span class="built_in">f</span>(x_bg, x_mid, y_mid + <span class="number">1</span>, y_ed, princess_x, princess_y);</span><br><span class="line">        <span class="built_in">f</span>(x_mid + <span class="number">1</span>, x_ed, y_bg, y_mid, x_mid + <span class="number">1</span>, y_mid);</span><br><span class="line">        <span class="built_in">f</span>(x_mid + <span class="number">1</span>, x_ed, y_mid + <span class="number">1</span>, y_ed, x_mid + <span class="number">1</span>, y_mid + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (princess_x &gt; x_mid &amp;&amp; princess_y &lt;= y_mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 公主在左下方</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, x_mid, y_mid + <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (x_bg == x_mid &amp;&amp; y_bg == y_mid)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">f</span>(x_bg, x_mid, y_bg, y_mid, x_mid, y_mid);</span><br><span class="line">        <span class="built_in">f</span>(x_bg, x_mid, y_mid + <span class="number">1</span>, y_ed, x_mid, y_mid + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">f</span>(x_mid + <span class="number">1</span>, x_ed, y_bg, y_mid, princess_x, princess_y);</span><br><span class="line">        <span class="built_in">f</span>(x_mid + <span class="number">1</span>, x_ed, y_mid + <span class="number">1</span>, y_ed, x_mid + <span class="number">1</span>, y_mid + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 公主在右下方</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, x_mid, y_mid, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (x_bg == x_mid &amp;&amp; y_bg == y_mid)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">f</span>(x_bg, x_mid, y_bg, y_mid, x_mid, y_mid);</span><br><span class="line">        <span class="built_in">f</span>(x_bg, x_mid, y_mid + <span class="number">1</span>, y_ed, x_mid, y_mid + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">f</span>(x_mid + <span class="number">1</span>, x_ed, y_bg, y_mid, x_mid + <span class="number">1</span>, y_mid);</span><br><span class="line">        <span class="built_in">f</span>(x_mid + <span class="number">1</span>, x_ed, y_mid + <span class="number">1</span>, y_ed, princess_x, princess_y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, princess_x, princess_y;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; princess_x &gt;&gt; princess_y;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>, <span class="built_in">pow</span>(<span class="number">2</span>, n), <span class="number">1</span>, <span class="built_in">pow</span>(<span class="number">2</span>, n), princess_x, princess_y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>经典的分治题</p>
<p>公主必出现在当前大正方形的左上，右上，左下，右下四个方位；那么大正方形中心填充的地毯缺口就会正对公主那个方位</p>
<p>因此，每一次都只需要填充当前大正方形的中心，然后分别向四个方位的四个小正方形递归</p>
<p>假设当前公主出现在左上方，那么填充中心的应当是1，随后向四个方位递归：</p>
<ul>
<li>公主坐标不变，向左上方递归，边界收缩；</li>
<li>公主坐标改为大正方形中心填充地毯的右上角部分，向右上方递归，边界收缩；</li>
<li>公主坐标改为大正方形中心填充地毯的左下角部分，向左下方递归，边界收缩；</li>
<li>公主坐标改为大正方形中心填充地毯的右下角部分，向右下方递归，边界收缩；</li>
</ul>
<p>循环往复，直到当前大正方形是<code>2 * 2</code>的规格，无法再分</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P1464. Function</title>
    <url>/2023/10/10/P1464-Function/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线性动态规划</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">ll mem[LEN][LEN][LEN];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">w</span><span class="params">(ll a, ll b, ll c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= <span class="number">0</span> || b &lt;= <span class="number">0</span> || c &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; <span class="number">20</span> || b &gt; <span class="number">20</span> || c &gt; <span class="number">20</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">w</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mem[a][b][c])</span><br><span class="line">        <span class="keyword">return</span> mem[a][b][c];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; b &amp;&amp; b &lt; c)</span><br><span class="line">        <span class="keyword">return</span> mem[a][b][c] = <span class="built_in">w</span>(a, b, c - <span class="number">1</span>) + <span class="built_in">w</span>(a, b - <span class="number">1</span>, c - <span class="number">1</span>) - <span class="built_in">w</span>(a, b - <span class="number">1</span>, c);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> mem[a][b][c] = <span class="built_in">w</span>(a - <span class="number">1</span>, b, c) + <span class="built_in">w</span>(a - <span class="number">1</span>, b - <span class="number">1</span>, c) + <span class="built_in">w</span>(a - <span class="number">1</span>, b, c - <span class="number">1</span>) - <span class="built_in">w</span>(a - <span class="number">1</span>, b - <span class="number">1</span>, c - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a, b, c;</span><br><span class="line">    <span class="keyword">while</span> ((cin &gt;&gt; a &gt;&gt; b &gt;&gt; c) &amp;&amp; (a != <span class="number">-1</span> || b != <span class="number">-1</span> || c != <span class="number">-1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;w(%lld, %lld, %lld) = %lld\n&quot;</span>, a, b, c, <span class="built_in">w</span>(a, b, c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>没有坑点，按照题意分配好记忆化搜索的语句即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P1498. 南蛮图腾</title>
    <url>/2023/10/11/P1498-%E5%8D%97%E8%9B%AE%E5%9B%BE%E8%85%BE/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>分治</li>
<li>字符串</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大长度为2048，高度为长度的一半</span></span><br><span class="line"><span class="type">char</span> table[<span class="number">1024</span>][<span class="number">2048</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2048</span>; ++j)</span><br><span class="line">            table[i][j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    table[<span class="number">1023</span>][<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>, table[<span class="number">1023</span>][<span class="number">1</span>] = table[<span class="number">1023</span>][<span class="number">2</span>] = <span class="string">&#x27;_&#x27;</span>, table[<span class="number">1023</span>][<span class="number">3</span>] = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line">    table[<span class="number">1022</span>][<span class="number">1</span>] = <span class="string">&#x27;/&#x27;</span>, table[<span class="number">1022</span>][<span class="number">2</span>] = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1024</span> - height; i &lt; <span class="number">1024</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; width; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; table[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, cnt = <span class="number">2</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> width = <span class="number">4</span>, height = width &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1024</span> - height; i &lt; <span class="number">1024</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; width; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//				向右复制</span></span><br><span class="line">                table[i][j + width] = table[i][j];</span><br><span class="line">                <span class="comment">//				向上复制</span></span><br><span class="line">                table[i - height][j + height] = table[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++cnt, width *= <span class="number">2</span>, height *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(width, height);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>划分子问题，每次把图腾向右复制和向上复制即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P1928. 外星密码</title>
    <url>/2023/10/10/P1928-%E5%A4%96%E6%98%9F%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
<li>字符串</li>
<li>分治</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            cin &gt;&gt; n;</span><br><span class="line">            string t = <span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">while</span> (n--)</span><br><span class="line">                s += t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">read</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>字符串的模拟题，先考虑逐个字符读入还是整行读入；很显然，本题应该选择逐字符读入</p>
<ul>
<li><p>由于每个闭合的<code>[]</code>实际上就是一个字符串，很容易联想到递归，每次处理完后返回结果字符串</p></li>
<li><p><code>[数字</code>就可以视作递归开始符，只要遇到了<code>[数字</code>就开启新的递归</p></li>
<li><p><code>]</code>可以视作递归结束符，只要遇到了它就返回当前递归的结果字符串</p></li>
<li><p>正常字母接在当前递归的结果字符串即可</p></li>
</ul>
<p>根据上述思路，就可以编写题解啦</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P1259. 黑白棋子的移动</title>
    <url>/2023/10/11/P1259-%E9%BB%91%E7%99%BD%E6%A3%8B%E5%AD%90%E7%9A%84%E7%A7%BB%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">550</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= N; ++i)</span><br><span class="line">        str[i] = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= <span class="number">2</span> * N; ++i)</span><br><span class="line">        str[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    str[i++] = <span class="string">&#x27;-&#x27;</span>, str[i] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * N + <span class="number">2</span>; ++i)</span><br><span class="line">        cout &lt;&lt; str[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> blank_idx = <span class="number">2</span> * N + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = N; i &gt; <span class="number">4</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(str[i], str[blank_idx]), <span class="built_in">swap</span>(str[i + <span class="number">1</span>], str[blank_idx + <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">print</span>();</span><br><span class="line">        <span class="built_in">swap</span>(str[i], str[blank_idx - <span class="number">2</span>]), <span class="built_in">swap</span>(str[i + <span class="number">1</span>], str[blank_idx - <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">print</span>();</span><br><span class="line">        blank_idx -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    单独处理只剩4个的时候</span></span><br><span class="line">    <span class="built_in">swap</span>(str[<span class="number">4</span>], str[blank_idx]), <span class="built_in">swap</span>(str[<span class="number">5</span>], str[blank_idx + <span class="number">1</span>]);</span><br><span class="line">    --blank_idx;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="built_in">swap</span>(str[<span class="number">4</span>], str[blank_idx]), <span class="built_in">swap</span>(str[<span class="number">5</span>], str[blank_idx + <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="built_in">swap</span>(str[<span class="number">2</span>], str[blank_idx]), <span class="built_in">swap</span>(str[<span class="number">3</span>], str[blank_idx + <span class="number">1</span>]);</span><br><span class="line">    --blank_idx;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="built_in">swap</span>(str[<span class="number">2</span>], str[blank_idx]), <span class="built_in">swap</span>(str[<span class="number">3</span>], str[blank_idx + <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="built_in">swap</span>(str[<span class="number">1</span>], str[blank_idx]), <span class="built_in">swap</span>(str[<span class="number">2</span>], str[blank_idx + <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">deal</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>纯粹的模拟题</p>
<p>每次两个空白格子和一对相邻的白黑棋子交换位置，然后两个空白格子的指针向前移，再换两个黑子即可，循环往复</p>
<p>只剩4个的时候单独处理即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P2437. 蜜蜂路线</title>
    <url>/2023/10/10/P2437-%E8%9C%9C%E8%9C%82%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>斐波那契</li>
<li>高精度</li>
<li>线性动态规划</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len_;</span><br><span class="line">    <span class="type">int</span> arr_[<span class="number">2500</span>];</span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr_[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(string s = <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr_, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr_));</span><br><span class="line">        len_ = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">            arr_[i] = s[len_ - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len_ = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr_[i + <span class="number">1</span>] += arr_[i] / <span class="number">10</span>;</span><br><span class="line">                arr_[i] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!arr_[len_])</span><br><span class="line">            --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, len_); i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">            cout &lt;&lt; arr_[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>+(BigInt a, BigInt b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">max</span>(a.len_, b.len_);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">        c[i] += a[i] + b[i];</span><br><span class="line">    c.<span class="built_in">flatten</span>(len + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="function">BigInt <span class="title">a</span><span class="params">(<span class="string">&quot;1&quot;</span>)</span>, <span class="title">b</span><span class="params">(<span class="string">&quot;1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n - m + <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        BigInt c;</span><br><span class="line">        c = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    b.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题目描述<strong>只能从标号小的蜂房爬到标号大的相邻蜂房</strong>，设<code>f[n]</code>为从1走到n的爬行路线，显然有状态转移方程：
<span class="math display">\[
f\left( n-1 \right) +f\left( n-2 \right) \rightarrow f\left( n \right)
\]</span>
典型的斐波那契数列！但题目是要求从m走到n，而斐波那契数列是从1开始的</p>
<p>所以应该从3执行到n-m+1（斐波那契数列的第1、第2已经设置为1了）</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>高精度</tag>
        <tag>斐波那契</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P3612. Secret Cow Code S</title>
    <url>/2023/10/11/P3612-Secret-Cow-Code-S/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>分治</li>
<li>字符串</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    ll n, len;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; n;</span><br><span class="line">    len = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">while</span> (len &lt; n)</span><br><span class="line">        len *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &gt; s.<span class="built_in">length</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; len / <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == len / <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">                n = len / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                n -= len / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>典型的分治题</p>
<p>题目大意是说，每次Copy一份当前字符串，把它最后一个字母挪到最前面，再接到原字符串后面，循环往复</p>
<p>假设原字符串为a，复制的字符串为b，那么每个字符串都是由a+b的格式组成的</p>
<p>先求出n所在字符串的长度len，然后进行以下判断：</p>
<ul>
<li>n的位置在len/2及以内，说明是在原字符串a，那么n不变</li>
<li>n的位置大于len/2，将其位置映射到a中</li>
<li>len除以2</li>
<li>循环往复，直到len等于最初始的字符串长度</li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P1990. 覆盖墙壁</title>
    <url>/2023/10/11/P1990-%E8%A6%86%E7%9B%96%E5%A2%99%E5%A3%81/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>递推</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, prefix[LEN], dp[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>, prefix[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = (prefix[i - <span class="number">1</span>] + (i &lt; <span class="number">3</span> ? <span class="number">0</span> : prefix[i - <span class="number">3</span>])) % <span class="number">10000</span>;</span><br><span class="line">        prefix[i] = (prefix[i - <span class="number">1</span>] + dp[i]) % <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>看这篇大佬的<a
href="https://www.luogu.com.cn/blog/222223/solution-p1990">思路</a></p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>P1080. 国王游戏</title>
    <url>/2023/10/15/P1080-%E5%9B%BD%E7%8E%8B%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>贪心</li>
<li>高精度</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e4</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len_;</span><br><span class="line">    <span class="type">int</span> arr_[<span class="number">10500</span>];</span><br><span class="line">    <span class="built_in">BigInt</span>(<span class="type">int</span> x = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr_, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr_));</span><br><span class="line">        <span class="keyword">for</span> (len_ = <span class="number">1</span>; x; ++len_)</span><br><span class="line">            arr_[len_] = x % <span class="number">10</span>, x /= <span class="number">10</span>;</span><br><span class="line">        --len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr_[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, len_); i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; arr_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len_ = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr_[i + <span class="number">1</span>] += arr_[i] / <span class="number">10</span>;</span><br><span class="line">                arr_[i] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!arr_[len_])</span><br><span class="line">            --len_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>*(BigInt a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">int</span> len = a.len_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += a[i] * b;</span><br><span class="line">    &#125;</span><br><span class="line">    c.<span class="built_in">flatten</span>(len + <span class="number">11</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">greater_eq</span><span class="params">(BigInt a, BigInt b, <span class="type">int</span> lst_dg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lst_dg &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[lst_dg + b.len_] != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.len_; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[lst_dg + i - <span class="number">1</span>] &gt; b[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[lst_dg + i - <span class="number">1</span>] &lt; b[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>/(BigInt a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt c;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.len_; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += (r * <span class="number">10</span> + a[i]) / b;</span><br><span class="line">        r = (r * <span class="number">10</span> + a[i]) % b;</span><br><span class="line">    &#125;</span><br><span class="line">    c.<span class="built_in">flatten</span>(a.len_);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a_, b_;</span><br><span class="line">&#125; arr[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i].a_ &gt;&gt; arr[i].b_;</span><br><span class="line">    <span class="built_in">sort</span>(arr + <span class="number">1</span>, arr + <span class="number">1</span> + n, [](Node a, Node b) -&gt; <span class="type">bool</span></span><br><span class="line">         &#123; <span class="built_in">return</span> (<span class="number">1ll</span> * a.a_ * a.b_) &lt; (<span class="number">1ll</span> * b.a_ * b.b_); &#125;);</span><br><span class="line">    <span class="function">BigInt <span class="title">mul</span><span class="params">(arr[<span class="number">0</span>].a_)</span>, ans, div</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        div = mul / arr[i].b_;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">greater_eq</span>(ans, div, ans.len_ - div.len_ + <span class="number">1</span>))</span><br><span class="line">            ans = div;</span><br><span class="line">        mul = mul * arr[i].a_;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题眼有<strong>获得奖赏最多的大臣，所获奖赏尽可能的少</strong>，很容易想到以下几种可能</p>
<ul>
<li>二分，但是貌似没有可以二分的东西...</li>
<li>状压DP，但是状态存不下啊啊...</li>
<li>贪心</li>
</ul>
<p>贪心主要分析单调性，所以将视角放在相邻两个元素；假设有相邻位置<code>i &lt; j</code>，<code>i</code>之前的总乘积为<code>S</code></p>
<p>当前两个位置的大臣各自所获金币的最大值V<sub>1</sub>，两个大臣的位置交换后，各自所获金币的最大值V<sub>2</sub></p>
<p>根据题意，以V<sub>1</sub> &lt; V<sub>2</sub>的优先级进行重新排序
<span class="math display">\[
\text{交换之前，}\max \left(
\underset{i\text{位置}}{\underbrace{\frac{S}{b_i}}}\,\,_{,}^{\,\,}\underset{j\text{位置}}{\underbrace{\frac{S\times
a_i}{b_j}}} \right) =V_1
\\
\text{交换之后，}\max \left(
\underset{i\text{位置}}{\underbrace{\frac{S}{b_j}}}\,\,_{,}^{\,\,}\underset{j\text{位置}}{\underbrace{\frac{S\times
a_j}{b_i}}} \right) =V_2
\]</span> 两边都可以约去<code>S</code>，变成 <span
class="math display">\[
\max \left( \frac{1}{b_i}_{,}^{\,\,}\frac{a_i}{b_j} \right) &lt;\max
\left( \frac{1}{b_j}_{,}^{\,\,}\frac{a_j}{b_i} \right)
\]</span> 两边通分一下，变成 <span class="math display">\[
\max \left( b_j\,\,, a_i\times b_i \right) &lt;\max \left( b_i\,\,,
a_j\times b_j \right)
\]</span>
设a<sub>i</sub>，b<sub>i</sub>，a<sub>j</sub>，b<sub>j</sub>分别为A、B、C、D，式子可以简化为
<span class="math display">\[
\max \left( D\,\,, A\cdot B \right) &lt;\max \left( B\,\,, C\cdot D
\right)
\]</span>
如果右侧式子B为最大，即B大于C乘D；由于A只能为正整数，那么A乘B也大于D，两侧式子就变成了：
<span class="math display">\[
A\cdot B&lt;B
\]</span>
这可能吗？所以B可以直接去掉，左侧的D也同理直接去掉，就得到了最终的贪心单调性
<span class="math display">\[
A\cdot B&lt;C\cdot D
\]</span></p>
<p><span class="math display">\[
a_i\cdot b_i&lt;a_j\cdot b_j\,\,, i&lt;j
\]</span></p>
<p>剩下的部分就不难了，套高精度乘低精度以及高精度除低精度的模板即可</p>
<p>这里不能用高精除高精的模板！！！！会超时！！！！</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>高精度</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P1090. 合并果子</title>
    <url>/2023/10/12/P1090-%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>贪心</li>
<li>堆</li>
<li>优先队列</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v_;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> v = <span class="number">0</span>) : <span class="built_in">v_</span>(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;a, <span class="type">const</span> Node &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.v_ &gt; b.v_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, in;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; in;</span><br><span class="line">        q.<span class="built_in">emplace</span>(<span class="built_in">Node</span>(in));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a, b, t, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = q.<span class="built_in">top</span>().v_, q.<span class="built_in">pop</span>();</span><br><span class="line">        b = q.<span class="built_in">top</span>().v_, q.<span class="built_in">pop</span>();</span><br><span class="line">        ans += (t = a + b);</span><br><span class="line">        q.<span class="built_in">emplace</span>(<span class="built_in">Node</span>(t));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>哈夫曼树的模板题</p>
<p>根据本题要求，能做到插入和弹出都做到有序的，只有堆（或者叫优先队列）</p>
<p>C++的<code>priority_queue</code>排序实现略有反人类，默认比较仍是<code>&lt;</code>，但却是大根堆....（降序排列，正常都是升序排列）</p>
<p>所以需要新建一个结构体，并重载<code>&lt;</code>，内部的排序规则反着来就行</p>
<p>我们要求升序，但是在这里就需要写成降序的样子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;a, <span class="type">const</span> Node &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.v_ &gt; b.v_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>P1106. 删数问题</title>
    <url>/2023/10/12/P1106-%E5%88%A0%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>贪心</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, cnt = <span class="number">0</span>;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (s.<span class="built_in">length</span>() &amp;&amp; cnt &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, pre = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; s.<span class="built_in">length</span>() &amp;&amp; s[i] - <span class="string">&#x27;0&#x27;</span> &gt;= pre; ++i)</span><br><span class="line">            pre = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        s.<span class="built_in">erase</span>(i - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (s.<span class="built_in">length</span>() &gt; <span class="number">1</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        s.<span class="built_in">erase</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>假设当前是数字<code>a</code>，后面一位是数字<code>b</code>，若<code>b &lt; a</code>，则<code>a</code>应该被删除</p>
<p>道理很简单，因为后面一个数更小的话，相同位数的情况下，用它来填充前一个位置生成的数显然会更小</p>
<blockquote>
<p>比如数字154，用4覆盖5的位置生成的数为144</p>
</blockquote>
<p>所以每次从头开始找升序序列，删除升序序列的最后一位即可</p>
<p>记得处理结果<strong>前导0</strong>以及<strong>只剩0</strong>的两种特殊情况</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P1094. 纪念品分组</title>
    <url>/2023/10/13/P1094-%E7%BA%AA%E5%BF%B5%E5%93%81%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>贪心</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">3e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum, n;</span><br><span class="line">    cin &gt;&gt; sum &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + n);</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>, ans = <span class="number">0</span>, l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// flag控制r独立分组的情况</span></span><br><span class="line">        s = arr[l];</span><br><span class="line">        <span class="type">int</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; s + arr[r] &lt;= sum)</span><br><span class="line">        &#123;</span><br><span class="line">            s += arr[r];</span><br><span class="line">            --r;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag == <span class="literal">false</span> ? --r : ++l;</span><br><span class="line">        ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (l == r ? ++ans : ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>不严谨的贪心题....要分组尽可能少，有两种选择：</p>
<ul>
<li>每次选较大和较小的，然后一直选较小的</li>
<li>每次选较大和较小的，然后一直选较大的</li>
</ul>
<p>第一种方案实现如下，但是WA了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">3e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum, n;</span><br><span class="line">    cin &gt;&gt; sum &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + n);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mx = arr[r];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; mx + arr[l] &lt;= sum)</span><br><span class="line">            mx += arr[l++];</span><br><span class="line">        --r;</span><br><span class="line">        ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[l] &lt;= sum)</span><br><span class="line">        ++ans;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>第二种方案实现就如题解；主要难点在于边界值的处理，因为还有<code>l &gt;= r</code>的情况要补充：</p>
<ul>
<li>如果两个指针正常运行，最终会在中间某处相遇，此刻<code>l == r</code>；那么最终结果要加1</li>
<li>如果全都合为一组，最终<code>r == 0, l == 1</code>；但这种情况已经计算过了，结果不变</li>
<li>如果全都自成一组，最终<code>r == 0, l == 0</code>；那么最终结果要加1</li>
</ul>
<p>综上，输出结果前补充一下<code>l == r</code>的情况即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P1223. 排队接水</title>
    <url>/2023/10/12/P1223-%E6%8E%92%E9%98%9F%E6%8E%A5%E6%B0%B4/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>贪心</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1050</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t_, id_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i].t_;</span><br><span class="line">        arr[i].id_ = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + n, [](Node a, Node b) -&gt; <span class="type">bool</span></span><br><span class="line">         &#123; <span class="keyword">return</span> a.t_ &lt; b.t_; &#125;);</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i].id_ &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        sum += arr[i].t_ * (n - i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl</span><br><span class="line">         &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; sum / n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>排队接水，显然前面的人用时越短，后面的人等的时间就越短</p>
<blockquote>
<p>因为大家都站着等你呐！</p>
</blockquote>
<p>题目这里表达不算清晰，求的是<strong>除每次打水的人之外，其余人等待时间的平均值</strong></p>
<p>所以计算的时候本人打水时间不要算进去</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P1208. 混合牛奶 Mixing Milk</title>
    <url>/2023/10/13/P1208-%E6%B7%B7%E5%90%88%E7%89%9B%E5%A5%B6-Mixing-Milk/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>贪心</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p_, a_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i].p_ &gt;&gt; arr[i].a_;</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + m, [](Node &amp;a, Node &amp;b) -&gt; <span class="type">bool</span></span><br><span class="line">         &#123; <span class="keyword">return</span> a.p_ &lt; b.p_; &#125;);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= arr[i].a_)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += arr[i].a_ * arr[i].p_;</span><br><span class="line">            n -= arr[i].a_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans += n * arr[i].p_;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>基础的贪心题，按单价升序排序即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P1478. 陶陶摘苹果（升级版）</title>
    <url>/2023/10/12/P1478-%E9%99%B6%E9%99%B6%E6%91%98%E8%8B%B9%E6%9E%9C%EF%BC%88%E5%8D%87%E7%BA%A7%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>贪心</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">5050</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x_, y_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, s, a, b;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i].x_ &gt;&gt; arr[i].y_;</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + n, [](Node &amp;a, Node &amp;b) -&gt; <span class="type">bool</span></span><br><span class="line">         &#123; <span class="keyword">return</span> a.y_ &lt; b.y_; &#125;);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, h = a + b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; s; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (h &gt;= arr[i].x_ &amp;&amp; s &gt;= arr[i].y_)</span><br><span class="line">        &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            s -= arr[i].y_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>每次摘力气消耗最少的苹果即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P1803. 凌乱的yyy/线段覆盖</title>
    <url>/2023/10/12/P1803-%E5%87%8C%E4%B9%B1%E7%9A%84yyy-%E7%BA%BF%E6%AE%B5%E8%A6%86%E7%9B%96/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>贪心</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> bg_, ed_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i].bg_ &gt;&gt; arr[i].ed_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + n, [](Node a, Node b) -&gt; <span class="type">bool</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span> (a.ed_ != b.ed_)</span><br><span class="line">                 <span class="keyword">return</span> a.ed_ &lt; b.ed_;</span><br><span class="line">             <span class="keyword">return</span> a.bg_ &lt; b.bg_;</span><br><span class="line">         &#125;);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, pre = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i].bg_ &gt;= pre)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = arr[i].ed_;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>要让参加活动最多，显然应该先参与结束时间最早的，宏观上能给后面的活动空出尽可能多的时间</p>
<p>如果结束时间相同，那同理应该先参与开始时间最早的</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P2240. 部分背包问题</title>
    <url>/2023/10/12/P2240-%E9%83%A8%E5%88%86%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>贪心</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_, v_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i].m_ &gt;&gt; arr[i].v_;</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + n, [](Node a, Node b) -&gt; <span class="type">bool</span></span><br><span class="line">         &#123; <span class="keyword">return</span> a.v_ * b.m_ &gt; b.v_ * a.m_; &#125;);</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t &gt;= arr[i].m_)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += arr[i].v_;</span><br><span class="line">            t -= arr[i].m_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans += <span class="number">1.0</span> * arr[i].v_ * t / arr[i].m_;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>价值尽可能多，且金币可以再分；所以不需要DP，典型的贪心算法</p>
<p>每次选单位价格最大的就行，直到该种金币用完再继续下一个</p>
<p>注意，为了避免除法带来的精度误差，转用乘法进行比较 <span
class="math display">\[
\frac{v_1}{m_1}&gt;\frac{v_2}{m_2}\rightarrow v_1\cdot m_2&gt;m_1\cdot
v_2
\]</span></p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P3817. 小A的糖果</title>
    <url>/2023/10/12/P3817-%E5%B0%8FA%E7%9A%84%E7%B3%96%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>贪心</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">ll arr[LEN], pivot, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ll &amp;pre, ll &amp;nxt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll sum = pre + nxt, diff = sum - pivot;</span><br><span class="line">    <span class="keyword">if</span> (diff &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    nxt -= diff;</span><br><span class="line">    <span class="keyword">if</span> (nxt &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pre += nxt;</span><br><span class="line">        nxt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += sum - (pre + nxt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; pivot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="built_in">f</span>(arr[i], arr[i + <span class="number">1</span>]);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>每次两两比较时，只吃后面那盒；如果后面那盒吃成了负数，再从前面那盒拿糖</p>
<p>因为根据题眼<strong>任意两个相邻</strong>，当前的后面那盒糖会继续被下次比较使用，尽可能降低它的糖数可减少后续的开销</p>
<p>记得开<code>long long</code></p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P4995. 跳跳！</title>
    <url>/2023/10/13/P4995-%E8%B7%B3%E8%B7%B3%EF%BC%81/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>贪心</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">350</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cost</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(arr[r] - arr[l], <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr + <span class="number">1</span>, arr + n + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n, dir = <span class="number">1</span>;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += <span class="built_in">cost</span>(l, r);</span><br><span class="line">        <span class="keyword">if</span> (dir)</span><br><span class="line">            ++l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            --r;</span><br><span class="line">        dir ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>基础的贪心题，每次从较小的跳到较大的，再从较大的跳到较小的即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P4447. 分组</title>
    <url>/2023/10/13/P4447-%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>贪心</li>
<li>二分</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt, in[LEN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//每组的最后一个数字，组的长度</span></span><br><span class="line">    <span class="type">int</span> ed_, len_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary_search</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = cnt - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//每次将值插入到右边界，保证单调性</span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid].ed_ &lt;= x - <span class="number">1</span>)</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[r].ed_ != x - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, idx;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; in[i];</span><br><span class="line">    <span class="built_in">sort</span>(in, in + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((idx = <span class="built_in">binary_search</span>(in[i])) == <span class="number">-1</span>)</span><br><span class="line">            arr[cnt].ed_ = in[i], arr[cnt++].len_ = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            arr[idx].ed_ = in[i], ++arr[idx].len_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i)</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, arr[i].len_);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>又是一道经典的贪心好题，以输入<code>&#123;-3, -3, -2, -2, -1, 0, 1, 1, 2, 2, 3&#125;</code>为例；题眼有<strong>连续</strong>二字，先排序方便处理</p>
<p>题眼有<strong>使得人数最少的组人数最多</strong>，乍一看还以为是考二分；但本质上是贪心策略</p>
<p>因为重复的数字若不加处理，只能孤立；题目是想让我们尽可能地把原本孤立的数并到其他组里去</p>
<p>根据题意，每个组都是连续的，也就是升序；重复的数也是按序并入组内，所以用结构体记录每个组的最后一个及组的长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//每组的最后一个数字，组的长度</span></span><br><span class="line">    <span class="type">int</span> ed_, len_;</span><br><span class="line">&#125; arr[LEN];</span><br></pre></td></tr></table></figure>
<p>贪心策略也很明朗：</p>
<ul>
<li>遍历结构体数组，在满足<strong>最后一位数字等于当前数字减1</strong>的组中，将当前数插入到长度最小的</li>
<li>否则新建一个组</li>
</ul>
<p>纯暴力遍历结构体数组会超时；考虑到我们是对输入排序了的，且从小到大进行操作；每个组也是升序排列</p>
<p>那么只要保证结构体数组的下标从小到大时，每个组的最后一位数字形成的序列也是升序，即可通过二分来达到<span
class="math inline">\(O\left( \log n \right)\)</span>的遍历复杂度</p>
<p>所以，在进行二分查找时，应该寻找并插入的是右边界，这样才能维护单调性</p>
<p>并且，我们每次新建的组也处在右边界的位置，相同条件下新建组的长度更小，被插入的优先级也理应更高</p>
<hr />
<p>按照上述例子，假设此刻要插入-1，请问选择左边界下标0还是右边界下标1的组呢？当然是右边界下标1啦</p>
<img src="/2023/10/13/P4447-%E5%88%86%E7%BB%84/1.png" class="" title="image-20231013230831919">
<p>如果每次选择的是左边界，即下标0；结构体数组下标从小到大，每个组的最后一位数字形成的序列就不是单调的了，也就无法进行二分</p>
<p>如下图所示，此时形成的序列是<code>1, -2, 1</code>，没有单调性</p>
<img src="/2023/10/13/P4447-%E5%88%86%E7%BB%84/2.png" class="" title="image-20231013231359984">
<p>如果选择右边界，形成的序列为<code>-2, 1, 1</code>，依旧遵守单调性！</p>
<img src="/2023/10/13/P4447-%E5%88%86%E7%BB%84/3.png" class="" title="image-20231013232118154">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心_解题技巧</title>
    <url>/2023/10/15/%E8%B4%AA%E5%BF%83-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>贪心与动态规划一直被津津乐道，它俩的共同点都是从状态之间的关联性下手</p>
<p><strong>贪心是寻找状态之间的单调性，动态规划是寻找状态之间的转移方程</strong>；<strong>本质上都是求状态间的关联性！</strong></p>
<p><strong>若能证明问题本身完全具有单调性，可以使用贪心求解；若单纯使用单调性并不能覆盖所有情况，就要考虑动态规划</strong></p>
<p>题目本身就蕴藏着单调性规律，可以见<a
href="https://www.luogu.com.cn/problem/P5019">铺设道路</a>以及哈夫曼树的<a
href="https://www.luogu.com.cn/problem/P1090">模板题</a></p>
<p>但绝大部分的难题比如<a
href="https://www.luogu.com.cn/problem/P1080">国王游戏</a>，需要根据题意比较相邻元素，它们位置交换前后的单调性差异求出单调性规律</p>
<p>又或者像<a
href="https://www.luogu.com.cn/problem/P4447">分组</a>，在操作的过程中不破坏元素间的单调性规律</p>
<p>一般贪心的数据范围比DP要大得多，可以作为小提示来选择</p>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P5019. 铺设道路</title>
    <url>/2023/10/13/P5019-%E9%93%BA%E8%AE%BE%E9%81%93%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>贪心</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, ans = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    ans = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[i - <span class="number">1</span>])</span><br><span class="line">            ans += arr[i] - arr[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>绝对经典的超级贪心好题！</p>
<p>考虑以下情况</p>
<img src="/2023/10/13/P5019-%E9%93%BA%E8%AE%BE%E9%81%93%E8%B7%AF/1.png" class="" title="image-20231013003617947">
<p>正常思路，每次找到最小的深度，并将其所在的连续区间一起填平....线段树都搞不定的啊，绝对超时</p>
<p>先按照题意模拟一遍：</p>
<p>6号位填平，1-7号位一起减1，天数加1</p>
<img src="/2023/10/13/P5019-%E9%93%BA%E8%AE%BE%E9%81%93%E8%B7%AF/2.png" class="" title="image-20231013004508004">
<p>3号位填平，1-5号位一起减1，天数加1</p>
<img src="/2023/10/13/P5019-%E9%93%BA%E8%AE%BE%E9%81%93%E8%B7%AF/3.png" class="" title="image-20231013004635372">
<p>然后1-2号位需要2天，4-5号位需要2天，7号位需要4天；一共的开销如下：
<span class="math display">\[
\underset{\text{填平}6\text{号}}{1}+\underset{\text{填平}3\text{号}}{1}+\underset{\text{填平}1-2\text{号}}{2}+\underset{\text{填平}4-5\text{号}}{3}+\underset{\text{填平}7\text{号}}{4}
\]</span>
显然可以发现，降序的连续序列的天数开销，取决于最大的那一位；所以作图如下：</p>
<ul>
<li><p>1-3号位组成的降序序列A，天数取决于1号位</p></li>
<li><p>4-6号位组成的降序序列B，天数取决于4号位</p></li>
<li><p>7号位组成的降序序列C，天数取决于7号位</p></li>
</ul>
<img src="/2023/10/13/P5019-%E9%93%BA%E8%AE%BE%E9%81%93%E8%B7%AF/4.png" class="" title="image-20231013010037532">
<p>得知A、B、C内部的天数开销还不算完，A过渡到B序列中间那部分的升序序列开销还需要计算，即3号位到4号位</p>
<p>3号位填平了2个单位，作为与3号位连续的4号位，也会被填平2个单位，还有<code>5 - 2 = 3</code>个单位需要被填平，即3天</p>
<p>又由于4号位代表的就是整个B序列的天数开销，所以B序列的开销就是3天；同理6-7号位的升序序列，开销为<code>5 - 1 = 4</code>天</p>
<p>整体的开销如下： <span class="math display">\[
\underset{A\text{序列的开销}}{4}+\underset{B\text{序列的开销}}{3}+\underset{C\text{序列的开销}}{4}
\]</span>
接下来难度升级一下，如果输入是<code>&#123;4, 3, 2, 5, 6, 1, 5&#125;</code>呢？答案是多少天？</p>
<img src="/2023/10/13/P5019-%E9%93%BA%E8%AE%BE%E9%81%93%E8%B7%AF/5.png" class="" title="image-20231013013438587">
<ul>
<li><p>A降序部分取决于1号位</p>
<p>而1号位之前没有东西，那么A降序开销即为<code>4</code>天</p></li>
<li><p>B升序这部分，3号位给4号位填平了2个单位，那么4号位还剩<code>5 - 2 = 3</code>天</p>
<p>3、4号位一共给5号位填平了5个单位，那么5号位还剩<code>6 - 5 = 1</code>天</p>
<p>所以B升序开销为<code>3 + 1 = 4</code>天</p></li>
<li><p>C降序这部分取决于5号位，而刚才B升序已经计算了5号位的开销，所以C降序不作计算</p></li>
<li><p>D升序这部分，6号位给7号位填平了1个单位，7号位还剩<code>5 - 1 = 4</code>天</p>
<p>所以D升序开销为<code>4</code>天</p></li>
<li><p>共计<code>4 + 4 + 4 = 12</code>天</p></li>
</ul>
<hr />
<p>之所以说这是贪心好题，因为它将贪心的精髓，<strong>单调性</strong>发挥到了极致（升序和降序序列的发现，极大降低了思考维度）</p>
<p>贪心与动态规划一直被津津乐道，它俩的共同点都是从状态之间的关联性下手</p>
<p><strong>贪心是寻找状态之间的单调性，动态规划是寻找状态之间的转移方程</strong></p>
<p><strong>本质上都是求状态间的关联性！</strong></p>
<p><strong>若能证明问题本身完全具有单调性，可以使用贪心求解；若单纯使用单调性并不能覆盖所有情况，就要考虑动态规划</strong></p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P1024. 一元三次方程求解</title>
    <url>/2023/10/16/P1024-%E4%B8%80%E5%85%83%E4%B8%89%E6%AC%A1%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>二分</li>
<li>分治</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eps 1e-4</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> A, B, C, D;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A * <span class="built_in">pow</span>(x, <span class="number">3</span>) + B * <span class="built_in">pow</span>(x, <span class="number">2</span>) + C * x + D;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf &quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; D;</span><br><span class="line">    <span class="type">double</span> l, r, mid, a, b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">double</span> x = <span class="number">-100</span>; x &lt; <span class="number">100</span>; ++x)</span><br><span class="line">    &#123;</span><br><span class="line">        l = x, r = x + <span class="number">1</span>, a = <span class="built_in">f</span>(l), b = <span class="built_in">f</span>(r);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a) &lt; eps)</span><br><span class="line">            <span class="built_in">print</span>(l);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">fabs</span>(b) &lt; eps)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a * b &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">            &#123;</span><br><span class="line">                mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (a * <span class="built_in">f</span>(mid) &gt; <span class="number">0</span>)</span><br><span class="line">                    l = mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print</span>(mid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>二分应用的模板题</p>
<p>根在<code>-100~100</code>的范围内，且根与根之间的绝对值大于等于1；可以将整体拆分为若干个区间长度为1的子区间进行二分求解</p>
<p>那么二分的左端点<code>l</code>范围从-100到99，右端点<code>r</code>就比<code>l</code>多1即可</p>
<p>根据<a
href="https://baike.baidu.com/item/%E9%9B%B6%E5%80%BC%E5%AE%9A%E7%90%86?fromModule=lemma_search-box">零值定理</a>可知，在一个区间内进行二分</p>
<p>若左右两端同朝一个点无限逼近（即右端点<code>r</code>与左端点<code>l</code>之间的距离小于某精度）且过程中两端函数值均异号，该点就是零点</p>
<p>那么二分中的<code>l</code>，<code>r</code>与中点<code>mid</code>该如何变换呢？</p>
<p>如果中点的函数值和某端点的正负性相同，那么零点一定在中点的另一侧</p>
<img src="/2023/10/16/P1024-%E4%B8%80%E5%85%83%E4%B8%89%E6%AC%A1%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/1.png" class="" title="image-20231016161519660">
<p>当然，还有特殊情况：</p>
<ul>
<li>左端点就是零点，输出这个零点</li>
<li>右端点就是零点，直接<code>continue</code>进行下一次（因为当前区间的右端点，就是下一轮区间的左端点）</li>
<li>左右端点都是零点，该情况和左端点情况相同</li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>P1102. A-B 数对</title>
    <url>/2023/10/16/P1102-A-B-%E6%95%B0%E5%AF%B9/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>二分</li>
<li>双指针</li>
<li>排列组合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<h2 id="乘法原理">乘法原理</h2>
<p>换个角度看，题目实际上是问你<code>B + C = A</code>的数对个数，</p>
<p>且题目规定C不为0，那么就不需要考虑B等于A的特殊情况，</p>
<p>由于<strong>不同位置的数字一样的数对算不同的数对</strong>，直接记录B与A的个数，符合条件的两者个数相乘即可，</p>
<p>为了防止计算重复，应从小到大找；记得开<code>long long</code>！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n, c, x;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; x, ++mp[x];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i : mp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mp.<span class="built_in">count</span>(i.first + c)) ans += <span class="number">1ll</span> * i.second * mp[i.first + c];</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分">二分</h2>
<p>根据<code>a = b + c</code>，排序后枚举b，以二分查找的形式得到满足条件的a个数，累加即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, c, x, arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; arr[i];</span><br><span class="line">  <span class="built_in">sort</span>(arr, arr + n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    ans += <span class="built_in">upper_bound</span>(arr, arr + n, arr[i] + c) -</span><br><span class="line">           <span class="built_in">lower_bound</span>(arr, arr + n, arr[i] + c);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双指针">双指针</h2>
<p>根据<code>a - c = b</code>，排序后可通过枚举<code>a</code>来得到<code>b</code>的值，且<code>b</code>一定小于<code>a</code>；所以用双指针来维护<code>b</code>出现的区间，</p>
<p>左边界<code>arr[l]</code>为第一个小于等于<code>b</code>，右边界<code>arr[r]</code>为第一个大于<code>b</code>，对于<code>b</code>来说是左闭右开区间，</p>
<p>这样一来，如果<code>arr[l] == b</code>，那么<code>r - l</code>显然就是<code>b</code>的个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, l, r, c, arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; arr[i];</span><br><span class="line">  <span class="built_in">sort</span>(arr, arr + n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> a = arr[i], b = a - c;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; n &amp;&amp; b &gt; arr[l]) ++l;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; n &amp;&amp; arr[r] &lt;= b) ++r;</span><br><span class="line">    <span class="keyword">if</span> (arr[l] == b) ans += r - l;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>排列组合</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>P1182. 数列分段 Section II</title>
    <url>/2023/10/18/P1182-%E6%95%B0%E5%88%97%E5%88%86%E6%AE%B5-Section-II/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>二分</li>
<li>前缀和</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, M, pre[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre[r] - pre[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt;= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sum</span>(r, l) &lt;= x)</span><br><span class="line">            ++r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="keyword">if</span> (l == r)</span><br><span class="line">                ++r;</span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ++cnt &lt;= M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="type">int</span> mx = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, in; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; in;</span><br><span class="line">        pre[i] = in + pre[i - <span class="number">1</span>];</span><br><span class="line">        mx = <span class="built_in">max</span>(mx, in);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = mx, r = pre[N];</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; l;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题眼<strong>每段和的最大值最小</strong>，使用二分进行求解；二分的对象就是区间和</p>
<ul>
<li>按当前区间和划分的段数大于需求，说明设定的区间和太小了，应该向右端点移动</li>
<li>等于需求，向左端点移动</li>
<li>小于需求，说明设定的区间和太大了，应向左端点移动</li>
</ul>
<p>还有两个注意点：</p>
<ul>
<li><p>通篇都是在求各个子区间的和，所以用前缀和数组进行优化；重复计算很容易超时</p></li>
<li><p>二分的左端点应该等于数组中的最大元素，否则最大的元素不能成为独立的区间导致答案错误</p>
<p>假设有案例如下，如果左端点从1开始答案会得到错误的1，很显然应该得到2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>P1163. 银行贷款</title>
    <url>/2023/10/18/P1163-%E9%93%B6%E8%A1%8C%E8%B4%B7%E6%AC%BE/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>二分</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> W0, W, M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>, p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">double</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p *= (<span class="number">1</span> + x);</span><br><span class="line">        sum += W / p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum &lt;= W0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; W0 &gt;&gt; W &gt;&gt; M;</span><br><span class="line">    <span class="type">double</span> l = <span class="number">0</span>, r = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>, l * <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>这道题在考验金融知识啊....推荐看这篇<a
href="https://www.cnblogs.com/hellohebin/p/17245774.html">博客</a></p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>P1678. 烦恼的高考志愿</title>
    <url>/2023/10/16/P1678-%E7%83%A6%E6%81%BC%E7%9A%84%E9%AB%98%E8%80%83%E5%BF%97%E6%84%BF/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>二分</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n, in, idx;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + m);</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; in;</span><br><span class="line">        <span class="type">int</span> a = arr[idx = <span class="built_in">lower_bound</span>(arr, arr + m, in) - arr];</span><br><span class="line">        <span class="type">int</span> b = arr[idx == <span class="number">0</span> ? idx : idx - <span class="number">1</span>];</span><br><span class="line">        ans += <span class="built_in">min</span>(<span class="built_in">abs</span>(in - a), <span class="built_in">abs</span>(in - b));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题目实际上的含义，是每次输入一个数，要你找另外两个数：</p>
<ul>
<li>第一个大于等于它的数。<code>lower_bound</code>就可以做到</li>
<li>小于它的数中最大（或者说仅次于它）的数。<code>lower_bound</code>结果的前一位就是</li>
</ul>
<p>然后比较这两个数谁与输入的数差值最小即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>P1873. EKO  砍树</title>
    <url>/2023/10/16/P1873-EKO-%E7%A0%8D%E6%A0%91/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>二分</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, M, arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>, diff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        ans += (diff = arr[i] - x) &lt;= <span class="number">0</span> ? <span class="number">0</span> : diff;</span><br><span class="line">    <span class="keyword">return</span> ans &gt;= M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; r;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>当满足木材的要求时，木机锯片要尽可能地高；要么是DP或贪心，要么是二分！这里很显然没有状态转移与单调性，所以只能是二分</p>
<p>锯片高度从0 ~
1e9，那么就二分锯片高度，每次判断当前高度下的木材，时间复杂度也只有<span
class="math inline">\(O\left( n\log n \right)\)</span>：</p>
<ul>
<li>如果木材多了，说明锯片高度过低了，向右边界移动</li>
<li>如果木材恰好满足需求，也要向右边界移动（因为题目说尽可能地高）</li>
<li>如果木材少了，说明锯片高度过高了，向左边界移动</li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>P2249. 查找</title>
    <url>/2023/10/15/P2249-%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>二分</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary_search</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= x)</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[l] == x)</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m, in;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; in;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">binary_search</span>(in, n) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>直接找左边界即可</p>
<p>当然也可以选择使用<code>lower_bound</code>函数，在离散化的时候也经常用到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m, in, idx;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; in;</span><br><span class="line">        cout &lt;&lt; (arr[idx = <span class="built_in">lower_bound</span>(arr + <span class="number">1</span>, arr + <span class="number">1</span> + n, in) - arr] == in ? idx : <span class="number">-1</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>P2440. 木材加工</title>
    <url>/2023/10/16/P2440-%E6%9C%A8%E6%9D%90%E5%8A%A0%E5%B7%A5/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>二分</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, K, arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        res += <span class="built_in">ceil</span>(arr[i] / x);</span><br><span class="line">    <span class="keyword">return</span> res &gt;= K;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line">    <span class="type">int</span> mx = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">        mx = <span class="built_in">max</span>(mx, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = mx;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; r;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>找满足条件下的最大值，基本是考察二分；二分切割长度<code>l</code>，范围从1到原木的最大长度</p>
<ul>
<li>如果当前长度<code>l</code>切割出来的数量大于需求，说明<code>l</code>小了，需要向右边界移动</li>
<li>如果等于需求，也要向右边界移动（因为求最大）</li>
<li>如果小于需求，说明<code>l</code>大了，向左边界移动</li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>P2678. 跳石头</title>
    <url>/2023/10/16/P2678-%E8%B7%B3%E7%9F%B3%E5%A4%B4/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>贪心</li>
<li>二分</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> L, N, M, arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] - pre &lt; x)</span><br><span class="line">            ++cnt;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pre = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt &lt;= M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; L &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    arr[N] = L;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = L;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; r;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题眼<strong>最短跳跃距离的最大值</strong>，很容易想到DP/贪心/二分</p>
<ul>
<li>DP：设二维数组<code>dp[i][j]</code>，表示在前<code>i</code>块石头移走<code>j</code>块石头的最短距离；但石头太多，数组可能会炸</li>
<li>贪心：每次搬走最短跳跃距离的石头，但是需要用堆来存储，时间复杂度可能吃不消</li>
</ul>
<p>重点讲一下二分的思路，直接二分最短跳跃距离，左端点为1，右端点为<code>L</code></p>
<p>从左往右遍历石头数组，若当前石头到上一个石头的距离小于当前最短跳跃距离，就把它移走</p>
<blockquote>
<p>为什么前后两个石头，就移后面的呢？</p>
<p>前面的石头与前前面的石头已经大于等于最短跳跃距离了，所以移前面的石头根本没有意义</p>
</blockquote>
<p>还有一个坑点，一定要把终点加入石头数组，也就是这行代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">arr[N] = L;</span><br></pre></td></tr></table></figure>
<p>你肯定会问，“刚才说移后面的石头，终点加进去了，岂不是终点也有可能被移走？”</p>
<p>代码层面上解释，终点确实“被移走”；但是换个角度来看，可以看作是终点的前一块石头被移走呢</p>
<blockquote>
<p>方才提过，前面的石头已经满足条件，再对其进行操作是无意义的，并不影响结果</p>
</blockquote>
<p>比如这组Hack数据，答案应为2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>P3743. kotori的设备</title>
    <url>/2023/10/18/P3743-kotori%E7%9A%84%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>二分</li>
<li>贪心</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<h2 id="二分">二分</h2>
<p>题目给了误差范围1e-4，显然就是让我们进行实数二分</p>
<p>把所有设备的耗电速度加起来，将其视作一个更大的设备；如果充电速度大于等于大设备的耗电速度，显然时间可以无限续，输出-1</p>
<p>二分设备使用时间<code>x</code>，左端点为0，右端点为1e15（由于充电的存在，右端点不确定，取大点总没错）</p>
<p>我们并不关心充电器具体到哪个设备充了多少的电，因为充电过程是连续的，充电的总电量总是<code>x * P</code></p>
<p>故而可从<strong>充电的总电量</strong>，<strong>维持各设备的电量大于等于0的总需电量</strong>，进行单调性判断</p>
<blockquote>
<p>因为我们需要让所有设备运行<code>x</code>时间呐！电量在这期间肯定大于等于0</p>
</blockquote>
<p>遍历设备，判断当前设备的耗电量<code>cost = arr[i].a_ * x</code>是否大于存量<code>arr[i].b_</code>，大于说明还需要充<code>cost - arr[i].b_</code>的电量</p>
<blockquote>
<p>若当前耗电量小于等于存量，说明不需要充电</p>
</blockquote>
<p>最后判断单调性：</p>
<ul>
<li><strong>充电的总电量</strong>大于<strong>维持各设备的电量大于等于0的总需电量</strong>，说明设备使用时间<code>x</code>选小了，应该向右端点移动</li>
<li>若等于，也要向右移动（求最大）</li>
<li>若小于，说明设备使用时间<code>x</code>选大了，应该向左端点移动</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a_, b_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>, cost;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((cost = arr[i].a_ * x) &gt; arr[i].b_)</span><br><span class="line">            sum += cost - arr[i].b_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum &lt;= x * P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; P;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i].a_ &gt;&gt; arr[i].b_;</span><br><span class="line">        sum += arr[i].a_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt;= P)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> l = <span class="number">0</span>, r = <span class="number">1e15</span>;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            l = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; r;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="贪心">贪心</h2>
<p>这道题第一眼我就认为应该用贪心写更好.....</p>
<p>设消耗比<code>t</code>等于耗电速度<code>a</code>除以电量<code>b</code>，显然<code>t</code>越大电量越快到零，也是最需要充电的；按照下面这个优先级进行排序
<span class="math display">\[
i&lt;j, \frac{a_i}{b_i}&gt;\frac{a_j}{b_j}\rightarrow a_i\cdot
b_j&gt;b_i\cdot a_j
\\
\]</span>
每次将<strong>当前消耗比最大t<sub>i</sub></strong>与<strong>次大t<sub>j</sub></strong>的两个设备作比较：</p>
<ul>
<li><p>若t<sub>i</sub>的充电工作时间，等于t<sub>j</sub>的不充电工作时间，就将它俩合并</p></li>
<li><p>若t<sub>i</sub>的充电工作时间仍小于t<sub>j</sub>的不充电工作时间，则两者无法合并；直接输出t<sub>i</sub>的充电工作时间并退出
<span class="math display">\[
\underset{\text{耗电量}}{\underbrace{\frac{b_j}{a_j}\cdot
a_i}}&gt;\underset{\text{电量}+\text{充电量}}{\underbrace{b_i+P\cdot
\frac{b_j}{a_j}}}
\]</span></p></li>
</ul>
<p>具体解释一下<code>合并</code>的含义，设t<sub>i</sub>的不充电工作时间为T<sub>a</sub>，t<sub>j</sub>的不充电工作时间为T<sub>b</sub>，显然T<sub>a</sub>
&lt; T<sub>b</sub></p>
<p>如果能靠充电，让t<sub>i</sub>多T<sub>b</sub> -
T<sub>a</sub>的工作时间，即t<sub>i</sub>的充电工作时间等于t<sub>j</sub>的不充电工作时间</p>
<p>那么T<sub>b</sub>前，充电器只给t<sub>i</sub>充电；T<sub>b</sub>后，充电器要<strong>来回</strong>给t<sub>i</sub>和t<sub>j</sub>一起充电，保证它们俩尽可能地工作时间长</p>
<blockquote>
<p>为什么可以来回？因为充电器是瞬移的</p>
</blockquote>
<p>所以原来的充电效率是<code>P</code>，现在相同时间要给两个设备充电，效率只能减半为<code>P/2</code></p>
<p>你肯定会问，那也不能一直<code>P / 2</code>、<code>P / 3</code>、<code>P / 4</code>...除下去呀！精度肯定不准！</p>
<p>故而将两者合并，耗电速度相加，电量也相加，视作一个大设备整体进行充电就行啦！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> a_, b_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; P;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i].a_ &gt;&gt; arr[i].b_;</span><br><span class="line">        sum += arr[i].a_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt;= P)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + N, [](Node &amp;a, Node &amp;b) -&gt; <span class="type">bool</span></span><br><span class="line">         &#123; <span class="keyword">return</span> a.a_ * b.b_ &gt; a.b_ * b.a_; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i + <span class="number">1</span>].b_ * arr[i].a_ &gt; arr[i + <span class="number">1</span>].a_ * arr[i].b_ + P * arr[i + <span class="number">1</span>].b_)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; arr[i].b_ / (arr[i].a_ - P);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i + <span class="number">1</span>].a_ += arr[i].a_;</span><br><span class="line">        arr[i + <span class="number">1</span>].b_ += arr[i].b_;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; arr[N - <span class="number">1</span>].b_ / (arr[N - <span class="number">1</span>].a_ - P);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>P3853. 路标设置</title>
    <url>/2023/10/17/P3853-%E8%B7%AF%E6%A0%87%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>二分</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> L, N, M;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; ++i)</span><br><span class="line">        res += <span class="built_in">ceil</span>((arr[i + <span class="number">1</span>] - arr[i]) / x) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res &lt;= M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; L &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = L;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; l;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题眼，要我们求<strong>相邻路标的最大距离的最小值</strong>；DP/贪心/二分依次判断，只可能是二分（因为并没有什么明显的状态转移与单调性）</p>
<p>直接二分相邻路标的最大距离，左端点为1，右端点为L</p>
<ul>
<li><p>每次从左到右遍历，向上取整(相邻路标之间的距离 /
当前要求的最大距离) - 1</p>
<p>就是相邻路标之间还能插几个新路标</p></li>
<li><p>当前结果小于M，说明最大距离太大了，应该缩小（向左端点移动）</p></li>
<li><p>当前结果等于M，也要向左端点移动（因为题目要找满足要求中的最小值）</p></li>
<li><p>当前结果大于M，说明最大距离太小了，应该增大（向右端点移动）</p></li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>二分_解题技巧</title>
    <url>/2023/10/18/%E4%BA%8C%E5%88%86-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="适用范围">适用范围</h1>
<ol type="1">
<li>能找到确切的答案边界范围</li>
<li>答案的分布具有单调性</li>
</ol>
<p>满足上述两点就可以尝试二分答案搜索了~</p>
<p>一般来说，会有<strong>最大求最小</strong>、<strong>最小求最大</strong>、<strong>在误差精度的范围内</strong>等等字眼</p>
<h1 id="模板">模板</h1>
<p>答案二分的伪代码模板如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">    <span class="comment">//l和r都要可取</span></span><br><span class="line">    mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//防止溢出</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">        <span class="comment">//向右边界移动就是 l = mid + 1</span></span><br><span class="line">        <span class="comment">//向左边界移动就是 r = mid - 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果求的是右边界, return r</span></span><br><span class="line"><span class="comment">//如果求的是左边界，return l</span></span><br></pre></td></tr></table></figure>
<p>实数二分的伪代码模板如下，可通过该<a
href="https://www.luogu.com.cn/problem/P1024">模板题</a>熟悉：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(r - l &gt; eps)&#123;</span><br><span class="line">    <span class="comment">//eps是精度范围</span></span><br><span class="line">    mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">        <span class="comment">//向右边界移动就是 l = mid</span></span><br><span class="line">        <span class="comment">//向左边界移动就是 r = mid</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果求的是右边界, return r</span></span><br><span class="line"><span class="comment">//如果求的是左边界，return l</span></span><br></pre></td></tr></table></figure>
<h1 id="贴士">贴士</h1>
<p>STL自带的俩函数：</p>
<ul>
<li><p><code>lower_bound</code>函数是找到第一个大于或等于</p></li>
<li><p><code>upper_bound</code>函数是找到第一个大于</p></li>
</ul>
<p>可通过<a
href="https://www.luogu.com.cn/problem/P1678">P1678</a>来熟悉</p>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>P1032. 字串变换</title>
    <url>/2023/10/22/P1032-%E5%AD%97%E4%B8%B2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>BFS</li>
<li>字符串</li>
<li>哈希表</li>
<li>双向BFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string a, b, k[maxn], v[maxn];</span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; astep, bstep;</span><br><span class="line">queue&lt;string&gt; aq, bq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(queue&lt;string&gt; &amp;aq, queue&lt;string&gt; &amp;bq, unordered_map&lt;string, <span class="type">int</span>&gt; &amp;astep,</span></span></span><br><span class="line"><span class="params"><span class="function">      unordered_map&lt;string, <span class="type">int</span>&gt; &amp;bstep, string k[], string v[])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sz = aq.<span class="built_in">size</span>(), as = astep[aq.<span class="built_in">front</span>()], bs = bstep[bq.<span class="built_in">front</span>()];</span><br><span class="line">  <span class="keyword">while</span> (sz--) &#123;</span><br><span class="line">    string u = aq.<span class="built_in">front</span>();</span><br><span class="line">    aq.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      string p = k[i];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; u.<span class="built_in">length</span>(); ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u.<span class="built_in">substr</span>(j, p.<span class="built_in">length</span>()) == p) &#123;</span><br><span class="line">          string t = u.<span class="built_in">substr</span>(<span class="number">0</span>, j) + v[i] + u.<span class="built_in">substr</span>(j + p.<span class="built_in">length</span>());</span><br><span class="line">          <span class="keyword">if</span> (bstep.<span class="built_in">count</span>(t)) <span class="keyword">return</span> as + bs + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (bstep.<span class="built_in">count</span>(t)) <span class="keyword">continue</span>;</span><br><span class="line">          astep[t] = astep[u] + <span class="number">1</span>;</span><br><span class="line">          aq.<span class="built_in">emplace</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> res, cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (a == b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  astep[a] = <span class="number">0</span>, bstep[b] = <span class="number">0</span>;</span><br><span class="line">  aq.<span class="built_in">emplace</span>(a), bq.<span class="built_in">emplace</span>(b);</span><br><span class="line">  <span class="keyword">while</span> (!aq.<span class="built_in">empty</span>() &amp;&amp; !bq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (aq.<span class="built_in">size</span>() &lt;= bq.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      res = <span class="built_in">f</span>(aq, bq, astep, bstep, k, v);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res = <span class="built_in">f</span>(bq, aq, bstep, astep, v, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res &lt;= <span class="number">10</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">if</span> (++cnt == <span class="number">10</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string x, y;</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  <span class="comment">// 不能用哈希表存储映射，因为会有重复键</span></span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; x &gt;&gt; y) k[n] = x, v[n] = y, ++n;</span><br><span class="line">  <span class="type">int</span> res = <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="keyword">if</span> (~res) &#123;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO ANSWER!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>双向BFS板子题。</p>
<p>有几个注意点，其余直接看代码就行：</p>
<ul>
<li><p>每次的新状态是<strong>只换一处匹配点</strong>，而不是全换</p>
<p>比如有规则<code>abc -&gt; xu</code>，字符串<code>abcabc</code>，那么<code>xuabc</code>就是新状态，<code>abcxu</code>是另一个新状态</p></li>
<li><p>用哈希表记录每种字符串是否出现过 + 步数，避免死循环</p></li>
<li><p>不能用哈希表存储映射，因为会有重复键</p></li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>BFS</tag>
        <tag>双向BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1101. 单词方阵</title>
    <url>/2023/10/22/P1101-%E5%8D%95%E8%AF%8D%E6%96%B9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">120</span>;</span><br><span class="line">string str = <span class="string">&quot;yizhong&quot;</span>;</span><br><span class="line"><span class="type">int</span> N, walk[<span class="number">8</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">char</span> arr[LEN][LEN], ans[LEN][LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= N &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//虚假的dfs，直接逐点枚举八个方向即可</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> ux, <span class="type">int</span> uy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> diff_x = walk[i][<span class="number">0</span>], diff_y = walk[i][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> x = ux, y = uy, j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; <span class="number">7</span> &amp;&amp; <span class="built_in">valid</span>(x += diff_x, y += diff_y) &amp;&amp; str[j] == arr[x][y])</span><br><span class="line">            ++j;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">7</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>, x = ux, y = uy; j &lt; <span class="number">7</span>; ++j, x += diff_x, y += diff_y)</span><br><span class="line">            ans[x][y] = arr[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; arr[i][j];</span><br><span class="line">            ans[i][j] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i][j] == <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">                <span class="built_in">dfs</span>(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i, cout &lt;&lt; endl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; ans[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>虚假的DFS.....每次找到<code>y</code>字母，就向8个方向遍历即可.....</p>
<p>如果找到了<code>yizhong</code>字符串，就复制到对应位置的答案数组保存</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1019. 单词接龙</title>
    <url>/2023/10/22/P1019-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
<li>字符串</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> N, ans, vis[LEN], table[LEN][LEN];</span><br><span class="line">string arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//a在前b在后，相同部分的长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = a.<span class="built_in">find_last_of</span>(b[<span class="number">0</span>]), len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (idx &lt; a.<span class="built_in">length</span>() &amp;&amp; len &lt; b.<span class="built_in">length</span>() &amp;&amp; a[idx] == b[len])</span><br><span class="line">        ++idx, ++len;</span><br><span class="line">    <span class="keyword">if</span> (idx == a.<span class="built_in">length</span>() &amp;&amp; len &lt; a.<span class="built_in">length</span>() &amp;&amp; len &lt; b.<span class="built_in">length</span>())</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//i在前j在后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">            table[i][j] = <span class="built_in">f</span>(arr[i], arr[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pre, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//更新ans不能放在循环的if里</span></span><br><span class="line">    <span class="comment">//万一其他字母都不符合if呢？岂不是漏了开头第一个...</span></span><br><span class="line">    ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i] &lt; <span class="number">2</span> &amp;&amp; table[pre][i] != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nxt_sum = sum + arr[i].<span class="built_in">length</span>() - table[pre][i];</span><br><span class="line">            ++vis[i];</span><br><span class="line">            <span class="built_in">dfs</span>(i, nxt_sum);</span><br><span class="line">            --vis[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">char</span> chr;</span><br><span class="line">    cin &gt;&gt; chr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i][<span class="number">0</span>] == chr)</span><br><span class="line">        &#123;</span><br><span class="line">            ++vis[i];</span><br><span class="line">            <span class="built_in">dfs</span>(i, arr[i].<span class="built_in">length</span>());</span><br><span class="line">            --vis[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>一开始还以为是状压DP，但是<code>1 &lt;&lt; (20 * 2)</code>的数量级让我望而却步...看起来只能用dfs搜索</p>
<p>有两个字符串<code>a</code>和<code>b</code>，<code>b</code>要接在<code>a</code>后面，求重叠部分的逻辑：</p>
<ol type="1">
<li><p>有<code>b</code>的开头字符<code>chr</code>，在<code>a</code>中找<code>chr</code>最后一次出现的位置并记录在变量<code>idx</code>；若没有出现，返回-1</p></li>
<li><p>设变量<code>idx</code>为<code>a</code>的重叠部分下标，变量<code>len = 0</code>为<code>b</code>的重叠部分下标，两个下标的字母相等就同时往后移</p></li>
<li><p>若<code>idx</code>最终等于<code>a.length()</code>，说明重叠部分存在</p>
<p>但是！若重叠部分的长度<code>len</code>等于<code>a.length()</code>或者<code>b.length()</code>，说明某字符串被包含在另一个字符串中，返回-1</p></li>
</ol>
<p>各字符串前后拼接的结果会被重复使用，所以提前打表在二维数组<code>table[i][j]</code>中，代表字符串<code>j</code>接在字符串<code>i</code>后面</p>
<p>其余部分套dfs模板即可~</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1162. 填涂颜色</title>
    <url>/2023/10/23/P1162-%E5%A1%AB%E6%B6%82%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">35</span>;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="comment">//四向不是八向，不然会插进圈内</span></span><br><span class="line"><span class="type">int</span> arr[LEN][LEN], vis[LEN][LEN], walk[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//秉持正难则反的原则，直接改变圈内的不方便</span></span><br><span class="line"><span class="comment">//那就改变圈外，输出的时候判断一下就好</span></span><br><span class="line"><span class="comment">//外面应该多一圈，不然无法围绕1进行搜索</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt; N || y &lt; <span class="number">0</span> || y &gt; N || arr[x][y] == <span class="number">-1</span> || arr[x][y] == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    arr[x][y] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        <span class="built_in">dfs</span>(x + walk[i][<span class="number">0</span>], y + walk[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//外面多一圈</span></span><br><span class="line">    ++N;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">1</span>; ++i, cout &lt;&lt; endl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N - <span class="number">1</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i][j] == <span class="number">-1</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;0 &quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!arr[i][j])</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;2 &quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;1 &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>秉持正难则反的原则，直接改变圈内的不方便；那就改变圈外，输出的时候判断一下就好</p>
<p>用dfs把1外围的所有0都改成-1，这样输出的时候：</p>
<ul>
<li>等于-1的位置输出0</li>
<li>等于1的位置输出1</li>
<li>等于0的位置输出2</li>
</ul>
<p>要注意，外面应该多一圈，不然无法围绕1进行搜索</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1219. 八皇后 Checker Challenge</title>
    <url>/2023/10/19/P1219-%E5%85%AB%E7%9A%87%E5%90%8E-Checker-Challenge/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans, N, cols[LEN], l_dia[<span class="number">2</span> * LEN], r_dia[<span class="number">2</span> * LEN], record[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> row)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row &gt; N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (++ans &lt;= <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">                cout &lt;&lt; record[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">1</span>; col &lt;= N; ++col)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cols[col] || l_dia[row - col + <span class="number">13</span>] || r_dia[row + col])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        cols[col] = l_dia[row - col + <span class="number">13</span>] = r_dia[row + col] = <span class="number">1</span>;</span><br><span class="line">        record[row] = col;</span><br><span class="line">        <span class="built_in">dfs</span>(row + <span class="number">1</span>);</span><br><span class="line">        cols[col] = l_dia[row - col + <span class="number">13</span>] = r_dia[row + col] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>要保证同一行、同一列、左对角线和右对角线只有一个棋子，各用一个一维数组记录对应位置是否有棋子即可</p>
<p>我选择的是按行递归，所以行记录数组就免了（下一轮递归的行号肯定大于当前行号，不会重复）</p>
<p>难点在于左对角线和右对角线的规律，以<code>N = 6</code>为例子：</p>
<ul>
<li><p>主左对角线（即<code>&#123;1, 1&#125;</code>,<code>&#123;2, 2&#125;</code>,<code>&#123;3, 3&#125;</code>所在的对角线)的左侧，左对角线的元素行号
- 列号大于0</p>
<p>主左对角线上的元素，行号 - 列号等于0</p>
<p>主左对角线右侧，左对角线的元素行号 -
列号小于0；数组没有负数下标，＋13转正就行</p></li>
<li><p>任意一条右对角线上的元素，它们之间行号 +
列号的和都是相等的</p></li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1443. 马的遍历</title>
    <url>/2023/10/19/P1443-%E9%A9%AC%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>BFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x_, y_;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">queue&lt;Node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, M, ans[<span class="number">450</span>][<span class="number">450</span>], walk[<span class="number">8</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Node u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ux = u.x_, uy = u.y_;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = ux + walk[i][<span class="number">0</span>], y = uy + walk[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; N || y &lt; <span class="number">1</span> || y &gt; M || ans[x][y] != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            ans[x][y] = ans[ux][uy] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">emplace</span>(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="built_in">sizeof</span>(ans));</span><br><span class="line">    q.<span class="built_in">emplace</span>(x, y);</span><br><span class="line">    ans[x][y] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i, <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%-5d&quot;</span>, ans[i][j]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>BFS的模板题，有三个注意点：</p>
<ul>
<li>答案数组初始值不能为0，因为起点本身的答案就是0</li>
<li>BFS要设置标志数组不走回头路！在这里答案数组也可以作为标志数组使用，因为访问过的点其答案肯定不为初始值</li>
<li>输出的格式是左对齐并占5个字宽</li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1433. 吃奶酪</title>
    <url>/2023/10/21/P1433-%E5%90%83%E5%A5%B6%E9%85%AA/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>状态压缩动态规划</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<p>一开始以为是贪心，但很容易举个反例：如果有多个距离一样的奶酪，该走哪个确保整体最优呢？</p>
<p>很明显也不是单纯的DFS或BFS：</p>
<ul>
<li>最大有15个奶酪，也就是说纯粹用DFS高达15的阶乘...再怎么剪枝也会炸</li>
<li>也不是BFS，BFS是找步骤最低的解...这里要找解里面总距离最小的</li>
</ul>
<p>那只有DP一种可能了</p>
<hr />
<p>微观上看，每个合法的序列都可以拆分成子序列+结尾元素，比如序列<code>&#123;1, 2, 3, 4, 5&#125; = &#123;1, 2, 3, 4&#125; + &#123;5&#125;</code></p>
<p>最多只有15个元素，而<code>int</code>有32位，所以可以将子序列映射为整数，以状态压缩来达成DP</p>
<blockquote>
<p>内存限制是10<sup>6</sup>数量级，故而状态压缩不能超过2<sup>20</sup>这一极限</p>
</blockquote>
<p>这样并不能保存元素的前后顺序，所以每次只保存，相同组成的序列中总距离最小的</p>
<h2 id="递推">递推</h2>
<p>根据上述思路，很容易写出状态转移方程： <span class="math display">\[
\min \left( dp\left[ i \right] \left[ j \right] ,dp\left[ i\oplus
(1&lt;&lt;(j-1)) \right] \left[ k \right] +dis\left( j,k \right) \right)
\rightarrow dp\left[ i \right] \left[ j \right]
\]</span>
<code>i</code>代表当前序列，以<code>j</code>结尾；而当前序列是由某个不包含<code>j</code>，以<code>k</code>结尾的子序列在末尾添加<code>j</code>组成的</p>
<blockquote>
<p>你可能会好奇为什么是<code>1 &lt;&lt; (j - 1)</code>而不是<code>1 &lt;&lt; j</code>，这样不是占了最低位属于起点的位置吗？</p>
<p>因为起点必须包含在序列且只能出现在开头，边界值初始化时可以一次性处理</p>
<p>如果把最低位空着，会导致部分状态转移遇到跳过起点的情况导致报错</p>
<p><strong>我调了10多个小时带来的教训</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="type">double</span> ans = INT_MAX, table[LEN][LEN], dp[<span class="number">1</span> &lt;&lt; LEN][LEN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x_, y_;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">double</span> x = <span class="number">0</span>, <span class="type">double</span> y = <span class="number">0</span>) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(Node &amp;a, Node &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x1 = a.x_, y1 = a.y_, x2 = b.x_, y2 = b.y_;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(x2 - x1, <span class="number">2</span>) + <span class="built_in">pow</span>(y2 - y1, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//提前打表，两点之间的距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= N - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">            table[i][j] = table[j][i] = <span class="built_in">dis</span>(arr[i], arr[j]);</span><br><span class="line">    <span class="comment">//初始化最大值</span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">127</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="comment">//由于不能自己跳自己</span></span><br><span class="line">    <span class="comment">//所以令序列只有自己的情况下，等同于从起点跳到当前点</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        dp[<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)][i] = table[<span class="number">0</span>][i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i].x_ &gt;&gt; arr[i].y_;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; N); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//序列里如果不包含结尾元素，那肯定是伪序列呐</span></span><br><span class="line">            <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= N; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//不能自己跳自己</span></span><br><span class="line">                <span class="keyword">if</span> (k == j)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i ^ (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][k] + table[j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, dp[(<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="记忆化搜索">记忆化搜索</h2>
<p>如果用递归实现，就方便很多了....因为能直接记录上个序列及其结尾元素</p>
<p>每次判断应该添加什么元素到上次序列的末尾：</p>
<ul>
<li><p>如果之前有记录本次前后搭配</p>
<p>若之前的搭配值更小，保留原有的</p>
<p>若之前的搭配值更大，用当前搭配更新</p></li>
<li><p>若无记录，记录本次搭配</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> N, vis[LEN];</span><br><span class="line"><span class="type">double</span> ans = INT_MAX, table[LEN][LEN], mem[<span class="number">1</span> &lt;&lt; LEN][LEN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x_, y_;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">double</span> x = <span class="number">0</span>, <span class="type">double</span> y = <span class="number">0</span>) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(Node &amp;a, Node &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x1 = a.x_, y1 = a.y_, x2 = b.x_, y2 = b.y_;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(x2 - x1, <span class="number">2</span>) + <span class="built_in">pow</span>(y2 - y1, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//提前打表，两点之间的距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= N - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">            table[i][j] = table[j][i] = <span class="built_in">dis</span>(arr[i], arr[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pre：上次序列的最后一位，因为状态压缩导致顺序混乱，所以要单独记录</span></span><br><span class="line"><span class="comment">//qe：上次序列</span></span><br><span class="line"><span class="comment">//sum：上次总距离</span></span><br><span class="line"><span class="comment">//cnt：计数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pre, <span class="type">int</span> qe, <span class="type">double</span> sum, <span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果过程中总和已经大于答案，剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (sum &gt;= ans)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//统计答案</span></span><br><span class="line">    <span class="keyword">if</span> (cnt &gt; N)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, sum);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0点必须为序列第一个，所以从1开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">double</span> nxt_sum = sum + table[pre][i];</span><br><span class="line">        <span class="comment">//之前该情况出现过，且之前的值更小</span></span><br><span class="line">        <span class="comment">//那当然本次要剪枝了，因为我们只保留最小值</span></span><br><span class="line">        <span class="keyword">if</span> (mem[qe][i] &amp;&amp; mem[qe][i] &lt;= nxt_sum)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[i] = <span class="number">1</span>;</span><br><span class="line">        mem[qe][i] = nxt_sum;</span><br><span class="line">        <span class="built_in">dfs</span>(i, qe | (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)), nxt_sum, cnt + <span class="number">1</span>);</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i].x_ &gt;&gt; arr[i].y_;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>状态压缩DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P1596. Lake Counting S</title>
    <url>/2023/10/22/P1596-Lake-Counting-S/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">150</span>;</span><br><span class="line"><span class="type">int</span> N, M;</span><br><span class="line"><span class="type">int</span> vis[LEN][LEN], walk[<span class="number">8</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">char</span> arr[LEN][LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; N || y &lt; <span class="number">1</span> || y &gt; M)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (vis[x][y] || arr[x][y] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    vis[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        <span class="built_in">dfs</span>(x + walk[i][<span class="number">0</span>], y + walk[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">            cin &gt;&gt; arr[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i][j] == <span class="string">&#x27;W&#x27;</span> &amp;&amp; !vis[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">                <span class="built_in">dfs</span>(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>如果当前点是<code>W</code>且没有被访问过，说明这是一个全新的水坑，就用dfs去遍历并打上访问标签即可，代表该水坑已计算</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1135. 奇怪的电梯</title>
    <url>/2023/10/19/P1135-%E5%A5%87%E6%80%AA%E7%9A%84%E7%94%B5%E6%A2%AF/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>BFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">250</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, A, B, ans = <span class="number">-1</span>, dis[LEN], vis[LEN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> floor_, cnt_;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> floor, <span class="type">int</span> cnt) : <span class="built_in">floor_</span>(floor), <span class="built_in">cnt_</span>(cnt) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">queue&lt;Node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Node u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> uf = u.floor_, uc = u.cnt_;</span><br><span class="line">        <span class="keyword">if</span> (uf == B)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = uc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-1</span>; i &lt;= <span class="number">1</span>; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> f = uf + i * dis[uf];</span><br><span class="line">            <span class="keyword">if</span> (f &lt; <span class="number">1</span> || f &gt; N || vis[f])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            vis[f] = <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">emplace</span>(f, uc + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        cin &gt;&gt; dis[i];</span><br><span class="line">    q.<span class="built_in">emplace</span>(A, <span class="number">0</span>);</span><br><span class="line">    vis[A] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题眼<strong>至少要按几次按钮</strong>，要找步骤最少的解当然是BFS</p>
<p>有两个注意点：</p>
<ul>
<li>BFS不回头，所以走过的楼层就不再走，否则会导致死循环</li>
<li>每次先判断当前楼层是否为答案，再枚举下一次的新状态</li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1605. 迷宫</title>
    <url>/2023/10/22/P1605-%E8%BF%B7%E5%AE%AB/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> N, M, bg_x, bg_y, ed_x, ed_y, ans;</span><br><span class="line"><span class="type">int</span> arr[LEN][LEN], vis[LEN][LEN], obs[LEN][LEN], walk[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; N || y &lt; <span class="number">1</span> || y &gt; M || vis[x][y])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == ed_x &amp;&amp; y == ed_y)</span><br><span class="line">    &#123;</span><br><span class="line">        ++ans;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        <span class="built_in">dfs</span>(x + walk[i][<span class="number">0</span>], y + walk[i][<span class="number">1</span>]);</span><br><span class="line">    vis[x][y] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t, x, y;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M &gt;&gt; t &gt;&gt; bg_x &gt;&gt; bg_y &gt;&gt; ed_x &gt;&gt; ed_y;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        vis[x][y] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(bg_x, bg_y);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>DFS模板题，直接套DFS模板即可</p>
<p>这里偷了懒，将障碍物直接标记为“已走过”也可以达到阻挡路径的效果</p>
<p>但还是要养成好习惯，单独再建一个障碍物数组比较好...防止吃亏</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1825. Corn Maze S</title>
    <url>/2023/10/22/P1825-Corn-Maze-S/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>BFS</li>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">350</span>;</span><br><span class="line"><span class="type">int</span> N, M, vis[LEN][LEN], walk[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="type">char</span> arr[LEN][LEN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x_, y_, time_;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>, <span class="type">int</span> time = <span class="number">0</span>) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y), <span class="built_in">time_</span>(time) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">queue&lt;Node&gt; q;</span><br><span class="line"><span class="comment">//记录传送门</span></span><br><span class="line">pair&lt;Node, Node&gt; p[<span class="number">27</span>];</span><br><span class="line">Node bg, ed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">emplace</span>(bg.x_, bg.y_, <span class="number">0</span>);</span><br><span class="line">    vis[bg.x_][bg.y_] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Node u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ux = u.x_, uy = u.y_, ut = u.time_;</span><br><span class="line">        <span class="keyword">if</span> (ux == ed.x_ &amp;&amp; uy == ed.y_)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; ut;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = ux + walk[i][<span class="number">0</span>], y = uy + walk[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">char</span> chr = arr[x][y];</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; N || y &lt; <span class="number">1</span> || y &gt; M || vis[x][y] || chr == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isalpha</span>(chr))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> nxt_x = p[chr - <span class="string">&#x27;A&#x27;</span>].first.x_ == x ? p[chr - <span class="string">&#x27;A&#x27;</span>].second.x_ : p[chr - <span class="string">&#x27;A&#x27;</span>].first.x_;</span><br><span class="line">                <span class="type">int</span> nxt_y = p[chr - <span class="string">&#x27;A&#x27;</span>].first.y_ == y ? p[chr - <span class="string">&#x27;A&#x27;</span>].second.y_ : p[chr - <span class="string">&#x27;A&#x27;</span>].first.y_;</span><br><span class="line">                <span class="comment">//传送门不能被记录</span></span><br><span class="line">                q.<span class="built_in">emplace</span>(nxt_x, nxt_y, ut + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                vis[x][y] = <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">emplace</span>(x, y, ut + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; arr[i][j];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isalpha</span>(arr[i][j]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!p[arr[i][j] - <span class="string">&#x27;A&#x27;</span>].first.x_)</span><br><span class="line">                    p[arr[i][j] - <span class="string">&#x27;A&#x27;</span>].first.x_ = i, p[arr[i][j] - <span class="string">&#x27;A&#x27;</span>].first.y_ = j;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p[arr[i][j] - <span class="string">&#x27;A&#x27;</span>].second.x_ = i, p[arr[i][j] - <span class="string">&#x27;A&#x27;</span>].second.y_ = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[i][j] == <span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                bg.x_ = i, bg.y_ = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[i][j] == <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ed.x_ = i, ed.y_ = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题眼<strong>起点到出口所需的最短时间</strong>，而每走一步就是1单位时间，所以是求步骤最少的解，直接套bfs模板即可</p>
<p>唯一的坑点就在于，<strong>传送门是不需要被标记数组标记的！</strong>因为传送门不同于其他点，本身不会衍生其他状态</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P2404. 自然数的拆分问题</title>
    <url>/2023/10/22/P2404-%E8%87%AA%E7%84%B6%E6%95%B0%E7%9A%84%E6%8B%86%E5%88%86%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> N, ans[LEN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//cnt统计取了多少个数，方便输出</span></span><br><span class="line"><span class="comment">//pre保存上一次取的数</span></span><br><span class="line"><span class="comment">//sum保存上一次的总和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cnt, <span class="type">int</span> pre, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; N)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum == N &amp;&amp; cnt &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ans[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; cnt; ++i)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; ans[i];</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pre; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[cnt] = i;</span><br><span class="line">        <span class="built_in">dfs</span>(cnt + <span class="number">1</span>, i, sum + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>标准的dfs模板题，没有坑点；唯一注意的是，需要额外增加一个<code>pre</code>变量保存上一次递归选择的数</p>
<p>因为根据题意，后面的数应该大于等于前面的数</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P2895. Meteor Shower S</title>
    <url>/2023/10/20/P2895-Meteor-Shower-S/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>BFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">350</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = <span class="number">-1</span>, vis[LEN][LEN], table[LEN][LEN], walk[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x_, y_, t_;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> t) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y), <span class="built_in">t_</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">queue&lt;Node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(table, <span class="number">-1</span>, <span class="built_in">sizeof</span>(table));</span><br><span class="line">    <span class="type">int</span> n, x, y, t;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; t;</span><br><span class="line">        <span class="comment">//坑点，同一位置可能有数次流星</span></span><br><span class="line">        <span class="keyword">if</span> (table[x][y] == <span class="number">-1</span>)</span><br><span class="line">            table[x][y] = t;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            table[x][y] = <span class="built_in">min</span>(t, table[x][y]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nxt_x = x + walk[i][<span class="number">0</span>], nxt_y = y + walk[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nxt_x &lt; <span class="number">0</span> || nxt_y &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            table[nxt_x][nxt_y] = table[nxt_x][nxt_y] == <span class="number">-1</span> ? t : <span class="built_in">min</span>(table[nxt_x][nxt_y], t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">emplace</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    vis[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Node u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ux = u.x_, uy = u.y_, ut = u.t_;</span><br><span class="line">        <span class="keyword">if</span> (table[ux][uy] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ut;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = ux + walk[i][<span class="number">0</span>], y = uy + walk[i][<span class="number">1</span>], t = ut + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || vis[x][y] || (table[x][y] != <span class="number">-1</span> &amp;&amp; table[x][y] &lt;= t))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">emplace</span>(x, y, t);</span><br><span class="line">            vis[x][y] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题眼<strong>最少需要多少时间到达一个安全的格子</strong>，求步骤最少的解自然是BFS；本题蕴藏着相当多的细节</p>
<ol type="1">
<li><p>不要省标记数组。</p>
<p>在地区被炸之前，你是可以自由出入它的；所以不能将坠落时间直接赋值到标记数组上</p>
<p>仍需要额外建立一个标记数组来控制程序不要回头</p></li>
<li><p>同一个地方流星会掉数次。</p>
<p>每一片地区都有可能被炸数次，所以每次更新坠落点及其周围区域的坠落时间时，都要取最小值</p></li>
<li><p>牛是可以跑出牧场的。</p>
<p>题眼提到<strong>她只能在第一象限中，平行于坐标轴行动</strong></p>
<p>也就是说，牛的横纵坐标不能为负数，但是正数取值并没有限制</p>
<p>尽管题目给了横纵坐标各300的取值限制，但如果能从坐标轴上方或右方逃离牧场，也算解</p></li>
</ol>
<p>整理上述细节后，本题就没有难点啦~</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索_解题技巧</title>
    <url>/2023/10/23/%E6%90%9C%E7%B4%A2-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="使用范围">使用范围</h1>
<p>DFS，深度优先搜索，寻找操作步骤字典序最小的解；白话文来说，就是能按序遍历所有情况</p>
<p>然而，DFS也是可以求最小解的：</p>
<ol type="1">
<li>用一个全局变量，记录最小值（打擂台）</li>
<li>迭代加深</li>
</ol>
<p>BFS，广度优先搜索，找到步骤最小的解；白话文来说，就是递归/迭代次数最少的解</p>
<h1 id="dfs">DFS</h1>
<h2 id="模板">模板</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="comment">//k代表递归层数，或者说要填第几个空</span></span><br><span class="line">    <span class="keyword">if</span>(所有空都填完了)&#123;</span><br><span class="line">        判断最优解/记录答案;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(枚举这个空能填的选项)</span><br><span class="line">        <span class="keyword">if</span>(这个选项是合法的)&#123;</span><br><span class="line">            记录下这个空(保存现场);</span><br><span class="line">            <span class="built_in">dfs</span>(k+<span class="number">1</span>);</span><br><span class="line">            取消这个空(恢复现场);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板仅供参考，毕竟千变万化（我本人也不按照模板设计），核心编程思路有两点：</p>
<ol type="1">
<li><p>递归函数体内，每次处理的是当前的选项；下一次的情况丢给下一次递归就好</p>
<p>若下一次递归的情况不符合题意怎么办呢？还往下递归吗？</p>
<p>当然，函数体开头直接写相关的<code>return</code>语句，等下一次递归执行时，不就自动处理掉了嘛</p></li>
<li><p>根据题意判断是否要恢复现场。但基本上，都需要额外新建标记数组来记录解以及重复情况</p>
<p>如果拿不定主意，千万不要省标记数组！！！会吃大亏！</p></li>
</ol>
<h2 id="练习题">练习题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1019">P1019</a>
字符串拼接+DFS</li>
<li><a href="https://www.luogu.com.cn/problem/P1036">P1036</a>
选数+DFS</li>
<li><a href="https://www.luogu.com.cn/problem/P1088">P1088</a>
全排列</li>
<li><a href="https://www.luogu.com.cn/problem/P1101">P1101</a>
八个方向DFS</li>
<li><a href="https://www.luogu.com.cn/problem/P1149">P1149</a>
数学+DFS</li>
<li><a href="https://www.luogu.com.cn/problem/P1157">P1157</a>
选数+DFS</li>
<li><a href="https://www.luogu.com.cn/problem/P1162">P1162</a>
正难则反覆盖+DFS</li>
<li><a href="https://www.luogu.com.cn/problem/P1219">P1219</a>
经典的八皇后！</li>
<li><a href="https://www.luogu.com.cn/problem/P1363">P1363</a>
如何处理地图无限大的搜索</li>
<li><a href="https://www.luogu.com.cn/problem/P1596">P1596</a>
经典的flood-fill模型，DFS找连通块个数</li>
<li><a href="https://www.luogu.com.cn/problem/P1605">P1605</a>
DFS枚举走迷宫的方案数</li>
<li><a href="https://www.luogu.com.cn/problem/P1706">P1706</a>
经典的全排列！</li>
<li><a href="https://www.luogu.com.cn/problem/P2036">P2036</a>
简单剪枝</li>
<li><a href="https://www.luogu.com.cn/problem/P2089">P2089</a>
简单剪枝</li>
<li><a href="https://www.luogu.com.cn/problem/P2392">P2392</a>
分类DFS</li>
<li><a href="https://www.luogu.com.cn/problem/P2404">P2404</a>
经典的自然数拆分</li>
<li><a href="https://www.luogu.com.cn/problem/P2853">P2853</a>
flood-fill找共同连通块</li>
<li><a href="https://www.luogu.com.cn/problem/P5318">P5318</a>
图的遍历</li>
<li><a href="https://www.acwing.com/problem/content/167/">acwing-165.
小猫爬山</a> 中等难度的分配问题+剪枝</li>
<li><a href="http://poj.org/problem?id=3074">poj-3074 Sudoku</a>
高难度状态压缩+剪枝</li>
<li><a href="http://poj.org/problem?id=2676">poj-2676 Sudoku</a>
poj-3074的简化版</li>
<li><a href="https://www.luogu.com.cn/problem/P1120">P1120</a>
高难度剪枝</li>
<li><a href="https://www.luogu.com.cn/problem/T148457">P1731</a>
高难度剪枝</li>
<li><a href="https://www.luogu.com.cn/problem/P1074">P1074</a>
剪枝+状态压缩</li>
<li><a href="https://www.luogu.com.cn/problem/P1092">P1092</a> 剪枝</li>
<li><a href="https://www.luogu.com.cn/problem/P1312">P1312</a>
消消乐的大模拟，考验码力</li>
</ul>
<h1 id="bfs">BFS</h1>
<h2 id="模板-1">模板</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Q是队列</span></span><br><span class="line">Q.<span class="built_in">push</span>(初始状态);<span class="comment">//将初始状态入队</span></span><br><span class="line"><span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    State u = Q.<span class="built_in">front</span>();<span class="comment">//取出队首</span></span><br><span class="line">    Q.<span class="built_in">pop</span>();<span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">for</span>(枚举所有可扩展状态)<span class="comment">//找到u的所有可达状态v</span></span><br><span class="line">        <span class="keyword">if</span>(是合法的)<span class="comment">//v需要满足某些条件，如未访问过、未在队内等</span></span><br><span class="line">            Q.<span class="built_in">push</span>(v);<span class="comment">//入队(同时可能需要维护某些必要信息)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我基本也不按模板来...核心编程思路也有两点：</p>
<ol type="1">
<li><p>与DFS不同，BFS的函数体内每次处理的是下一次的选项！所以下一次的状态是否塞入队列，当前就要决定好！</p></li>
<li><p>BFS为了避免死循环，也同样需要标记数组记录重复情况；比如<a
href="https://www.luogu.com.cn/problem/P2895">该题</a></p>
<p>二次强调，除非确实认定逻辑上不需要标记数组，否则一定要加上！多个数组才多少空间啊....</p></li>
</ol>
<h2 id="练习题-1">练习题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1135">P1135</a>
二维走地图</li>
<li><a href="https://www.luogu.com.cn/problem/P1443">P1443</a>
二维走地图</li>
<li><a href="https://www.luogu.com.cn/problem/P1825">P1825</a>
二维走地图</li>
<li><a href="https://www.luogu.com.cn/problem/P2895">P2895</a>
二维走地图</li>
<li><a href="http://poj.org/problem?id=3322">poj-3322</a>
三维走地图</li>
<li><a href="https://www.acwing.com/problem/content/175/">acwing-173</a>
flood-fill模型</li>
<li><a
href="https://www.acwing.com/problem/content/description/176/">acwing-174</a>
双重BFS，Dijkstra和SPFA的精髓题，绝世好题！</li>
<li><a
href="https://www.acwing.com/problem/content/description/190/">acwing-188</a>
二维走地图</li>
<li><a href="https://www.luogu.com.cn/problem/P2960">P2960</a>
二维走地图，输入有坑</li>
<li><a href="http://poj.org/problem?id=2044">poj-2044</a>
思维题+二维走地图</li>
</ul>
<h1 id="进阶搜索">进阶搜索</h1>
<p>根据边权情况分类即可：</p>
<ol type="1">
<li><p>问题只计最少步数，等价于在边权都为1的图上求最短路。</p>
<p>使用普通的BFS，时间复杂度<span class="math inline">\(O\left( N
\right)\)</span></p>
<p>每个状态<strong>只访问（入队）一次，第一次入队时</strong>即为该状态的最少步数。</p></li>
<li><p>问题每次扩展的代价可能是0或1，等价于在边权只有0和1的图上求最短路。</p>
<p>使用双端队列BFS，时间复杂度<span class="math inline">\(O\left( N
\right)\)</span></p>
<p>每个状态被<strong>更新（入队）多次，只扩展一次，第一次出队时</strong>即为该状态的最小代价。</p></li>
<li><p>问题每次扩展的代价是任意数值，等价于一般的最短路问题。</p>
<ol type="1">
<li><p>使用优先队列BFS，时间复杂度<span class="math inline">\(O\left(
N\log N \right)\)</span>。</p>
<p>每个状态被<strong>更新（入队）多次，只扩展一次，第一次出队时</strong>即为该状态的最小代价。</p></li>
<li><p>使用迭代思想+普通的BFS（常用SPFA），时间复杂度<span
class="math inline">\(O\left( N^2 \right)\)</span>。</p>
<p>每个状态被更新（入队）、扩展（出队）多次，最终完成搜索后，记录数组中保存了最小代价。</p></li>
</ol></li>
</ol>
<h2 id="优先队列bfs">优先队列BFS</h2>
<h3 id="使用">使用</h3>
<p>其实就是Dijkstra和SPFA</p>
<h3 id="练习题-2">练习题</h3>
<ul>
<li><a href="http://poj.org/problem?id=3635">poj-3635</a></li>
</ul>
<h2 id="双端队列bfs">双端队列BFS</h2>
<h3 id="使用-1">使用</h3>
<p>只能用在边权0或1的图上求最短路，和dijkstra完全一样的写法，只不过二叉堆换成了双端队列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d)), <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">d[<span class="number">1</span>] = <span class="number">0</span>, q.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">  q.<span class="built_in">pop_front</span>();</span><br><span class="line">  <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">  vis[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = g[i].nxt_) &#123;</span><br><span class="line">    <span class="type">int</span> v = g[i].v_, w = g[i].w_ &gt; mid;</span><br><span class="line">    <span class="keyword">if</span> (d[v] &gt; d[u] + w) &#123;</span><br><span class="line">      d[v] = d[u] + w;</span><br><span class="line">      <span class="keyword">if</span> (w)</span><br><span class="line">        q.<span class="built_in">push_back</span>(v);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        q.<span class="built_in">push_front</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习题-3">练习题</h3>
<ul>
<li><a
href="https://www.acwing.com/problem/content/description/177/">acwing-175</a>
模板题</li>
<li><a href="http://poj.org/problem?id=3662">poj-3662</a> 二分 +
双端队列BFS求最短路</li>
</ul>
<h2 id="双向bfs">双向BFS</h2>
<h3 id="使用-2">使用</h3>
<p>用以减少一半的搜索树深度，两个方向轮流做BFS，每次可以先选状态少的进行扩展；</p>
<p>注意！如果有无解情况，一定要先排除，否则复杂度会是普通BFS的两倍！</p>
<p>若要输出路径，反向BFS的方向数组千万记得取反！</p>
<blockquote>
<p>正向方向数组为opa[4]={上，右，下，左}</p>
<p>反向方向数组应为opb[4]={下，左，上，右}</p>
</blockquote>
<p>在反向BFS中，目标状态作为起点，中间状态作为终点；但客观上目标状态才是终点，中间状态是起点。</p>
<p>所以，在反向BFS的视角中，从目标状态朝中间状态向上移动；</p>
<p>客观上应该保存为从中间状态朝向目标状态向下移动！</p>
<p>如果双向BFS仍超时，只能考虑启发式搜索进行优化了。</p>
<h3 id="练习题-4">练习题</h3>
<ul>
<li><a
href="https://acm.hdu.edu.cn/showproblem.php?pid=3085">hdoj-3085</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1032">P1032</a></li>
<li><a
href="https://www.acwing.com/problem/content/submission/181/">acwing-179.
八数码</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1379">P1379</a>
上面那道题的低配版</li>
</ul>
<h2 id="迭代加深">迭代加深</h2>
<h3 id="使用-3">使用</h3>
<p>因为DFS的性质，无法像BFS一样很方便地找最少步骤解，要么就只能开一个全局变量打擂台并剪枝；</p>
<p>迭代加深就是模拟BFS，判断答案在第几层，异曲同工之妙。</p>
<h3 id="练习题-5">练习题</h3>
<ul>
<li><a href="http://poj.org/problem?id=2248">poj-2248</a> 模板题</li>
<li><a href="http://poj.org/problem?id=1167">poj-1167</a></li>
<li><a href="http://poj.org/problem?id=3700">poj-3700</a>
贪心+迭代加深控制步数，非常好的题！</li>
<li><a href="https://www.luogu.com.cn/problem/P1763">P1763</a>
高难度剪枝，枚举分母所考虑的细节</li>
</ul>
<h2 id="双向dfs">双向DFS</h2>
<h3 id="使用-4">使用</h3>
<p>减少一半的搜索树深度</p>
<h3 id="练习题-6">练习题</h3>
<ul>
<li><a href="https://www.acwing.com/problem/content/173/">acwing-171</a>
双向DFS模板题</li>
<li><a href="https://www.luogu.com.cn/problem/CF525E">CF525E</a>
高难度的记忆化搜索优化</li>
<li><a href="https://www.luogu.com.cn/problem/CF912E">CF912E</a>
优化双向DFS + 二分 + 双指针</li>
<li><a href="https://www.luogu.com.cn/problem/P4799">P4799</a>
和上面那题类似</li>
</ul>
<h2 id="astar">Astar</h2>
<h3 id="使用-5">使用</h3>
<p>设当前状态为<code>now</code>，当前状态到目标状态的<strong>最小开销(理想值)</strong>为估价函数<code>f(now)</code>，初始状态到当前状态的开销为<code>d[now]</code></p>
<p>每次取出最小的<code>f(now) + d[now]</code>进行扩展</p>
<p>与Dijkstra的大不相同！</p>
<p>除了目标状态之外，其余状态会<strong>重复出队入队</strong>，<strong>不能</strong>像Dijkstra那样只出队一次！</p>
<p>因为<code>f(now) + d[now]</code>是由两个变量共同组成，收敛性不一致；</p>
<p>且由于本身用了Dijkstra的贪心思想，所以不能用在负边权的图上！</p>
<p>适用于规模巨大的优先队列BFS题，一定要用估价函数来加快搜索进程否则会TLE的那种</p>
<h3 id="练习题-7">练习题</h3>
<ul>
<li><a
href="https://www.acwing.com/problem/content/description/180/">第K短路</a>
模板题</li>
<li><a
href="https://www.acwing.com/problem/content/submission/181/">八数码</a></li>
<li><a href="https://www.luogu.com.cn/problem/P5507">机关</a></li>
</ul>
<h2 id="idastar">IDAstar</h2>
<h3 id="使用-6">使用</h3>
<p>迭代加深+估价函数构成，</p>
<p>每次计算<code>初始状态到当前状态的开销 + 当前状态到目标状态的最小开销(理想值，即估价函数)</code>是否大于阈值，用以剪枝</p>
<h3 id="练习题-8">练习题</h3>
<ul>
<li><a
href="https://www.acwing.com/problem/content/description/182/">排书</a></li>
<li><a
href="https://www.acwing.com/problem/content/description/183/">回转游戏</a></li>
<li><a
href="https://www.acwing.com/problem/content/description/195/">算乘方的牛</a>
最大公约数 + 数学思维剪枝，涵盖了几乎所有的剪枝技巧，大赞！</li>
<li><a
href="https://www.acwing.com/problem/content/description/196/">涂满它</a>
flood-fill优化</li>
<li><a
href="https://www.acwing.com/problem/content/description/197/">骑士精神</a></li>
<li><a href="https://www.luogu.com.cn/problem/P2324">P2324</a>
上面那道题的低配版</li>
</ul>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1241 括号序列</title>
    <url>/2023/10/24/P1241-%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>栈</li>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">101</span>;</span><br><span class="line"><span class="type">bool</span> match[LEN];</span><br><span class="line">string s;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是右括号，返回左括号</span></span><br><span class="line"><span class="comment">//如果是左括号，返回@</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">get</span><span class="params">(<span class="type">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;@&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">char</span> lchr, rchr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)s.<span class="built_in">length</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((lchr = <span class="built_in">get</span>(rchr = s[i])) == <span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">emplace</span>(i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> u = st.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span> (s[u] == lchr)</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            match[u] = match[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)s.<span class="built_in">length</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (match[i])</span><br><span class="line">            cout &lt;&lt; s[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;()&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>这道题的题面与样例简直就是大便...</p>
<p>根据题眼，<strong>如果它是一个右括号，考察它与它左侧离它最近的未匹配的的左括号</strong></p>
<p>很显然左括号应该塞入栈，每次用右括号与栈顶的符号对比</p>
<ul>
<li>如果匹配成功，当前的右括号与栈顶的左括号都将自身的标志置为1，并弹出该左括号</li>
<li>若不成功，继续下一次</li>
</ul>
<p>若一个符号的标志为1，则说明可以正常输出；否则输出时要补全另一半</p>
<p>字符串的题目要考虑整串读入或逐字符读入哪个方便，本题应选择整串读入，因为要遍历</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>P1160. 队列安排</title>
    <url>/2023/10/24/P1160-%E9%98%9F%E5%88%97%E5%AE%89%E6%8E%92/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
<li>链表</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pre_, nxt_, key_;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> pre = <span class="number">0</span>, <span class="type">int</span> nxt = <span class="number">0</span>, <span class="type">int</span> key = <span class="number">0</span>) : <span class="built_in">pre_</span>(pre), <span class="built_in">nxt_</span>(nxt), <span class="built_in">key_</span>(key) &#123;&#125;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dummyhead arr[0]</span></span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>, idx[LEN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//找x的下标，若无则返回0(即伪节点)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> now = dummyhead.nxt_;</span><br><span class="line">    <span class="keyword">while</span> (now &amp;&amp; arr[now].key_ != x)</span><br><span class="line">        now = arr[now].nxt_;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//y插到x的右边(后面)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins_back</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// int now = find(x);</span></span><br><span class="line">    <span class="type">int</span> now = idx[x];</span><br><span class="line">    arr[++tot] = <span class="built_in">Node</span>(now, arr[now].nxt_, y);</span><br><span class="line">    arr[arr[now].nxt_].pre_ = tot;</span><br><span class="line">    arr[now].nxt_ = tot;</span><br><span class="line">    idx[y] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//y插到x的左边(前面)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins_front</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// int now = find(x);</span></span><br><span class="line">    <span class="type">int</span> now = idx[x];</span><br><span class="line">    arr[++tot] = <span class="built_in">Node</span>(arr[now].pre_, now, y);</span><br><span class="line">    arr[arr[now].pre_].nxt_ = tot;</span><br><span class="line">    arr[now].pre_ = tot;</span><br><span class="line">    idx[y] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到x的下标，并删除它</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// int now = find(x);</span></span><br><span class="line">    <span class="type">int</span> now = idx[x];</span><br><span class="line">    <span class="keyword">if</span> (!now)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> pre = arr[now].pre_, nxt = arr[now].nxt_;</span><br><span class="line">    arr[nxt].pre_ = pre;</span><br><span class="line">    arr[pre].nxt_ = nxt;</span><br><span class="line">    idx[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> now = dummyhead.nxt_;</span><br><span class="line">    <span class="keyword">while</span> (now)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[now].key_ &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        now = arr[now].nxt_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, t, k, p;</span><br><span class="line">    <span class="comment">//初始状态有个1</span></span><br><span class="line">    <span class="built_in">ins_back</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; k &gt;&gt; p;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">ins_front</span>(k, i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">ins_back</span>(k, i);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="built_in">del</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>链表增删查改操作的模板题，直接看题解就行</p>
<p>这里有个注意点，不能每次搜索后再删除，这样时间复杂度高达<span
class="math inline">\(O\left( n^2 \right)\)</span>会超时</p>
<p>需要设置一个下标数组<code>idx</code>，存放每个数字对应的节点编号来替代<code>find</code>函数</p>
<blockquote>
<p>其实这里也不需要删除操作，额外新建一个标记数组记录需要被删除的数字，输出时跳过即可</p>
</blockquote>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P1540. 机器翻译</title>
    <url>/2023/10/24/P1540-%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
<li>队列</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1050</span>;</span><br><span class="line"><span class="type">int</span> idx[LEN];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n, in, ans = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; in;</span><br><span class="line">        <span class="keyword">if</span> (idx[in])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ++ans;</span><br><span class="line">        ++idx[in];</span><br><span class="line">        q.<span class="built_in">emplace</span>(in);</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; m)</span><br><span class="line">        &#123;</span><br><span class="line">            --idx[q.<span class="built_in">front</span>()];</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题眼<strong>软件会清空最早进入内存的那个单词</strong>，满足先进先出的性质，选择队列进行操作即可</p>
<p>因为队列不方便遍历，所以新建数组<code>idx</code>记录对应数字在内存中的个数</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>P1449 后缀表达式</title>
    <url>/2023/10/23/P1449-%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
<li>字符串</li>
<li>栈</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="type">char</span> chr;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; chr &amp;&amp; chr != <span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (chr == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">emplace</span>(num);</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(chr))</span><br><span class="line">        &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + chr - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> b = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> a = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">switch</span> (chr)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                st.<span class="built_in">emplace</span>(a + b);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                st.<span class="built_in">emplace</span>(a - b);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                st.<span class="built_in">emplace</span>(a * b);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                st.<span class="built_in">emplace</span>(a / b);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; st.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>字符串的题目，先考虑整串读入还是逐字符读入，很显然应该选择后者</p>
<p>注意点如下：</p>
<ul>
<li>数字有很多位，所以额外新建<code>num</code>变量记录每一位；如果遇到<code>.</code>就将这个数字塞入栈</li>
<li>每个运算符都需要两个操作数。所以遇到操作符，就从栈里面弹出两个元素进行运算</li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>字符串</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>P1996. 约瑟夫问题</title>
    <url>/2023/10/23/P1996-%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表</li>
<li>队列</li>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<p>这道题无法使用数组，因为要删除元素...</p>
<h2 id="双向链表">双向链表</h2>
<p>用链表实现很简单，每次走<code>m - 1</code>步，输出对应元素并删除；期间如果走到了链表末尾，就从伪节点的后继节点继续遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pre_, nxt_, key_;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> pre = <span class="number">0</span>, <span class="type">int</span> nxt = <span class="number">0</span>, <span class="type">int</span> key = <span class="number">0</span>) : <span class="built_in">pre_</span>(pre), <span class="built_in">nxt_</span>(nxt), <span class="built_in">key_</span>(key) &#123;&#125;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//伪节点</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dummyhead arr[0]</span></span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除now下标的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    arr[arr[now].pre_].nxt_ = arr[now].nxt_;</span><br><span class="line">    arr[arr[now].nxt_].pre_ = arr[now].pre_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//新建链表节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[++tot] = <span class="built_in">Node</span>(tot, arr[tot].nxt_, i);</span><br><span class="line">        arr[tot - <span class="number">1</span>].nxt_ = tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下标0是伪节点，应从下标1开始遍历</span></span><br><span class="line">    <span class="type">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (dummyhead.nxt_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            now = arr[now].nxt_;</span><br><span class="line">            <span class="keyword">if</span> (!now)</span><br><span class="line">                now = dummyhead.nxt_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> nxt = arr[now].nxt_;</span><br><span class="line">        <span class="keyword">if</span> (!nxt)</span><br><span class="line">            nxt = dummyhead.nxt_;</span><br><span class="line">        cout &lt;&lt; arr[now].key_ &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">del</span>(now);</span><br><span class="line">        now = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列">队列</h2>
<p>如果把队首的元素移动到队尾，不就相当于循环访问吗？</p>
<p>每次队首的人出队，然后移到队尾，一直循环直到第k个人，将这个人删除即可，重复这一操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        q.<span class="built_in">emplace</span>(i);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">1</span>; cnt &lt; m; ++cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(q.<span class="built_in">front</span>());</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>模拟</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>P2058. 海港</title>
    <url>/2023/10/24/P2058-%E6%B5%B7%E6%B8%AF/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>队列</li>
<li>滑动窗口</li>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<p>标准的队列模板题，或者说滑动窗口模板题</p>
<p>一个区间有序，要让区间和保证小于等于某值，很显然可以用以下步骤达成：</p>
<ol type="1">
<li>初始时，左指针<code>l</code>和右指针<code>r</code>同在一个位置</li>
<li>当左右指针构成的区间和满足要求时，右指针<code>r</code>一直向右移</li>
<li>若不满足要求，则左指针<code>l</code>向右移，缩短区间长度，直到满足条件或两指针再次重合</li>
</ol>
<h2 id="朴素版">朴素版</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//记录各国籍的人数</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t_;<span class="comment">//船到达时间</span></span><br><span class="line">    <span class="type">int</span> k_;<span class="comment">//人数</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v_;<span class="comment">//存放该船的乘客</span></span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rt arr[r].t_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rk arr[r].k_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rv arr[r].v_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lt arr[l].t_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lk arr[l].k_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lv arr[l].v_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, in, l = <span class="number">0</span>, r = <span class="number">0</span>;<span class="comment">//区间的左右指针</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; rt &gt;&gt; rk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rk; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; in;</span><br><span class="line">            rv.<span class="built_in">emplace_back</span>(in);</span><br><span class="line">            ++mp[in];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//区间和大于24小时，区间应收缩，左指针向右移</span></span><br><span class="line">        <span class="keyword">while</span> (rt - lt + <span class="number">1</span> &gt; <span class="number">86400</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lk; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (mp.<span class="built_in">count</span>(lv[i]))</span><br><span class="line">                &#123;</span><br><span class="line">                    --mp[lv[i]];</span><br><span class="line">                    <span class="comment">//如果该国籍人数为0，则从哈希表中移除该国籍</span></span><br><span class="line">                    <span class="keyword">if</span> (!mp[lv[i]])</span><br><span class="line">                        mp.<span class="built_in">erase</span>(lv[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++l;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; mp.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        ++r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="炫技版">炫技版</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//由于国籍最大才为3e5，可以直接用桶数组计数，避免哈希表的开销</span></span><br><span class="line"><span class="type">int</span> cnt[LEN];</span><br><span class="line"><span class="comment">//每次都是移除左指针的船，而船又是按时间升序输入，满足先入先出的规则</span></span><br><span class="line"><span class="comment">//直接用一个队列存放所有船的人即可</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t_;</span><br><span class="line">    <span class="type">int</span> k_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rt arr[r].t_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rk arr[r].k_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lt arr[l].t_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lk arr[l].k_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, in, ans = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; rt &gt;&gt; rk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rk; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; in;</span><br><span class="line">            q.<span class="built_in">emplace</span>(in);</span><br><span class="line">            <span class="keyword">if</span> (cnt[in]++ == <span class="number">0</span>)</span><br><span class="line">                ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rt - lt + <span class="number">1</span> &gt; <span class="number">86400</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lk; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (cnt[u] &amp;&amp; --cnt[u] == <span class="number">0</span>)</span><br><span class="line">                    --ans;</span><br><span class="line">            &#125;</span><br><span class="line">            ++l;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        ++r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>队列</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>P2234. 营业额统计</title>
    <url>/2023/10/25/P2234-%E8%90%A5%E4%B8%9A%E9%A2%9D%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>链表</li>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<p>每次要找子序列中最接近当前元素的值，肯定希望其有序</p>
<h2 id="平衡树">平衡树</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF_MAX 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF_MIN 0xc0c0c0c0</span></span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, in, ans = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; ans;</span><br><span class="line">    <span class="comment">//塞入极大值和极小值是为了避免繁琐边界值的讨论</span></span><br><span class="line">    <span class="comment">//正常情况下，it可能会是st.begin()，也有可能是st.end()</span></span><br><span class="line">    <span class="comment">//加上极小值，it最小也只会出现在st.begin() + 1</span></span><br><span class="line">    <span class="comment">//加上极大值，it最大也只会出现在st.end() - 1</span></span><br><span class="line">    s.<span class="built_in">emplace</span>(ans), s.<span class="built_in">emplace</span>(INF_MAX), s.<span class="built_in">emplace</span>(INF_MIN);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; in;</span><br><span class="line">        multiset&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">lower_bound</span>(in);</span><br><span class="line">        ans += <span class="built_in">min</span>(<span class="built_in">abs</span>(in - *it), <span class="built_in">abs</span>(in - *<span class="built_in">prev</span>(it)));</span><br><span class="line">        s.<span class="built_in">emplace</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表">链表</h2>
<p>先建立结构体，记录第几天及该天的营业额，并按照营业额排序</p>
<p>新建数组<code>money</code>，效果和结构体一样，下标为第几天，值为该天营业额</p>
<p>根据排序后的结构体数组中的天数，建立双向链表</p>
<p>这样一来，每次先从天数大的开始，从数组<code>money</code>获取其营业额并与相邻节点比较；比较结束后，将其删除</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pre[LEN], nxt[LEN], money[LEN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> money_, day_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, ans = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i].money_;</span><br><span class="line">        arr[i].day_ = i;</span><br><span class="line">        money[i] = arr[i].money_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr + <span class="number">1</span>, arr + <span class="number">1</span> + n, [](Node &amp;a, Node &amp;b) -&gt; <span class="type">bool</span></span><br><span class="line">         &#123; <span class="keyword">return</span> a.money_ &lt; b.money_; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[arr[i].day_] = arr[i - <span class="number">1</span>].day_;</span><br><span class="line">        nxt[arr[i].day_] = arr[i + <span class="number">1</span>].day_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> day = n; day &gt;= <span class="number">1</span>; --day)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = pre[day], r = nxt[day], now = money[day];</span><br><span class="line">        <span class="keyword">if</span> (l &amp;&amp; r)</span><br><span class="line">            ans += <span class="built_in">min</span>(<span class="built_in">abs</span>(now - money[l]), <span class="built_in">abs</span>(now - money[r]));<span class="comment">//有前驱与后继</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!l &amp;&amp; r)</span><br><span class="line">            ans += <span class="built_in">abs</span>(now - money[r]);<span class="comment">//无前驱但有后继</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &amp;&amp; !r)</span><br><span class="line">            ans += <span class="built_in">abs</span>(now - money[l]);<span class="comment">//有前驱但无后继</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans += now;<span class="comment">//只有自己</span></span><br><span class="line">        <span class="comment">//删除当前天数</span></span><br><span class="line">        nxt[l] = r;</span><br><span class="line">        pre[r] = l;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P3156. 询问学号</title>
    <url>/2023/10/23/P3156-%E8%AF%A2%E9%97%AE%E5%AD%A6%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, tmp;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        cout &lt;&lt; v[tmp - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>直接拿<code>vector</code>存储即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P3613. 寄包柜</title>
    <url>/2023/10/23/P3613-%E5%AF%84%E5%8C%85%E6%9F%9C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, opt, i, j, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//初始化,一共0到n号</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; opt;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; i &gt;&gt; j &gt;&gt; k;</span><br><span class="line">            <span class="comment">//如果不够大，就扩容</span></span><br><span class="line">            <span class="keyword">if</span> (v[i].<span class="built_in">size</span>() &lt; j)</span><br><span class="line">                v[i].<span class="built_in">resize</span>(j + <span class="number">1</span>);</span><br><span class="line">            v[i][j] = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; i &gt;&gt; j;</span><br><span class="line">            cout &lt;&lt; v[i][j] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>由于寄包柜格子数量会改变，所以应该用<code>vector</code>来存放</p>
<p>如果某寄包柜的格子数量不够，直接用<code>vector</code>的<code>resize</code>函数扩容即可</p>
<p>也不需要考虑容量回收，因为题目说了<strong>保证查询的柜子有存过东西</strong>，哪怕是0也要保留下来</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P4387. 验证栈序列</title>
    <url>/2023/10/25/P4387-%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>栈</li>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[LEN], b[LEN];</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n || j &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; b[j] == st.<span class="built_in">top</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; n &amp;&amp; !st.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= n)</span><br><span class="line">            st.<span class="built_in">emplace</span>(a[i++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (st.<span class="built_in">empty</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>想了很多骚思路都超时，直接模拟出栈情况就行.....</p>
<p>每个即将入栈的元素，有两种选择：</p>
<ol type="1">
<li>留在栈里</li>
<li>不入栈，直接输出</li>
</ol>
<p>所以在编程的时候，每次只能进行一次操作：</p>
<ol type="1">
<li><p>要么将入栈序列的一个元素压入栈</p></li>
<li><p>要么写一个循环，只要当前出栈序列的元素等于栈顶</p>
<p>那么栈就弹出一个元素，出栈序列选择下一个元素</p></li>
</ol>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>栈、队列、链表_解题技巧</title>
    <url>/2023/10/25/%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E3%80%81%E9%93%BE%E8%A1%A8-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="栈">栈</h1>
<p>熟悉性质与基本操作：</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4387">验证栈序列</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1241">括号序列</a></li>
</ul>
<h1 id="队列">队列</h1>
<p>熟悉性质与基本操作：</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1996">约瑟夫问题</a></li>
</ul>
<p>滑动窗口模板题：</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P2058">海港</a></li>
</ul>
<h1 id="链表">链表</h1>
<p>编程的时候主要两个要点：</p>
<ul>
<li>存放节点的物理数组下标从1开始，因为下标0要留给<code>dummyhead</code>伪节点</li>
<li>增删节点时，节点自身，后继节点，前驱结点这三者都要注意修改</li>
</ul>
<p>熟悉性质与基本操作：</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1160">队列安排</a></li>
</ul>
<p>进阶思路：</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P2234">营业额统计</a></li>
</ul>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>排序_解题技巧</title>
    <url>/2023/10/25/%E6%8E%92%E5%BA%8F-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="模板题">模板题</h1>
<p>模板题：</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1177">P1177</a></li>
</ul>
<p>快排应用，找第K大</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1923">P1923</a></li>
</ul>
<p>归并应用，逆序对</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1908">P1908</a></li>
</ul>
<h1 id="排序的核心逆序对">排序的核心，逆序对</h1>
<ul>
<li><p><a
href="https://www.luogu.com.cn/problem/P1012">P1012</a></p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P4378">P4378</a>
冒泡排序的灵魂</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P4375">P4375</a>
P4378的加强版</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P1966">P1966</a>
最强逆序对的考查题</p></li>
</ul>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1229 遍历问题</title>
    <url>/2023/10/27/P1229-%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>二叉树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//前序序列和后序序列</span></span><br><span class="line">string pre, post;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; pre &gt;&gt; post;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, idx; i &lt; pre.<span class="built_in">length</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; post.<span class="built_in">length</span>(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[i] == post[j] &amp;&amp; pre[i + <span class="number">1</span>] == post[j - <span class="number">1</span>])</span><br><span class="line">                ++n;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; (<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>通过作图可以发现，如果父结点只有一个孩子，在知道前序后序的情况下有不同的中序遍历</p>
<img src="/2023/10/27/P1229-%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98/1.png" class="" title="image-20231027160938241">
<p>由于前序的输出规则是<code>中左右</code>，而后序的输出规则是<code>左右中</code>，显然：</p>
<ul>
<li>如果缺少左孩子，那么前序输出为<code>中右</code>，后序输出为<code>右中</code></li>
<li>如果缺少右孩子，那么前序输出为<code>中左</code>，后序输出为<code>左中</code></li>
</ul>
<p>找到满足这样的父结点数<code>n</code>后，根据乘法原理，每个这样的父结点都有两种可能性：有左孩子或者右孩子</p>
<p>所以最终结果应为2<sup>n</sup></p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>P1305. 新二叉树</title>
    <url>/2023/10/27/P1305-%E6%96%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>二叉树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lc_, rc_;</span><br><span class="line">&#125; tree[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">idx</span><span class="params">(<span class="type">char</span> chr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> chr - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_order</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cout &lt;&lt; (<span class="type">char</span>)(root - <span class="number">1</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="built_in">pre_order</span>(tree[root].lc_), <span class="built_in">pre_order</span>(tree[root].rc_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, flag = <span class="literal">true</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">char</span> root, rt, lc, rc;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; rt &gt;&gt; lc &gt;&gt; rc;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">        &#123;</span><br><span class="line">            root = rt;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tree[<span class="built_in">idx</span>(rt)].lc_ = lc == <span class="string">&#x27;*&#x27;</span> ? <span class="number">0</span> : <span class="built_in">idx</span>(lc);</span><br><span class="line">        tree[<span class="built_in">idx</span>(rt)].rc_ = rc == <span class="string">&#x27;*&#x27;</span> ? <span class="number">0</span> : <span class="built_in">idx</span>(rc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pre_order</span>(<span class="built_in">idx</span>(root));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>由于最多26个结点，且值均不重复；可将值作为结点在链式存储中的物理数组下标，即<code>字母 - 'a' + 1</code></p>
<p>这样即可方便地修改父结点</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>P1827. 美国血统</title>
    <url>/2023/10/27/P1827-%E7%BE%8E%E5%9B%BD%E8%A1%80%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>二叉树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//前序和中序数组</span></span><br><span class="line">string pre, in;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pl 前序左端点</span></span><br><span class="line"><span class="comment">//pr 前序右端点</span></span><br><span class="line"><span class="comment">//il 中序左端点</span></span><br><span class="line"><span class="comment">//ir 中序右端点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pl, <span class="type">int</span> pr, <span class="type">int</span> il, <span class="type">int</span> ir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pr &lt; pl || ir &lt; il)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> idx = il; idx &lt;= ir; ++idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre[pl] == in[idx])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(pl + <span class="number">1</span>, pl + idx - il, il, idx - <span class="number">1</span>);<span class="comment">//递归左子树</span></span><br><span class="line">            <span class="built_in">dfs</span>(pl + idx - il + <span class="number">1</span>, pr, idx + <span class="number">1</span>, ir);<span class="comment">//递归右子树</span></span><br><span class="line">            cout &lt;&lt; pre[pl];<span class="comment">//输出当前根结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; in &gt;&gt; pre;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, pre.<span class="built_in">length</span>() - <span class="number">1</span>, <span class="number">0</span>, in.<span class="built_in">length</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>通过前序遍历可以找出当前二叉树的根（即前序遍历中第一个位置的值）</p>
<p>中序遍历可以找出当前二叉树的根所在的位置，即可以找到左子树与右子树的大小；即可递归找左右子树的根结点</p>
<p>假设有：</p>
<ul>
<li>前序遍历 <code>&#123;1 2 3 4 5 6 7&#125;</code></li>
<li>中序遍历 <code>&#123;4 3 5 2 6 1 7&#125;</code></li>
</ul>
<p>先找出前序遍历的根1，然后在中序遍历中找到1的位置</p>
<ul>
<li><p>前序遍历 <code>&#123;[1] 2 3 4 5 6 7&#125;</code></p></li>
<li><p>中序遍历 <code>&#123;4 3 5 2 6 [1] 7&#125;</code></p></li>
</ul>
<p>所以“4 3 5 2
6”这些数都是在以1为根的左子树里面，“7”是在以1为根的右子树里面</p>
<p>因此，可以在前序遍历中提取出“2 3 4 5
6”这个区间作为左子树的前序遍历，“7”这个区间作为右子树的前序遍历</p>
<p>最终递归的时候按照后序遍历的顺序输出根结点的值即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>P4715. 淘汰赛</title>
    <url>/2023/10/26/P4715-%E6%B7%98%E6%B1%B0%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>二叉树</li>
</ul>
<span id="more"></span>
<p># 题解</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id_, v_;</span><br><span class="line">&#125; arr[<span class="number">4</span> * LEN];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rt arr[root]</span></span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">dfs</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果当前是叶子结点，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (root &gt;= (<span class="number">1</span> &lt;&lt; N))</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    <span class="comment">//递归建立左子树、右子树，最后才建立父结点</span></span><br><span class="line">    <span class="comment">//类似后序遍历</span></span><br><span class="line">    Node lc = <span class="built_in">dfs</span>(root * <span class="number">2</span>), rc = <span class="built_in">dfs</span>(root * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> rt = lc.v_ &gt; rc.v_ ? lc : rc;<span class="comment">//每次取左右孩子的最大值建立父结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="comment">//顺序存储树时，1为根结点下标</span></span><br><span class="line">    <span class="comment">//2 * i为左孩子下标，2 * i + 1为右孩子下标</span></span><br><span class="line">    <span class="comment">//先填满叶子结点，满二叉树中，编号不小于1 &lt;&lt; N都是叶子结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; N); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i + (<span class="number">1</span> &lt;&lt; N)].v_;</span><br><span class="line">        arr[i + (<span class="number">1</span> &lt;&lt; N)].id_ = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; (arr[<span class="number">2</span>].v_ &lt; arr[<span class="number">3</span>].v_ ? arr[<span class="number">2</span>].id_ : arr[<span class="number">3</span>].id_);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题意画出如下流程图</p>
<p>很显然题目是要我们根据叶子结点构造一颗满二叉树，以<strong>父结点等于两个子结点中的最大值</strong>这个规律</p>
<img src="/2023/10/26/P4715-%E6%B7%98%E6%B1%B0%E8%B5%9B/1.png" class="" title="image-20231026193528180">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>P1185. 绘制二叉树</title>
    <url>/2023/10/28/P1185-%E7%BB%98%E5%88%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>二叉树</li>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">10240</span>;</span><br><span class="line"><span class="type">char</span> ans[LEN][LEN]; <span class="comment">//记录答案</span></span><br><span class="line"><span class="type">bool</span> del[LEN][LEN]; <span class="comment">//一维记录被删结点的层次，二维记录被删结点的名次</span></span><br><span class="line"><span class="type">int</span> width, height, m, n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//横纵坐标，层次，在树中的下标</span></span><br><span class="line">    <span class="comment">//左孩子的下标等于 父结点 * 2</span></span><br><span class="line">    <span class="comment">//右孩子的下标等于 父结点 * 2 + 1</span></span><br><span class="line">    <span class="type">int</span> x_, y_, lv_, id_;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> lv, <span class="type">int</span> id) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y), <span class="built_in">lv_</span>(lv), <span class="built_in">id_</span>(id) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">queue&lt;Node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//孩子结点往父亲结点方向，填充斜杠</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">filling</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">bool</span> lft, <span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lft)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">            ans[x + i][y + i] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">            ans[x + i][y - i] = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Node u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//即将填充的斜杠个数</span></span><br><span class="line">        <span class="type">int</span> cnt = u.lv_ == m - <span class="number">1</span> ? <span class="number">1</span> : <span class="number">3</span> * <span class="built_in">pow</span>(<span class="number">2</span>, m + <span class="number">1</span> - u.lv_ - <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//左孩子的信息</span></span><br><span class="line">        <span class="type">int</span> lx = u.x_ - (cnt + <span class="number">1</span>), ly = u.y_ - (cnt + <span class="number">1</span>), llv = u.lv_ + <span class="number">1</span>, lid = u.id_ * <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//右孩子的信息</span></span><br><span class="line">        <span class="type">int</span> rx = u.x_ - (cnt + <span class="number">1</span>), ry = u.y_ + (cnt + <span class="number">1</span>), rlv = u.lv_ + <span class="number">1</span>, rid = u.id_ * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果左孩子不被删除</span></span><br><span class="line">        <span class="keyword">if</span> (!del[llv][lid - (<span class="number">1</span> &lt;&lt; u.lv_) + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            ans[lx][ly] = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">            <span class="comment">//填充斜杠</span></span><br><span class="line">            <span class="built_in">filling</span>(lx, ly, <span class="literal">true</span>, cnt);</span><br><span class="line">            <span class="comment">//如果左孩子是最后一层，说明它是叶子结点没有孩子，就没必要塞入队列</span></span><br><span class="line">            <span class="keyword">if</span> (llv != m)</span><br><span class="line">                q.<span class="built_in">emplace</span>(lx, ly, llv, lid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!del[rlv][rid - (<span class="number">1</span> &lt;&lt; u.lv_) + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            ans[rx][ry] = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">            <span class="built_in">filling</span>(rx, ry, <span class="literal">false</span>, cnt);</span><br><span class="line">            <span class="keyword">if</span> (rlv != m)</span><br><span class="line">                q.<span class="built_in">emplace</span>(rx, ry, rlv, rid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> level, idx;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="comment">//如果只有一层，即根结点，直接输出即可</span></span><br><span class="line">    <span class="comment">//因为不可能删除根结点</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="string">&#x27; &#x27;</span>, <span class="built_in">sizeof</span>(ans));</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; level &gt;&gt; idx;</span><br><span class="line">        del[level][idx] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算整棵树的宽度与高度</span></span><br><span class="line">    width = <span class="number">6</span> * <span class="built_in">pow</span>(<span class="number">2</span>, m - <span class="number">2</span>) - <span class="number">1</span>, height = <span class="number">3</span> * <span class="built_in">pow</span>(<span class="number">2</span>, m - <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//加入根结点</span></span><br><span class="line">    q.<span class="built_in">emplace</span>(height - <span class="number">1</span>, (width - <span class="number">1</span>) / <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    ans[height - <span class="number">1</span>][(width - <span class="number">1</span>) / <span class="number">2</span>] = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = height - <span class="number">1</span>; x &gt;= <span class="number">0</span>; --x, cout &lt;&lt; endl)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; width; ++y)</span><br><span class="line">            cout &lt;&lt; ans[x][y];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>具体实现细节见代码，主要阐述一下编程思维</p>
<p>很容易想到实现流程：</p>
<ul>
<li><p>最终要输出结果，所以需要二维数组<code>ans</code>来保存</p>
<p>还要一个标志数组<code>del</code>记录第几层的第几个结点需要被删除</p></li>
<li><p>从根结点开始，递归地处理左子树与右子树</p>
<p>左右子树的处理次序与答案不相关，DFS或BFS的实现也与答案不相关；因为本身其实是一颗满二叉树</p>
<p>但这种按层次处理的二叉树问题，显然用BFS能极大降低思维难度</p></li>
<li><p>若用BFS实现</p>
<p>每次当前的父结点判断左右孩子是否需要被删除：</p>
<ul>
<li><p>需要被删除的就不填充斜杠与孩子结点</p></li>
<li><p>保留的孩子则填充与父结点之间的斜杠；若孩子所处不在最后一层，就将其添加进队列进行下一轮扩展</p>
<p>（最后一层是叶子结点，没有孩子，扩展啥）</p></li>
</ul></li>
</ul>
<hr />
<p>答案的存储样式如下：</p>
<img src="/2023/10/28/P1185-%E7%BB%98%E5%88%B6%E4%BA%8C%E5%8F%89%E6%A0%91/1.png" class="" title="image-20231028225318216">
<p>先找找x轴，即二叉树的高度<code>height</code>的规律</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">m</th>
<th style="text-align: center;">height</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">6</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">12</td>
</tr>
</tbody>
</table>
<p>得到<span class="math inline">\(height=3\times
2^{m-2}\)</span>这一规律，其中<code>m = 1</code>只有根结点的时候特判即可</p>
<p>接下来找y轴，二叉树的宽度<code>width</code>的规律</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">m</th>
<th style="text-align: center;">width</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">5</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">11</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">23</td>
</tr>
</tbody>
</table>
<p>得到<span class="math inline">\(width=6\times
2^{m-2}-1\)</span>这一规律，同样<code>m = 1</code>时特判</p>
<hr />
<p>根结点的位置规律：<span
class="math inline">\(\text{横坐标}x=height-1\)</span>，<span
class="math inline">\(\text{纵坐标}y=\frac{width-1}{2}\)</span></p>
<p>由于满二叉树的对称性，尽管题目没有给出其他层数的数据，但知道根结点就能在草稿纸上推斜杠的规律</p>
<hr />
<p>正常情况下根结点所在层次定义为第一层，但是斜杠的规律就不好找；所以定义叶子结点为固定的第一层</p>
<p>设当前层次为<code>lv</code>，斜杠数定义为<strong>当前层次的父结点与其左或右孩子中间的斜杠数</strong></p>
<p>比如<code>lv = 3</code>，此时斜杠数等于第3层的父结点与第2层的左或右孩子中间的斜杠数</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">lv</th>
<th style="text-align: center;">斜杠数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">11</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;">23</td>
</tr>
</tbody>
</table>
<p>得到<span class="math inline">\(\text{斜杠数}=3\times
2^{lv-3}-1\)</span>，<code>lv</code>等于2时特判</p>
<p>这是叶子结点为第一层时的定义，需要将其转换为根结点为第一层的定义：<span
class="math inline">\(\text{斜杠数}=3\times 2^{m+1-lv-3}-1\)</span></p>
<blockquote>
<p>你可以自己发现一下规律，有数组<code>&#123;1, 2, 3, 4&#125;</code></p>
<p>要变成<code>&#123;4, 3, 2, 1&#125;</code>要如何做呢？</p>
<p>每个元素被5减不就好了嘛~</p>
</blockquote>
<hr />
<p>如何断定当前结点是该层的第几个呢？</p>
<p>假设根结点的下标为1，以顺序存储的办法</p>
<p>那么左孩子的下标为<code>父结点下标 * 2</code>，右孩子的下标为<code>父结点下标 * 2 + 1</code></p>
<img src="/2023/10/28/P1185-%E7%BB%98%E5%88%B6%E4%BA%8C%E5%8F%89%E6%A0%91/2.png" class="" title="image-20231028233451559">
<p>假设当前为<code>k + 1</code>层，下标为<code>id</code>；根据满二叉树的性质，本层之前共有<span
class="math inline">\(2^k-1\)</span>个结点</p>
<p>那么该节点在本层的次序，不就等于<span class="math inline">\(id-\left(
2^k-1 \right)\)</span>嘛</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>P4913. 二叉树深度</title>
    <url>/2023/10/26/P4913-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>二叉树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lc_, rc_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rt arr[root]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(rt.lc_), <span class="built_in">dfs</span>(rt.rc_)) + <span class="number">1</span>;<span class="comment">//根结点的深度 = 左右子树的最大深度 + 根结点本身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i].lc_ &gt;&gt; arr[i].rc_;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题目每次是按照结点编号增加子结点的，如果按照顺序存储，估算一下数组大小：</p>
<ul>
<li>1结点的子结点若是2，那么2的下标是<code>1结点的下标 * 2 = 2</code></li>
<li>2结点的子结点若是3，那么3的下标是<code>2结点的下标 * 2 = 4</code></li>
<li>3结点的子结点若是4，那么4的下标是<code>3结点的下标 * 2 = 8</code></li>
<li>如此类推，1e6节点的下标是2<sup>1e6</sup>，任何类型的数组都存不下</li>
</ul>
<p>上述是二叉树的一种极端情况，退化成了一条链</p>
<p>此时树的深度等于结点个数<code>n</code>，若采用顺序存储需要建立一个大小为2<sup>n</sup>的数组</p>
<img src="/2023/10/26/P4913-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6/1.png" class="" title="image-20231026212214958">
<p>所以需要用链式存储，用结构体记录左右孩子的位置</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>P5076. 普通二叉树（简化版）</title>
    <url>/2023/10/29/P5076-%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E7%AE%80%E5%8C%96%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>平衡树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//lc_: 左孩子下标</span></span><br><span class="line">    <span class="comment">//rc_: 右孩子下标</span></span><br><span class="line">    <span class="comment">//size_: 以当前结点为根结点时，左右子树的结点个数和(包括本身的个数num_)</span></span><br><span class="line">    <span class="comment">//value_: 结点的权值</span></span><br><span class="line">    <span class="comment">//num_: 当前结点权值出现的次数</span></span><br><span class="line">    <span class="type">int</span> lc_, rc_, size_, value_, num_;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> lc = <span class="number">0</span>, <span class="type">int</span> rc = <span class="number">0</span>, <span class="type">int</span> size = <span class="number">0</span>, <span class="type">int</span> value = <span class="number">0</span>, <span class="type">int</span> num = <span class="number">1</span>) : <span class="built_in">lc_</span>(lc), <span class="built_in">rc_</span>(rc), <span class="built_in">size_</span>(size), <span class="built_in">value_</span>(value), <span class="built_in">num_</span>(num) &#123;&#125;</span><br><span class="line">&#125; tree[LEN];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rt tree[root]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc tree[tree[root].lc_]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc tree[tree[root].rc_]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//更新沿途的结点信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rt.size_ = lc.size_ + rc.size_ + rt.num_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找数的排名</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rk</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//若找不到，返回第一个大于x的数的排名</span></span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//小于当前根结点值，向左子树找</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; rt.value_)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rk</span>(x, rt.lc_);</span><br><span class="line">    <span class="comment">//大于当前根结点值，向右子树找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; rt.value_)</span><br><span class="line">        <span class="keyword">return</span> lc.size_ + rt.num_ + <span class="built_in">rk</span>(x, rt.rc_);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> lc.size_ + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询排名为x的数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//排名x的数在左子树</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt;= lc.size_)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">kth</span>(x, rt.lc_);</span><br><span class="line">    <span class="comment">//当前根结点就是排名为x的数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt;= lc.size_ + rt.num_)</span><br><span class="line">        <span class="keyword">return</span> rt.value_;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">kth</span>(x - lc.size_ - rt.num_, rt.rc_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//x在左子树</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; rt.value_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果左子树存在，继续递归</span></span><br><span class="line">        <span class="keyword">if</span> (rt.lc_)</span><br><span class="line">            <span class="built_in">insert</span>(x, rt.lc_);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tree[rt.lc_ = ++tot] = <span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, x);<span class="comment">//不存在则新建左孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; rt.value_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (rt.rc_)</span><br><span class="line">            <span class="built_in">insert</span>(x, rt.rc_);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tree[rt.rc_ = ++tot] = <span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ++rt.num_;</span><br><span class="line">    <span class="built_in">update</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> q, root, opt, x;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    tree[root = ++tot] = <span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2147483647</span>);</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; opt &gt;&gt; x;</span><br><span class="line">        <span class="keyword">switch</span> (opt)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            cout &lt;&lt; <span class="built_in">rk</span>(x, root) &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            cout &lt;&lt; <span class="built_in">kth</span>(x, root) &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nth = <span class="built_in">rk</span>(x, root) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nth == <span class="number">0</span>)</span><br><span class="line">                cout &lt;&lt; <span class="number">-2147483647</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="built_in">kth</span>(nth, root) &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            cout &lt;&lt; <span class="built_in">kth</span>(<span class="built_in">rk</span>(x + <span class="number">1</span>, root), root) &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">insert</span>(x, root);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本题是BST二叉搜索树的模板题，BST本身并没有应用空间，基本都是在用Splay、Treap、红黑树等平衡树</p>
<p>但手敲BST之后能对后续的平衡树学习有极大的帮助</p>
<p>具体实现细节见代码，主要讲一下实现难点</p>
<h2 id="编程设计">编程设计</h2>
<h3 id="查询x数的排名">查询x数的排名</h3>
<p>每次将x和根结点root的权值比较：</p>
<ul>
<li><p>如果x小于根结点root的权值，那么root及其右子树里面的所有权值都比x要大，所以递归下去查询左子树</p></li>
<li><p>如果x大于根结点root的权值，那么root及其左子树里面的所有权值都比x要小，所以递归下去查找右子树</p>
<p>并且把左子树的大小及根结点的权值出现次数纳入到答案中</p></li>
<li><p>如果x等于根结点root的权值，答案就等于<code>左子树大小 + 1</code></p></li>
<li><p>如果x不存在，返回第一个大于x的数的排名</p></li>
</ul>
<p>比如数据<code>&#123;1, 2, 3, 3, 5&#125;</code></p>
<p>查询0，应返回1</p>
<p>查询3，应返回3</p>
<p>查询5，应返回5</p>
<p>查询6，应返回6</p>
<h3 id="查询排名为x的数">查询排名为x的数</h3>
<ul>
<li>如果x小于或等于左子树的大小，则数必在左子树当中，递归查询左子树</li>
<li>如果x大于左子树的大小但小于等于<code>左子树大小 + 根结点权值出现次数</code>，说明根结点的权值就是该数</li>
<li>若大于<code>左子树大小 + 根结点权值出现次数</code>，说明在右子树；则减去<code>左子树大小 + 根结点权值出现次数</code>后递归查询右子树</li>
</ul>
<h3 id="插入">插入</h3>
<p>找合适的位置插入即可，不再赘述</p>
<h3 id="前驱与后继">前驱与后继</h3>
<p>这才是本题的核心坑点</p>
<p>根据题眼<strong>未找到前驱输出−2147483647，未找到后驱输出2147483647</strong>，实际上就是数列中的极小值和极大值...</p>
<p>找数的排名时，若该数不存在则返回第一个大于该数的排名；可以插入一个结点，令其权值设为极大值</p>
<p>比如<code>&#123;1, 2&#125;</code>查找数字3，得到的结果是3，但是数列并没有3；直接插入极大值<code>&#123;1, 2, 2147483647&#125;</code>解决</p>
<p>可以直接插入极小值吗？不可以！因为排名是根据左子树大小来计算的，插入极小值左子树大小会变更</p>
<p>考虑到唯一没有前驱的时候，就是求第一元素的前驱...所以特判即可处理</p>
<hr />
<p>怎么求前驱呢？先求该数的排名<code>nth</code>，再去找排名等于<code>nth - 1</code>的数即可</p>
<blockquote>
<p>题目说了，<strong>排名定义为比当前数小的数的个数+1</strong></p>
<p>无论该数有多少个重复，都只取该数的第一个的排名作为答案</p>
<p>若该数不存在，也是<strong>返回第一个大于该数的排名</strong></p>
<p>两种情况下，排名减去1都是前驱的排名</p>
</blockquote>
<p>怎么求后驱呢？不能像前驱那样，会受重复数的影响</p>
<blockquote>
<p>比如有例子<code>&#123;1, 3, 3, 4, 4, 5&#125;</code></p>
<p>查找3，排名为2</p>
<p>查找4，排名为4</p>
<p>如果找排名为3的数，答案是3而不是4</p>
</blockquote>
<p>应该去找<code>x + 1</code>的数的排名，再通过这个排名去找数，才能得到后继</p>
<p>还是那个性质，<strong>若该数不存在，返回第一个大于该数的排名</strong></p>
<blockquote>
<p>比如有例子<code>&#123;1, 3, 3, 4, 4, 7&#125;</code></p>
<p>要找4的后继，就先去找5的排名</p>
<p>但是5不存在，返回排名6</p>
<p>再去找排名6的数，得到真正的后继数字7</p>
</blockquote>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树_解题技巧</title>
    <url>/2023/10/30/%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="二叉树基础">二叉树基础</h2>
<ul>
<li><p><a href="https://www.luogu.com.cn/problem/P4715">P4715</a>
顺序存储基础</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P4913">P4913</a>
链式存储基础</p></li>
</ul>
<h2 id="二叉树的遍历">二叉树的遍历</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1827">P1827</a>
根据前序中序求后序</li>
<li><a href="https://www.luogu.com.cn/problem/P1229">P1229</a>
根据前序后序求中序个数，找只有一个孩子的父结点</li>
<li><a href="https://www.luogu.com.cn/problem/P1305">P1305</a>
建树后求前序</li>
<li><a href="https://www.luogu.com.cn/problem/P1030">P1030</a>
根据中序后序求前序</li>
<li><a href="https://www.luogu.com.cn/problem/P1185">P1185</a>
层次遍历构建二叉树，重要的模拟题！</li>
</ul>
<h2 id="二叉搜索树-bst">二叉搜索树 BST</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P5076">P5076</a>
模板题</li>
</ul>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>P1113 杂务</title>
    <url>/2023/11/09/P1113-%E6%9D%82%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>拓扑排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="comment">//每个任务的前置任务中的最大时间开销，每个任务的时间开销，每个任务的入度</span></span><br><span class="line"><span class="type">int</span> n, mx[LEN], val[LEN], ind[LEN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[LEN];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> rt;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ind[i] == <span class="number">0</span>) &#123;</span><br><span class="line">      rt = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  q.<span class="built_in">emplace</span>(rt);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, sz = e[u].<span class="built_in">size</span>(); i &lt; sz; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> v = e[u][i];</span><br><span class="line">      <span class="comment">//取前置任务开销里最大的</span></span><br><span class="line">      mx[v] = <span class="built_in">max</span>(mx[v], val[u]);</span><br><span class="line">      <span class="keyword">if</span> (--ind[v] == <span class="number">0</span>) &#123;</span><br><span class="line">        val[v] += mx[v];</span><br><span class="line">        q.<span class="built_in">emplace</span>(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a, b, c;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    val[a] = b;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; c &amp;&amp; c) &#123;</span><br><span class="line">      e[c].<span class="built_in">emplace_back</span>(a);</span><br><span class="line">      ++ind[a];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">toposort</span>();</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans = <span class="built_in">max</span>(ans, val[i]);</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>拓扑排序的模板题，直接上《深基》的图解便于理解，只不过书上用DFS实现，我用的Kahn</p>
<img src="/2023/11/09/P1113-%E6%9D%82%E5%8A%A1/1.png" class="" title="image-20231109224134030">
<img src="/2023/11/09/P1113-%E6%9D%82%E5%8A%A1/2.png" class="" title="image-20231109224243858">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1196. 银河英雄传说</title>
    <url>/2023/11/13/P1196-%E9%93%B6%E6%B2%B3%E8%8B%B1%E9%9B%84%E4%BC%A0%E8%AF%B4/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>边带权并查集</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">10e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, fa[LEN], dis[LEN], sz[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="type">int</span> anc = fa[x];</span><br><span class="line">  fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">  dis[x] += dis[anc];</span><br><span class="line">  <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="built_in">find</span>(x), b = <span class="built_in">find</span>(y);</span><br><span class="line">  fa[a] = b;</span><br><span class="line">  dis[a] = sz[b];</span><br><span class="line">  sz[b] += sz[a];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i, sz[i] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; ch &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">join</span>(x, y);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">find</span>(x) != <span class="built_in">find</span>(y))</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">abs</span>(dis[x] - dis[y]) - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题目要求两结点中间有多少个结点，令<code>dis[x]</code>为<code>x</code>走到祖宗结点的所需步数</p>
<p>这样一来，<code>abs(dis[x] - dis[y])</code>就能得到<code>x</code>走到<code>y</code>的所需步数，再减去到达<code>y</code>的那一步</p>
<p>最终要求的就是<code>abs(dis[x] - dis[y]) - 1</code></p>
<blockquote>
<p>题目要求结点之间的个数，不含两结点本身</p>
</blockquote>
<hr />
<p>先考虑路径压缩部分。由于并查集合并时只会修改祖宗结点</p>
<p>那么结点3的步数可以直接从0修改到集合A的大小，令<code>sz[x]</code>为<code>x</code>为祖先时，其内部的集合大小</p>
<p>即<code>dis[3] = sz[1] = 2</code></p>
<p>但是<code>dis[4]</code>仍等于1，还是处在以3为祖先情况下尚未更新</p>
<p>所以应该有<code>新dis[4] = 原dis[4] + 更新后的dis[3]</code></p>
<hr />
<p>再考虑合并部分。</p>
<p>方才提到，可以直接令结点3的步数赋值为集合A的大小，结合路径压缩就可以更新集合B的所有子结点</p>
<p>修改完结点3后，再更新集合A的大小<code>sz[1] = sz[1] + sz[3]</code></p>
<img src="/2023/11/13/P1196-%E9%93%B6%E6%B2%B3%E8%8B%B1%E9%9B%84%E4%BC%A0%E8%AF%B4/1.png" class="" title="image-20231113014542307">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>P1347. 排序</title>
    <url>/2023/11/18/P1347-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>拓扑排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">26</span>;</span><br><span class="line"><span class="type">int</span> n, m, tot, cnt, len, head[LEN], ind[LEN], tind[LEN], val[LEN];</span><br><span class="line">string ans;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> to_, nxt_;</span><br><span class="line">&#125; e[(<span class="type">int</span>)<span class="number">600</span> + <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  e[tot].nxt_ = head[u], e[tot].to_ = v;</span><br><span class="line">  head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 由于是在线建图，入度为0且有边的结点才纳入</span></span><br><span class="line">    <span class="keyword">if</span> (~head[i] &amp;&amp; !tind[i]) &#123;</span><br><span class="line">      q.<span class="built_in">emplace</span>(i);</span><br><span class="line">      <span class="comment">// 初始时路径长度为1，即本身</span></span><br><span class="line">      val[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    ans += (<span class="type">char</span>)(u + <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    ++cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = e[i].nxt_) &#123;</span><br><span class="line">      <span class="type">int</span> v = e[i].to_;</span><br><span class="line">      val[v] = <span class="built_in">max</span>(val[v], val[u] + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (--tind[v] == <span class="number">0</span>) q.<span class="built_in">emplace</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) len = <span class="built_in">max</span>(len, val[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (tind[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 链式前向星保存有向边</span></span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">  string in;</span><br><span class="line">  <span class="type">int</span> u, v;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="comment">// 每次都要拓扑排序+找最长路，得初始化</span></span><br><span class="line">    <span class="comment">// len记录最长路径，cnt记录拓扑序列长度，ans记录答案</span></span><br><span class="line">    len = cnt = <span class="number">0</span>, ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">memset</span>(val, <span class="number">0</span>, <span class="built_in">sizeof</span>(val));</span><br><span class="line">    cin &gt;&gt; in, u = in[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>, v = in[<span class="number">2</span>] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="built_in">add</span>(u, v), ++ind[v];</span><br><span class="line">    <span class="built_in">copy</span>(ind, ind + LEN, tind);</span><br><span class="line">    <span class="comment">// 初始化结束</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">toposort</span>()) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Inconsistency found after &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; relations.&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt == n &amp;&amp; len == n) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Sorted sequence determined after &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; relations: &quot;</span> &lt;&lt; ans</span><br><span class="line">           &lt;&lt; <span class="string">&quot;.&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cnt != n || len != n) cout &lt;&lt; <span class="string">&quot;Sorted sequence cannot be determined.&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>将题目抽象化，记<code>A -&gt; B</code>为<code>A &lt; B</code>，实际上是问所给条件能否构成<code>A -&gt; B -&gt; C -&gt; D</code></p>
<p>需要满足以下两个条件：</p>
<ul>
<li>不存在环路，<code>A -&gt; D</code>时不可能存在<code>D -&gt; A</code></li>
<li>图中的最长路长度等于元素个数<code>n</code></li>
</ul>
<p>所以步骤设计如下：</p>
<ol type="1">
<li>用链式前向星在线建图。因为结果要返回步骤数，不能选择离线</li>
<li>每次拓扑排序+寻找最长路，有以下三种情况：
<ul>
<li>拓扑序列的元素个数、<code>n</code>、最长路长度三者相等，此时能确定整个数列的顺序</li>
<li>边全部建完后，上述三者仍有不等的情况，说明无法确定</li>
<li>拓扑序列的元素个数不等于<code>n</code>，说明存在环路，输出矛盾结果</li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1536. 村村通</title>
    <url>/2023/10/30/P1536-%E6%9D%91%E6%9D%91%E9%80%9A/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>并查集</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1050</span>;</span><br><span class="line"><span class="type">int</span> ans, fa[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> fa[], <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa, fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> fa[], <span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> f1 = <span class="built_in">find</span>(fa, a), f2 = <span class="built_in">find</span>(fa, b);</span><br><span class="line">    <span class="keyword">if</span> (f1 != f2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//每次合并都会减少一个连通块</span></span><br><span class="line">        fa[f1] = f2;</span><br><span class="line">        --ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, a, b;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            fa[i] = i;</span><br><span class="line">        ans = n;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            <span class="built_in">join</span>(fa, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题眼<strong>任何两个城镇间都可以实现交通</strong>，也就是将所有城镇并入到同一个集合中，考虑并查集</p>
<p>先处理每条存在的边，即把每条存在的边所连接的两个结点用并查集合并起来</p>
<p>然后通过记录不同的代表元个数，就可以知道有多少个集合，即有多少个连通块了</p>
<p>每次合并连通块的个数都会减一，若要满足题意，则连通块应该只有一个；所以答案就是<code>连通块数 - 1</code></p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>P1525. 关押罪犯</title>
    <url>/2023/11/10/P1525-%E5%85%B3%E6%8A%BC%E7%BD%AA%E7%8A%AF/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>扩展域并查集</li>
<li>贪心</li>
<li>二分图</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//扩大一倍</span></span><br><span class="line"><span class="type">int</span> n, m, fa[LEN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="built_in">find</span>(x), b = <span class="built_in">find</span>(y);</span><br><span class="line">  fa[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y_, w_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="comment">//扩大的那一倍也要初始化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (n &lt;&lt; <span class="number">1</span>); ++i) fa[i] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; arr[i].x_ &gt;&gt; arr[i].y_ &gt;&gt; arr[i].w_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(arr + <span class="number">1</span>, arr + <span class="number">1</span> + m,</span><br><span class="line">       [](node &amp;a, node &amp;b) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> a.w_ &gt; b.w_; &#125;);</span><br><span class="line">  <span class="type">int</span> x, y, a, b;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    x = arr[i].x_, y = arr[i].y_;</span><br><span class="line">    <span class="keyword">if</span> ((a = <span class="built_in">find</span>(x)) == (b = <span class="built_in">find</span>(y))) &#123;</span><br><span class="line">      cout &lt;&lt; arr[i].w_;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">join</span>(x, y + n), <span class="built_in">join</span>(y, x + n);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>扩展域并查集的模板题</p>
<p>很容易想到贪心策略，将仇恨值从大到小排，优先拆开仇恨值大的，即可保证后续数据组成的集合仇恨值尽量小</p>
<p>样例为例，排序后得到数据如下，自上而下处理：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">x</th>
<th style="text-align: center;">y</th>
<th style="text-align: center;">w</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">28351</td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">12884</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">6618</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">3512</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">2534</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">1805</td>
</tr>
</tbody>
</table>
<p>对于每个人而言，都有两种关系：“我的朋友”和“我的敌人”</p>
<p>扩展域并查集中，多一种关系就扩大一倍空间以存储额外的关系；在这里，多出来的一倍空间存储<strong>我的敌人</strong>集合</p>
<p>假设当前有输入<code>1 2 28351</code></p>
<p><code>2</code>应该放在<code>1 + n</code>同一集合，意为将<code>2</code>放入<code>1</code>的敌人集合</p>
<p>相应的，<code>1</code>应该放在<code>2 + n</code>同一集合，意为将<code>1</code>放入<code>2</code>的敌人集合</p>
<p>重复上述操作，直到发现当前两个人已经在同一集合内，无法再拆；此时就得到了最大的仇恨值，输出即可</p>
<blockquote>
<p>我们是以仇恨值从大到小的顺序拆开两个人的</p>
<p>若当前二人已在同一集合，是之前拆分更大仇恨值得到的结果</p>
<p>如果依旧再拆，岂不是违背贪心策略吗？</p>
</blockquote>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>并查集</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>P1363. 幻象迷宫</title>
    <url>/2023/11/17/P1363-%E5%B9%BB%E8%B1%A1%E8%BF%B7%E5%AE%AB/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">2500</span>;</span><br><span class="line"><span class="type">int</span> n, m, walk[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="type">bool</span> ans;</span><br><span class="line"><span class="type">char</span> arr[LEN][LEN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">bool</span> vis_;</span><br><span class="line">  <span class="type">int</span> nx_, ny_;</span><br><span class="line">&#125; vis[LEN][LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> nx, <span class="type">int</span> ny)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ans) <span class="keyword">return</span>;</span><br><span class="line">  x = (x + n) % n, y = (y + m) % m;</span><br><span class="line">  <span class="keyword">if</span> (arr[x][y] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (vis[x][y].vis_) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((vis[x][y].nx_ != nx || vis[x][y].ny_ != ny)) ans = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  vis[x][y].vis_ = <span class="number">1</span>, vis[x][y].nx_ = nx, vis[x][y].ny_ = ny;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(x + walk[i][<span class="number">0</span>], y + walk[i][<span class="number">1</span>], nx + walk[i][<span class="number">0</span>], ny + walk[i][<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">    ans = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i][j];</span><br><span class="line">        <span class="keyword">if</span> (arr[i][j] == <span class="string">&#x27;S&#x27;</span>) x = i, y = j;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(x, y, x, y);</span><br><span class="line">    cout &lt;&lt; (ans ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>迷宫是能无限延伸的，但实际上就是个九宫格....</p>
<p>终止条件如下：</p>
<ul>
<li><p>遇到墙停止</p></li>
<li><p>遇到之前走过的、取模后相对位置相同的起点停止，说明可以无限循环</p></li>
</ul>
<p>但通过作图可以发现，不管在迷宫外还是迷宫内都有可能存在环</p>
<p>正常的标志数组<code>vis</code>只会记录坐标是否访问过，这里需要做如下改进：</p>
<ul>
<li><p><code>x</code>和<code>y</code>为取模后的坐标，用于判断相对位置；<code>nx</code>和<code>ny</code>记录真实的坐标</p></li>
<li><p><code>nx_</code>和<code>ny_</code>记录上一次访问该结点的真实坐标，<code>vis_</code>判断该结点是否被访问过</p></li>
<li><p>如果再次遇到某个点，其性质如下，则说明能无限循环：</p>
<ul>
<li>该点之前被访问过（<code>vis_</code>为真）</li>
<li>之前访问该点的真实坐标，与当前真实坐标不同(<code>nx != nx_</code>或<code>ny != ny_</code>)</li>
</ul>
<p>如果是环，第二次遇到该点真实坐标还是会相同；</p>
<p>而若能无限循环，第二次的真实坐标肯定与第一次不同，一往无前了都</p></li>
</ul>
<img src="/2023/11/17/P1363-%E5%B9%BB%E8%B1%A1%E8%BF%B7%E5%AE%AB/1.png" class="" title="image-20231117165900624">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1551. 亲戚</title>
    <url>/2023/10/30/P1551-%E4%BA%B2%E6%88%9A/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>并查集</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">5050</span>;</span><br><span class="line"><span class="type">int</span> fa[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> f1 = <span class="built_in">find</span>(a), f2 = <span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span> (f1 != f2)</span><br><span class="line">        fa[f1] = f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, p, a, b;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">join</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(a) != <span class="built_in">find</span>(b))</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>并查集的模板题，我觉得《深基》讲得还是很透彻的，直接上图</p>
<img src="/2023/10/30/P1551-%E4%BA%B2%E6%88%9A/1.png" class="" title="image-20231030144044001">
<img src="/2023/10/30/P1551-%E4%BA%B2%E6%88%9A/2.png" class="" title="image-20231030144147864">
<img src="/2023/10/30/P1551-%E4%BA%B2%E6%88%9A/3.png" class="" title="image-20231030144225172">
<img src="/2023/10/30/P1551-%E4%BA%B2%E6%88%9A/4.png" class="" title="image-20231030144259743">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>P1621. 集合</title>
    <url>/2023/11/10/P1621-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>并查集</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a, b, p, cnt, fa[LEN], prim[LEN];</span><br><span class="line"><span class="type">bool</span> vis[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="built_in">find</span>(x), b = <span class="built_in">find</span>(y);</span><br><span class="line">  fa[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//线性筛</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= b; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) prim[cnt++] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">1ll</span> * i * prim[j] &gt; b) <span class="keyword">continue</span>;</span><br><span class="line">      vis[i * prim[j]] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (i % prim[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= b; ++i) fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x; i &lt; cnt; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prim[i] &lt; p) <span class="keyword">continue</span>;</span><br><span class="line">    x = prim[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j * x &lt;= b; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j * x &gt;= a) <span class="built_in">join</span>(x, x * j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = a; i &lt;= b; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[i] == i) ++ans;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>先用线性筛得到指定范围内的所有质数，再枚举每个质数的所有倍数；若倍数在指定范围内，则质数所在集合与倍数所在集合合并即可</p>
<p>注意！质数本身可能不在范围内，但合并时会将其并入</p>
<p>故而合并时，应将质数的祖先设置为倍数，便于统计集合数</p>
<p>如图所示，显然前者通过<code>fa[i] == i</code>即可一次遍历得到集合数；而后者需要一次寻找各结点祖先，一次计数祖先共两次遍历</p>
<img src="/2023/11/10/P1621-%E9%9B%86%E5%90%88/1.png" class="" title="image-20231110230158304">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>质数</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>P1807. 最长路</title>
    <url>/2023/11/15/P1807-%E6%9C%80%E9%95%BF%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>拓扑排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">5e4</span> + <span class="number">50</span>, MIN = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"><span class="type">int</span> n, m, tot, head[LEN], dp[LEN], ind[LEN];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> to_, nxt_, w_;</span><br><span class="line">&#125; e[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">  e[tot].nxt_ = head[u], e[tot].to_ = v, e[tot].w_ = w;</span><br><span class="line">  head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ind[i]) &#123;</span><br><span class="line">      q.<span class="built_in">emplace</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = e[i].nxt_) &#123;</span><br><span class="line">      <span class="type">int</span> v = e[i].to_;</span><br><span class="line">      <span class="keyword">if</span> (dp[u] != MIN) dp[v] = <span class="built_in">max</span>(dp[v], dp[u] + e[i].w_);</span><br><span class="line">      <span class="keyword">if</span> (--ind[v] == <span class="number">0</span>) q.<span class="built_in">emplace</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> u, v, w;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head)), <span class="built_in">memset</span>(dp, <span class="number">0xc0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    <span class="built_in">add</span>(u, v, w);</span><br><span class="line">    ++ind[v];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">toposort</span>();</span><br><span class="line">  cout &lt;&lt; (dp[n] == MIN ? <span class="number">-1</span> : dp[n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题目说明了是<strong>有向无环图</strong>，即DAG，那么就可以使用拓扑排序</p>
<p>设<code>dp[x]</code>为到达结点<code>x</code>的最长路径，可以找到状态转移方程：
<span class="math display">\[
dp\left[ v \right] =\max \left( dp\left[ v \right] ,dp\left[ u \right]
+w \right) ,u\xrightarrow{w}v
\]</span>
题目问的仅仅是<code>1</code>到<code>n</code>的最长路径，除1以外的、入度为0的结点为起点的路径就要无视掉</p>
<p>所以令<code>dp[1] = 0</code>，而其他入度为0的结点设置为<code>dp[x] = MIN</code></p>
<p>这样一来，在决定最大路径时，只要忽略<code>dp[x] == MIN</code>的结点即可</p>
<p>因为拓扑排序是自上而下的，子结点等于<code>MIN</code>只有一种情况，那就是没有访问到</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1892. 团伙</title>
    <url>/2023/11/11/P1892-%E5%9B%A2%E4%BC%99/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>扩展域并查集</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, p, q, fa[LEN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="built_in">find</span>(x), b = <span class="built_in">find</span>(y);</span><br><span class="line">  fa[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (n &lt;&lt; <span class="number">1</span>); ++i) fa[i] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; ch &gt;&gt; p &gt;&gt; q;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">join</span>(p, q);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">join</span>(q + n, p), <span class="built_in">join</span>(p + n, q);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (fa[i] == i) ++ans;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>典型的扩展域并查集</p>
<p>每个人都有两种关系属性，<strong>我的朋友</strong>和<strong>我的敌人</strong>，所以<code>fa</code>数组应该多开一倍</p>
<p><code>1 ~ n</code>的范围存储<strong>我的朋友</strong>这一关系，<code>n + 1 ~ 2n</code>的范围存储<strong>我的敌人</strong>这一关系</p>
<p>题目给了两个关系传递要求：</p>
<ul>
<li><p>朋友的朋友是朋友</p>
<p><code>p</code>和<code>q</code>直接合并即可</p></li>
<li><p>敌人的敌人是朋友</p>
<p>对于<code>p</code>而言，它的敌人关系对应<code>p + n</code>，那么<code>q</code>应与<code>p + n</code>同处一集合</p>
<p>同样的，对于<code>q</code>而言，它的敌人关系对应<code>q + n</code>，那么<code>p</code>应于<code>q + n</code>同处一集合</p>
<p>考虑以下样例：</p>
<blockquote>
<p>E 1 2</p>
<p>E 2 6</p>
</blockquote></li>
</ul>
<p>​ 设字符<code>&#123;&#125;</code>代表同一集合，根据上述描述有：</p>
<p>​
<code>&#123;1+n, 2&#125;</code>、<code>&#123;2+n, 1&#125;</code>、<code>&#123;2+n, 6&#125;</code>、<code>&#123;6+n, 2&#125;</code></p>
<p>​ 是满足题目要求的</p>
<p>这里还有一个小Trick，合并的时候应让朋友关系设置为敌人关系的祖先，而不能颠倒：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">join</span>(q + n, p), <span class="built_in">join</span>(p + n, q);</span><br></pre></td></tr></table></figure>
<p>两者颠倒从效果上看并不会有差异，无论怎样二者都将同处一集合</p>
<p>但朋友关系设为敌人关系的祖先，最终统计连通块个数会更方便，只需一次遍历判断<code>fa[i] == i</code>即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>P1955. 程序自动分析</title>
    <url>/2023/11/11/P1955-%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>并查集</li>
<li>离散化</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, tot, fa[LEN], discre[LEN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y_, e_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="built_in">find</span>(x), b = <span class="built_in">find</span>(y);</span><br><span class="line">  fa[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 离散化开始</span></span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; arr[i].x_ &gt;&gt; arr[i].y_ &gt;&gt; arr[i].e_;</span><br><span class="line">    discre[tot++] = arr[i].x_, discre[tot++] = arr[i].y_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(discre, discre + tot);</span><br><span class="line">  tot = <span class="built_in">unique</span>(discre, discre + tot) - discre;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    arr[i].x_ = <span class="built_in">lower_bound</span>(discre, discre + tot, arr[i].x_) - discre + <span class="number">1</span>;</span><br><span class="line">    arr[i].y_ = <span class="built_in">lower_bound</span>(discre, discre + tot, arr[i].y_) - discre + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 离散化结束</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="built_in">sort</span>(arr + <span class="number">1</span>, arr + <span class="number">1</span> + n,</span><br><span class="line">       [](node &amp;a, node &amp;b) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> a.e_ &gt; b.e_; &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i].e_) &#123;</span><br><span class="line">      <span class="built_in">join</span>(arr[i].x_, arr[i].y_);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">find</span>(arr[i].x_) == <span class="built_in">find</span>(arr[i].y_)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) <span class="built_in">work</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本题<strong>不能</strong>使用扩展域并查集或边带权并查集，从两个角度分析</p>
<h2 id="边带权并查集">边带权并查集</h2>
<p>举个例子：</p>
<ul>
<li><p>A和B相等，B和C相等，能推出A等于C</p></li>
<li><p>A和B相等，B和C不等，能推出A不等于C</p></li>
<li><p>A和B不等，B和C相等，能推出A不等于C</p></li>
<li><p>A和B不等，B和C不等，A和C能确定唯一的关系吗？不能吧</p>
<p>假设A等于1，B等于2，C也等于1，此时A等于C</p>
<p>若A等于1，B等于2，C等于3，此时A不等于C</p>
<p>并查集是不能处理重边的，它本身只是一个森林</p></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">A(A与B的关系边权)</th>
<th style="text-align: center;">B(B与C的关系边权)</th>
<th style="text-align: center;">C(A与C的关系边权)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">?</td>
</tr>
</tbody>
</table>
<h2 id="扩展域并查集">扩展域并查集</h2>
<p>举个例子：</p>
<blockquote>
<p>1 2 0</p>
<p>2 3 0</p>
</blockquote>
<p>也就是1不等于2, 2不等于3</p>
<p>按照扩展域的处理方式，原长度存储相等关系，扩大一倍的长度存储不等关系</p>
<p>那么有<code>&#123;1+n, 2&#125;</code>、<code>&#123;2+n, 1&#125;</code>、<code>&#123;2+n, 3&#125;</code>、<code>&#123;3+n, 2&#125;</code></p>
<p>合并后的结果为<code>&#123;1+n, 3+n, 2&#125;</code>、<code>&#123;2+n, 1, 3&#125;</code></p>
<p>可是1和3之间的关系并不能确定啊？你这就把它俩放一个集合了？</p>
<h2 id="正解">正解</h2>
<p>首先离散化，1e9的数据范围肯定会炸</p>
<p>通过排序，先处理相等关系，然后再判断不等关系是否与相等关系矛盾即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>P1918 保龄球</title>
    <url>/2023/10/31/P1918-%E4%BF%9D%E9%BE%84%E7%90%83/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q, in;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; in, mp[in] = i;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; in;</span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="built_in">count</span>(in))</span><br><span class="line">            cout &lt;&lt; mp[in] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题眼<strong>保证各个位置的瓶子数不同</strong>，直接用哈希表模拟即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P2024. 食物链</title>
    <url>/2023/11/12/P2024-%E9%A3%9F%E7%89%A9%E9%93%BE/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>边带权并查集</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, k, fa[LEN], val[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="type">int</span> anc = fa[x];</span><br><span class="line">  fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">  val[x] = (val[x] + val[anc]) % <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="built_in">find</span>(x), b = <span class="built_in">find</span>(y);</span><br><span class="line">  fa[a] = b;</span><br><span class="line">  val[a] = (val[y] + w - val[x] + <span class="number">3</span>) % <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x, y, w, a, b, ans = <span class="number">0</span>;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i;</span><br><span class="line">  <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">    cin &gt;&gt; w &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; n || y &gt; n || (w == <span class="number">2</span> &amp;&amp; x == y))</span><br><span class="line">      ++ans;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      --w;</span><br><span class="line">      a = <span class="built_in">find</span>(x), b = <span class="built_in">find</span>(y);</span><br><span class="line">      <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">        <span class="built_in">join</span>(x, y, w);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != (val[x] - val[y] + <span class="number">3</span>) % <span class="number">3</span>) ++ans;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>边带权并查集的模板题</p>
<p>设边权表达式为<span
class="math inline">\(X\xrightarrow{w}Y\)</span></p>
<ul>
<li><code>w</code>等于0时，X和Y是同类</li>
<li><code>w</code>等于1时，X吃Y</li>
<li><code>w</code>等于2时，X被Y吃</li>
</ul>
<h2 id="边权表">边权表</h2>
<p>举几个例子：</p>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 18%" />
<col style="width: 18%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">A(A对于B的关系)</th>
<th style="text-align: center;">B(B对于C的关系)</th>
<th style="text-align: center;">C(A对于C的关系)</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td
style="text-align: center;">A、B同类，B、C同类，那么A、C也是同类</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">A吃B，B吃C，那么A被C吃</td>
</tr>
<tr class="odd">
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">A被B吃，B被C吃，那么A吃C</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">A吃B，B、C同类，那么A吃C</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">A、B同类，B吃C，那么A吃C</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">A被B吃，B、C同类，那么A被C吃</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">A、B同类，B被C吃，那么A被C吃</td>
</tr>
</tbody>
</table>
<p>可以发现，如果已知<code>A -&gt; B</code>，<code>B -&gt; C</code>，可得<code>A -&gt; C</code></p>
<p>边权表是编写边带权并查集的核心，只有关系能够递推与传递才有意义啊</p>
<h2 id="路径压缩">路径压缩</h2>
<p>如左图所示，B是A的父亲，C是A、B的祖先（所以中间画虚线）；右图则是路径压缩后的模样</p>
<img src="/2023/11/12/P2024-%E9%A3%9F%E7%89%A9%E9%93%BE/1.png" class="" title="image-20231112195946997">
<p>可以发现，已知<code>A -&gt; B</code>，<code>B -&gt; C</code>，要求<code>A -&gt; C</code></p>
<p>这一操作在刚才的边权表已经计算过了，可以直接令<code>val[x]</code>为<code>x</code>结点到其祖先的边权</p>
<p>那么有</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> B = fa[A];</span><br><span class="line">...</span><br><span class="line"><span class="comment">//原本A-&gt;B的边权加上B-&gt;C的边权，就等于A-&gt;C的边权啦</span></span><br><span class="line">val[A] = (val[A] + val[B]) % <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<img src="/2023/11/12/P2024-%E9%A3%9F%E7%89%A9%E9%93%BE/2.png" class="" title="image-20231112202420158">
<h2 id="合并">合并</h2>
<p>两个集合合并时，<strong>只</strong>需要修改祖先结点的<code>val值</code>，因为子结点会在路径压缩的过程中更新</p>
<p>已知x和y的边权为w，要合并x和y所在的集合，<strong>只</strong>需要修改祖先a的<code>val值</code></p>
<blockquote>
<p>因为祖先a的祖先原本是自己，现在变成祖先b了</p>
</blockquote>
<p>通过作图，可以得到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内部加3是为了避免负数的出现</span></span><br><span class="line">val[a] = (val[y] + w - val[x] + <span class="number">3</span>) % <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<img src="/2023/11/12/P2024-%E9%A3%9F%E7%89%A9%E9%93%BE/3.png" class="" title="image-20231112211003065">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>P1983. 车站分级</title>
    <url>/2023/11/19/P1983-%E8%BD%A6%E7%AB%99%E5%88%86%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>贪心</li>
<li>拓扑排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, cnt, tot, ans, head[LEN], val[LEN], ind[LEN];</span><br><span class="line"><span class="type">bool</span> vis[LEN][LEN];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> to_, nxt_;</span><br><span class="line">&#125; e[(<span class="type">int</span>)<span class="number">1e6</span> + <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  e[tot].nxt_ = head[u], e[tot].to_ = v;</span><br><span class="line">  head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ind[i] == <span class="number">0</span>) &#123;</span><br><span class="line">      q.<span class="built_in">emplace</span>(i);</span><br><span class="line">      val[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = e[i].nxt_) &#123;</span><br><span class="line">      <span class="type">int</span> v = e[i].to_;</span><br><span class="line">      val[v] = <span class="built_in">max</span>(val[v], val[u] + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (--ind[v] == <span class="number">0</span>) q.<span class="built_in">emplace</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, val[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//链式前向星存储有向边</span></span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">  <span class="type">int</span> bg, ed, arr[LEN], used[LEN];</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr)), <span class="built_in">memset</span>(used, <span class="number">0</span>, <span class="built_in">sizeof</span>(used));</span><br><span class="line">    cin &gt;&gt; cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++j) &#123;</span><br><span class="line">      cin &gt;&gt; arr[j];</span><br><span class="line">      used[arr[j]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bg = arr[<span class="number">1</span>], ed = arr[cnt];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = bg; u &lt;= ed; ++u) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!used[u]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v, k = <span class="number">1</span>; k &lt;= cnt; ++k) &#123;</span><br><span class="line">          v = arr[k];</span><br><span class="line">          <span class="keyword">if</span> (!vis[u][v]) &#123;</span><br><span class="line">            <span class="comment">//去掉重边</span></span><br><span class="line">            vis[u][v] = <span class="number">1</span>;</span><br><span class="line">            ++ind[v];</span><br><span class="line">            <span class="built_in">add</span>(u, v);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">toposort</span>();</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>由于要级别最少，可以考虑以下贪心策略：</p>
<p>令停靠站之间的优先级均相等，设停靠站的集合为<code>A</code>；不停靠站之间的优先级也均相等，设不停靠站的集合为<code>B</code></p>
<p>而不停靠站的优先级肯定小于停靠站的，有<code>A &gt; B</code>，即两个优先级</p>
<p>推广一下，题目需求的最少优先级数，实际上是求<code>A &gt; B &gt; C ... &gt; D</code>这一有向无环图的最长路径</p>
<p>所以步骤设计如下：</p>
<ol type="1">
<li>令每辆车的不停靠站指向停靠站（反过来也行，能代表大小关系即可）</li>
<li>去掉重边（不同车经过的站点可能相同）</li>
<li>拓扑排序求最长路径即可</li>
</ol>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P2294. 狡猾的商人</title>
    <url>/2023/11/13/P2294-%E7%8B%A1%E7%8C%BE%E7%9A%84%E5%95%86%E4%BA%BA/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>边带权并查集</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, fa[LEN], dis[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="type">int</span> anc = fa[x];</span><br><span class="line">  fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">  dis[x] += dis[anc];</span><br><span class="line">  <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="built_in">find</span>(x), b = <span class="built_in">find</span>(y);</span><br><span class="line">  fa[a] = b;</span><br><span class="line">  dis[a] = dis[y] + w - dis[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="type">int</span> x, y, w;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) fa[i] = i, dis[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">    --x;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(x) != <span class="built_in">find</span>(y)) &#123;</span><br><span class="line">      <span class="built_in">join</span>(x, y, w);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (dis[x] - dis[y] != w) &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  flag ? <span class="built_in">puts</span>(<span class="string">&quot;true&quot;</span>) : <span class="built_in">puts</span>(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) <span class="built_in">work</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>询问当前请求是否满足前提条件的，要量化之前的关系保存下来的，一般是边带权并查集</p>
<h2 id="路径压缩">路径压缩</h2>
<p>设<code>dis[x]</code>为<code>x</code>结点到当前祖先结点的步数，通过作图可知<code>[x, y] = dis[x - 1] - dis[y]</code></p>
<p>通过编程实现就是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">新dis[x] = 原dis[x] + 新dis[x的父亲]</span><br></pre></td></tr></table></figure>
<img src="/2023/11/13/P2294-%E7%8B%A1%E7%8C%BE%E7%9A%84%E5%95%86%E4%BA%BA/1.png" class="" title="image-20231113150746687">
<h2 id="合并">合并</h2>
<p>同样作图，很显然能得到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dis[a] = dis[y] + w - dis[x];</span><br></pre></td></tr></table></figure>
<img src="/2023/11/13/P2294-%E7%8B%A1%E7%8C%BE%E7%9A%84%E5%95%86%E4%BA%BA/2.png" class="" title="image-20231113152409678">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>P2712. 摄像头</title>
    <url>/2023/11/20/P2712-%E6%91%84%E5%83%8F%E5%A4%B4/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>拓扑排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="comment">// arr记录摄像头的位置，is判断当前位置是不是摄像头所在</span></span><br><span class="line"><span class="type">int</span> n, tot, cnt, head[LEN], ind[LEN], arr[LEN];</span><br><span class="line"><span class="type">bool</span> is[LEN];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> nxt_, to_;</span><br><span class="line">&#125; e[LEN * LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  e[tot].nxt_ = head[u], e[tot].to_ = v;</span><br><span class="line">  head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ind[arr[i]] == <span class="number">0</span>) &#123;</span><br><span class="line">      q.<span class="built_in">emplace</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    ++cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = e[i].nxt_) &#123;</span><br><span class="line">      <span class="type">int</span> v = e[i].to_;</span><br><span class="line">      <span class="comment">// 入度为0的摄像头才加入队列，不是摄像头没有意义呀</span></span><br><span class="line">      <span class="keyword">if</span> (is[v] &amp;&amp; --ind[v] == <span class="number">0</span>) q.<span class="built_in">emplace</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 链式前向星存储有向边</span></span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">  <span class="type">int</span> u, v, m;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; u;</span><br><span class="line">    is[arr[i] = u] = <span class="literal">true</span>;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">      cin &gt;&gt; v;</span><br><span class="line">      ++ind[v];</span><br><span class="line">      <span class="built_in">add</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">toposort</span>();</span><br><span class="line">  cnt == n ? cout &lt;&lt; <span class="string">&quot;YES&quot;</span> : cout &lt;&lt; n - cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>设有向边<code>A -&gt; B</code>为A监视B</p>
<p>如果拆掉A，被监视的B自然就少一个入度；若要删除B，就必须保证B没有入度（不被监视）</p>
<p>每次都只处理入度为0的结点，其中产生新的入度0结点也要循环处理</p>
<p>显然直接套拓扑排序板子即可....</p>
<p>记得额外新建数组保存摄像头的位置哟~</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P3370. 字符串哈希</title>
    <url>/2023/10/30/P3370-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>哈希函数</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">23333</span>, P = <span class="number">131</span>;</span><br><span class="line">string s;</span><br><span class="line">vector&lt;string&gt; hsh[LEN];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)s.<span class="built_in">length</span>(); ++i)</span><br><span class="line">        h = (<span class="number">1ll</span> * P * h + s[i]) % LEN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; hsh[h].<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hsh[h][i] == s)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hsh[h].<span class="built_in">emplace_back</span>(s);</span><br><span class="line">    ++ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>经典的拉链法处理哈希碰撞</p>
<p>拉链法是在每个存放数据的地方开一个链表/数组</p>
<p>如果有多个键值索引到同一个地方，把它们都放到那个位置的链表/数组中</p>
<p>查询的时候需要把对应位置的链表/数组整个扫一遍，对其中的每个数据比较其键值与查询的键值是否一致</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>哈希函数</tag>
      </tags>
  </entry>
  <entry>
    <title>P2814. 家谱</title>
    <url>/2023/11/12/P2814-%E5%AE%B6%E8%B0%B1/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>并查集</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;string, string&gt; fa;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">find</span><span class="params">(string x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(string x, string y)</span> </span>&#123;</span><br><span class="line">  string a = <span class="built_in">find</span>(x), b = <span class="built_in">find</span>(y);</span><br><span class="line">  fa[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">  string anc, str;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; str &amp;&amp; (ch = str[<span class="number">0</span>]) != <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">    str = str.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果不存在这个人，就先初始化</span></span><br><span class="line">    <span class="keyword">if</span> (!fa.<span class="built_in">count</span>(str)) fa[str] = str;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">      anc = str;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">join</span>(str, anc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cout &lt;&lt; str &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">find</span>(str) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>并查集的板子题，只不过从数组改用哈希表</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>P3405. Cities and States S</title>
    <url>/2023/10/31/P3405-Cities-and-States-S/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>哈希函数</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">23333</span>, P = <span class="number">131</span>;</span><br><span class="line"><span class="comment">//拉链法处理冲突</span></span><br><span class="line"><span class="comment">//pair第一个元素保存字符串哈希值，第二个元素保存字符串哈希值出现的个数</span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; hsh[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gethash</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>) * P * P * P + (a[<span class="number">1</span>] - <span class="string">&#x27;A&#x27;</span>) * P * P + (b[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>) * P + (b[<span class="number">1</span>] - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = x % LEN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; hsh[idx].<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//哈希表中存在该字符串哈希值，增加次数即可</span></span><br><span class="line">        <span class="keyword">if</span> (hsh[idx][i].first == x)</span><br><span class="line">        &#123;</span><br><span class="line">            ++hsh[idx][i].second;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若不存在，新增</span></span><br><span class="line">    hsh[idx].<span class="built_in">emplace_back</span>(x, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = x % LEN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; hsh[idx].<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hsh[idx][i].first == x)</span><br><span class="line">            <span class="keyword">return</span> hsh[idx][i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] == b[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ans += <span class="built_in">find</span>(<span class="built_in">gethash</span>(b.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">2</span>), a.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">2</span>)));</span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">gethash</span>(a.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">2</span>), b.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">2</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>输入<code>城市+州</code>，要你去找<code>州+城市</code>的字符串个数，手写哈希表并用拉链法处理冲突即可</p>
<p>哈希本身不难，看题解即可。下面着重讲一下重点：</p>
<h2 id="去重">去重</h2>
<p>统计对数，一般都是离线操作，即统计完所有各类字符串的个数后，从头扫到尾</p>
<p>比如字符串<code>ab</code>有2个，字符串<code>ba</code>有3个，那么就有<code>2 * 3 = 6</code>对；但遇到字符串<code>ba</code>会再去寻找<code>ab</code>，重复计算</p>
<p>如果是在线操作，就不会重复了，相当于当前字符串与前面满足条件的字符串各组一次</p>
<blockquote>
<p>比如有满足条件的字符串A和B，与之配对的有C和D</p>
<p>离线操作中，迭代到字符串A和B时，有<code>A -- c</code>、<code>A -- D</code>、<code>B -- C</code>、<code>B -- D</code></p>
<p>迭代到字符串C和D时，又会重复<code>C -- A</code>、<code>C -- B</code>、<code>D -- A</code>、<code>D -- B</code></p>
<p>所以直接在线操作就好，只留后者那一种情况</p>
</blockquote>
<h2 id="坑">坑</h2>
<p>假设有组合城市<code>a</code>、州<code>b</code>，城市<code>c</code>、州<code>d</code></p>
<p>按照题目的要求，寻找<code>a == d</code>且<code>b == c</code>的一对组合进行配对</p>
<p>考虑一个满足条件的特例，如果<code>a == b</code>，此时<code>a == d</code>且<code>a == c</code>，那么<code>b == d == a == c</code></p>
<p>然而题目说<strong>同一个州内不会有两个同名的城市</strong>，该特例虽满足配对条件，但与前提不符，应当删去</p>
<p>就是下面这段代码的由来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] == b[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>哈希函数</tag>
      </tags>
  </entry>
  <entry>
    <title>P3535. TOU-Tour de Byteotia</title>
    <url>/2023/11/14/P3535-TOU-Tour-de-Byteotia/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>并查集</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, k, fa[LEN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="built_in">find</span>(x), b = <span class="built_in">find</span>(y);</span><br><span class="line">  fa[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x, y, ans = <span class="number">0</span>;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    e[x].<span class="built_in">emplace_back</span>(y), e[y].<span class="built_in">emplace_back</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> u, v, i = n; i &gt; k; --i) &#123;</span><br><span class="line">    fa[i] = u = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; e[u].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">      v = e[u][j];</span><br><span class="line">      <span class="keyword">if</span> (fa[v] &amp;&amp; <span class="built_in">find</span>(u) != <span class="built_in">find</span>(v)) <span class="built_in">join</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> u, v, i = k; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">    fa[i] = u = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; e[u].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">      v = e[u][j];</span><br><span class="line">      <span class="keyword">if</span> (!fa[v]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">find</span>(u) == <span class="built_in">find</span>(v))</span><br><span class="line">        ++ans;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">join</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>并查集其中一个用途就是用来判环：</p>
<blockquote>
<p>A、B两结点已连通（祖先相同），若此时再赋A、B两点一条边，必存在环</p>
</blockquote>
<p>由于题目要求<strong>编号小于等于k的点都不在环上</strong>，那也得先有环啊：</p>
<ol type="1">
<li>反向建图，编号从<code>n</code>遍历到<code>k+1</code>，编号大于k的点先构成图</li>
<li>编号从<code>k</code>遍历到<code>1</code>，判断当前结点的所有边，若与之前的图构成环，则删除</li>
</ol>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>P2853. Cow Picnic S</title>
    <url>/2023/11/17/P2853-Cow-Picnic-S/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, k, tot, ans, head[LEN], vis[LEN], cow[LEN], cnt[LEN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> to_, nxt_;</span><br><span class="line">&#125; e[(<span class="type">int</span>)<span class="number">1e5</span> + <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  e[tot].nxt_ = head[u], e[tot].to_ = v;</span><br><span class="line">  head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vis[x]) <span class="keyword">return</span>;</span><br><span class="line">  vis[x] = <span class="number">1</span>;</span><br><span class="line">  ++cnt[x];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; ~i; i = e[i].nxt_) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(e[i].to_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> u, v;</span><br><span class="line">  cin &gt;&gt; k &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) cin &gt;&gt; cow[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    <span class="built_in">add</span>(u, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">dfs</span>(cow[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt[i] == k) ++ans;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>从奶牛所在牧场开始dfs，所经路径中的牧场的被访问次数加一</p>
<p>dfs结束后，遍历所有牧场的被访问次数，等于<code>k</code>就是我们需要的</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P3916 图的遍历</title>
    <url>/2023/11/09/P3916-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>强连通分量</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<h2 id="dfs">DFS</h2>
<p>如果直接对每个点都做一次DFS，肯定超时</p>
<p>考虑在DFS的过程中做优化。设DFS函数<code>f(x)</code>为x能到达的编号最大的点</p>
<p>显然有<code>f(1) = max(1, f(2))</code>，<code>f(2) = max(2, f(4))</code>，<code>f(4) = max(4, f(3))</code>，<code>f(3) = 3</code></p>
<p>这样一来，在回溯的过程中就能一并处理同一路径的其他结点，避免重复计算</p>
<img src="/2023/11/09/P3916-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/1.png" class="" title="image-20231109215350499">
<p>但是，图论的题目得当心是否存在环；本题并没有说排除环这一情况，如下图的一个环</p>
<p><code>f(1) = max(1, f(2))</code>，<code>f(2) = max(2, f(4))</code>，<code>f(4) = max(4, f(3))</code>，<code>f(3) = max(3, f(1))</code></p>
<p>如果按照上述思路，<code>f(3)</code>最终会拿自己和<strong>未更新</strong>的<code>f(1)</code>进行相比，得到错误的<code>f(3) = 3</code>，但实际上<code>f(3) = 4</code></p>
<img src="/2023/11/09/P3916-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/2.png" class="" title="image-20231109220637253">
<p>所以转变一下思路，之前是让点自己去找它能到达的最大的点，现在让最大的点去告诉哪些点能到达它</p>
<p>用反向边建图，若原图中有一条边是<code>u -&gt; v</code>，我们就建反向的边<code>v -&gt; u</code></p>
<p>从编号大的结点<code>v</code>开始DFS，更新所经路径上没有被更新过的结点为<code>v</code>即可</p>
<blockquote>
<p>因为从<code>n</code>枚举到1时，被更新过的点一定是用比当前数字大的点更新的</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, val[LEN];</span><br><span class="line"><span class="comment">//标志数组，走过的结点不再走</span></span><br><span class="line"><span class="type">bool</span> vis[LEN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> mx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vis[x]) <span class="keyword">return</span>;</span><br><span class="line">  val[x] = mx, vis[x] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, sz = e[x].<span class="built_in">size</span>(); i &lt; sz; ++i) <span class="built_in">dfs</span>(e[x][i], mx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    e[y].<span class="built_in">emplace_back</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) <span class="built_in">dfs</span>(i, i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cout &lt;&lt; val[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>P4017. 最大食物链计数</title>
    <url>/2023/11/14/P4017-%E6%9C%80%E5%A4%A7%E9%A3%9F%E7%89%A9%E9%93%BE%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>拓扑排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">5e5</span> + <span class="number">50</span>, MOD = <span class="number">80112002</span>;</span><br><span class="line"><span class="type">int</span> n, m, f[LEN], ind[LEN], outd[LEN];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (ind[i] == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//将入度为0的点加入队列</span></span><br><span class="line">      q.<span class="built_in">emplace</span>(i);</span><br><span class="line">      f[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="type">int</span> y = e[x][i];</span><br><span class="line">      f[y] = (f[y] + f[x]) % MOD;</span><br><span class="line">      <span class="comment">//点y无入度，将点y加入队列</span></span><br><span class="line">      <span class="keyword">if</span> (--ind[y] == <span class="number">0</span>) q.<span class="built_in">emplace</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="comment">//邻接表存储边</span></span><br><span class="line">    e[x].<span class="built_in">emplace_back</span>(y);</span><br><span class="line">    <span class="comment">//点x的出度加1，点y的入度加1</span></span><br><span class="line">    ++outd[x], ++ind[y];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">toposort</span>();</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="comment">//在出度为0的点中统计答案</span></span><br><span class="line">    <span class="keyword">if</span> (outd[i] == <span class="number">0</span>) ans = (ans + f[i]) % MOD;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>拓扑排序的模板题，直接用《深基》的截图吧~</p>
<img src="/2023/11/14/P4017-%E6%9C%80%E5%A4%A7%E9%A3%9F%E7%89%A9%E9%93%BE%E8%AE%A1%E6%95%B0/1.png" class="" title="image-20231114200308386">
<img src="/2023/11/14/P4017-%E6%9C%80%E5%A4%A7%E9%A3%9F%E7%89%A9%E9%93%BE%E8%AE%A1%E6%95%B0/2.png" class="" title="image-20231114200526164">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P4305. 不重复数字</title>
    <url>/2023/11/11/P4305-%E4%B8%8D%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">5e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> in;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    cin &gt;&gt; in;</span><br><span class="line">    <span class="keyword">if</span> (!mp.<span class="built_in">count</span>(in)) &#123;</span><br><span class="line">      cout &lt;&lt; in &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">      mp[in] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mp.<span class="built_in">clear</span>();</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) <span class="built_in">f</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>哈希表记录是否出现过即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P5250. 木材仓库</title>
    <url>/2023/10/31/P5250-%E6%9C%A8%E6%9D%90%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, opt, val;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; opt &gt;&gt; val;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">count</span>(val))</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Already Exist&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                st.<span class="built_in">emplace</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (st.<span class="built_in">empty</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            set&lt;<span class="type">int</span>&gt;::iterator i = st.<span class="built_in">lower_bound</span>(val), j = i;</span><br><span class="line">            <span class="comment">//val比所有数都小，只有第一个数符合</span></span><br><span class="line">            <span class="keyword">if</span> (i == st.<span class="built_in">begin</span>())</span><br><span class="line">                <span class="number">1</span> == <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//val比所有数都大，只有最后一个数符合</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == st.<span class="built_in">end</span>())</span><br><span class="line">                --i;</span><br><span class="line">            <span class="comment">//比较前后两个数谁更接近val，程度相同取前者(取出比较短的一根)</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i = val - *(--j) &lt;= (*i) - val ? j : i;</span><br><span class="line">            cout &lt;&lt; (*i) &lt;&lt; endl, st.<span class="built_in">erase</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>直接看题解即可，很简单的模拟题</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P5318. 查找文献</title>
    <url>/2023/11/08/P5318-%E6%9F%A5%E6%89%BE%E6%96%87%E7%8C%AE/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
<li>BFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[LEN];</span><br><span class="line"><span class="comment">//标志数组，限制结点只被访问一次</span></span><br><span class="line"><span class="type">bool</span> vis[LEN];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序后存储</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; arr[i].x_ &gt;&gt; arr[i].y_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(arr + <span class="number">1</span>, arr + <span class="number">1</span> + m, [](edge &amp;a, edge &amp;b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.x_ != b.x_) <span class="keyword">return</span> a.x_ &lt; b.x_;</span><br><span class="line">    <span class="keyword">return</span> a.y_ &lt; b.y_;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    e[arr[i].x_].<span class="built_in">emplace_back</span>(arr[i].y_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vis[x]) <span class="keyword">return</span>;</span><br><span class="line">  vis[x] = <span class="literal">true</span>;</span><br><span class="line">  cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, sz = e[x].<span class="built_in">size</span>(); i &lt; sz; ++i) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(e[x][i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">  q.<span class="built_in">emplace</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; u &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, sz = e[u].<span class="built_in">size</span>(); i &lt; sz; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vis[e[u][i]]) <span class="keyword">continue</span>;</span><br><span class="line">      vis[e[u][i]] = <span class="literal">true</span>;</span><br><span class="line">      q.<span class="built_in">emplace</span>(e[u][i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>图遍历的模板题，直接看题解就行</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P5266. 学籍管理</title>
    <url>/2023/10/31/P5266-%E5%AD%A6%E7%B1%8D%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, opt, score;</span><br><span class="line">    string name;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; opt;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; name &gt;&gt; score;</span><br><span class="line">            mp[name] = score;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;OK&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; name;</span><br><span class="line">            <span class="keyword">if</span> (!mp.<span class="built_in">count</span>(name))</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Not found&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; mp[name] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; name;</span><br><span class="line">            <span class="keyword">if</span> (!mp.<span class="built_in">count</span>(name))</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Not found&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mp.<span class="built_in">erase</span>(name), cout &lt;&lt; <span class="string">&quot;Deleted successfully&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; mp.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>直接用哈希表模拟即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P5937. Parity Game</title>
    <url>/2023/11/13/P5937-Parity-Game/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>边带权并查集</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, cnt, fa[LEN], val[LEN], discrete[LEN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y_, w_;</span><br><span class="line">&#125; arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="type">int</span> anc = fa[x];</span><br><span class="line">  fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">  val[x] ^= val[anc];</span><br><span class="line">  <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="built_in">find</span>(x), b = <span class="built_in">find</span>(y);</span><br><span class="line">  val[a] = w ^ val[y] ^ val[x];</span><br><span class="line">  fa[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 离散化开始</span></span><br><span class="line">  <span class="built_in">sort</span>(discrete + <span class="number">1</span>, discrete + <span class="number">1</span> + cnt);</span><br><span class="line">  cnt = <span class="built_in">unique</span>(discrete + <span class="number">1</span>, discrete + <span class="number">1</span> + cnt) - (discrete + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    arr[i].x_ =</span><br><span class="line">        <span class="built_in">lower_bound</span>(discrete + <span class="number">1</span>, discrete + <span class="number">1</span> + cnt, arr[i].x_) - discrete;</span><br><span class="line">    arr[i].y_ =</span><br><span class="line">        <span class="built_in">lower_bound</span>(discrete + <span class="number">1</span>, discrete + <span class="number">1</span> + cnt, arr[i].y_) - discrete;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 离散化结束</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cnt; ++i) fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x, y, w;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    x = arr[i].x_, y = arr[i].y_, w = arr[i].w_;</span><br><span class="line">    --x;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(x) != <span class="built_in">find</span>(y)) &#123;</span><br><span class="line">      <span class="built_in">join</span>(x, y, w);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (val[x] ^ val[y] != w) &#123;</span><br><span class="line">        cout &lt;&lt; i - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string str;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; arr[i].x_ &gt;&gt; arr[i].y_ &gt;&gt; str;</span><br><span class="line">    arr[i].w_ = str[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    discrete[++cnt] = arr[i].x_, discrete[++cnt] = arr[i].y_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">init</span>(), <span class="built_in">work</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>数据范围高达1e9，所以先需要离散化</p>
<h2 id="路径压缩">路径压缩</h2>
<p>先作图，发现结点之间的边权是可以传递的，可以进行路径压缩：</p>
<img src="/2023/11/13/P5937-Parity-Game/2.png" class="" title="image-20231113225244583">
<p>令偶数边权为0，奇数边权为1，可以发现以下规律：</p>
<table style="width:100%;">
<colgroup>
<col style="width: 29%" />
<col style="width: 29%" />
<col style="width: 29%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">x(x走到y步数的奇偶性)</th>
<th style="text-align: center;">y(y走到z步数的奇偶性)</th>
<th style="text-align: center;">z(x走到z步数的奇偶性)</th>
<th style="text-align: center;">备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">偶+偶=偶</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">偶+奇=奇</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">奇+偶=奇</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">奇+奇=偶</td>
</tr>
</tbody>
</table>
<p>令<code>val[x]</code> 为x走到当前祖先的所需步数，直接用异或即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">新val[x] = 旧val[x] ^ 新val[父结点]</span><br></pre></td></tr></table></figure>
<h2 id="合并">合并</h2>
<p>根据上述推断，显然有<code>x到y的步数 + y到祖先b的步数 = x到祖先b的步数</code></p>
<p>就可以得到<code>祖先a到祖先b的步数 = x到y的步数 + y到祖先b的步数 - x到祖先a的步数</code></p>
<img src="/2023/11/13/P5937-Parity-Game/3.png" class="" title="image-20231113225445542">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>P6121. Closing the Farm G</title>
    <url>/2023/11/13/P6121-Closing-the-Farm-G/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>反向建图</li>
<li>并查集</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, tot, fa[LEN], del[LEN], ans[LEN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="built_in">find</span>(x), b = <span class="built_in">find</span>(y);</span><br><span class="line">  fa[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="comment">// 不能加这句话哟！因为要确定该结点是否已被新建</span></span><br><span class="line">  <span class="comment">// for (int i = 1; i &lt;= n; ++i) fa[i] = i;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="comment">//无向图当然双向都要保存</span></span><br><span class="line">    e[x].<span class="built_in">emplace_back</span>(y), e[y].<span class="built_in">emplace_back</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; del[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">    <span class="comment">//建立该结点</span></span><br><span class="line">    fa[x] = x = del[i];</span><br><span class="line">    ++tot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>, sz = e[x].<span class="built_in">size</span>(); j &lt; sz; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (fa[y = e[x][j]] &amp;&amp; <span class="built_in">find</span>(x) != <span class="built_in">find</span>(y)) &#123;</span><br><span class="line">        --tot;</span><br><span class="line">        <span class="built_in">join</span>(x, y);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[i] = tot;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans[i] == <span class="number">1</span> ? <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>) : <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>并查集基本不考虑删除操作，时间复杂度直接上天了</p>
<p>从原图逐个删结点，完全可以用反向建图来达到一样的效果：</p>
<ul>
<li><p><code>fa</code>数组在常规并查集中，需要初始化为自己，代表默认情况下祖先就是自己</p>
<p>这里不需要初始化，保持为0即可，代表“尚未创建该结点”</p>
<p>直到建立该结点时，再初始化为<code>fa[x] = x</code></p>
<p>每次建立新结点时，<code>tot</code>加一，因为多了一个独立的连通块</p></li>
<li><p>遍历当前结点的边，如果同边的另一个结点已被创建，说明当前这条边就是有效的</p>
<p>但是，应再判断另一个结点是否已经与当前结点连通；若连通，没必要合并，若不连通，合并的同时<code>tot</code>减1</p></li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>P8710. 网络分析</title>
    <url>/2023/11/13/P8710-%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>并查集</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, fa[LEN], val[LEN], add[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="built_in">find</span>(x), b = <span class="built_in">find</span>(y);</span><br><span class="line">  <span class="comment">//剪枝，否则超时</span></span><br><span class="line">  <span class="keyword">if</span> (a == b) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    val[i] += add[<span class="built_in">find</span>(i)];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(add, <span class="number">0</span>, <span class="built_in">sizeof</span>(add));</span><br><span class="line">  fa[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="type">int</span> opt, a, b, p, t;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    cin &gt;&gt; opt;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">      cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">      <span class="built_in">join</span>(a, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">      cin &gt;&gt; p &gt;&gt; t;</span><br><span class="line">      add[<span class="built_in">find</span>(p)] += t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cout &lt;&lt; val[i] + add[<span class="built_in">find</span>(i)] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>将并查集作为数据结构的好题很少见啊~</p>
<p>更新并查集的一个子结点，如何将影响扩散至整个集合？</p>
<p>将各个子结点的累加量，记录在该子结点的祖先，即<code>add[祖先]</code>保存</p>
<p>每次合并前，遍历整个集合，把祖先记录的累加量一次性赋给其所在集合内的所有子结点</p>
<blockquote>
<p>假设集合A有累加量<code>4</code>，B有累加量<code>8</code>，A、B两集合即将合并</p>
<p>我们应分别将<code>4</code>赋给集合A的所有结点，<code>8</code>赋给集合B的所有结点后，两集合再合并</p>
<p>否则强行合并的话，最终就变成了B集合有累加量<code>4 + 8 = 12</code>，这是不对的</p>
</blockquote>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>P8686. 修改数组</title>
    <url>/2023/11/14/P8686-%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>并查集</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, fa[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x, anc;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; LEN; ++i) fa[i] = i;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    cout &lt;&lt; (anc = <span class="built_in">find</span>(x)) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    fa[anc] = anc + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>并查集在搜索上的妙用</p>
<p>考虑以下例子：</p>
<ol type="1">
<li><p>初始状态下，数组为空；分别输入<code>2</code>、<code>1</code>，数组变成<code>&#123;2, 1&#125;</code></p></li>
<li><p>再输入<code>1</code>，你会希望数组内的<code>1</code>元素指向<code>3</code>，这样就不必暴力地轮询加1</p>
<p>如果输入<code>2</code>呢？你也希望数组内的<code>2</code>元素指向<code>3</code></p>
<p>塞入<code>3</code>后，数组变成<code>&#123;2, 1, 3&#125;</code></p></li>
<li><p>再输入<code>1</code>，你希望数组内的<code>1</code>元素指向<code>4</code></p>
<p>如果输入<code>2</code>呢？你希望数组内的<code>2</code>元素指向<code>4</code></p>
<p>如果输入<code>3</code>呢？你还是希望数组内的<code>3</code>元素指向<code>4</code></p>
<p>塞入<code>4</code>后，数组变成<code>&#123;2, 1, 3, 4&#125;</code></p></li>
<li><p>再输入<code>1</code>，你希望数组内的<code>1</code>元素指向<code>5</code></p>
<p>如果输入<code>2</code>呢？你希望数组内的<code>2</code>元素指向<code>5</code></p>
<p>如果输入<code>3</code>呢？你希望数组内的<code>3</code>元素指向<code>5</code></p>
<p>如果输入<code>4</code>呢？你还是希望数组内的<code>4</code>元素指向<code>5</code></p>
<p>塞入<code>4</code>后，数组变成<code>&#123;2, 1, 3, 4, 5&#125;</code></p></li>
</ol>
<p>发现了吗，每次查询的时候，我们都会希望原数组是个经过路径压缩后的并查集</p>
<img src="/2023/11/14/P8686-%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84/1.png" class="" title="image-20231114172751644">
<p>所以每次查询完结点的祖先后，令祖先的祖先为<code>祖先 + 1</code>即可，代表下次查询应该指向的值</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>P8893. 智能推荐</title>
    <url>/2023/11/19/P8893-%E6%99%BA%E8%83%BD%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>拓扑排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">5e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> N, K, P, R, tot, ans = <span class="number">-1</span>, arr[LEN], head[LEN], ind[LEN], val[LEN];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> to_, nxt_;</span><br><span class="line">&#125; e[LEN * LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  e[tot].to_ = v, e[tot].nxt_ = head[u];</span><br><span class="line">  head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= P; ++i) q.<span class="built_in">emplace</span>(arr[i]);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (u == K) &#123;</span><br><span class="line">      ans = val[K];</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = e[i].nxt_) &#123;</span><br><span class="line">      <span class="type">int</span> v = e[i].to_;</span><br><span class="line">      val[v] = <span class="built_in">max</span>(val[v], val[u] + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (--ind[v] == <span class="number">0</span>) q.<span class="built_in">emplace</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 链式前向星存储有向边</span></span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">  <span class="type">int</span> u, v, s, p;</span><br><span class="line">  cin &gt;&gt; N &gt;&gt; K &gt;&gt; P;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= P; ++i) cin &gt;&gt; arr[i];</span><br><span class="line">  cin &gt;&gt; R;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= R; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s; ++j) &#123;</span><br><span class="line">      cin &gt;&gt; u;</span><br><span class="line">      <span class="built_in">add</span>(u, v);</span><br><span class="line">      ++ind[v];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">toposort</span>();</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>每次只能做被推荐的题目，而题目要被推荐，得先做完一系列前置题目</p>
<p>令前置题目指向推荐题目后，直接套拓扑排序板子即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希函数_解题技巧</title>
    <url>/2023/11/10/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>绝大部分的场景用STL自带即可解决，但部分题目还是需要自己手敲哈希表处理</p>
<p>一般手敲哈希表选用<a
href="https://oi-wiki.org/ds/hash/#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0">拉链法</a>实现，掌握<a
href="https://www.luogu.com.cn/problem/P3370">P3370</a>和<a
href="https://www.luogu.com.cn/problem/P3405">P3405</a>这两题即可</p>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>哈希函数</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串哈希_解题技巧</title>
    <url>/2023/11/10/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="定义">定义</h1>
<p>能将一个字符串<span class="math inline">\(s\)</span>映射为整数的函数$
f $，我们可以将其称作为Hash函数，即： <span class="math display">\[
f\left( s \right) \longrightarrow \text{数字}
\]</span> 如此一来，就能方便我们比较两个字符串是否相等。</p>
<p>下面介绍的方法在算法界称为<strong>Rabin-Karp算法</strong>，简称<strong>RK</strong></p>
<h1 id="性质">性质</h1>
<ol type="1">
<li><p>在 Hash 函数值不一样的时候，两个字符串一定不一样</p></li>
<li><p>在 Hash 函数值一样的时候，两个字符串不一定一样</p>
<p>我们将 Hash 函数值一样但原字符串不一样的现象称为哈希碰撞</p></li>
</ol>
<h1 id="实现">实现</h1>
<p>令<span
class="math inline">\(h\)</span>为哈希数组，字符串起始下标为1（计算机内是0起始），<span
class="math inline">\(h[i]\)</span>记录下标<span
class="math inline">\([1...i]\)</span>字串的哈希值；<span
class="math inline">\(l\)</span>为字符串长度，<span
class="math inline">\(P\)</span>为质数</p>
<p>有哈希数组公式如下。在没有特别注解的情况下默认都是用它： <span
class="math display">\[
h\left[ i \right] =h\left[ i-1 \right] \times P+idx\left( s\left[ i
\right] \right)
\]</span></p>
<p><span class="math display">\[
i\in \left[ 1,l \right]
\]</span></p>
<p>一般<span class="math inline">\(idx\)</span>函数定义如下：</p>
<blockquote>
<p>idx(x) = x - 'a' + 1</p>
</blockquote>
<p>但没必要，一般直接用字符的ASCII码，即int(s[i])替代即可</p>
<p>以字符串xyz举例：</p>
<blockquote>
<p>h[0] = 0</p>
<p>h[1] = h[0] * P + s[1] = x</p>
<p>h[2] = h[1] * P + s[2] = x*P + y</p>
<p>h[3] = h[2] * P + s[3] = x<em>P<sup>2</sup> + y </em> P + z</p>
</blockquote>
<p>显然，哈希数组公式是将字符串作为了<span
class="math inline">\(P\)</span>进制的数来描述，那么可以用数学语言进行归纳：
<span class="math display">\[
f\left( s \right) =\sum{\begin{array}{c}
    l\\
    i=1\\
\end{array}s\left[ i \right] \times P^{l-i}}\left( mod\,\,M \right)
\]</span></p>
<hr />
<p>另一种哈希数组公式描述如下。其中<span
class="math inline">\(p\)</span>数组保存<span
class="math inline">\(P\)</span>的幂次，即<span
class="math inline">\(p[i]\)</span>保存<span
class="math inline">\(P^{i}\)</span>的结果： <span
class="math display">\[
p\left[ i \right] =p\left[ i-1 \right] \times P
\]</span></p>
<p><span class="math display">\[
h[i]=idx(s[i])\times p[i-1]+h[i-1]
\]</span></p>
<p>用数学语言归纳的话就是这样： <span class="math display">\[
f\left( s \right) =\sum{\begin{array}{c}
    l\\
    i=1\\
\end{array}s\left[ i \right] \times P^{i-1}\left( mod\,\,M \right)}
\]</span> 结果如下：</p>
<blockquote>
<p>p[0] = 1, h[0] = 0</p>
<p>p[1] = P, h[1] = s[1] * p[0] + h[0] = x</p>
<p>p[2] = P<sup>2</sup>, h[2] = s[2] * p[1] + h[1] = x + y*P</p>
<p>p[3] = P<sup>3</sup>, h[3] = s[3] * p[2] + h[2] = x + y*P +
z*P<sup>2</sup></p>
</blockquote>
<p>故而用第一种公式处理源字符串得到的哈希值，等于用第二种公式处理源字符串的翻转</p>
<p>即： <span class="math display">\[
f_{\text{第一种}}\left( abc \right) =f_{\text{第二种}}\left( cba \right)
\]</span></p>
<hr />
<p>下面解答一些疑问，默认为第一种公式</p>
<h2 id="为什么取模">为什么取模？</h2>
<p>对<span
class="math inline">\(M\)</span>取模是因为幂次运算过于巨无霸，必须要手动控制精度确保不会溢出</p>
<h2 id="m是质数为什么">M是质数，为什么？</h2>
<p>哈希表中的数列冲突分布间隔，受模的因子数量影响；同样的随机数列，模的因子越多，冲突的可能性就越大</p>
<p>所以要减少冲突，肯定希望模的因子最少，而因子最少的就是质数了</p>
<p>详细证明可参见<a
href="https://blog.csdn.net/zhishengqianjun/article/details/79087525">链接</a></p>
<h2 id="m一般取什么值">M一般取什么值？</h2>
<p>一般在算法界，我们喜欢取1e9+7和1e9+9</p>
<p>这俩是<span
class="math inline">\(2^{30}\)</span>范围内比较好记的超大质数，好处在哪？</p>
<ol type="1">
<li>所有模过之后的数进行加法操作不会溢出int范围</li>
</ol>
<p><span class="math display">\[
a,b&lt;2^{30}, a+b&lt;2^{31}
\]</span></p>
<ol start="2" type="1">
<li>所有模过之后的数进行乘法操作不会溢出long long范围 <span
class="math display">\[
a\times b&lt;2^{60}
\]</span></li>
</ol>
<p>详细讨论可参见<a
href="https://www.zhihu.com/question/49374703">链接</a></p>
<h2 id="p一般取什么值">P一般取什么值？</h2>
<p>我个人喜欢131和13331，<span
class="math inline">\(P\)</span>一定要小于<span
class="math inline">\(M\)</span>（不然取模的意义在哪呢）</p>
<p>有一个在线判断质数的<a
href="https://www.osgeo.cn/app/s2711">网址</a>，可以记一个你喜欢的质数（笑）</p>
<h2 id="求子串的哈希值">求子串的哈希值？</h2>
<p>令<span class="math inline">\(f_i\left( s \right)\)</span>表示<span
class="math inline">\(f\left( s\left[ 1...i \right]
\right)\)</span>，即下标1到<span
class="math inline">\(i\)</span>的字串哈希值</p>
<p>我们需要求下标<span
class="math inline">\([l..r]\)</span>的字串哈希值就是： <span
class="math display">\[
f\left( s\left[ l...r \right] \right) =s\left[ l \right] \times
P^{r-l}+s\left[ l+1 \right] \times P^{r-l-1}+...+s\left[ r-1 \right]
\times P+s\left[ r \right]
\]</span> 观察下方两个式子</p>
<p><span class="math inline">\(f_l\left( s
\right)\)</span>是下标1到<span
class="math inline">\(l\)</span>的字串哈希值，<span
class="math inline">\(f_r\left( s \right)\)</span>是下标1到<span
class="math inline">\(r\)</span>的字串哈希值，<span
class="math inline">\(l\)</span>&lt;<span
class="math inline">\(r\)</span> <span class="math display">\[
f_l\left( s \right) =s\left[ 1 \right] \times P^{l-1}+s\left[ 2 \right]
\times P^{l-2}+...+s\left[ l-1 \right] \times P+s\left[ l \right]
\]</span></p>
<p><span class="math display">\[
f_r\left( s \right) =s\left[ 1 \right] \times P^{r-1}+s\left[ 2 \right]
\times P^{r-2}+...+s\left[ r-1 \right] \times P+s\left[ r \right]
\]</span></p>
<p>列出下标1到<span class="math inline">\(l-1\)</span>的字串哈希值 <span
class="math display">\[
f_{l-1}\left( s \right) =s\left[ 1 \right] \times P^{l-2}+s\left[ 2
\right] \times P^{l-3}+...+s\left[ l-2 \right] \times P+s\left[ l-1
\right]
\]</span> 如果再乘<span class="math inline">\(P^{r-l+1}\)</span> <span
class="math display">\[
P^{r-l+1}\times f_{l-1}\left( s \right) =s\left[ 1 \right] \times
P^{r-1}+s\left[ 2 \right] \times P^{l-2}+...+s\left[ l-2 \right] \times
P^{r-l+2}+s\left[ l-1 \right] \times P^{r-l+1}
\]</span> 你会惊奇地发现，任何一个字串的哈希值都能通过这个等式以<span
class="math inline">\(O(1)\)</span>的时间复杂度算出 <span
class="math display">\[
f\left( s\left[ l...r \right] \right) =f_r\left( s \right)
-f_{l-1}\left( s \right) \times P^{r-l+1}
\]</span> 如果用哈希公式来表达，那就是 <span class="math display">\[
h\left[ l...r \right] =h\left[ r \right] -h\left[ l-1 \right] \times
P^{r-l+1}
\]</span> 大质数<span
class="math inline">\(P\)</span>的幂次用上面提到的<span
class="math inline">\(p\)</span>数组记录，即<span
class="math inline">\(p[i]\)</span>等于<span
class="math inline">\(P\)</span>的<span
class="math inline">\(i\)</span>次幂 <span class="math display">\[
h\left[ l...r \right] =h\left[ r \right] -h\left[ l-1 \right] \times
p\left[ r-l+1 \right]
\]</span> 方才说过，为了防止溢出，我们会对<span
class="math inline">\(M\)</span>进行取模 <span class="math display">\[
h\left[ l...r \right] =\left( h\left[ r \right] -h\left[ l-1 \right]
\times p\left[ r-l+1 \right] \right) \%M
\]</span>
表达式结果有可能是负数。编程语言是允许对负数取模的（事实上被模数和模数都允许为负数），但负数会带来很多不确定...</p>
<p>（也没人喜欢负数吧，笑）</p>
<p>所以还需作以下处理得到最终的字串哈希表达式： <span
class="math display">\[
h\left[ l...r \right] =\left( \left( h\left[ r \right] -h\left[ l-1
\right] \times p\left[ r-l+1 \right] \right) \%M+M \right) \%M
\]</span></p>
<h2 id="取模的trick">取模的Trick</h2>
<p>上面的各种七七八八取模操作会相当影响编程...</p>
<p>可喜的是，在实际编程中可以令<span
class="math inline">\(h\)</span>与<span
class="math inline">\(p\)</span>这种存储超大质数的数组类型设定为<code>unsigned long long</code>，这样一旦溢出会自动取模<span
class="math inline">\(2^{64}\)</span></p>
<p>所以你只需要这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="comment">//s为字符串，P取了131，M就是2^64</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P = <span class="number">131</span>, N = s.<span class="built_in">length</span>() + <span class="number">1</span>;</span><br><span class="line">ull h[N], p[N], h_r[N];</span><br><span class="line">p[<span class="number">0</span>]=<span class="number">1</span>,h[<span class="number">0</span>]=<span class="number">0</span>,h_r[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//h数组使用的第一种公式</span></span><br><span class="line"><span class="comment">//h_r数组使用的第二种公式</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++ )&#123;</span><br><span class="line">    <span class="comment">//编程中还需使用s[i-1]，因为计算机内部数组下标还是0开头</span></span><br><span class="line">    h[i] = h[i<span class="number">-1</span>] * P + s[i<span class="number">-1</span>];</span><br><span class="line">    p[i] = p[i<span class="number">-1</span>] * P;</span><br><span class="line">    h_r[i] = s[i<span class="number">-1</span>] * p[i<span class="number">-1</span>] + h_r[i<span class="number">-1</span>];</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="双哈希">双哈希</h2>
<p>字面意思，用两个不同的质数进行两次取模，结果用一对数<span
class="math inline">\(&lt;h_1[i],h_2[i]&gt;\)</span>来代表字符串的哈希值</p>
<p>（但说实话，我刷题还没遇到过必须用双哈希解决冲突的....没有对冲突率如此严苛）
<span class="math display">\[
h_1\left[ i \right] =h_1\left[ i-1 \right] \times P+idx\left( s\left[ i
\right] \right) \left( mod\,\,M_1 \right)
\]</span></p>
<p><span class="math display">\[
h_2\left[ i \right] =h_2\left[ i-1 \right] \times P+idx\left( s\left[ i
\right] \right) \left( mod\,\,M_2 \right)
\]</span></p>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>哈希函数</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集_解题技巧</title>
    <url>/2023/11/14/%E5%B9%B6%E6%9F%A5%E9%9B%86-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="求连通块集合个数">求连通块、集合个数</h1>
<ul>
<li><p>能保证没有冗余的合并操作时</p>
<p>正常情况下，初始时每个结点的祖先都是自己；若结点个数为<code>tot</code>，初始时则有<code>tot</code>个连通块</p>
<p>每一次合并都会少一个连通块，就执行<code>--tot</code>；最终的连通块个数就等于<code>tot</code></p>
<p>比如<a
href="https://www.luogu.com.cn/problem/P1536">P1536</a></p></li>
<li><p>有冗余合并操作，但能固定祖先结点时</p>
<p>例如<a href="https://www.luogu.com.cn/problem/P1892">P1892</a>和<a
href="https://www.luogu.com.cn/problem/P1621">P1621</a>，通过固定祖先结点的方式，以<span
class="math inline">\(O\left( n
\right)\)</span>的时间复杂度判断<code>fa[i] == i</code>即可得到连通块数</p></li>
<li><p>上述情况都无法满足时</p>
<p>先以<span class="math inline">\(O\left( n\log n
\right)\)</span>的时间复杂度寻找所有结点的祖先，再以<span
class="math inline">\(O\left( n
\right)\)</span>的时间复杂度对祖先计数....</p>
<p>还需要额外的<span class="math inline">\(O\left( n
\right)\)</span>的空间复杂度保存祖先....</p>
<p>所以万不得已尽量别用该办法，考察并查集的题数据量都很大，很容易TLE</p></li>
</ul>
<h1 id="普通并查集">普通并查集</h1>
<h2 id="用法">用法</h2>
<p>并查集只有<strong>查询</strong>、<strong>合并</strong>两种操作！</p>
<blockquote>
<p>其实是有删除操作的，参见<a
href="https://oi-wiki.org/ds/dsu/#%E5%88%A0%E9%99%A4">Wiki</a></p>
<p>但实际复杂度高到天上去了....</p>
</blockquote>
<p>并查集能在一张无向图中维护结点之间的连通性</p>
<p>这个“连通性”是可以通过结点之间的关系量化的</p>
<blockquote>
<p>假设有一条规律，亲戚的亲戚也是我的亲戚</p>
<p>有<code>A -&gt; B</code>，即<code>A</code>与<code>B</code>是亲戚；也有<code>B -&gt; C</code>，显然能得到<code>A -&gt; C</code></p>
</blockquote>
<h2 id="练习题">练习题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1551">P1551</a>
并查集板子题</li>
<li><a href="https://www.luogu.com.cn/problem/P1536">P1536</a>
学会统计连通块</li>
<li><a href="https://www.luogu.com.cn/problem/P1621">P1621</a>
分类的思维</li>
<li><a href="https://www.luogu.com.cn/problem/P1955">P1955</a>
必刷的经典好题！强化后续的扩展域、边带权并查集理解</li>
<li><a href="https://www.luogu.com.cn/problem/P2814">P2814</a>
哈希表替代数组</li>
</ul>
<h1 id="作为优化手段数据结构">作为优化手段/数据结构</h1>
<ul>
<li><p><a href="https://www.luogu.com.cn/problem/P3535">P3535</a>
并查集判环，并用反向建图实现贪心</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P8686">P8686</a>
优化搜索</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P6121">P6121</a>
反向建图实现并查集的结点删除</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P8710">P8710</a>
修改子结点，影响扩散至全集合</p></li>
</ul>
<h1 id="扩展域并查集种类并查集">扩展域并查集（种类并查集）</h1>
<h2 id="用法-1">用法</h2>
<p>根据不同的关系属性，将数据拆分并重组为不同的集合</p>
<p>记得双向都要处理！因为<code>a</code>对<code>b</code>的关系，也同样有<code>b</code>对<code>a</code></p>
<p>常见于<strong>求某一种关系的集合</strong></p>
<blockquote>
<p>举个例子，对于人而言，有“朋友”、“亲人”和“敌人”三种关系</p>
<p>现在要你求有几个“朋友”的集合</p>
</blockquote>
<h2 id="练习题-1">练习题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1525">P1525</a>
经典的模板题</li>
<li><a href="https://www.luogu.com.cn/problem/P1892">P1892</a>
也是板子题</li>
</ul>
<h1 id="边带权并查集带权并查集">边带权并查集（带权并查集）</h1>
<h2 id="用法-2">用法</h2>
<p>扩展域并查集是根据关系将数据拆分重组成不同的集合</p>
<p>边带权并查集则是将关系映射为边权，从而能将不同的关系合并至同一集合</p>
<p>常见于<strong>判断所给条件是否满足前提</strong></p>
<blockquote>
<p>举个例子，对于人而言，有“朋友”、“亲人”和“敌人”三种关系</p>
<p>现有a、b二人，题目说他俩是亲人关系，要你辨真伪</p>
<p>你需要知道两件事：</p>
<ol type="1">
<li><p>a和b有没有关系</p>
<p>即希望a和b能够通过某种方式验证连通性，判断祖先是否一致</p></li>
<li><p>a和b若有关系，符不符合题意</p>
<p>即希望能记录a和b之间的关系</p></li>
</ol>
<p>白话文来说，在边带权并查集中，任何两个结点都是连通的，代表这两个结点是“有关系的”</p>
<p>而两个结点之间的关系则通过它俩的边权记录，代表“是什么关系”</p>
</blockquote>
<p>具体的设计思路，参考<a
href="https://www.luogu.com.cn/problem/P2024">P2024</a></p>
<h2 id="练习题-2">练习题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P2024">P2024</a>
经典的模板题</li>
<li><a href="https://www.luogu.com.cn/problem/P1196">P1196</a>
也是经典的模板题</li>
<li><a href="https://www.luogu.com.cn/problem/P2294">P2294</a></li>
<li><a href="https://www.luogu.com.cn/problem/P5937">P5937</a></li>
</ul>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序_解题技巧</title>
    <url>/2023/11/20/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="常见考点">常见考点</h1>
<ul>
<li><p><strong>判断有向图是否存在环</strong></p>
<p>将结点个数、拓扑序列的元素个数二者对比，不等则说明存在环路</p></li>
<li><p><strong>判断有向图的拓扑序列是否唯一</strong></p>
<p>若唯一，无环且最长路等于节点数<code>n</code>，默认情况下节点本身的长度为1。</p>
<p>先要判环，随后有两种做法：</p>
<ol type="1">
<li><p>直接计算每个点的最长路，最后循环比较；常数略大但是没有逻辑坑点。</p></li>
<li><p>判断队列入度为0的元素个数是否大于1；</p>
<p>好写常数小，但是要注意逻辑坑点，有环情况、拓扑序列不唯一情况、无环且唯一三种情况的优先级处理！</p></li>
</ol></li>
<li><p>根据<strong>一种、可传递的</strong>优先级规则（类似贪心），将有向图划分为若干个集合，并根据优先级按序处理各个集合</p></li>
</ul>
<h1 id="与并查集的异同">与并查集的异同</h1>
<h2 id="相同">相同</h2>
<ul>
<li><p>有向无环图只能朝一个方向（反向不就带环了吗），只能根据<strong>一种、可传递的</strong>优先级规则进行分类</p></li>
<li><p>尽管并查集是无向图，且有扩展域并查集、边带权并查集两类</p>
<p>但根本上也是将各种状态合并为<strong>一种、且可传递的</strong>优先级规则</p></li>
</ul>
<h2 id="不同">不同</h2>
<ul>
<li><p>有向无环图的结点整体分布是自上而下，且有向边的方向均朝下</p></li>
<li><p>并查集是不固定的森林结构，没有层次可言</p></li>
</ul>
<h1 id="练习题">练习题</h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1113">P1113</a>
模板题+最长路</li>
<li><a href="https://www.luogu.com.cn/problem/P4017">P4017</a>
模板题+最长路</li>
<li><a href="https://www.luogu.com.cn/problem/P1807">P1807</a>
控制拓扑排序的起点</li>
<li><a href="https://www.luogu.com.cn/problem/P1347">P1347</a>
验证拓扑序列是否唯一的经典题</li>
<li><a
href="https://www.acwing.com/problem/content/description/345/">acwing-343</a>
验证拓扑序列是否唯一的经典题</li>
<li><a href="https://www.luogu.com.cn/problem/P1983">P1983</a>
模板题+最长路</li>
<li><a href="https://www.luogu.com.cn/problem/P8893">P8893</a>
最长路</li>
<li><a href="https://www.luogu.com.cn/problem/P2712">P2712</a>
最长路</li>
<li><a
href="https://www.acwing.com/problem/content/description/166/">acwing-164</a>
分层倒序处理+状态压缩</li>
</ul>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1017. 进制转换</title>
    <url>/2023/11/22/P1017-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>进制</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string ans;</span><br><span class="line">  <span class="type">int</span> num, mod, p, q, r;</span><br><span class="line">  cin &gt;&gt; num &gt;&gt; mod;</span><br><span class="line">  p = num;</span><br><span class="line">  <span class="keyword">while</span> (p || p % mod &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    q = p;</span><br><span class="line">    r = p % mod, p /= mod;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; <span class="number">0</span>) r = q - (++p * mod);</span><br><span class="line">    ans += (r &gt;= <span class="number">10</span> ? (<span class="type">char</span>)(r - <span class="number">10</span> + <span class="string">&#x27;A&#x27;</span>) : (<span class="type">char</span>)(r + <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">  cout &lt;&lt; num &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;(base&quot;</span> &lt;&lt; mod &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>和正常的进制转换一样使用短除法</p>
<p>但余数若为负数，得到的商要往回加，直到余数为正数</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>进制</tag>
      </tags>
  </entry>
  <entry>
    <title>P1072. Hankson 的趣味题</title>
    <url>/2023/12/09/P1072-Hankson-%E7%9A%84%E8%B6%A3%E5%91%B3%E9%A2%98/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>最大公约数</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a / <span class="built_in">gcd</span>(a, b) * b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, a0, a1, b0, b1;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    cin &gt;&gt; a0 &gt;&gt; a1 &gt;&gt; b0 &gt;&gt; b1;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= b1 / i; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (b1 % i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">gcd</span>(i, a0) == a1 &amp;&amp; <span class="built_in">lcm</span>(i, b0) == b1) ++ans;</span><br><span class="line">        <span class="keyword">if</span> (i != b1 / i &amp;&amp; <span class="built_in">gcd</span>(b1 / i, a0) == a1 &amp;&amp; <span class="built_in">lcm</span>(b1 / i, b0) == b1)</span><br><span class="line">          ++ans;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>有两种思路枚举x：</p>
<ol type="1">
<li><p>由于a1是x的约数，可以枚举a1的倍数，直到b1为止</p>
<p>时间复杂度为<span class="math display">\[O\left( \frac{b1}{a1}
\right)\]</span></p></li>
<li><p>由于x是b1的约数，可以枚举b1的约数</p>
<p>时间复杂度为<span class="math display">\[O\left( \sqrt{b1} \right)
\]</span></p></li>
</ol>
<p>显然应该选第二种，每次判断<code>i</code>和<code>b1/i</code>这一对约数是否满足条件即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>最大公约数</tag>
      </tags>
  </entry>
  <entry>
    <title>P1069. 细胞分裂</title>
    <url>/2023/12/10/P1069-%E7%BB%86%E8%83%9E%E5%88%86%E8%A3%82/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>算术基本定理</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> m1, m2, tot, pri[LEN], cnt[LEN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分解质因数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= m1 / i; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m1 % i == <span class="number">0</span>) &#123;</span><br><span class="line">      pri[++tot] = i;</span><br><span class="line">      <span class="keyword">while</span> (m1 % i == <span class="number">0</span>) ++cnt[i], m1 /= i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (m1 &gt; <span class="number">1</span>) ++cnt[m1], pri[++tot] = m1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, s, ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2, <span class="built_in">f</span>();</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="comment">// m1 == 1时的特殊情况，此时没有质数</span></span><br><span class="line">    <span class="comment">// 但此时x完全可以取0</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> num = <span class="number">0</span>, p = pri[i];</span><br><span class="line">      <span class="keyword">if</span> (s % p) &#123;</span><br><span class="line">        x = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (s % p == <span class="number">0</span>) &#123;</span><br><span class="line">        ++num, s /= p;</span><br><span class="line">      &#125;</span><br><span class="line">      x = <span class="built_in">max</span>(x, (cnt[p] * m2 - <span class="number">1</span>) / num + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (~x) ans = <span class="built_in">min</span>(ans, x);</span><br><span class="line">  &#125;</span><br><span class="line">  ans == <span class="number">0x3f3f3f3f</span> ? cout &lt;&lt; <span class="number">-1</span> : cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>《深基》的教学题，直接上图</p>
<img src="/2023/12/10/P1069-%E7%BB%86%E8%83%9E%E5%88%86%E8%A3%82/1.png" class="" title="image-20231210155754423">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>质数</tag>
      </tags>
  </entry>
  <entry>
    <title>P1143. 进制转换</title>
    <url>/2023/11/21/P1143-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>进制</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string str, ans;</span><br><span class="line">  <span class="type">int</span> n, m, num;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; str &gt;&gt; m;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> ch : str) &#123;</span><br><span class="line">    num = <span class="built_in">isdigit</span>(ch) ? ch - <span class="string">&#x27;0&#x27;</span> : ch - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    a = a * n + num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (a) &#123;</span><br><span class="line">    ans += (num = a % m) &gt;= <span class="number">10</span> ? num - <span class="number">10</span> + <span class="string">&#x27;A&#x27;</span> : num + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    a /= m;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>先把<code>n</code>进制数转换为十进制数，再把十进制数转换为<code>m</code>进制数即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>进制</tag>
      </tags>
  </entry>
  <entry>
    <title>P1100. 高低位交换</title>
    <url>/2023/11/22/P1100-%E9%AB%98%E4%BD%8E%E4%BD%8D%E4%BA%A4%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>位运算</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> num, a = <span class="number">0xffff0000</span>, b = <span class="number">0x0000ffff</span>;</span><br><span class="line">  cin &gt;&gt; num;</span><br><span class="line">  cout &lt;&lt; (((num &amp; a) &gt;&gt; <span class="number">16</span>) | ((num &amp; b) &lt;&lt; <span class="number">16</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>取高低16位后交换位置即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>P1029. 最大公约数和最小公倍数问题</title>
    <url>/2023/12/09/P1029-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>最大公约数</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<h2 id="枚举约数">枚举约数</h2>
<p>由于<span class="math inline">\(PQ=xy\)</span>，且<span
class="math inline">\(P\shortmid
y\)</span>，所以枚举y的所有约数；约数是成对出现的，每次可以得到两个约数<code>p</code>和<code>y/p</code></p>
<p>然后用<code>xy/约数</code>得到<code>q</code>，再判断<code>p</code>和<code>q</code>的最大公约数是否满足条件即可，时间复杂度为<span
class="math inline">\(O\left( \sqrt{y} \right)\)</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x, y, ans = <span class="number">0</span>;</span><br><span class="line">  cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">  ll mul = x * y;</span><br><span class="line">  <span class="comment">// 枚举y的约数，可以是p也可以是y/p</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">1</span>; p &lt;= y / p; ++p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (y % p == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">gcd</span>(p, mul / p) == x) ++ans;</span><br><span class="line">      <span class="keyword">if</span> (p != y / p &amp;&amp; <span class="built_in">gcd</span>(y / p, x * p) == x) ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举倍数">枚举倍数</h2>
<p>由于<span class="math inline">\(x\shortmid
p\)</span>，所以可以通过枚举<code>x</code>的倍数，来枚举<code>p</code>，显然<code>p</code>不会超过最小公倍数<code>y</code></p>
<p>但是这样做的时间复杂度是<span class="math inline">\(O\left(
\frac{y}{x} \right)\)</span>，比枚举约数的方式复杂度高了很多</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x, y, ans = <span class="number">0</span>;</span><br><span class="line">  cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">  ll mul = x * y;</span><br><span class="line">  <span class="comment">// 通过枚举x的倍数的方式枚举p，肯定不会超过最小公倍数y</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> p = x; p &lt;= y; p += x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mul % p == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="type">int</span> q = mul / p;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">gcd</span>(p, q) == x) ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>最大公约数</tag>
      </tags>
  </entry>
  <entry>
    <title>P1246. 编码</title>
    <url>/2023/12/08/P1246-%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排列组合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">27</span>;</span><br><span class="line">string str;</span><br><span class="line"><span class="type">int</span> ans, c[LEN][LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN; ++i) &#123;</span><br><span class="line">    c[i][<span class="number">0</span>] = c[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">      c[i][j] = c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">1</span> || len &gt; <span class="number">6</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str[i] &gt;= str[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  cin &gt;&gt; str;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">judge</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, len = str.<span class="built_in">length</span>(); i &lt; len; ++i) ans += c[<span class="number">26</span>][i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> pre = <span class="number">96</span>, i = <span class="number">0</span>, len = str.<span class="built_in">length</span>(); i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = pre + <span class="number">1</span>; j &lt; str[i]; ++j) &#123;</span><br><span class="line">      ans += c[<span class="number">26</span> - (j - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>)][len - (i + <span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    pre = str[i];</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>具体思路参照https://www.luogu.com.cn/blog/AlexWei/solution-p1246</p>
<p>这里主要讲一下精髓，以<code>abc</code>为例</p>
<p>第2个位置的可能性下意识认为是<span
class="math inline">\(C_{25}^{1}\)</span>，第3个位置的可能性下意识认为是<span
class="math inline">\(C_{24}^{1}\)</span></p>
<p>所以结果是<span class="math inline">\(C_{25}^{1}\times
C_{24}^{1}\)</span>吗？错误的！因为这样并不能保证第3个位置绝对大于第2个位置</p>
<p>但是将后面两个位置视为整体，用<span
class="math inline">\(C_{25}^{2}\)</span>同时取就能保证有序了：</p>
<ol type="1">
<li>绝对不会重复</li>
<li>组合数是无序的，或者说，任意顺序！自然可以视作升序方式排列</li>
</ol>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>P1403. 约数研究</title>
    <url>/2023/12/11/P1403-%E7%BA%A6%E6%95%B0%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>枚举约数</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, ans, cnt[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j += i) &#123;</span><br><span class="line">      ++cnt[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; LEN; ++i) ans += cnt[i];</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>求每个数<span
class="math inline">\(n\)</span>的约数个数，不可能一个个遍历到<span
class="math inline">\(\sqrt{n}\)</span>，总的复杂度高达<span
class="math inline">\(O\left( n\sqrt{n} \right)\)</span></p>
<p>可以让每个数告诉自己的倍数，“我是你的因数”，这样总的复杂度只有<span
class="math inline">\(O\left( \sum{\begin{array}{c}  n\\  i=1\\
\end{array}\frac{n}{i}} \right)\)</span>，调和级数</p>
<p>接近<span class="math inline">\(O\left( n\log n \right)\)</span></p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>最大公约数</tag>
      </tags>
  </entry>
  <entry>
    <title>P1414. 又是毕业季II</title>
    <url>/2023/12/11/P1414-%E5%8F%88%E6%98%AF%E6%AF%95%E4%B8%9A%E5%AD%A3II/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>最大公约数</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<p>最多1e4个数据，用暴力搜索真的去模拟n个元素取k个还得两两取最大公约数...显然不现实</p>
<p>一个数的最大公约数是自己本身，所以有两种思路</p>
<h2 id="枚举倍数">枚举倍数</h2>
<p>枚举这个数的倍数，显然有<span class="math display">\[gcd\left( a,ax
\right) =a\]</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, cnt[LEN], w[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> in;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; in, ++cnt[in];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1e6</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= <span class="number">1e6</span>; j += i) &#123;</span><br><span class="line">      w[i] += cnt[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>, i = <span class="number">1e6</span>; i &gt;= <span class="number">1</span> &amp;&amp; k &lt;= n; ++k) &#123;</span><br><span class="line">    <span class="keyword">while</span> (w[i] &lt; k) --i;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举约数">枚举约数</h2>
<p>任何一个数a，和它的约数b取最大公约数，显然等于b</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, w[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> in;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; in;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= in / j; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (in % j) <span class="keyword">continue</span>;</span><br><span class="line">      ++w[j];</span><br><span class="line">      <span class="keyword">if</span> (j != in / j) ++w[in / j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>, i = <span class="number">1e6</span>; i &gt;= <span class="number">1</span> &amp;&amp; k &lt;= n; ++k) &#123;</span><br><span class="line">    <span class="keyword">while</span> (w[i] &lt; k) --i;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>最大公约数</tag>
      </tags>
  </entry>
  <entry>
    <title>P1593. 因子和</title>
    <url>/2023/12/12/P1593-%E5%9B%A0%E5%AD%90%E5%92%8C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>算术基本定理</li>
<li>快速幂</li>
<li>乘法逆元</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e8</span> + <span class="number">50</span>, MOD = <span class="number">9901</span>;</span><br><span class="line"><span class="comment">// 记录有多少个质因子，对应质因子的幂次</span></span><br><span class="line">ll tot, pri[LEN], cnt[LEN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速幂</span></span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">  ll ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (ans * a) % mod;</span><br><span class="line">    a = a * a % mod;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//费马小定理求逆元</span></span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll mod)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">ksm</span>(a, mod - <span class="number">2</span>, mod); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算术基本定理拆分质因子</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decompose</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= a / i; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a % i) <span class="keyword">continue</span>;</span><br><span class="line">    pri[++tot] = i;</span><br><span class="line">    <span class="keyword">while</span> (a % i == <span class="number">0</span>) a /= i, ++cnt[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; <span class="number">1</span>) pri[++tot] = a, ++cnt[a];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) &#123;</span><br><span class="line">    cnt[pri[i]] *= b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll a, b;</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  <span class="built_in">decompose</span>(a, b, MOD);</span><br><span class="line">  ll ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) &#123;</span><br><span class="line">    ll p = pri[i];</span><br><span class="line">    <span class="comment">//此时费马小定理不可用</span></span><br><span class="line">    <span class="keyword">if</span> ((p - <span class="number">1</span>) % MOD == <span class="number">0</span>) &#123;</span><br><span class="line">      ans = (ans * (cnt[p] + <span class="number">1</span>)) % MOD;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ans =</span><br><span class="line">          (ans * (<span class="built_in">inv</span>(p - <span class="number">1</span>, MOD) * (<span class="built_in">ksm</span>(p, cnt[p] + <span class="number">1</span>, MOD) - <span class="number">1</span> + MOD) % MOD) %</span><br><span class="line">           MOD) %</span><br><span class="line">          MOD;  <span class="comment">// 算术基本定理求解约数和</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题目本身不难，算术基本定理+费马小定理+快速幂模板即可，但是坑点很多：</p>
<ol type="1">
<li><p>必须全换成<code>long long</code>，否则会溢出</p></li>
<li><p>快速幂的结果可能为0，那么<code>ksm(p, cnt[p] + 1, MOD) - 1</code>将会是负数</p>
<p>应当先加<code>MOD</code>后再取模，即<code>(ksm(p, cnt[p] + 1, MOD) - 1 + MOD) % MOD</code></p></li>
<li><p>如果<code>(p - 1) % MOD == 0</code>，即<span
class="math inline">\(p-1\equiv 0\left( mod\,\,MOD \right)\)</span></p>
<p>此时不满足费马小定理的前提条件，也就没有乘法逆元</p>
<p>根据算术基本定理，有<span class="math inline">\(a^b=\left(
{p_1}^{k_1}{p_2}^{k_2}\cdots {p_m}^{k_m} \right)
^b={p_1}^{bk_1}{p_2}^{bk_2}\cdots {p_m}^{bk_m}\)</span></p>
<p>那么约数和等于 
   $$
   \frac{{p_1}^{bk_1+1}-1}{p_1-1}\frac{{p_2}^{bk_2+1}-1}{p_2-1}\cdots \frac{{p_m}^{bk_m+1}-1}{p_m-1}
   $$
   </p></li>
</ol>
<p>​ 根据等比数列展开一下 <span class="math display">\[
\left( 1+p_1+\cdots +{p_1}^{bk_1} \right) \left( 1+p_2+\cdots
+{p_2}^{bk_2} \right) \cdots \left( 1+p_m+\cdots +{p_m}^{bk_m} \right)
\]</span> ​ 为节约篇幅，只观察<span class="math inline">\(\left(
1+p_m+\cdots +{p_m}^{bk_m} \right) \left( mod\,\,MOD \right)
\\\)</span>， ​ 若有：<span class="math inline">\(p_m\equiv 1\left(
mod\,\,MOD \right)\)</span> ​ 根据同余式的性质，显然上式能化简成：<span
class="math inline">\(\left( bk_m+1 \right) \left( mod\,\,MOD
\right)\)</span></p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
        <tag>质数</tag>
        <tag>乘法逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>P1572. 计算分数</title>
    <url>/2023/12/10/P1572-%E8%AE%A1%E7%AE%97%E5%88%86%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>最大公约数</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">lcm</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1ll</span> * a * b / <span class="built_in">gcd</span>(a, b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">  ll ra = <span class="number">0</span>, rb = <span class="number">1</span>, a, b, tmp;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%lld/%lld&quot;</span>, &amp;a, &amp;b)) &#123;</span><br><span class="line">    tmp = <span class="built_in">lcm</span>(rb, b);</span><br><span class="line">    ra = ra * tmp / rb + a * tmp / b, rb = tmp;</span><br><span class="line">    <span class="keyword">if</span> (ra &lt; <span class="number">0</span>) flag = <span class="number">1</span>, ra = -ra;</span><br><span class="line">    tmp = <span class="built_in">gcd</span>(ra, rb);</span><br><span class="line">    ra /= tmp, rb /= tmp;</span><br><span class="line">    <span class="keyword">if</span> (flag) flag = <span class="number">0</span>, ra = -ra;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ra);</span><br><span class="line">  <span class="keyword">if</span> (rb != <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;/%lld&quot;</span>, rb);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>正常模拟通分和约分的过程即可，有两个注意点：</p>
<ol type="1">
<li><p>辗转相除法（欧几里得算法）不能处理负数</p>
<p>所以若分子为负数，先转为正数处理，结果再加上负号</p></li>
<li><p>如果分母为1，只需要输出分子</p></li>
</ol>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>最大公约数</tag>
      </tags>
  </entry>
  <entry>
    <title>P1469. 找筷子</title>
    <url>/2023/11/21/P1469-%E6%89%BE%E7%AD%B7%E5%AD%90/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>位运算</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, ans, in;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    cin &gt;&gt; in;</span><br><span class="line">    ans ^= in;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>相同的数异或为零，那么剩下的就是答案了</p>
<p>一开始想着用哈希表计数来着，但是数太多直接炸了内存...</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="type">int</span> n, in;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; in;</span><br><span class="line">    ++mp[in];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;second % <span class="number">2</span>) &#123;</span><br><span class="line">      cout &lt;&lt; it-&gt;first;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>P1835. 素数密度</title>
    <url>/2023/12/09/P1835-%E7%B4%A0%E6%95%B0%E5%AF%86%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>区间筛</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line">bitset&lt;LEN&gt; vis;</span><br><span class="line"><span class="type">int</span> tot, pri[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) pri[++tot] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; <span class="number">1ll</span> * i * pri[j] &lt;= n; ++j) &#123;</span><br><span class="line">      vis[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  vis.<span class="built_in">reset</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(<span class="number">1</span> &lt;&lt; <span class="number">16</span>);  <span class="comment">// 线性筛2^16以内的质数</span></span><br><span class="line">  ll l, r;</span><br><span class="line">  cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) &#123;</span><br><span class="line">    <span class="comment">// 埃氏筛的思想，筛掉[l,r]范围内的pri[i]的倍数</span></span><br><span class="line">    <span class="comment">// 至少是2倍，总不能把自己也筛了吧-。-</span></span><br><span class="line">    <span class="keyword">for</span> (ll j = <span class="built_in">max</span>(<span class="number">2ll</span>, (l - <span class="number">1</span>) / pri[i] + <span class="number">1</span>) * pri[i]; j &lt;= r; j += pri[i]) &#123;</span><br><span class="line">      vis[j - l] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 左边界l至少为2，因为0和1不是质数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">2ll</span>, l); i &lt;= r; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i - l]) ++ans;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>直接上《深基》的图</p>
<img src="/2023/12/09/P1835-%E7%B4%A0%E6%95%B0%E5%AF%86%E5%BA%A6/1.png" class="" title="image-20231209192248222">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>质数</tag>
      </tags>
  </entry>
  <entry>
    <title>P2638. 安全系统</title>
    <url>/2023/12/08/P2638-%E5%AE%89%E5%85%A8%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>高精度</li>
<li>排列组合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bigint</span> &#123;</span><br><span class="line">  <span class="type">int</span> len_;</span><br><span class="line">  <span class="type">int</span> arr_[<span class="number">1050</span>];</span><br><span class="line">  <span class="built_in">Bigint</span>(<span class="type">int</span> x = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(arr_, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr_));</span><br><span class="line">    len_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      arr_[++len_] = x % <span class="number">10</span>;</span><br><span class="line">      x /= <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> x) &#123; <span class="keyword">return</span> arr_[x]; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(<span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    len_ = len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr_[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        arr_[i + <span class="number">1</span>] += arr_[i] / <span class="number">10</span>;</span><br><span class="line">        arr_[i] %= <span class="number">10</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!arr_[len_] &amp;&amp; len_) --len_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, len_); i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">      cout &lt;&lt; arr_[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; C[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"></span><br><span class="line">Bigint <span class="keyword">operator</span>+(Bigint a, Bigint b) &#123;</span><br><span class="line">  Bigint c;</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">max</span>(a.len_, b.len_);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">    c[i] += a[i] + b[i];</span><br><span class="line">  &#125;</span><br><span class="line">  c.<span class="built_in">flatten</span>(len + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bigint <span class="keyword">operator</span>*(Bigint a, Bigint b) &#123;</span><br><span class="line">  Bigint c;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.len_; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b.len_; ++j) &#123;</span><br><span class="line">      c[i + j - <span class="number">1</span>] += a[i] * b[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  c.<span class="built_in">flatten</span>(a.len_ + b.len_);</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">50</span>; ++i) &#123;</span><br><span class="line">    C[i][<span class="number">0</span>] = C[i][i] = <span class="built_in">Bigint</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">      C[i][j] = C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, a, b;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  <span class="built_in">f</span>();</span><br><span class="line">  Bigint ans;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= a; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= b; ++j) &#123;</span><br><span class="line">      ans = ans + (C[n + i - <span class="number">1</span>][i] * C[n + j - <span class="number">1</span>][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ans.<span class="built_in">print</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>先考虑这么一个问题：</p>
<blockquote>
<p><code>a</code>个球放进<code>n</code>个盒子，且盒子允许为空</p>
</blockquote>
<p>根据插板法，每个盒子都提前塞一个进去，这样保证盒子内至少有一个</p>
<p>则共有<code>n+a</code>个元素，<code>n+a-1</code>个空隙；选其中<code>n-1</code>个空隙插入板子，可以分出<code>n</code>组</p>
<p>得到<span
class="math display">\[C_{n+a-1}^{n-1}=C_{n+a-1}^{a}\]</span></p>
<p>根据题意<strong>一个存储区可以存放任意多个0和任意多个1</strong>，说明0和1的分配是相互独立的，可以采用乘法原理</p>
<p>故而当0的个数为<code>a</code>，1的个数为<code>b</code>时，分配方案有<span
class="math display">\[C_{n+a-1}^{a}\times C_{n+b-1}^{b}\]</span></p>
<hr />
<p>但是，题目还有一句话<strong>0和1可以不用全部储存</strong>，那就意味着0的个数其实是<code>0 ~ a</code>，1的个数其实是<code>0 ~ b</code></p>
<p>所以需要双重循环来遍历每种搭配</p>
<hr />
<p>其次，组合数过大且不能取模，所以必须采用高精度来存储</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>P2651. 添加括号III</title>
    <url>/2023/12/11/P2651-%E6%B7%BB%E5%8A%A0%E6%8B%AC%E5%8F%B7III/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>最大公约数</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> t, n, a, b, x, g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b, n -= <span class="number">2</span>, b = b / <span class="built_in">gcd</span>(a, b);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">      cin &gt;&gt; x;</span><br><span class="line">      b = b / <span class="built_in">gcd</span>(x, b);</span><br><span class="line">    &#125;</span><br><span class="line">    b == <span class="number">1</span> ? cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl : cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>这道题第一个坑点，就是没告诉你括号是可以嵌套的</p>
<p>比如这个式子<span class="math inline">\(1/\left( \left( 2/3 \right)
/4 \right)\)</span>，除了第二位必须是分母，其余都可以变成分子</p>
<p>第二个坑点，测试点会卡你不准用乘法，否则<code>long long</code>都溢出</p>
<p>由于只需要保证分母为1，所以每次只保存分母除去与分子的最大公约数即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>最大公约数</tag>
      </tags>
  </entry>
  <entry>
    <title>P2660. zzc 种田</title>
    <url>/2023/12/11/P2660-zzc-%E7%A7%8D%E7%94%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>最大公约数</li>
<li>贪心</li>
<li>分治</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!a || !b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4</span> * b * (a / b) + <span class="built_in">dfs</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll x, y;</span><br><span class="line">  cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">dfs</span>(<span class="built_in">max</span>(x, y), <span class="built_in">min</span>(x, y));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>乍一看数据范围，1e16...绝对不可能是暴力模拟</p>
<p>考虑贪心策略，可以发现同样大小的格子数，组成正方形得到的总周长是远小于组成矩阵的：</p>
<img src="/2023/12/11/P2660-zzc-%E7%A7%8D%E7%94%B0/1.png" class="" title="image-20231211171249468">
<p>所以就可以得到分治策略：</p>
<blockquote>
<p>每一次将大矩形分解成一个最大的正方形+小矩形</p>
<p>正方形的周长可以直接纳入答案内，对小矩形进行递归分解；直到长宽中的某一方可以整除另一方，代表当前是正方形</p>
<p>不管怎样，要么能以某个大正方形结束，要么能以边长为1的最小的正方形结束</p>
</blockquote>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>贪心</tag>
        <tag>最大公约数</tag>
      </tags>
  </entry>
  <entry>
    <title>P1866. 编号</title>
    <url>/2023/11/22/P1866-%E7%BC%96%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
<li>排列组合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e3</span> + <span class="number">50</span>, MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; arr[i];</span><br><span class="line">  <span class="built_in">sort</span>(arr, arr + n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) ans = (ans * (arr[i] - i)) % MOD;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>就拿样例来说吧</p>
<ul>
<li><p>5在前，8在后时</p>
<p>组合数为 <span class="math display">\[
C\begin{array}{c}
  1\\
  5\\
\end{array}\cdot C\begin{array}{c}
  1\\
  7\\
\end{array}
\]</span></p></li>
<li><p>8在前，5在后时</p>
<p>组合数为 <span class="math display">\[
\underset{6-8\text{里选}}{\underbrace{C\begin{array}{c}
  1\\
  3\\
\end{array}}}\cdot
\underset{1-5\text{里选}}{\underbrace{C\begin{array}{c}
  1\\
  5\\
\end{array}}}+\underset{1-5\text{里选}}{\underbrace{C\begin{array}{c}
  1\\
  5\\
\end{array}}}\cdot
\underset{1-4\text{里选}}{\underbrace{C\begin{array}{c}
  1\\
  4\\
\end{array}}}
\]</span></p></li>
</ul>
<p>可以发现两者是完全一样的，顺序不影响最终的结果</p>
<p>从小到大排序后，每次都乘上<code>arr[i] - i</code>，即<code>当前可能性 = 当前可选 - 之前已选</code></p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>P2789 直线交点数</title>
    <url>/2023/12/08/P2789-%E7%9B%B4%E7%BA%BF%E4%BA%A4%E7%82%B9%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排列组合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">bool</span> vis[LEN];</span><br><span class="line"><span class="type">int</span> n, ans, arr[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pre, <span class="type">int</span> idx, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (idx &gt; n || sum &gt; n) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (sum == n) &#123;</span><br><span class="line">    <span class="type">int</span> cnt = arr[<span class="number">0</span>], tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; idx; ++i) tot += arr[i] * cnt, cnt += arr[i];</span><br><span class="line">    <span class="keyword">if</span> (!vis[tot]) ++ans;</span><br><span class="line">    vis[tot] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = pre; i &lt;= n; ++i) &#123;</span><br><span class="line">    arr[idx] = i;</span><br><span class="line">    <span class="built_in">dfs</span>(i, idx + <span class="number">1</span>, sum + i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p><strong>无三线共点</strong>的含义是，当前直线要么与其他直线相交产生<strong>新</strong>的交点，要么与其他直线平行</p>
<p>根据这一特性，考虑采用分组的方式将情况分类</p>
<p>假设<code>(x)</code>代表该组内有<code>x</code>条直线平行，不在一个组内的直线相交</p>
<p>比如<code>(2)、(3)</code>代表第1个组内有2条直线平行，第2个组内有3条直线平行</p>
<p>第1个组与第2个组相交，得到<code>2 * 3 = 6</code>个交点</p>
<p>接下来以样例<code>n == 4</code>举例，有<code>&#123;0、3、4、5、6&#125;</code>共5种交点数</p>
<img src="/2023/12/08/P2789-%E7%9B%B4%E7%BA%BF%E4%BA%A4%E7%82%B9%E6%95%B0/1.png" class="" title="image-20231208142421097">
<p>通过观察可以发现，实际上就是对整数<code>n</code>进行拆分，对每一种可行的拆分方案执行如下操作：</p>
<blockquote>
<p>假设有拆分方案<code>arr=&#123;1,1,2&#125;</code>，实际上就是<code>(1)、(1)、(2)</code></p>
<p>令初始时<code>cnt = 1 = arr[0]</code>，记录需要被交的直线个数；<code>tot</code>记录交点数</p>
<p>从<code>arr[1]</code>开始，此时<code>arr[1] * cnt = 1 * 1 = 1</code>，<code>tot += 1</code>，<code>cnt += arr[1]</code></p>
<p>代表<code>(1)</code>已与<code>(1)</code>相交</p>
<p>走到<code>arr[2]</code>，此时<code>arr[2] * cnt = 2 * 2 = 4</code>，<code>tot += 4</code></p>
<p>代表<code>(2)</code>已与<code>(1)、(1)</code>相交</p>
</blockquote>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>P2822. 组合数问题</title>
    <url>/2023/12/07/P2822-%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排列组合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">2e3</span> + <span class="number">50</span>;</span><br><span class="line">ll k, C[LEN][LEN], s[LEN][LEN];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> ? <span class="number">0</span> : s[x][y]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 杨辉三角求组合数C_&#123;i&#125;^&#123;j&#125;</span></span><br><span class="line">  <span class="built_in">memset</span>(C, <span class="number">-1</span>, <span class="built_in">sizeof</span>(C));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2000</span>; ++i) &#123;</span><br><span class="line">    C[i][<span class="number">0</span>] = C[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">      C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % k;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 二维前缀和</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2000</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2000</span>; ++j) &#123;</span><br><span class="line">      s[i][j] =</span><br><span class="line">          <span class="built_in">f</span>(i - <span class="number">1</span>, j) + <span class="built_in">f</span>(i, j - <span class="number">1</span>) - <span class="built_in">f</span>(i - <span class="number">1</span>, j - <span class="number">1</span>) + (C[i][j] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t, n, m;</span><br><span class="line">  cin &gt;&gt; t &gt;&gt; k;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; s[n][m] &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>求解组合数的模板题，先根据《深基》的几张图来回顾一下杨辉三角吧</p>
<img src="/2023/12/07/P2822-%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/1.png" class="" title="image-20231207224213024">
<img src="/2023/12/07/P2822-%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/2.png" class="" title="image-20231207224417108">
<img src="/2023/12/07/P2822-%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/3.png" class="" title="image-20231207224509259">
<img src="/2023/12/07/P2822-%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/4.png" class="" title="image-20231207224616715">
<hr />
<p>先将2000以内的组合数打表求出</p>
<p>那样数字会过于庞大，好在题意是求能否整除<code>k</code>；所以每次只保存模<code>k</code>的值即可（模运算不影响加法乘法）</p>
<p>当然，组合数数组需要初始化为<code>-1</code>而不是常规的<code>0</code>，否则不能确定到底是模<code>k</code>后得到的<code>0</code>还是初始就是<code>0</code></p>
<p>从杨辉三角的视角看，题目每次询问的是二维数组某一区间内，模<code>k</code>后为0的组合数个数</p>
<p>所以用二维前缀和再次打表！</p>
<p>比如<code>n = 3, m = 3, k = 2</code>的话，求<span
class="math inline">\(\left\{
C_{0}^{0},C_{1}^{0},C_{1}^{1},C_{2}^{0},C_{2}^{1},C_{2}^{2},C_{3}^{0},C_{3}^{1},C_{3}^{2},C_{3}^{3}
\right\}\)</span>中模<code>k</code>后等于0的个数</p>
<p>用帕斯卡公式求出的组合数数组</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">-1</td>
<td style="text-align: center;">-1</td>
<td style="text-align: center;">-1</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">-1</td>
<td style="text-align: center;">-1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">-1</td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>对<code>k</code>取模后，组合数数组如下</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">-1</td>
<td style="text-align: center;">-1</td>
<td style="text-align: center;">-1</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">-1</td>
<td style="text-align: center;">-1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">-1</td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>很明显只有<span
class="math inline">\(C_{2}^{1}\)</span>是满足条件的，答案为1</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>P2926. Patting Heads S</title>
    <url>/2023/12/09/P2926-Patting-Heads-S/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>质数</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, arr[LEN], cnt[LEN], w[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; arr[i], ++cnt[arr[i]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1e6</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= <span class="number">1e6</span>; j += i) &#123;</span><br><span class="line">      w[j] += cnt[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cout &lt;&lt; w[arr[i]] - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>《深基》的教学题，直接上图</p>
<img src="/2023/12/09/P2926-Patting-Heads-S/1.png" class="" title="image-20231209144206712">
<img src="/2023/12/09/P2926-Patting-Heads-S/2.png" class="" title="image-20231209144238528">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>质数</tag>
      </tags>
  </entry>
  <entry>
    <title>P3383. 线性筛素数</title>
    <url>/2023/12/09/P3383-%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线性筛</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e7</span> + <span class="number">50</span>;</span><br><span class="line">bitset&lt;(<span class="type">int</span>)1e8&gt; vis;</span><br><span class="line"><span class="type">int</span> n, q, k, tot, pri[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) pri[++tot] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; <span class="number">1ll</span> * i * pri[j] &lt;= n; ++j) &#123;</span><br><span class="line">      vis[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">  <span class="built_in">f</span>();</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    cout &lt;&lt; pri[k] &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>线性筛的模板题</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>质数</tag>
      </tags>
  </entry>
  <entry>
    <title>P3601. 签到题</title>
    <url>/2023/12/11/P3601-%E7%AD%BE%E5%88%B0%E9%A2%98/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>欧拉函数</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e7</span> + <span class="number">50</span>, MOD = <span class="number">666623333</span>;</span><br><span class="line">bitset&lt;LEN&gt; vis;</span><br><span class="line">ll l, r, tot, pri[LEN], arr[LEN], phi[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">  <span class="comment">// 欧拉筛1e6以内的质数</span></span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= <span class="number">1e6</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) pri[++tot] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; <span class="number">1ll</span> * i * pri[j] &lt;= <span class="number">1e6</span>; ++j) &#123;</span><br><span class="line">      vis[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// arr记录原始值，phi记录欧拉函数</span></span><br><span class="line">  <span class="keyword">for</span> (ll i = l; i &lt;= r; ++i) arr[i - l] = phi[i - l] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="comment">// 区间筛求欧拉函数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> p = pri[i];</span><br><span class="line">    <span class="keyword">for</span> (ll j = <span class="built_in">max</span>(<span class="number">2ll</span>, (l - <span class="number">1</span>) / p + <span class="number">1</span>) * p; j &lt;= r; j += p) &#123;</span><br><span class="line">      phi[j - l] = phi[j - l] / p * (p - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">while</span> (arr[j - l] % p == <span class="number">0</span>) arr[j - l] /= p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (ll i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i - l] &gt; <span class="number">1</span>) phi[i - l] = phi[i - l] / arr[i - l] * (arr[i - l] - <span class="number">1</span>);</span><br><span class="line">    ans = (i - phi[i - l] + ans) % MOD;  <span class="comment">// 减掉互质的个数就等于不互质的个数了</span></span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>欧拉函数的模板题，但因为数据规模过大，不可能用线性筛的方式去求；只能采取区间筛结合欧拉函数定义来算</p>
<p>设<span class="math inline">\(p\)</span>代表质因子，那么有<span
class="math inline">\(n={p_1}^{k_1}{p_2}^{k_2}\cdots
{p_m}^{k_m}\)</span></p>
<p>有<span class="math inline">\(\varphi \left( n \right)
={p_1}^{k_1-1}\left( p_1-1 \right) {p_2}^{k_2-1}\left( p_2-1 \right)
\cdots {p_m}^{k_m-1}\left( p_m-1 \right)\)</span></p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>质数</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title>P3913. 车的攻击</title>
    <url>/2023/12/08/P3913-%E8%BD%A6%E7%9A%84%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排列组合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> nx, ny, x[LEN], y[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, k, a, b;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    x[nx++] = a, y[ny++] = b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(x, x + nx), <span class="built_in">sort</span>(y, y + ny);</span><br><span class="line">  nx = <span class="built_in">unique</span>(x, x + nx) - x, ny = <span class="built_in">unique</span>(y, y + ny) - y;</span><br><span class="line">  cout &lt;&lt; (<span class="number">1ll</span> * n * n) - (<span class="number">1ll</span> * (n - nx) * (n - ny));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>不同车之间影响的格子会有重复，秉持着正难则反的原则，考虑<code>总格子数 - 不受影响的格子数</code></p>
<p>车的影响范围是当前整行与当前整列，所以不管有几个车、如何影响，不受影响的格子肯定也能拼成一个矩形</p>
<p>可以得到公式<code>不受影响的格子数 = 不受影响的行数 * 不受影响的列数</code></p>
<p>但是棋盘长度高达<code>1e9</code>，不能常规采用一个<code>bool类型的vis[1e9]数组</code>去记录</p>
<p>考虑到车的个数只有<code>1e6</code>，所以选择给车的横纵坐标去重</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>P4057. 晨跑</title>
    <url>/2023/12/11/P4057-%E6%99%A8%E8%B7%91/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>最大公约数</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">lcm</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1ll</span> * a * b / <span class="built_in">gcd</span>(a, b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll a, b, c;</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">lcm</span>(<span class="built_in">lcm</span>(a, b), c);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>求三者的最小公倍数即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>最大公约数</tag>
      </tags>
  </entry>
  <entry>
    <title>数论_解题技巧</title>
    <url>/2023/11/21/%E6%95%B0%E8%AE%BA-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="位运算">位运算</h1>
<h2 id="技巧">技巧</h2>
<p>参见<a href="https://oi-wiki.org/math/bit/">链接</a>以及<a
href="https://oi-wiki.org/math/binary-set/">链接</a></p>
<h2 id="练习题">练习题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1469">P1469</a>
异或的巧用</li>
<li><a href="https://www.luogu.com.cn/problem/P1100">P1100</a>
无符号移位</li>
</ul>
<h1 id="进制">进制</h1>
<h2 id="技巧-1">技巧</h2>
<p>参见<a href="https://oi-wiki.org/math/base/">链接</a></p>
<h2 id="练习题-1">练习题</h2>
<ul>
<li><p><a href="https://www.luogu.com.cn/problem/P1017">P1017</a>
必须掌握的模板题！</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P1143">P1143</a>
n进制转m进制的范例，先把n进制转为十进制，再用短除法将十进制转为m进制</p></li>
</ul>
<h1 id="快速幂">快速幂</h1>
<h2 id="技巧-2">技巧</h2>
<p>参考<a
href="https://oi-wiki.org/math/binary-exponentiation/">链接</a></p>
<h2 id="练习题-2">练习题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1226">P1226</a>
模板题</li>
<li><a href="https://www.luogu.com.cn/problem/P1045">P1045</a>
高精度与快速幂的结合</li>
</ul>
<h1 id="整除">整除</h1>
<h2 id="技巧-3">技巧</h2>
<p>参见<a
href="https://oi-wiki.org/math/number-theory/basic/#%E6%95%B4%E9%99%A4">链接</a>，但是并不全...</p>
<p>补充几个关键性质：</p>
<ol type="1">
<li><p>若<span class="math inline">\(a\shortmid b\)</span>且<span
class="math inline">\(b\shortmid c\)</span>，那么<span
class="math inline">\(a\shortmid c\)</span></p></li>
<li><p>若<span class="math inline">\(a\shortmid b\)</span>且<span
class="math inline">\(a\shortmid
c\)</span>，那么对任意的整数x，y，有<span
class="math inline">\(a\shortmid bx+cy\)</span></p></li>
<li><p>设整数<span class="math inline">\(m\ne 0\)</span>，那么<span
class="math inline">\(a\shortmid b\)</span>等价于<span
class="math inline">\(ma\shortmid mb\)</span></p></li>
<li><p>如果<span class="math inline">\(k\)</span>是<span
class="math inline">\(n\)</span>的约数，那么<span
class="math inline">\(\frac{n}{k}\)</span>也一定是<span
class="math inline">\(n\)</span>的约数</p>
<p>只要限定<span class="math inline">\(k\leqslant
\frac{n}{k}\)</span>，即<span class="math inline">\(k\leqslant
\sqrt{n}\)</span>，就可以在<span class="math inline">\(O\left( \sqrt{n}
\right)\)</span>的时间复杂度内找到<span
class="math inline">\(n\)</span>的所有约数</p></li>
<li><p>对于约数、倍数相关的题目，经常用到枚举约数贡献和枚举倍数贡献两个切入点</p></li>
</ol>
<h2 id="练习题-3">练习题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P2926">P2926</a>
对枚举约数和枚举倍数解题的思考</li>
</ul>
<h1 id="质数与合数">质数与合数</h1>
<h2 id="技巧-4">技巧</h2>
<p>参考<a
href="https://oi-wiki.org/math/number-theory/basic/#%E7%B4%A0%E6%95%B0%E4%B8%8E%E5%90%88%E6%95%B0">链接</a></p>
<p>质数和合数本身唯一常用的知识点就是：</p>
<blockquote>
<p>若<span class="math inline">\(a\)</span>为合数，则一定存在质数<span
class="math inline">\(p\shortmid a\)</span>，且<span
class="math inline">\(p\leqslant \sqrt{a}\)</span></p>
<p>埃氏筛以此为核心实现的</p>
</blockquote>
<p>还有一个易错点，虽然1不是质数，但是1与任何数互质！</p>
<h2 id="模板">模板</h2>
<p>判断一个整数是否为质数的模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= a; ++i)</span><br><span class="line">    <span class="keyword">if</span> (a % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>埃氏筛</p>
<p>一般用埃氏筛的思路解题较多，真正筛质数其实多用线性筛</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!vis[i]) &#123;  <span class="comment">// 如果i没有被筛去，那么i是一个质数</span></span><br><span class="line">    prime[++tot] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i &lt;&lt; <span class="number">1</span>; j &lt;= n; j += i) &#123;  <span class="comment">// 枚举i的所有倍数j</span></span><br><span class="line">      vis[j] = <span class="number">1</span>;                           <span class="comment">// 质数i的倍数是合数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线性筛（欧拉筛）</p>
<p>除了筛质数，计算积性函数也是用它哟！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!vis[i]) prime[++tot] = i;  <span class="comment">// 如果i没有被筛去，那么i是一个质数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n;</span><br><span class="line">       ++j) &#123;               <span class="comment">// 枚举当前所有质数prime[j]</span></span><br><span class="line">    vis[i * prime[j]] = <span class="number">1</span>;  <span class="comment">// i的prime[j]倍是合数</span></span><br><span class="line">    <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习题-4">练习题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3383">P3383</a>
线性筛模板题</li>
<li><a href="https://www.luogu.com.cn/problem/P1835">P1835</a>
区间筛的模板题，一定要会！</li>
<li><a href="https://www.luogu.com.cn/problem/P7960">P7960</a>
埃氏筛的灵活运用</li>
</ul>
<h1 id="最大公约数与最小公倍数">最大公约数与最小公倍数</h1>
<h2 id="技巧-5">技巧</h2>
<p>参见<a
href="https://oi-wiki.org/math/number-theory/gcd/">链接</a></p>
<p>总结一下常用结论：</p>
<ol type="1">
<li><p>对任意整数<span class="math inline">\(m\)</span>，<span
class="math inline">\(m\left( a_1,\cdots ,a_k \right) =\left(
ma_1,\cdots ,ma_k \right)\)</span>
即整数同时成倍放大/缩小，最大公约数也放大/缩小相同倍数</p>
<p><strong>该性质也同样适用于最小公倍数</strong></p>
<p>可以发现，有<span class="math inline">\(gcd\left( a,b \right) =e,
gcd\left( \frac{a}{e},\frac{b}{e} \right) =1\)</span>存在；即<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>除掉最大公因数，两者将会互质</p></li>
<li><p>对任意整数<span class="math inline">\(x\)</span>，<span
class="math inline">\(\left( a_1,a_2 \right) =\left( a_1,a_2+a_1x
\right)\)</span></p>
<p>即一个整数加/减上另一个整数的任意倍数，它们的最大公约数不变；其中<span
class="math inline">\(\left( a,0 \right) =a\)</span></p>
<p>这是欧几里得算法（辗转相除法）的基础！</p>
<p>不适用最小公倍数</p></li>
<li><p><span class="math inline">\(\left( a_1,a_2,a_3,\cdots ,a_{k+r}
\right) =\left( \left( a_1,\cdots ,a_k \right) ,\left( a_{k+1},\cdots
,a_{k+r} \right) \right)\)</span> ，最大公约数的运算是满足“结合律”的</p>
<p><strong>该性质也同样适用于最小公倍数</strong></p></li>
<li><p><span class="math inline">\(\left[ a_1,a_2 \right] \times \left(
a_1,a_2 \right) =a_1\times
a_2\)</span>，即最大公约数×最小公倍数＝原来两个数的乘积</p></li>
</ol>
<h2 id="模板-1">模板</h2>
<p>求最大公约数的欧几里得算法（辗转相除法）<strong>不能处理负数</strong>，但是可以不区分a、b两个参数的大小</p>
<p>因为哪怕小了下一次递归就换回来了...</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br></pre></td></tr></table></figure>
<p>求最小公倍数的话，用两数之积除以它们的最大公约数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x / <span class="built_in">gcd</span>(x, y) * y; &#125; <span class="comment">//先除后乘是为了防止溢出</span></span><br></pre></td></tr></table></figure>
<h2 id="练习题-5">练习题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1029">P1029</a>
枚举公约数的倍数，还是枚举公倍数的约数选择</li>
<li><a href="https://www.luogu.com.cn/problem/P1072">P1072</a>
枚举公约数的倍数，还是枚举公倍数的约数选择</li>
<li><a href="https://www.luogu.com.cn/problem/P1414">P1414</a>
最大公约数的性质</li>
<li><a href="https://www.luogu.com.cn/problem/P1403">P1403</a>
枚举约数个数</li>
<li><a href="https://www.luogu.com.cn/problem/P1572">P1572</a>
模拟分数计算时的通分和约分操作</li>
<li><a href="https://www.luogu.com.cn/problem/P2651">P2651</a>
模拟分数计算，细节有提升</li>
<li><a href="https://www.luogu.com.cn/problem/P4057">P4057</a>
最小公倍数的模拟题</li>
<li><a href="https://www.luogu.com.cn/problem/P2660">P2660</a>
最大公约数与分治、贪心的结合</li>
</ul>
<h1 id="算术基本定理">算术基本定理</h1>
<h2 id="技巧-6">技巧</h2>
<p>设<span class="math inline">\(a&gt;1\)</span>，那么必有<span
class="math inline">\(a={p_1}^{a_1}{p_2}^{a_2}\cdots
{p_s}^{a_s}\)</span></p>
<p>其中<span class="math inline">\(p_j\left( 1\leqslant j\leqslant s
\right)\)</span>是两两不相同的质数，<span
class="math inline">\(a_j\left( 1\leqslant j\leqslant s
\right)\)</span>表示对应质数的幂次（出现的次数）</p>
<p>若在不计次序的意义下，该分解式是唯一的，俗称“分解质因数”；比如48＝2<sup>4</sup>×3</p>
<hr />
<p>有以下重要推论，假定<span
class="math inline">\(a={p_1}^{a_1}{p_2}^{a_2}\cdots
{p_s}^{a_s}\)</span></p>
<ol type="1">
<li><span class="math inline">\(d\)</span>是<span
class="math inline">\(a\)</span>的约数的充要条件是<span
class="math inline">\(d={p_1}^{e_1}{p_2}^{e_2}\cdots
{p_s}^{e_s},0\leqslant e_j\leqslant a_j,1\leqslant j\leqslant
s\)</span></li>
</ol>
<p>​ 即<span
class="math inline">\(d\)</span>中每个质数的幂次都不超过<span
class="math inline">\(a\)</span>的，每个质因子上的幂次直接决定了两数之间的整除性</p>
<p>​
例如12＝2<sup>2</sup>×3,72＝2<sup>3</sup>×3<sup>2</sup>，看到12的质因子上的每个幂次都对应地比72小，可以得到<span
class="math inline">\(12\shortmid 72\)</span>的结论</p>
<ol start="2" type="1">
<li>若<span class="math inline">\(b={p_1}^{\beta _1}{p_2}^{\beta
_2}\cdots {p_s}^{\beta _s}\)</span>（这里允许某些<span
class="math inline">\(a_j\)</span>或<span class="math inline">\(\beta
_j\)</span>为零），有最大公约数与最小公倍数的计算公式：</li>
</ol>
<p>​ <span class="math display">\[\left( a,b \right) ={p_1}^{\delta
_1}{p_2}^{\delta _2}\cdots {p_s}^{\delta _s},\delta _j=\min \left(
a_j,\beta _j \right) ,1\leqslant j\leqslant s\]</span> ​ <span
class="math display">\[\left[ a,b \right] ={p_1}^{\gamma
_1}{p_2}^{\gamma _2}\cdots {p_s}^{\gamma _s},\gamma _j=\max \left(
a_j,\beta _j \right) ,1\leqslant j\leqslant s\]</span></p>
<ol start="3" type="1">
<li>用<span class="math inline">\(\tau \left( a
\right)\)</span>表示<span
class="math inline">\(a\)</span>的所有正约数的个数，则<span
class="math inline">\(\tau \left( a \right) =\left( a_1+1 \right) \left(
a_2+1 \right) \cdots \left( a_s+1 \right)\)</span></li>
</ol>
<p>​
比如a＝2<sup>7</sup>×3<sup>8</sup>×5<sup>9</sup>，直接可以写出a的因子个数等于＝(7+1)(8+1)(9+1)＝720个</p>
<ol start="4" type="1">
<li>用<span class="math inline">\(\sigma \left( a
\right)\)</span>表示<span
class="math inline">\(a\)</span>的所有正约数的和，有  

$$
\sigma \left( a \right) =\small{\frac{{p_1}^{a_1+1}-1}{p_1-1}}\small{\frac{{p_2}^{a_2+1}-1}{p_2-1}}\cdots \small{\frac{{p_s}^{a_s+1}-1}{p_s-1}}=\left( 1+p_1+\cdots {p_1}^{a_1} \right) \left( 1+p_2+\cdots {p_2}^{a_2} \right) \cdots \left( 1+p_s+\cdots {p_s}^{a_s} \right)
$$


 
​		比如
$$
\sigma \left( 120 \right) =\frac{2^4-1}{2-1}\frac{3^2-1}{3-1}\frac{5^2-1}{5-1}=\left( 1+2+2^2+2^3 \right) \left( 1+3 \right) \left( 1+5 \right)
$$
</li>
</ol>
<h2 id="模板-2">模板</h2>
<p>分解质因数有很多写法，我列出我常用的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; ++i) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">    pri[++tot] = i;</span><br><span class="line">    <span class="keyword">while</span> (n % i == <span class="number">0</span>) ++cnt[i], n /= i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">1</span>) ++cnt[n], pri[++tot] = n;<span class="comment">//有且只有一个大于根号n的质因数</span></span><br></pre></td></tr></table></figure>
<h2 id="练习题-6">练习题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1069">P1069</a>
算术基本定理的模板题</li>
</ul>
<h1 id="模意义下的运算">模意义下的运算</h1>
<p>加减乘法没有什么特殊： <span class="math display">\[
\left( a\pm b \right) \,\,mod\,\,M\,\,=\,\,\left( a\,\,mod\,\,M\,\,\pm
\,\,b\,\,mod\,\,M \right) \,\,mod\,\,M
\]</span></p>
<p><span class="math display">\[
\left( a\times b \right) \,\,mod\,\,M\,\,=\,\,\left(
a\,\,mod\,\,M\,\,\times \,\,b\,\,mod\,\,M \right) \,\,mod\,\,M
\]</span></p>
<p>除法不行，需要用到<strong>乘法逆元</strong>来转换</p>
<h1 id="同余">同余</h1>
<p>若两数a，b除以m的余数相等，则称a，b模m同余，记作<span
class="math inline">\(a\equiv b\left( mod\,\,m \right)\)</span></p>
<p>有如下重要特殊性质：</p>
<ul>
<li>整除性：</li>
</ul>
<p><span class="math inline">\(m\mid \,\,\left( a-b \right)\)</span></p>
<p>简单证明一下：</p>
<blockquote>
<p>a ＝ A ＋ xm，b ＝ B ＋ ym</p>
<p>由于a和b同余，那么A和B相等</p>
<p>显然a－b＝(x－y)m是m的倍数</p>
</blockquote>
<ul>
<li>反身性：</li>
</ul>
<p><span class="math inline">\(a\equiv a\left( mod\,\,m
\right)\)</span></p>
<ul>
<li>对称性：</li>
</ul>
<p>若<span class="math inline">\(a\equiv b\left( mod\,\,m
\right)\)</span> ，则<span class="math inline">\(b\equiv a\left(
mod\,\,m \right)\)</span></p>
<ul>
<li>传递性：</li>
</ul>
<p>若<span class="math inline">\(a\equiv b\left( mod\,\,m
\right)\)</span>，<span class="math inline">\(b\equiv c\left( mod\,\,m
\right)\)</span><span class="math inline">\(，则\)</span><span
class="math inline">\(a\equiv c\left( mod\,\,m \right)\)</span></p>
<ul>
<li>基本运算：</li>
</ul>
<p><span class="math display">\[
\left. \begin{array}{r}
    a\equiv b\left( mod\,\,m \right)\\
    c\equiv d\left( mod\,\,m \right)\\
\end{array} \right\} \Longrightarrow \begin{cases}
    a\pm c\equiv b\pm d\left( mod\,\,m \right)\\
    ac\equiv bd\left( mod\,\,m \right)\\
\end{cases}
\]</span></p>
<p>当<span class="math inline">\(c =
d\)</span>时，则为等量加法、减法：<span class="math inline">\(a\pm
c\equiv b\pm c\left( mod\,\,m \right)\)</span></p>
<p>还有以下推导： <span class="math display">\[
a\equiv b\left( mod\,\,m \right) \Rightarrow \begin{cases}
    an\equiv bn\left( mod\,\,m \right) ,\forall n\in \mathbb{Z}\\
    a^n\equiv b^n\left( mod\,\,m \right) ,\forall n\in \mathbb{N}
^*,\text{不能逆推！}\\
    P\left( a \right) \equiv P\left( b \right) \left( mod\,\,m \right)
,P\left( x \right) \text{为任意整系数多项式函数}\\
    ak\equiv bk\left( mod\,\,mk \right) , k,m\in \mathbb{N} ^*\\
    \frac{a}{d}\equiv \frac{b}{d}\left( mod\,\,\frac{m}{d} \right) ,
d\mid a,d\mid b,d\mid m\\
    \text{若}n\mid m,\text{有}a\equiv b\left( mod\,\,n \right)\\
\end{cases}
\]</span></p>
<ul>
<li>除法：</li>
</ul>
<p><span class="math display">\[
ac\equiv bc\left( mod\,\,m \right) \Rightarrow a\equiv b\left(
mod\,\,m/gcd\left( c,m \right) \right)
\]</span></p>
<p>稍微来证明一下方便记忆：</p>
<blockquote>
<p>根据同余的整除性，有<span class="math inline">\(m\mid \left( a-b
\right) c\)</span></p>
<p>根据整除的性质，两边同除<span class="math inline">\(gcd\left( m,c
\right)\)</span>整除性质保持不变</p>
<p>变成<span class="math inline">\(\frac{m}{gcd\left( m,c \right)}\mid
\frac{c}{gcd\left( m,c \right)}\cdot \left( a-b \right)\)</span>
假设<span class="math inline">\(gcd\left( m,c \right)
=e\)</span>，那么<span class="math inline">\(gcd\left(
\frac{m}{e},\frac{c}{e} \right) =1\)</span></p>
<p>所以<span class="math inline">\(\frac{m}{gcd\left( m,c \right)}\bot
\frac{c}{gcd\left( m,c \right)}\)</span>，<span
class="math inline">\(\frac{m}{gcd\left( m,c
\right)}\)</span>的质因子与<span
class="math inline">\(\frac{c}{gcd\left( m,c
\right)}\)</span>的质因子没有交集</p>
<p>故而推出<span class="math inline">\(\frac{m}{gcd\left( m,c
\right)}\mid \left( a-b \right)\)</span></p>
</blockquote>
<p>还有一个冷门性质： <span class="math display">\[
a\equiv b\left( mod\,\,m_i \right) \left( i=1,2,\cdots ,n \right)
\Rightarrow a\equiv b\left( mod\,\,lcm\left( m_1,m_2,\cdots ,m_n \right)
\right)
\]</span></p>
<h1 id="乘法逆元">乘法逆元</h1>
<p>（后期更新）</p>
<h2 id="练习题-7">练习题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1593">P1593</a>
算术基本定理+费马小定理+快速幂的结合</li>
</ul>
<h1 id="欧拉函数">欧拉函数</h1>
<h2 id="技巧-7">技巧</h2>
<p>（后期更新，<a
href="https://www.cnblogs.com/littlehb/p/15213612.html">链接</a>虽然很多错，但还凑合）</p>
<h2 id="练习题-8">练习题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3601">P3601</a>
根据欧拉函数定义，结合区间筛求出</li>
</ul>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>组合数学与计数_解题技巧</title>
    <url>/2023/12/12/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E4%B8%8E%E8%AE%A1%E6%95%B0-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="排列组合">排列组合</h1>
<h2 id="技巧">技巧</h2>
<p>具体参考<a
href="https://oi-wiki.org/math/combinatorics/combination/">链接</a></p>
<h2 id="模板">模板</h2>
<p>如果对<span class="math inline">\(\left( \begin{array}{c}  n\\  m\\
\end{array}
\right)\)</span>组合数轮询并不多，按照定义求单个组合数即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">c</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">  ll ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; n - m; --i) &#123;</span><br><span class="line">    ans *= i;</span><br><span class="line">    ans /= (n + <span class="number">1</span> - i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果轮询次数过多，还是用杨辉三角打表吧：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">  c[i][<span class="number">0</span>] = c[i][i] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">    c[i][j] = c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习题">练习题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P2822">P2822</a>
杨辉三角模板题，二维前缀和优化</li>
<li><a href="https://www.luogu.com.cn/problem/P1246">P1246</a>
组合数的精髓：可视作任意顺序</li>
<li><a href="https://www.luogu.com.cn/problem/P2638">P2638</a>
插板法+高精度</li>
<li><a href="https://www.luogu.com.cn/problem/P2789">P2789</a>
分组后使用乘法原理</li>
<li><a href="https://www.luogu.com.cn/problem/P3913">P3913</a>
分组后使用乘法原理</li>
<li><a href="https://www.luogu.com.cn/problem/P1866">P1866</a>
贪心优化运算</li>
<li><a href="https://www.luogu.com.cn/problem/P2415">P2415</a>
组合数的求和</li>
</ul>
<h1 id="卡特兰数">卡特兰数</h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1044">P1044</a>
模板题</li>
</ul>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>组合数学与计数</tag>
      </tags>
  </entry>
  <entry>
    <title>P7960. 报数</title>
    <url>/2023/12/12/P7960-%E6%8A%A5%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>质数</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e7</span> + <span class="number">50</span>;</span><br><span class="line">bitset&lt;LEN&gt; vis;</span><br><span class="line"><span class="type">int</span> nxt[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1e7</span> + <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>, j = i;</span><br><span class="line">    <span class="keyword">while</span> (j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j % <span class="number">10</span> == <span class="number">7</span>) &#123;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      j /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j = i; j &lt;= <span class="number">1e7</span> + <span class="number">10</span>; j += i) vis[j] = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nxt[pre] = i;</span><br><span class="line">      pre = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="type">int</span> t, x;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    cout &lt;&lt; (vis[x] ? <span class="number">-1</span> : nxt[x]) &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>参照埃氏筛的思路，如果当前数字含有7，那么就枚举其倍数</p>
<p>题目要求保存每个可行数字的后继，参考链表的结构即可</p>
<p>唯一的坑点是测试点的范围是略大于1e7的</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>质数</tag>
      </tags>
  </entry>
  <entry>
    <title>P1578. 奶牛浴场</title>
    <url>/2024/01/10/P1578-%E5%A5%B6%E7%89%9B%E6%B5%B4%E5%9C%BA/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>最大子矩形</li>
<li>障碍物法</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, ans, L, W;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y_;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpx</span><span class="params">(node &amp;x, node &amp;y)</span> </span>&#123; <span class="keyword">return</span> x.x_ &lt; y.x_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpy</span><span class="params">(node &amp;x, node &amp;y)</span> </span>&#123; <span class="keyword">return</span> x.y_ &lt; y.y_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; L &gt;&gt; W &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i].x_ &gt;&gt; a[i].y_;</span><br><span class="line">  <span class="comment">// 四个顶点也算障碍点</span></span><br><span class="line">  a[++n] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, a[++n] = &#123;<span class="number">0</span>, W&#125;, a[++n] = &#123;L, <span class="number">0</span>&#125;, a[++n] = &#123;L, W&#125;;</span><br><span class="line">  <span class="comment">// 从左到右扫一遍</span></span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, cmpx);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>, d = W;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">      <span class="type">int</span> l = a[i].x_, r = a[j].x_;</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, (r - l) * (d - u));</span><br><span class="line">      a[i].y_ &lt;= a[j].y_ ? d = <span class="built_in">min</span>(d, a[j].y_) : u = <span class="built_in">max</span>(u, a[j].y_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从上到下扫一遍</span></span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, cmpy);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>, d = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">      <span class="type">int</span> l = a[i].y_, r = a[j].y_;</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, (r - l) * (d - u));</span><br><span class="line">      a[i].x_ &lt;= a[j].x_ ? d = <span class="built_in">min</span>(d, a[j].x_) : u = <span class="built_in">max</span>(u, a[j].x_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>障碍物法的模板题，直接上王知昆巨佬的PPT思路截图。</p>
<img src="/2024/01/10/P1578-%E5%A5%B6%E7%89%9B%E6%B5%B4%E5%9C%BA/1.png" class="" title="image-20240110222221326">
<img src="/2024/01/10/P1578-%E5%A5%B6%E7%89%9B%E6%B5%B4%E5%9C%BA/2.png" class="" title="image-20240110222303601">
<img src="/2024/01/10/P1578-%E5%A5%B6%E7%89%9B%E6%B5%B4%E5%9C%BA/3.png" class="" title="image-20240110222350327">
<img src="/2024/01/10/P1578-%E5%A5%B6%E7%89%9B%E6%B5%B4%E5%9C%BA/4.png" class="" title="image-20240110222450070">
<img src="/2024/01/10/P1578-%E5%A5%B6%E7%89%9B%E6%B5%B4%E5%9C%BA/5.png" class="" title="image-20240110222515221">
<img src="/2024/01/10/P1578-%E5%A5%B6%E7%89%9B%E6%B5%B4%E5%9C%BA/6.png" class="" title="image-20240110222543213">
<img src="/2024/01/10/P1578-%E5%A5%B6%E7%89%9B%E6%B5%B4%E5%9C%BA/7.png" class="" title="image-20240110222629623">
<img src="/2024/01/10/P1578-%E5%A5%B6%E7%89%9B%E6%B5%B4%E5%9C%BA/8.png" class="" title="image-20240110222703041">
<img src="/2024/01/10/P1578-%E5%A5%B6%E7%89%9B%E6%B5%B4%E5%9C%BA/9.png" class="" title="image-20240110222740190">
<img src="/2024/01/10/P1578-%E5%A5%B6%E7%89%9B%E6%B5%B4%E5%9C%BA/10.png" class="" title="image-20240110222817691">
<img src="/2024/01/10/P1578-%E5%A5%B6%E7%89%9B%E6%B5%B4%E5%9C%BA/11.png" class="" title="image-20240110222841066">
<img src="/2024/01/10/P1578-%E5%A5%B6%E7%89%9B%E6%B5%B4%E5%9C%BA/12.png" class="" title="image-20240110222914707">
<p>之前我们根据x轴排序，从左往右处理的时候，会漏了上述两类情况；</p>
<p>那么再根据y轴排序，再从上往下处理一遍即可；</p>
<p>（看PPT的图就能发现，遗漏的情况在从上往下处理的过程中会被一并解决）。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>P1725. 琪露诺</title>
    <url>/2024/01/12/P1725-%E7%90%AA%E9%9C%B2%E8%AF%BA/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线性动态规划</li>
<li>单调队列</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"><span class="type">int</span> n, l, r, head, tail, a[maxn], q[maxn], dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">0xc0</span>, <span class="built_in">sizeof</span>(dp)), dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail &amp;&amp; i &gt; r + q[head]) ++head;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail &amp;&amp; dp[q[tail - <span class="number">1</span>]] &lt; dp[i - l]) --tail;</span><br><span class="line">    q[tail++] = i - l;</span><br><span class="line">    dp[i] = dp[q[head]] + a[i];</span><br><span class="line">    <span class="keyword">if</span> (i + r &gt; n) ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题意，显然能得到状态转移方程： <span class="math display">\[
dp\left[ i \right] =\max \left( dp\left[ j \right] \right) +a\left[ i
\right] ,j\in \left[ i-R,i-L \right]
\]</span> 求区间极值，用单调队列优化即可。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P1638. 逛画展</title>
    <url>/2023/12/29/P1638-%E9%80%9B%E7%94%BB%E5%B1%95/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>双指针</li>
<li>滑动窗口</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, ansa, ansb, a[maxn], c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="type">int</span> len = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>, l = <span class="number">1</span>, r = <span class="number">1</span>; l &lt;= r &amp;&amp; r &lt;= n; ++r) &#123;</span><br><span class="line">    <span class="comment">// 右指针向右扩张窗口</span></span><br><span class="line">    <span class="keyword">if</span> (c[a[r]]++ == <span class="number">0</span>) ++cnt;</span><br><span class="line">    <span class="comment">// 满足条件的情况下，左指针向右收缩寻找最短长度</span></span><br><span class="line">    <span class="keyword">while</span> (cnt == m) &#123;</span><br><span class="line">      <span class="keyword">if</span> (len &gt; r - l + <span class="number">1</span>) len = r - l + <span class="number">1</span>, ansa = l, ansb = r;</span><br><span class="line">      <span class="keyword">if</span> (--c[a[l++]] == <span class="number">0</span>) --cnt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ansa &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ansb;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>滑动窗口的模板题，题意是要你寻找一个<strong>满足条件的最短窗口长度</strong></p>
<p>设计思路很明显：</p>
<ul>
<li><p>窗口设计为“左闭右闭区间”，条件处理和可行性判定在本次完成</p></li>
<li><p>只要没有满足条件，右指针向右扩张窗口</p></li>
<li><p>只要满足条件，左指针向右收缩窗口寻找最短长度</p></li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>P1714. 切蛋糕</title>
    <url>/2024/01/12/P1714-%E5%88%87%E8%9B%8B%E7%B3%95/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>单调队列</li>
<li>前缀和</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, pre[maxn];</span><br><span class="line"><span class="type">int</span> head, tail, q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; pre[i], pre[i] += pre[i - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail &amp;&amp; q[head] - <span class="number">1</span> + m &lt; i) ++head;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail &amp;&amp; pre[q[tail - <span class="number">1</span>]] &gt; pre[i]) --tail;</span><br><span class="line">    q[tail++] = i;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, pre[i + <span class="number">1</span>] - pre[q[head]]);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>一开始的想法肯定是前缀和，然后左端点<code>l</code>和右端点<code>r</code>随便选....但显然会TLE。</p>
<p>考虑到前缀和的公式<code>pre[r] - pre[l - 1]</code>，</p>
<p>相同的<code>pre[r]</code>时，显然<code>pre[l - 1]</code>最小时就能得到<code>m</code>区间长度内的极大值。</p>
<p>推导得到<code>l - 1</code>的区间范围： <span class="math display">\[
\\
\left( l-1 \right) \in \left[ r-m,r-1 \right] \begin{cases}
    r-l+1\leqslant m\Longrightarrow r-m\leqslant l-1\\
    l-1\leqslant r-1\\
\end{cases}
\]</span>
所以用单调队列保存该区间内的极小值，用来更新<code>r</code>即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>P1115. 最大子段和</title>
    <url>/2023/12/29/P1115-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>分治</li>
<li>线性动态规划</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<h2 id="线性动态规划">线性动态规划</h2>
<p>设<code>dp[i]</code>的含义为：</p>
<blockquote>
<p><strong>以<code>a[i]</code>为结尾的连续序列里，连续序列和的极大值</strong></p>
</blockquote>
<p>显然能得到状态转移方程： <span class="math display">\[
dp\left[ i \right] =\max \left( dp\left[ i-1 \right] +a\left[ i \right]
,a\left[ i \right] \right) ,2\leqslant i\leqslant n
\]</span> 直接编程即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, ans, a[maxn], dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">  ans = dp[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>] + a[i], a[i]);</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分治">分治</h2>
<p>考虑最大子段和出现的位置：</p>
<ol type="1">
<li>只出现在左半部分，不包含中线；</li>
<li>只出现在右半部分，不包含中线；</li>
<li>包含中线。</li>
</ol>
<img src="/2023/12/29/P1115-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/1.png" class="" title="image-20231229194924986">
<p>前两种可能分治处理即可，重点是第三种可能。</p>
<p>由于一定要经过中线，可以从中线开始向两边走；</p>
<p>分别取左半部分的最大后缀和右半部分的最大前缀后相加即可。</p>
<img src="/2023/12/29/P1115-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/2.png" class="" title="image-20231229195654812">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">50</span>, mi = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"><span class="type">int</span> n, ans = mi, a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, a[l]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = r + ((l - r) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> lsm = <span class="number">0</span>, rsm = <span class="number">0</span>, lmx = mi, rmx = mi;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = mid; i &gt;= l; --i) lsm += a[i], lmx = <span class="built_in">max</span>(lmx, lsm);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = mid + <span class="number">1</span>; i &lt;= r; ++i) rsm += a[i], rmx = <span class="built_in">max</span>(rmx, rsm);</span><br><span class="line">  ans = <span class="built_in">max</span>(ans, lmx + rmx);</span><br><span class="line">  <span class="built_in">f</span>(l, mid), <span class="built_in">f</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="built_in">f</span>(<span class="number">1</span>, n);</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P2032. 扫描</title>
    <url>/2024/01/03/P2032-%E6%89%AB%E6%8F%8F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>单调队列</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, k, head, tail, a[maxn], q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail &amp;&amp; i - q[head] &gt;= k) ++head;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail &amp;&amp; a[q[tail - <span class="number">1</span>]] &lt;= a[i]) --tail;</span><br><span class="line">    q[tail++] = i;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= k) cout &lt;&lt; a[q[head]] &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>直接上《深进》的图</p>
<img src="/2024/01/03/P2032-%E6%89%AB%E6%8F%8F/1.png" class="" title="image-20240103143410393">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>P1950. 长方形</title>
    <url>/2024/01/02/P1950-%E9%95%BF%E6%96%B9%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>单调栈</li>
<li>悬线法</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">char</span> c[maxn][maxn];</span><br><span class="line"><span class="type">int</span> n, m, top, st[maxn], h[maxn], l[maxn], r[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">      cin &gt;&gt; c[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) h[j] = c[i][j] == <span class="string">&#x27;.&#x27;</span> ? h[j] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//左开右开区间</span></span><br><span class="line">    <span class="comment">//求向右最大延伸，维护不减单调栈</span></span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">      <span class="keyword">while</span> (top &amp;&amp; h[st[top]] &gt; h[j]) r[st[top--]] = j;</span><br><span class="line">      st[++top] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (top) r[st[top--]] = m + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//求向左最大延伸，维护递增单调栈</span></span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">      <span class="keyword">while</span> (top &amp;&amp; h[st[top]] &gt;= h[j]) l[st[top--]] = j;</span><br><span class="line">      st[++top] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (top) l[st[top--]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) ans += <span class="number">1ll</span> * h[j] * (j - l[j]) * (r[j] - j);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本题是<a
href="https://www.luogu.com.cn/problem/P4147">P4147</a>的升级版，请先掌握该题；题目问有多少种剪矩形的办法。</p>
<p>根据悬线法可知，一个最大矩形可以由中线切开，<code>组成的可能性 = 左半部分的可能性 * 右半部分的可能性</code></p>
<p>本题实际上就是求每个悬线向左和向右的最大扩展距离罢了~</p>
<img src="/2024/01/02/P1950-%E9%95%BF%E6%96%B9%E5%BD%A2/1.png" class="" title="image-20240102203224051">
<p>但是要注意不重不漏哟，如下图所示：</p>
<ul>
<li><p>A向右扩展时可以和P4147一样正常找最大</p></li>
<li><p>B向左扩展时遇到高度小于等于时就终止，因为A向右扩展时已经找过最大值了</p></li>
</ul>
<img src="/2024/01/02/P1950-%E9%95%BF%E6%96%B9%E5%BD%A2/2.png" class="" title="image-20240102212902807">
<p>明白了这些后，再看《深进》就懂啦~</p>
<img src="/2024/01/02/P1950-%E9%95%BF%E6%96%B9%E5%BD%A2/3.png" class="" title="image-20240102213436015">
<img src="/2024/01/02/P1950-%E9%95%BF%E6%96%B9%E5%BD%A2/4.png" class="" title="image-20240102213534052">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>P2216. 理想的正方形</title>
    <url>/2024/01/03/P2216-%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>单调队列</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, k, a[maxn][maxn];</span><br><span class="line"><span class="type">int</span> row_mx[maxn][maxn], row_mi[maxn][maxn];</span><br><span class="line"><span class="type">int</span> col_mx[maxn][maxn], col_mi[maxn][maxn];</span><br><span class="line"><span class="type">int</span> h_mx, t_mx, q_mx[maxn];</span><br><span class="line"><span class="type">int</span> h_mi, t_mi, q_mi[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">      cin &gt;&gt; a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    h_mx = t_mx = h_mi = t_mi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">      <span class="comment">// 每行k单位的最大值</span></span><br><span class="line">      <span class="keyword">while</span> (h_mx &lt; t_mx &amp;&amp; j - q_mx[h_mx] &gt;= k) ++h_mx;</span><br><span class="line">      <span class="keyword">while</span> (h_mx &lt; t_mx &amp;&amp; a[i][q_mx[t_mx - <span class="number">1</span>]] &lt;= a[i][j]) --t_mx;</span><br><span class="line">      q_mx[t_mx++] = j;</span><br><span class="line">      <span class="keyword">if</span> (j &gt;= k) row_mx[i][j - k + <span class="number">1</span>] = a[i][q_mx[h_mx]];</span><br><span class="line">      <span class="comment">// 每行k单位的最小值</span></span><br><span class="line">      <span class="keyword">while</span> (h_mi &lt; t_mi &amp;&amp; j - q_mi[h_mi] &gt;= k) ++h_mi;</span><br><span class="line">      <span class="keyword">while</span> (h_mi &lt; t_mi &amp;&amp; a[i][q_mi[t_mi - <span class="number">1</span>]] &gt;= a[i][j]) --t_mi;</span><br><span class="line">      q_mi[t_mi++] = j;</span><br><span class="line">      <span class="keyword">if</span> (j &gt;= k) row_mi[i][j - k + <span class="number">1</span>] = a[i][q_mi[h_mi]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m - k + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">    h_mx = t_mx = h_mi = t_mi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="comment">// 每列k单位的最大值</span></span><br><span class="line">      <span class="keyword">while</span> (h_mx &lt; t_mx &amp;&amp; i - q_mx[h_mx] &gt;= k) ++h_mx;</span><br><span class="line">      <span class="keyword">while</span> (h_mx &lt; t_mx &amp;&amp; row_mx[q_mx[t_mx - <span class="number">1</span>]][j] &lt;= row_mx[i][j]) --t_mx;</span><br><span class="line">      q_mx[t_mx++] = i;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= k) col_mx[i - k + <span class="number">1</span>][j] = row_mx[q_mx[h_mx]][j];</span><br><span class="line">      <span class="comment">// 每列k单位的最小值</span></span><br><span class="line">      <span class="keyword">while</span> (h_mi &lt; t_mi &amp;&amp; i - q_mi[h_mi] &gt;= k) ++h_mi;</span><br><span class="line">      <span class="keyword">while</span> (h_mi &lt; t_mi &amp;&amp; row_mi[q_mi[t_mi - <span class="number">1</span>]][j] &gt;= row_mi[i][j]) --t_mi;</span><br><span class="line">      q_mi[t_mi++] = i;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= k) col_mi[i - k + <span class="number">1</span>][j] = row_mi[q_mi[h_mi]][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - k + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m - k + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">      ans = <span class="built_in">min</span>(ans, col_mx[i][j] - col_mi[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>直接上《深进》</p>
<img src="/2024/01/03/P2216-%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/1.png" class="" title="image-20240103160919239">
<img src="/2024/01/03/P2216-%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/2.png" class="" title="image-20240103161020266">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>P2671. 求和</title>
    <url>/2023/12/30/P2671-%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>模拟</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">10007</span>;</span><br><span class="line"><span class="type">int</span> n, m, ans, color[maxn], num[maxn], cnt[maxn][<span class="number">2</span>], sum[maxn][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; num[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; color[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    ++cnt[color[i]][i &amp; <span class="number">1</span>];</span><br><span class="line">    sum[color[i]][i &amp; <span class="number">1</span>] = (sum[color[i]][i &amp; <span class="number">1</span>] + i) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> c, t, i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    c = color[i];</span><br><span class="line">    <span class="keyword">if</span> (cnt[c][i &amp; <span class="number">1</span>] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">      t = <span class="number">1ll</span> * num[i] * (sum[c][i &amp; <span class="number">1</span>] + <span class="number">1ll</span> * i * (cnt[c][i &amp; <span class="number">1</span>] - <span class="number">2</span>) % mod) %</span><br><span class="line">          mod;</span><br><span class="line">      ans = (ans + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题意，<code>y - x = z - y</code>得到<code>(x + z) / 2 = y</code>，且<code>x</code>、<code>y</code>、<code>z</code>三者均为整数；</p>
<p>那么<code>x</code>和<code>z</code>的奇偶性必须相同，因为<code>奇 + 奇</code>或<code>偶 + 偶</code>才会等于偶数啊；题目还说color<sub>x</sub>和color<sub>z</sub>也要相同。</p>
<p>有个大概思路，使用二维数组，行代表颜色，列代表奇偶性来对编号进行分类。</p>
<hr />
<p>假设有编号1-5：</p>
<ul>
<li>1、3、5颜色等于A</li>
<li>2颜色等于A</li>
<li>4颜色等于B</li>
</ul>
<p>数组情况如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">奇数</th>
<th style="text-align: center;">偶数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">颜色A</td>
<td style="text-align: center;">1、3、5</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="even">
<td style="text-align: center;">颜色B</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">4</td>
</tr>
</tbody>
</table>
<p>根据题目要求，即求1、3、5三个编号中两两对(x + z) *
(number<sub>x</sub> + number<sub>z</sub>)的和。</p>
拆开来看，答案等于下列三个式子相加： $$ ans
<span class="math display">\[\begin{cases}
    1number_1+1number_3+3number_1+3number_3\\
    1number_1+1number_5+5number_1+5number_5\\
    3number_3+3number_5+5number_3+5number_5\\
\end{cases}\]</span>
<p>\</p>
\ <span class="math display">\[
合并同类项，发现规律：
\]</span> ans
<span class="math display">\[\begin{cases}
    \left( 1+1+3+5 \right) number_1\\
    \left( 3+1+3+5 \right) number_3\\
    \left( 5+1+3+5 \right) number_5\\
\end{cases}\]</span>
<p>\</p>
<p>\ $$
其中<code>1 + 3 + 5</code>是同颜色同奇偶集合内的编号和，设为<span
class="math inline">\(sum\left[ color_i \right] \left[ i\&amp;1
\right]\)</span></p>
<p>设<span class="math inline">\(cnt\left[ color_i \right] \left[
i\&amp;1 \right]\)</span>是同颜色同奇偶集合内的个数</p>
<p>那么每个<code>i</code>对结果的贡献就是： <span
class="math display">\[
number_i\times \left\{ \left( cnt\left[ color_i \right] \left[ i\&amp;1
\right] -2 \right) \times i+sum\left[ color_i \right] \left[ i\&amp;1
\right] \right\}
\]</span></p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P1886. 单调队列</title>
    <url>/2024/01/11/P1886-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>单调队列</li>
<li>滑动窗口</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, k, a[maxn];</span><br><span class="line"><span class="type">int</span> head, tail, q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="comment">// 区间最小</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 删除不在范围内的元素</span></span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail &amp;&amp; i &gt;= q[head] + k) ++head;</span><br><span class="line">    <span class="comment">// 维持单调性</span></span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail &amp;&amp; a[i] &lt; a[q[tail - <span class="number">1</span>]]) --tail;</span><br><span class="line">    q[tail++] = i;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= k) cout &lt;&lt; a[q[head]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 区间最大</span></span><br><span class="line">  cout &lt;&lt; endl, head = tail = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail &amp;&amp; i &gt;= q[head] + k) ++head;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail &amp;&amp; a[i] &gt; a[q[tail - <span class="number">1</span>]]) --tail;</span><br><span class="line">    q[tail++] = i;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= k) cout &lt;&lt; a[q[head]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>滑动窗口的模板题，直接看代码即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>P2880. Balanced Lineup G</title>
    <url>/2024/01/11/P2880-Balanced-Lineup-G/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>倍增</li>
<li>ST表</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<p>ST表的模板题，直接上《深进》的截图咯。</p>
<img src="/2024/01/11/P2880-Balanced-Lineup-G/1.png" class="" title="image-20240111211323865">
<img src="/2024/01/11/P2880-Balanced-Lineup-G/2.png" class="" title="image-20240111211358472">
<h2 id="区间重叠方式">区间重叠方式</h2>
<h3 id="原理">原理</h3>
<img src="/2024/01/11/P2880-Balanced-Lineup-G/3.png" class="" title="image-20240111211615654">
<h3 id="实现">实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, q, a[maxn], mx[maxn][<span class="number">20</span>], mi[maxn][<span class="number">20</span>], log_2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="comment">// ST表预处理</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) mx[i][<span class="number">0</span>] = mi[i][<span class="number">0</span>] = a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; ++j) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i) &#123;</span><br><span class="line">      mx[i][j] = <span class="built_in">max</span>(mx[i][j - <span class="number">1</span>], mx[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">      mi[i][j] = <span class="built_in">min</span>(mi[i][j - <span class="number">1</span>], mi[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// log预处理</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) log_2[i] = log_2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> k = log_2[r - l + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(mx[l][k], mx[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> k = log_2[r - l + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">min</span>(mi[l][k], mi[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 区间重叠方式求RMQ</span></span><br><span class="line">  <span class="type">int</span> l, r, k;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">query_max</span>(l, r) - <span class="built_in">query_min</span>(l, r) &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间不重不漏方式很重要">区间不重不漏方式（很重要！）</h2>
<h3 id="原理-1">原理</h3>
<img src="/2024/01/11/P2880-Balanced-Lineup-G/4.png" class="" title="image-20240111212629671">
<h3 id="实现-1">实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, q, a[maxn], mx[maxn][<span class="number">20</span>], mi[maxn][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="comment">// ST表预处理</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) mx[i][<span class="number">0</span>] = mi[i][<span class="number">0</span>] = a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; ++j) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i) &#123;</span><br><span class="line">      mx[i][j] = <span class="built_in">max</span>(mx[i][j - <span class="number">1</span>], mx[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">      mi[i][j] = <span class="built_in">min</span>(mi[i][j - <span class="number">1</span>], mi[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> k = r - l + <span class="number">1</span>, ans = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = l; (<span class="number">1</span> &lt;&lt; i) &lt;= k; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((k &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, mx[j][i]);</span><br><span class="line">      j += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> k = r - l + <span class="number">1</span>, ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = l; (<span class="number">1</span> &lt;&lt; i) &lt;= k; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((k &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      ans = <span class="built_in">min</span>(ans, mi[j][i]);</span><br><span class="line">      j += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 区间不重不漏方式求RMQ</span></span><br><span class="line">  <span class="type">int</span> l, r, k;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">query_max</span>(l, r) - <span class="built_in">query_min</span>(l, r) &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title>P2866. Bad Hair Day S</title>
    <url>/2024/01/02/P2866-Bad-Hair-Day-S/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>单调栈</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">8e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, top, st[maxn];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">while</span> (top &amp;&amp; st[top] &lt;= x) &#123;</span><br><span class="line">      ans += top - <span class="number">1</span>, --top;</span><br><span class="line">    &#125;</span><br><span class="line">    st[++top] = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (top) &#123;</span><br><span class="line">    ans += top - <span class="number">1</span>, --top;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>每头牛只能向右看，且只能看到比自己矮的，一直看到大于等于自己的停止；显然的单调栈裸题</p>
<img src="/2024/01/02/P2866-Bad-Hair-Day-S/1.png" class="" title="image-20240102151606688">
<p>可以发现，当单调栈收缩时，栈顶对答案的贡献就等于<code>top - 1</code>；<code>top</code>是当前栈内元素个数</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>P3143. Diamond Collector S</title>
    <url>/2024/01/09/P3143-Diamond-Collector-S/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>双指针</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, k, a[maxn], lmx[maxn], rmx[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> l = n, r = n; r &gt;= <span class="number">1</span>; --r) &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">1</span> &amp;&amp; a[r] - a[l] &lt;= k) &#123;</span><br><span class="line">      rmx[l] = <span class="built_in">max</span>(rmx[l + <span class="number">1</span>], r - l + <span class="number">1</span>);</span><br><span class="line">      --l;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>; l &lt;= n; ++l) &#123;</span><br><span class="line">    <span class="keyword">while</span> (r &lt;= n &amp;&amp; a[r] - a[l] &lt;= k) &#123;</span><br><span class="line">      lmx[r] = <span class="built_in">max</span>(lmx[r - <span class="number">1</span>], r - l + <span class="number">1</span>);</span><br><span class="line">      ++r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, lmx[i] + rmx[i + <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>一个区间内的任意两元素差值在<code>k</code>以内，保证该区间最大值和最小值差值在<code>k</code>以内即可；故而先将数组排序。</p>
<p>由于每个元素会被重复选择，比如：</p>
<ol type="1">
<li>该元素作为某区间的最小值</li>
<li>该元素作为某区间的最大值</li>
</ol>
<p>故而必须分开讨论：</p>
<ol type="1">
<li><p>用双指针，<code>l</code>和<code>r</code>默认值均为<code>n</code>；</p>
<p>即以从大到小的顺序，计算以<code>l</code>作为左端点（区间最小）时，向右最大扩展的区间长度<code>r - l + 1</code>;</p>
<p>同时令<code>rmx[i]</code>记录<code>i、i + 1、i + 2...n</code>中某个最大的向右扩展长度</p></li>
<li><p>用双指针，<code>l</code>和<code>r</code>默认值均为<code>1</code>；</p>
<p>即以从小到大的顺序，计算以<code>r</code>作为右端点（区间最大）时，向左最大扩展的区间长度<code>r - l + 1</code>;</p>
<p>同时令<code>lmx[i]</code>记录<code>1、2、3...i</code>中某个最大的向左扩展长度</p></li>
</ol>
<p>所以，最后只需要再扫一遍打擂台，计算<code>lmx[i] + rmx[i + 1]</code>的最大值即可。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>P3467. PLA-Postering</title>
    <url>/2024/01/11/P3467-PLA-Postering/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>单调栈</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">3e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, ans, top, st[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> nul, x;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    cin &gt;&gt; nul &gt;&gt; x;</span><br><span class="line">    <span class="keyword">while</span> (top &amp;&amp; x &lt;= st[top]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x != st[top]) ++ans;</span><br><span class="line">      --top;</span><br><span class="line">    &#125;</span><br><span class="line">    st[++top] = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (top--) ++ans;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本题宽度是没用的，因为海报能无限大。</p>
<img src="/2024/01/11/P3467-PLA-Postering/1.png" class="" title="image-20240111032232256">
<p>作图发现，用单调栈维护一个高度单调递增序列；</p>
<p>当某高度<code>h</code>破坏单调性时，单调栈内大于等于<code>h</code>都要弹出，但只需计数大于<code>h</code>的高度；</p>
<p>不统计等于<code>h</code>的高度，是因为<code>h</code>原本就需要入栈，入栈后肯定会被某一次操作再次计数的。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>P4147. 玉蟾宫</title>
    <url>/2024/01/01/P4147-%E7%8E%89%E8%9F%BE%E5%AE%AB/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>单调栈</li>
<li>最大子矩形</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<p>以下图为例：</p>
<img src="/2024/01/01/P4147-%E7%8E%89%E8%9F%BE%E5%AE%AB/1.png" class="" title="image-20231231223744507">
<h2 id="单调栈">单调栈</h2>
<p>但凡是个矩形，必须有个底、有个高；那么以行为单位处理，统计以第<code>k</code>行为底边的矩形。</p>
<p>假设当前统计以第4行为底的矩形，那么例图可以转换如下所示。</p>
<p>实际上就是在这个”山“形状中寻找一个极大的矩形。</p>
<img src="/2024/01/01/P4147-%E7%8E%89%E8%9F%BE%E5%AE%AB/2.png" class="" title="image-20231231225642959">
<p>考虑当高度单调递增时，每一列都能向右延伸至边界：</p>
<img src="/2024/01/01/P4147-%E7%8E%89%E8%9F%BE%E5%AE%AB/3.png" class="" title="image-20231231234409186">
<p>一旦破坏了单调性，每列向右扩展得到的最大矩形如下：</p>
<img src="/2024/01/01/P4147-%E7%8E%89%E8%9F%BE%E5%AE%AB/4.png" class="" title="image-20240101022417846">
<p>设<code>h[i][j]</code>代表以第<code>i</code>行为底，第<code>j</code>列从底往上最大连续空格的数量（就是矩形的高）</p>
<p>故而得到下列处理流程：</p>
<ol type="1">
<li><p>每个第<code>i</code>行都用单调栈维护一个<code>h[i][j]</code>单调递增的序列；</p></li>
<li><p>若<strong>待进栈</strong><code>j</code>的高度小于等于栈顶<code>top</code>的高度，</p>
<p>代表以<code>top</code>的宽度为左边，以<code>top</code>的高度向右扩展的矩阵到头了；</p></li>
<li><p>统计以<code>top</code>的宽度为左边，以<code>top</code>的高度向右扩展的矩阵宽度，</p>
<p>即当前矩阵宽度<code>sum</code> = 上一个矩阵宽度 +
当前<code>top</code>的宽度。</p></li>
<li><p>以<code>top</code>的宽度为左边，以<code>top</code>的高度向右扩展的最大矩阵面积，</p>
<p>显然等于<code>sum * h[i][st[top]]</code></p></li>
</ol>
<hr />
<p>以上述为例，当前<code>top</code>的高度为5，待进栈<code>j</code>的高度为2；</p>
<p>根据<strong>当前矩阵宽度<code>sum</code> = 上一个矩阵宽度 +
当前<code>top</code>的宽度</strong>可知，</p>
<blockquote>
<p>sum = 0（默认值）+ <code>top</code>的宽度（默认为1）= 1</p>
</blockquote>
<p>也就是说，以<code>top</code>的宽度为左边，以<code>top</code>的高度向右最大扩展的矩形的宽度为1。</p>
<p>随后弹出<code>top</code>，此刻<code>top</code>的高度为3，依旧大于等于<code>j</code>的高度2</p>
<blockquote>
<p>sum = 1 + <code>top</code>的宽度 = 2</p>
</blockquote>
<p>再弹出<code>top</code>，此刻<code>top</code>的高度为2，依旧大于等于2</p>
<blockquote>
<p>sum = 2 + <code>top</code>的宽度 = 3</p>
</blockquote>
<p>弹出<code>top</code>后，此时<code>top</code>的高度1和<strong>待进栈</strong><code>j</code>的高度2，都可以扩展sum的宽度</p>
<p>那么令待进栈<code>j</code>的宽度 = sum + <code>j</code>自身宽度 =
4，再入栈即可</p>
<p>原本在栈内的元素不必动它，它们会和某个<code>top</code>一并处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">char</span> ch[maxn][maxn];</span><br><span class="line"><span class="type">int</span> n, m, ans, st[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> h_, w_;</span><br><span class="line">&#125; a[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> row)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>, top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top &amp;&amp; a[row][st[top]].h_ &gt;= a[row][j].h_) &#123;</span><br><span class="line">      sum += a[row][st[top]].w_;</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, sum * a[row][st[top--]].h_);</span><br><span class="line">    &#125;</span><br><span class="line">    st[++top] = j, a[row][j].w_ += sum;</span><br><span class="line">  &#125;</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (top) &#123;</span><br><span class="line">    sum += a[row][st[top]].w_;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, sum * a[row][st[top--]].h_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">      cin &gt;&gt; ch[i][j];</span><br><span class="line">      a[i][j].w_ = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (ch[i][j] == <span class="string">&#x27;F&#x27;</span>) a[i][j].h_ = a[i - <span class="number">1</span>][j].h_ + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">f</span>(i);</span><br><span class="line">  cout &lt;&lt; <span class="number">3</span> * ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="悬线法">悬线法</h2>
<p>直接上《深进》的图</p>
<img src="/2024/01/01/P4147-%E7%8E%89%E8%9F%BE%E5%AE%AB/5.png" class="" title="image-20240101162229047">
<img src="/2024/01/01/P4147-%E7%8E%89%E8%9F%BE%E5%AE%AB/6.png" class="" title="image-20240101162338526">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">char</span> c[maxn][maxn];</span><br><span class="line"><span class="type">int</span> n, m, ans, h[maxn][maxn], l[maxn][maxn], r[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">      cin &gt;&gt; c[i][j];</span><br><span class="line">      h[i][j] = <span class="number">1</span>, l[i][j] = r[i][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c[i][j] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; c[i][j + <span class="number">1</span>] == <span class="string">&#x27;F&#x27;</span>) l[i][j + <span class="number">1</span>] = l[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">2</span>; --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c[i][j] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; c[i][j - <span class="number">1</span>] == <span class="string">&#x27;F&#x27;</span>) r[i][j - <span class="number">1</span>] = r[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c[i][j] == <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c[i - <span class="number">1</span>][j] == <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">          h[i][j] = h[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">          l[i][j] = <span class="built_in">max</span>(l[i][j], l[i - <span class="number">1</span>][j]);</span><br><span class="line">          r[i][j] = <span class="built_in">min</span>(r[i][j], r[i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, (r[i][j] - l[i][j] + <span class="number">1</span>) * h[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans * <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>P4653. Sure Bet</title>
    <url>/2024/01/09/P4653-Sure-Bet/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>双指针</li>
<li>前缀和</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> ans, lsum, rsum, a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">double</span> &amp;x, <span class="type">double</span> &amp;y)</span> </span>&#123; <span class="keyword">return</span> x &gt; y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, cmp), <span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n, cmp);</span><br><span class="line">  <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (l &lt;= n &amp;&amp; r &lt;= n) &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= n &amp;&amp; lsum &lt;= rsum) &#123;</span><br><span class="line">      <span class="comment">//r - 1是因为此刻l可取，但r不可取</span></span><br><span class="line">      lsum += a[l], ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(lsum, rsum) - (l + r - <span class="number">1</span>)), ++l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (r &lt;= n &amp;&amp; rsum &lt; lsum) &#123;</span><br><span class="line">      <span class="comment">//l - 1是因为此刻r可取，但l不可取</span></span><br><span class="line">      rsum += b[r], ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(lsum, rsum) - (l - <span class="number">1</span> + r)), ++r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">4</span>) &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>A与B数组各取任意数量元素（代表顺序无关）；设A数组取<code>l</code>个，其和为<code>lsum</code>；设B数组取<code>r</code>个，其和为<code>rsum</code>；</p>
<p>题目要让<code>min(lsum, rsum) - (l + r)</code>最大。</p>
<p>两数组各自从大到小排序后，可直接套用贪心，因为很显然：</p>
<blockquote>
<p><code>l</code>和<code>r</code>都在增加，必须也要让<code>min(lsum, rsum)</code>尽可能大；</p>
<p>由于是从大到小排序，显然在相同长度的情况下，A或B数组的前缀和是最大的；</p>
<p>所以<code>l</code>可直接等价为A数组游标，<code>r</code>可直接等价为B数组游标；</p>
<p><code>lsum</code>可直接等价为A数组的前缀和，<code>rsum</code>可直接等价为B数组的前缀和；</p>
<p>每次只需要判断<code>lsum</code>和<code>rsum</code>谁更小，谁的游标就新增一个（因为要让最小值最大，维持平衡）</p>
</blockquote>
<img src="/2024/01/09/P4653-Sure-Bet/1.png" class="" title="image-20240108234412135">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>P7072. 直播获奖</title>
    <url>/2023/12/29/P7072-%E7%9B%B4%E6%92%AD%E8%8E%B7%E5%A5%96/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">650</span>;</span><br><span class="line"><span class="type">int</span> n, w, a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x, cnt;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; w;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x, ++a[x];</span><br><span class="line">    cnt = <span class="built_in">max</span>(<span class="number">1</span>, i * w / <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">600</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cnt &lt;= a[j]) &#123;</span><br><span class="line">        cout &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      cnt -= a[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>每次插入都要求有序，如果数字过大必须考虑平衡树！</p>
<p>很可惜这里数字最大只有600，采用计数排序；</p>
<p>每次计算最少的获奖个数<code>cnt</code>，从<code>600</code>开始往下累减人数，直到<code>cnt</code>小于等于某数的个数为止。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P7910. 插入排序</title>
    <url>/2024/01/10/P7910-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="comment">// b数组的键为原下标，值为现下标；便于修改</span></span><br><span class="line"><span class="type">int</span> n, b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> v_, idx_;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node &amp;x, node &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x.v_ != y.v_) <span class="keyword">return</span> x.v_ &lt; y.v_;</span><br><span class="line">  <span class="keyword">return</span> x.idx_ &lt; y.idx_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  x = b[x], a[x].v_ = v;</span><br><span class="line">  <span class="keyword">while</span> (x + <span class="number">1</span> &lt;= n &amp;&amp; !<span class="built_in">cmp</span>(a[x], a[x + <span class="number">1</span>])) <span class="built_in">swap</span>(a[x], a[x + <span class="number">1</span>]), ++x;</span><br><span class="line">  <span class="keyword">while</span> (x - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; !<span class="built_in">cmp</span>(a[x - <span class="number">1</span>], a[x])) <span class="built_in">swap</span>(a[x], a[x - <span class="number">1</span>]), --x;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) b[a[i].idx_] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; cout &lt;&lt; b[x] &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> opt, x, v, q;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i].idx_ = i, cin &gt;&gt; a[i].v_;</span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, cmp);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) b[a[i].idx_] = i;</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    cin &gt;&gt; opt;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">      cin &gt;&gt; x &gt;&gt; v;</span><br><span class="line">      <span class="built_in">update</span>(x, v);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cin &gt;&gt; x;</span><br><span class="line">      <span class="built_in">query</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本题主要难点在于两个：</p>
<ul>
<li><p>排序的优化</p>
<p>如果每次都以<span class="math inline">\(O\left( n\log n
\right)\)</span>的时间复杂度去重新打乱排序，肯定炸了；</p>
<p>但是如果是在有序数组内修改一个数，只需要用<span
class="math inline">\(O\left( n
\right)\)</span>的打擂台方式就能将其换到合适的位置。</p>
<p>（也就是题目说的插入排序....？这其实是冒泡不是吗....）</p></li>
<li><p>样例的解读</p>
<p>如果值不同，根据值从小到大排序；如果值相同，根据原本的下标序号从小到大排序。</p></li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>分治_解题技巧</title>
    <url>/2023/12/29/%E5%88%86%E6%B2%BB-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="练习题">练习题</h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1115">P1115</a>
分治的精髓题！也是学习线段树前的必刷题！</li>
<li><a href="https://www.luogu.com.cn/problem/P7883">P7883</a>、<a
href="https://www.luogu.com.cn/problem/P1429">P1429</a>、<a
href="https://www.luogu.com.cn/problem/P1257">P1257</a>，平面最近点对，经典的分治教学题</li>
</ul>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>唯一的雪花</title>
    <url>/2024/01/04/%E5%94%AF%E4%B8%80%E7%9A%84%E9%9B%AA%E8%8A%B1/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>双指针</li>
<li>滑动窗口</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; vis;</span><br><span class="line"><span class="type">int</span> t, n, a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vis.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">while</span> (l &lt;= r &amp;&amp; r &lt;= n) &#123;</span><br><span class="line">    <span class="keyword">while</span> (r &lt;= n &amp;&amp; !vis[a[r]]) ++vis[a[r++]];</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, r - l);</span><br><span class="line">    <span class="keyword">while</span> (a[l] != a[r]) --vis[a[l++]];</span><br><span class="line">    --vis[a[l++]];</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) <span class="built_in">f</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>用双指针维护一个滑动窗口：</p>
<ul>
<li><p>右指针所指的数字不重复，则向右扩展扩大窗口，同时用窗口大小更新答案；</p></li>
<li><p>右指针所指的数字重复时，设该数为<code>A</code>，</p>
<p>此刻窗口内有且只有一个<code>A</code>，那么将左指针向右扩展收缩窗口，直到窗口内无<code>A</code>停止收缩。</p></li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>P1030. 求先序排列</title>
    <url>/2023/10/27/P1030-%E6%B1%82%E5%85%88%E5%BA%8F%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>二叉树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//后序排列与中序排列</span></span><br><span class="line">string post, in;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pl: 后序排列左端点</span></span><br><span class="line"><span class="comment">//pr: 后序排列右端点</span></span><br><span class="line"><span class="comment">//il: 中序排列左端点</span></span><br><span class="line"><span class="comment">//ir: 中序排列右端点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pl, <span class="type">int</span> pr, <span class="type">int</span> il, <span class="type">int</span> ir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pr &lt; pl || ir &lt; il)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> idx = il; idx &lt;= ir; ++idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (post[pr] == in[idx])</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; in[idx];<span class="comment">//输出当前根结点</span></span><br><span class="line">            <span class="built_in">dfs</span>(pl, pl + idx - il - <span class="number">1</span>, il, il + idx - <span class="number">1</span>);<span class="comment">//递归左子树</span></span><br><span class="line">            <span class="built_in">dfs</span>(pl + idx - il, pr - <span class="number">1</span>, idx + <span class="number">1</span>, ir);<span class="comment">//递归右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; in &gt;&gt; post;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, post.<span class="built_in">length</span>() - <span class="number">1</span>, <span class="number">0</span>, in.<span class="built_in">length</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>通过后序遍历可以找出当前二叉树的根（即后序遍历中最后一个位置的值）</p>
<p>中序遍历可以找出当前二叉树的根所在的位置，即可以找到左子树与右子树的大小；即可递归找左右子树的根结点</p>
<p>假设有：</p>
<ul>
<li>后序遍历 <code>&#123;D E B C A&#125;</code></li>
<li>中序遍历 <code>&#123;D B E A C&#125;</code></li>
</ul>
<p>先找出后序遍历的根A，然后在中序遍历中找到A的位置</p>
<ul>
<li>后序遍历 <code>&#123;D E B C [A]&#125;</code></li>
<li>中序遍历 <code>&#123;D B E [A] C&#125;</code></li>
</ul>
<p>所以“D B
E”这些数都是在以A为根的左子树里面，“C”是在以A为根的右子树里面</p>
<p>因此，可以在后序遍历中提取出“D E
B”这个区间作为左子树的后序遍历，“C”这个区间作为右子树的后序遍历</p>
<p>最终递归的时候按照前序遍历的顺序输出根结点的值即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>P1083. 借教室</title>
    <url>/2024/01/18/P1083-%E5%80%9F%E6%95%99%E5%AE%A4/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>差分</li>
<li>线段树</li>
<li>二分</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<p>本题的最优解实际上是线段树，但是也有巧妙的解法。</p>
<h2 id="差分二分">差分+二分</h2>
<p>设需要修改订单的申请人编号为<code>idx</code>，能发现答案二分的单调性：</p>
<ul>
<li>如果<code>idx</code>大于真实答案，订单无法满足</li>
<li>如果<code>idx</code>小于真实答案，订单可以满足</li>
</ul>
<p>所以直接二分答案，每次用差分批量修改区间，并求差分数组的前缀和来验证答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, b[maxn];</span><br><span class="line">ll diff[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> d_, s_, t_;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(diff, <span class="number">0</span>, <span class="built_in">sizeof</span>(diff));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= idx; ++i) &#123;</span><br><span class="line">    diff[a[i].s_] += a[i].d_;</span><br><span class="line">    diff[a[i].t_ + <span class="number">1</span>] -= a[i].d_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    diff[i] += diff[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (diff[i] &gt; b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; b[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) cin &gt;&gt; a[i].d_ &gt;&gt; a[i].s_ &gt;&gt; a[i].t_;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">check</span>(m + <span class="number">1</span>)) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> l = <span class="number">1</span>, r = m;</span><br><span class="line">  <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl &lt;&lt; l;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线段树">线段树</h2>
<p>维护区间最小值即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> l_, r_;</span><br><span class="line">  ll mi_, lz_;</span><br><span class="line">&#125; seg[<span class="number">4</span> * maxn];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l(x) seg[x].l_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(x) seg[x].r_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mi(x) seg[x].mi_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lz(x) seg[x].lz_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123; <span class="built_in">mi</span>(rt) = <span class="built_in">min</span>(<span class="built_in">mi</span>(lson), <span class="built_in">mi</span>(rson)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">lz</span>(rt)) &#123;</span><br><span class="line">    <span class="built_in">mi</span>(lson) += <span class="built_in">lz</span>(rt), <span class="built_in">mi</span>(rson) += <span class="built_in">lz</span>(rt);</span><br><span class="line">    <span class="built_in">lz</span>(lson) += <span class="built_in">lz</span>(rt), <span class="built_in">lz</span>(rson) += <span class="built_in">lz</span>(rt);</span><br><span class="line">    <span class="built_in">lz</span>(rt) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">l</span>(rt) = l, <span class="built_in">r</span>(rt) = r;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    <span class="built_in">mi</span>(rt) = arr[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">build</span>(lson, l, mid), <span class="built_in">build</span>(rson, mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">up</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> L, <span class="type">int</span> R, ll v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= <span class="built_in">l</span>(rt) &amp;&amp; <span class="built_in">r</span>(rt) &lt;= R) &#123;</span><br><span class="line">    <span class="built_in">mi</span>(rt) += v, <span class="built_in">lz</span>(rt) += v;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">down</span>(rt);</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(rt) + <span class="built_in">r</span>(rt)) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= mid) <span class="built_in">update</span>(lson, L, R, v);</span><br><span class="line">  <span class="keyword">if</span> (R &gt; mid) <span class="built_in">update</span>(rson, L, R, v);</span><br><span class="line">  <span class="built_in">up</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= <span class="built_in">l</span>(rt) &amp;&amp; <span class="built_in">r</span>(rt) &lt;= R) <span class="keyword">return</span> <span class="built_in">mi</span>(rt);</span><br><span class="line">  <span class="built_in">down</span>(rt);</span><br><span class="line">  ll res = INT_MAX;</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(rt) + <span class="built_in">r</span>(rt)) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= mid) res = <span class="built_in">min</span>(res, <span class="built_in">query</span>(lson, L, R));</span><br><span class="line">  <span class="keyword">if</span> (R &gt; mid) res = <span class="built_in">min</span>(res, <span class="built_in">query</span>(rson, L, R));</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; arr[i];</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  ll d, s, t, res;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; d &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="keyword">if</span> (d &lt;= <span class="built_in">query</span>(<span class="number">1</span>, s, t)) &#123;</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, s, t, -d);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl &lt;&lt; i;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>线段树</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>P1719. 最大加权矩形</title>
    <url>/2024/01/13/P1719-%E6%9C%80%E5%A4%A7%E5%8A%A0%E6%9D%83%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>前缀和</li>
<li>最大子段和</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e2</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, pre[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化二维前缀和数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">      cin &gt;&gt; pre[i][j];</span><br><span class="line">      pre[i][j] += pre[i - <span class="number">1</span>][j] + pre[i][j - <span class="number">1</span>] - pre[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pre[x2][y2] - pre[x1 - <span class="number">1</span>][y2] - pre[x2][y1 - <span class="number">1</span>] + pre[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line">  <span class="comment">// 枚举矩形的上下边界</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; ++j) &#123;</span><br><span class="line">      <span class="type">int</span> dp = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line">      <span class="comment">// 控制上下边界后，按“最大子段和”的思路求子矩阵和</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">        <span class="type">int</span> cur = <span class="built_in">query</span>(i, k, j, k);</span><br><span class="line">        dp = <span class="built_in">max</span>(dp + cur, cur);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>二维前缀和的模板题+<a
href="https://www.luogu.com.cn/problem/P1115">最大子段和</a></p>
<img src="/2024/01/13/P1719-%E6%9C%80%E5%A4%A7%E5%8A%A0%E6%9D%83%E7%9F%A9%E5%BD%A2/1.png" class="" title="image-20240113213153651">
<img src="/2024/01/13/P1719-%E6%9C%80%E5%A4%A7%E5%8A%A0%E6%9D%83%E7%9F%A9%E5%BD%A2/2.png" class="" title="image-20240113213430499">
<img src="/2024/01/13/P1719-%E6%9C%80%E5%A4%A7%E5%8A%A0%E6%9D%83%E7%9F%A9%E5%BD%A2/3.png" class="" title="image-20240113213513344">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P1314. 聪明的质监员</title>
    <url>/2024/01/15/P1314-%E8%81%AA%E6%98%8E%E7%9A%84%E8%B4%A8%E7%9B%91%E5%91%98/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>二分</li>
<li>前缀和</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="comment">// wv前缀和 有效重量的个数和</span></span><br><span class="line"><span class="comment">// vv前缀和 有效重量的价值和</span></span><br><span class="line">ll s, wv[maxn], vv[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储矿石信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> w_, v_;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储区间信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">range</span> &#123;</span><br><span class="line">  <span class="type">int</span> l_, r_;</span><br><span class="line">&#125; b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(wv, <span class="number">0</span>, <span class="built_in">sizeof</span>(wv)), <span class="built_in">memset</span>(vv, <span class="number">0</span>, <span class="built_in">sizeof</span>(vv));</span><br><span class="line">  ll sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i].w_ &gt;= mid) &#123;</span><br><span class="line">      wv[i] += <span class="number">1</span>, vv[i] += a[i].v_;</span><br><span class="line">    &#125;</span><br><span class="line">    wv[i] += wv[i - <span class="number">1</span>], vv[i] += vv[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    sum += (wv[b[i].r_] - wv[b[i].l_ - <span class="number">1</span>]) * (vv[b[i].r_] - vv[b[i].l_ - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">  <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i].w_ &gt;&gt; a[i].v_, r = <span class="built_in">max</span>(r, a[i].w_);</span><br><span class="line">  ++r;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) cin &gt;&gt; b[i].l_ &gt;&gt; b[i].r_;</span><br><span class="line">  ll ans = LLONG_MAX;</span><br><span class="line">  <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    ll y = <span class="built_in">calc</span>(mid);</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(s - y));</span><br><span class="line">    <span class="keyword">if</span> (y == s) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y &gt; s) &#123;</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题意，每个区间内都有：</p>
<blockquote>
<p>Y = 合法个数乘上合法价值和</p>
</blockquote>
<p>而要我们求的<code>y</code>就等于每个区间的<code>Y</code>之和。</p>
<p>显然<code>区间合法个数</code>与<code>区间合法价值和</code>是满足容斥原理的，可以使用前缀和进行优化。</p>
<hr />
<p>由于要让<code>y</code>尽可能地接近<code>s</code>，发现结果具有单调性，可以进行答案二分：</p>
<ul>
<li>标准值<code>W</code>越大，那么合法的矿石就少，<code>y</code>就小；</li>
<li>标准值<code>W</code>越小，那么合法的矿石就多，<code>y</code>就大；</li>
<li><code>y</code>小于<code>s</code>时，说明<code>y</code>应该变大，这样才能接近<code>s</code>，也就是让<code>W</code>变小；</li>
<li><code>y</code>大于<code>s</code>时，说明<code>y</code>应该变小，这样才能接近<code>s</code>，也就是让<code>W</code>变大。</li>
</ul>
<p>而<code>W</code>的二分范围等于<code>[0, 最大矿石重量 + 1]</code>，</p>
<p>左边界是所有矿石都满足条件时，右边界是所有矿石都不满足条件时；这样就不会遗漏情况。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>P2004. 领地选择</title>
    <url>/2024/01/17/P2004-%E9%A2%86%E5%9C%B0%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>前缀和</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, c, ans_x, ans_y, pre[maxn][maxn];</span><br><span class="line">ll ans = LLONG_MIN;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pre[x2][y2] - pre[x1 - <span class="number">1</span>][y2] - pre[x2][y1 - <span class="number">1</span>] + pre[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">      cin &gt;&gt; pre[i][j];</span><br><span class="line">      pre[i][j] += pre[i - <span class="number">1</span>][j] + pre[i][j - <span class="number">1</span>] - pre[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - c + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r &amp;&amp; r &lt;= n) &#123;</span><br><span class="line">      <span class="keyword">if</span> (r - l + <span class="number">1</span> &gt; c) sum -= <span class="built_in">query</span>(i, l, i + c - <span class="number">1</span>, l), ++l;</span><br><span class="line">      sum += <span class="built_in">query</span>(i, r, i + c - <span class="number">1</span>, r);</span><br><span class="line">      <span class="keyword">if</span> (r &gt;= c &amp;&amp; sum &gt; ans) ans = sum, ans_x = i, ans_y = l;</span><br><span class="line">      ++r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans_x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans_y;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>枚举每个<code>c * c</code>的正方形和即可，这里的枚举方式选择对每行执行一次滑动窗口；</p>
<p>正方形和选择用二维前缀和进行优化。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>P1496. 火烧赤壁</title>
    <url>/2024/01/16/P1496-%E7%81%AB%E7%83%A7%E8%B5%A4%E5%A3%81/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>离散化</li>
<li>差分</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, btop, b[<span class="number">2</span> * maxn], ctop, c[<span class="number">2</span> * maxn], vis[<span class="number">2</span> * maxn];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> l_, r_;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 离散化处理</span></span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; a[i].l_ &gt;&gt; a[i].r_;</span><br><span class="line">    b[++btop] = a[i].l_, b[++btop] = a[i].r_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + btop);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= btop; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span> || b[i] != b[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      c[++ctop] = b[i];</span><br><span class="line">      mp[b[i]] = ctop;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 差分修改区间</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> l = mp[a[i].l_], r = mp[a[i].r_];</span><br><span class="line">    ++vis[l], --vis[r];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= btop; ++i) &#123;</span><br><span class="line">    vis[i] += vis[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (vis[i]) ans += c[i + <span class="number">1</span>] - c[i];</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>离散化的模板题，上《深进》截图。</p>
<img src="/2024/01/16/P1496-%E7%81%AB%E7%83%A7%E8%B5%A4%E5%A3%81/1.png" class="" title="image-20240116125720082">
<img src="/2024/01/16/P1496-%E7%81%AB%E7%83%A7%E8%B5%A4%E5%A3%81/2.png" class="" title="image-20240116125832942">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>离散化</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>P2367. 语文成绩</title>
    <url>/2024/01/15/P2367-%E8%AF%AD%E6%96%87%E6%88%90%E7%BB%A9/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>差分</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, p, a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x, y, z, cur = <span class="number">0</span>, ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">    b[i] = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (p--) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    b[x] += z, b[y + <span class="number">1</span>] -= z;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cur += b[i];</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, cur);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>一维差分的模板题，直接上《深进》截图。</p>
<img src="/2024/01/15/P2367-%E8%AF%AD%E6%96%87%E6%88%90%E7%BB%A9/1.png" class="" title="image-20240115204743228">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>P1884. Overplanting S</title>
    <url>/2024/01/16/P1884-Overplanting-S/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>离散化</li>
<li>差分</li>
<li>扫描线</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<h2 id="差分">差分</h2>
<p>以样例<code>0 5 4 1</code>为例，先要把它们转换成常规数组下的坐标（这里都是点啊！不是格子！）</p>
<img src="/2024/01/16/P1884-Overplanting-S/1.png" class="" title="image-20240116225333458">
<p>由于<code>1e8</code>远超数组下标能表达的范围，显然需要先离散化处理，然后根据样例作图：</p>
<img src="/2024/01/16/P1884-Overplanting-S/2.png" class="" title="image-20240116231220438">
<p>由于是不规则的矩形，考虑<a
href="https://www.luogu.com.cn/problem/P1496">P1496</a>的做法：</p>
<p>令<code>diff[i][j]</code>表示<code>i行j列</code>为左上角，<code>i + 1行j + 1列</code>为右下角的单位矩形，即下图的绿色单位矩形；</p>
<p>不管重复染色多少次，只要染色的单位矩形就只统计一次；</p>
<p>这样统计全图的绿色单位矩形就能得到不规则矩形面积。</p>
<img src="/2024/01/16/P1884-Overplanting-S/3.png" class="" title="image-20240116231625366">
<p>但显然，每个大矩形最多有接近<code>4000 * 4000</code>个单位矩形，最多<code>1000</code>个大矩形，是绝对会TLE的。</p>
<p>所以采用差分，每行进行批量修改即可，如图操作即可修改绿色一行：</p>
<img src="/2024/01/16/P1884-Overplanting-S/4.png" class="" title="image-20240116233935726">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, btop, b[<span class="number">4</span> * maxn], ctop, c[<span class="number">4</span> * maxn];</span><br><span class="line"><span class="type">int</span> diff[<span class="number">4</span> * maxn][<span class="number">4</span> * maxn];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x1_, y2_, x2_, y1_;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 注意换了位置</span></span><br><span class="line">    cin &gt;&gt; a[i].x1_ &gt;&gt; a[i].y2_ &gt;&gt; a[i].x2_ &gt;&gt; a[i].y1_;</span><br><span class="line">    b[++btop] = a[i].x1_, b[++btop] = a[i].y2_;</span><br><span class="line">    b[++btop] = a[i].x2_, b[++btop] = a[i].y1_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 离散化</span></span><br><span class="line">  <span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + btop);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= btop; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span> || b[i] != b[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      c[++ctop] = b[i];</span><br><span class="line">      mp[b[i]] = ctop;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 按行差分</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> x1 = mp[a[i].x1_], x2 = mp[a[i].x2_], y1 = mp[a[i].y1_],</span><br><span class="line">        y2 = mp[a[i].y2_];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> row = x1; row &lt; x2; ++row) &#123;</span><br><span class="line">      ++diff[row][y1], --diff[row][y2];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 按行前缀和</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ctop; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; ctop; ++j) &#123;</span><br><span class="line">      diff[i][j] += diff[i][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ctop; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; ctop; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (diff[i][j]) &#123;</span><br><span class="line">        ans += <span class="number">1ll</span> * (c[i + <span class="number">1</span>] - c[i]) * (c[j + <span class="number">1</span>] - c[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扫描线">扫描线</h2>
<p>本题的正解，直接套扫描线求面积并的板子即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, ytot, ltot, dy[<span class="number">2</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y1_, y2_, flag_;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node1 &amp;x) &#123; <span class="keyword">return</span> x_ &lt; x.x_; &#125;</span><br><span class="line">&#125; line[<span class="number">2</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node2</span> &#123;</span><br><span class="line">  <span class="type">int</span> status_;</span><br><span class="line">  ll sum_;</span><br><span class="line">&#125; seg[<span class="number">4</span> * <span class="number">2</span> * maxn];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> stat(x) seg[x].status_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sum(x) seg[x].sum_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sum</span>(rt) = <span class="built_in">stat</span>(rt) ? dy[r + <span class="number">1</span>] - dy[l] : (l == r ? <span class="number">0</span> : <span class="built_in">sum</span>(lson) + <span class="built_in">sum</span>(rson));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="built_in">stat</span>(rt) += v, <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= mid) <span class="built_in">update</span>(lson, l, mid, L, R, v);</span><br><span class="line">  <span class="keyword">if</span> (R &gt; mid) <span class="built_in">update</span>(rson, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">  <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="comment">// (x1, y2)为矩形左下角，(x2, y1)为矩形右上角</span></span><br><span class="line">    cin &gt;&gt; x1 &gt;&gt; y2 &gt;&gt; x2 &gt;&gt; y1;</span><br><span class="line">    dy[++ytot] = y1, dy[++ytot] = y2;</span><br><span class="line">    line[++ltot] = &#123;x1, y1, y2, <span class="number">1</span>&#125;, line[++ltot] = &#123;x2, y1, y2, <span class="number">-1</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot), <span class="built_in">sort</span>(line + <span class="number">1</span>, line + <span class="number">1</span> + ltot);</span><br><span class="line">  ytot = <span class="built_in">unique</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot) - <span class="number">1</span> - dy;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ltot; ++i) &#123;</span><br><span class="line">    y1 = <span class="built_in">lower_bound</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot, line[i].y1_) - dy;</span><br><span class="line">    y2 = <span class="built_in">lower_bound</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot, line[i].y2_) - dy;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, ytot - <span class="number">1</span>, y1, y2 - <span class="number">1</span>, line[i].flag_);</span><br><span class="line">    ans += <span class="built_in">sum</span>(<span class="number">1</span>) * (line[i + <span class="number">1</span>].x_ - line[i].x_);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>离散化</tag>
        <tag>差分</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>P2882. Face The Right Way G</title>
    <url>/2024/01/18/P2882-Face-The-Right-Way-G/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>贪心</li>
<li>差分</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, K, M, diff[maxn];</span><br><span class="line"><span class="type">char</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  K = M = INT_MAX;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">memset</span>(diff, <span class="number">0</span>, <span class="built_in">sizeof</span>(diff));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      diff[i] ^= diff[i - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (a[i] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; diff[i] || a[i] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; !diff[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + k - <span class="number">1</span> &lt;= n) &#123;</span><br><span class="line">          ++m;</span><br><span class="line">          diff[i + <span class="number">1</span>] ^= <span class="number">1</span>, diff[i + k] ^= <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          flag = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &amp;&amp; m &lt; M) K = k, M = m;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; K &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; M;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>在固定<code>k</code>的情况下，如何让<code>m</code>最小呢？先翻转<code>B</code>个数多的那一段<code>k</code>吗？万一每段<code>k</code>的<code>B</code>个数相同该怎么办？</p>
<p>贪心的侧重点不在增加<code>k</code>中
<code>B</code>的个数，而是尽可能减少修改<code>k</code>中的<code>F</code>；</p>
<p>白话文就是，尽可能减少拆东墙（改变<code>F</code>）补西墙（改变<code>B</code>）的次数。</p>
<p>如下图所示，范围<code>[1, 3]</code>内都是连续的<code>F</code>，图2显然比图1更优：</p>
<ul>
<li>图1拆了<code>[1, 3]</code>内的一个<code>F</code>，且不管后续如何，对于<code>[1, 3]</code>而言这就是劣的</li>
<li>图2没拆<code>[1, 3]</code>，且不管后续如何，对于<code>[1, 3]</code>而言这就是优的</li>
</ul>
<img src="/2024/01/18/P2882-Face-The-Right-Way-G/1.png" class="" title="image-20240118170459295">
<p>制定最终的贪心思路：</p>
<ul>
<li><p>尝试维护一个<code>[1, n]</code>的最长连续<code>F</code>序列，遍历顺序应该是从左到右或从右到左；</p>
<p>这里选择从左到右。</p></li>
<li><p>假设当前下标为<code>x</code>，<code>[1, x - 1]</code>已经是连续的<code>F</code>序列，不能回头动这个区间；</p>
<p>那么只要当前为<code>B</code>，就向右修改<code>[x, x + k - 1]</code>。</p></li>
<li><p>如果最后<code>[n - k + 2, n]</code>区间内还有<code>B</code>，说明贪心失败；反之成功。</p></li>
</ul>
<hr />
<p>修改区间可以用双指针，但是时间复杂度为平方级，用差分进行优化。</p>
<p>最后一个问题，枚举<code>k</code>可以用二分优化吗？</p>
<p>显然不可以，<code>k</code>小难道<code>m</code>就小了吗？<code>k</code>大难道<code>m</code>就大了吗？</p>
<p>只能暴力枚举啦~</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>P3017. Brownie Slicing G</title>
    <url>/2024/01/17/P3017-Brownie-Slicing-G/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>二分</li>
<li>前缀和</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e2</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> R, C, A, B, pre[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pre[x2][y2] - pre[x1 - <span class="number">1</span>][y2] - pre[x2][y1 - <span class="number">1</span>] + pre[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> valid = <span class="number">0</span>, x1 = <span class="number">1</span>, y1 = <span class="number">1</span>, x2 = <span class="number">1</span>, y2 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (x1 &lt;= R &amp;&amp; x2 &lt;= R) &#123;</span><br><span class="line">    <span class="type">int</span> block = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当前行数下，够不够竖切B个和为s的块</span></span><br><span class="line">    <span class="keyword">while</span> (y2 &lt;= C) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">query</span>(x1, y1, x2, y2) &gt;= s) &#123;</span><br><span class="line">        ++block;</span><br><span class="line">        y1 = y2 + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ++y2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (block &gt;= B) &#123;</span><br><span class="line">      <span class="comment">// 够的话，记录答案，并切换到下一横切</span></span><br><span class="line">      ++valid;</span><br><span class="line">      x2 = x1 = x2 + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不够的话，新增行数</span></span><br><span class="line">      ++x2;</span><br><span class="line">    &#125;</span><br><span class="line">    y1 = y2 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> valid &gt;= A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; R &gt;&gt; C &gt;&gt; A &gt;&gt; B;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= R; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= C; ++j) &#123;</span><br><span class="line">      cin &gt;&gt; pre[i][j];</span><br><span class="line">      pre[i][j] += pre[i - <span class="number">1</span>][j] + pre[i][j - <span class="number">1</span>] - pre[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> l = <span class="number">0</span>, r = pre[R][C];</span><br><span class="line">  <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; r;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>由于横切和竖切组合有接近无数种切法，靠暴力枚举找答案是绝对行不通的。</p>
<p>题目要让<strong>最小值最大</strong>，考虑二分答案：</p>
<blockquote>
<p>令<code>s</code>为所有蛋糕块里的最小值，</p>
<p>如果<code>s</code>是合法的，那么所有蛋糕块均为<code>s</code>的情况下，得到的块数一定是大于等于<code>A * B</code>的。</p>
<p>由此可以得到单调性：</p>
<ul>
<li><code>s</code>越大，总块数越小于<code>A * B</code></li>
<li><code>s</code>越小，总块数越大于<code>A * B</code></li>
<li>若总块数大于等于<code>A * B</code>，说明<code>s</code>过小了，应该增大</li>
<li>若总块数小于<code>A * B</code>，说明<code>s</code>过大了，应该减小</li>
</ul>
</blockquote>
<p>由于轮询的都是二维区间和，须用二维前缀和进行优化。</p>
<hr />
<p>设<code>(x1,y1)</code>为矩形左上角，<code>(x2,y2)</code>为矩形右下角</p>
<p>每次移动<code>y2</code>并判定矩形的和是否达到<code>s</code>，若是的话则令<code>y1 = y2 + 1</code>，进入下一次竖切：</p>
<img src="/2024/01/17/P3017-Brownie-Slicing-G/1.png" class="" title="image-20240117184129634">
<p>当<code>y2 == C</code>时，即本轮竖切全部结束后进行判定，随后令<code>y1 = y2 = 1</code>进行复位：</p>
<p>如果块数大于等于<code>B</code>，可进入下一次横切。</p>
<img src="/2024/01/17/P3017-Brownie-Slicing-G/2.png" class="" title="image-20240117184856380">
<p>如果块数小于<code>B</code>，和下一行合并后，再次竖切。</p>
<img src="/2024/01/17/P3017-Brownie-Slicing-G/3.png" class="" title="image-20240117185302092">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>P3029. Cow Lineup S</title>
    <url>/2024/02/24/P3029-Cow-Lineup-S/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>双指针</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, cnt;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, id_;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node &amp;x) &#123; <span class="keyword">return</span> x_ &lt; x.x_; &#125;</span><br><span class="line">&#125; arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; arr[i].x_ &gt;&gt; arr[i].id_;</span><br><span class="line">    ++mp[arr[i].id_];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(arr + <span class="number">1</span>, arr + <span class="number">1</span> + n);</span><br><span class="line">  cnt = mp.<span class="built_in">size</span>(), mp.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="type">int</span> head = <span class="number">1</span>, tail = <span class="number">1</span>, ans = INT_MAX;</span><br><span class="line">  <span class="keyword">while</span> (head &lt;= tail &amp;&amp; tail &lt;= n) &#123;</span><br><span class="line">    ++mp[arr[tail].id_];</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail &amp;&amp; mp.<span class="built_in">size</span>() == cnt) &#123;</span><br><span class="line">      ans = <span class="built_in">min</span>(ans, arr[tail].x_ - arr[head].x_);</span><br><span class="line">      <span class="keyword">if</span> (--mp[arr[head].id_] == <span class="number">0</span>) mp.<span class="built_in">erase</span>(arr[head].id_);</span><br><span class="line">      ++head;</span><br><span class="line">    &#125;</span><br><span class="line">    ++tail;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据<code>x</code>排序后，用双指针+哈希表维护当前区间内的奶牛种类数即可。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>P3397. 地毯</title>
    <url>/2024/01/16/P3397-%E5%9C%B0%E6%AF%AF/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>差分</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[maxn][maxn], b[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">    ++a[x1][y1], --a[x2 + <span class="number">1</span>][y1], --a[x1][y2 + <span class="number">1</span>], ++a[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i, cout &lt;&lt; endl) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">      a[i][j] += a[i - <span class="number">1</span>][j] + a[i][j - <span class="number">1</span>] - a[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">      cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>二维差分的模板题，上《深进》截图。</p>
<img src="/2024/01/16/P3397-%E5%9C%B0%E6%AF%AF/1.png" class="" title="image-20240116000041019">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>P3406. 海底高铁</title>
    <url>/2024/01/17/P3406-%E6%B5%B7%E5%BA%95%E9%AB%98%E9%93%81/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>差分</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n, m, b[maxn], diff[maxn], pre[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> a_, b_, c_;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) cin &gt;&gt; b[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) cin &gt;&gt; a[i].a_ &gt;&gt; a[i].b_ &gt;&gt; a[i].c_;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> mi = <span class="built_in">min</span>(b[i], b[i + <span class="number">1</span>]), mx = <span class="built_in">max</span>(b[i], b[i + <span class="number">1</span>]);</span><br><span class="line">    ++diff[mi], --diff[mx];</span><br><span class="line">  &#125;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    diff[i] += diff[i - <span class="number">1</span>];</span><br><span class="line">    ans += <span class="built_in">min</span>(<span class="number">1ll</span> * a[i].a_ * diff[i], (a[i].c_ + <span class="number">1ll</span> * a[i].b_ * diff[i]));</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>从<code>i</code>到<code>i + 1</code>的最低开销应该等于<span
class="math inline">\(\min \left( cnt_i\times a_i,c_i+cnt_i\times b_i
\right)\)</span>，</p>
<p>其中<span
class="math inline">\(cnt_i\)</span>代表<code>i</code>到<code>i + 1</code>的次数。</p>
<p>直接用差分进行区间修改即可。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>P4375. Out of Sorts G</title>
    <url>/2024/02/24/P4375-Out-of-Sorts-G/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, bit[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> val_, id_;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node &amp;x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val_ != x.val_) <span class="keyword">return</span> val_ &lt; x.val_;</span><br><span class="line">    <span class="keyword">return</span> id_ &lt; x.id_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">    bit[x] += v;</span><br><span class="line">    x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    res += bit[x];</span><br><span class="line">    x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; arr[i].val_, arr[i].id_ = i;</span><br><span class="line">  <span class="built_in">sort</span>(arr + <span class="number">1</span>, arr + <span class="number">1</span> + n);</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">add</span>(arr[i].id_, <span class="number">1</span>);</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(n) - <span class="built_in">query</span>(i));</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p><a
href="https://www.luogu.com.cn/problem/P4378">P4378</a>的加强版，假设有下列数组。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">值</th>
<th style="text-align: center;">65</th>
<th style="text-align: center;">64</th>
<th style="text-align: center;">63</th>
<th style="text-align: center;">62</th>
<th style="text-align: center;">61</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">下标</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
</tr>
</tbody>
</table>
<p>第一次冒泡排序（正常的冒泡排序）后，成功将元素<code>65</code>送到了它应去的地方，下标5的位置。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">值</th>
<th style="text-align: center;">64</th>
<th style="text-align: center;">63</th>
<th style="text-align: center;">62</th>
<th style="text-align: center;">61</th>
<th style="text-align: center;">65</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">下标</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
</tr>
</tbody>
</table>
<p>第二次排序后，将元素<code>61</code>送到了下标1的位置</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">值</th>
<th style="text-align: center;">61</th>
<th style="text-align: center;">64</th>
<th style="text-align: center;">63</th>
<th style="text-align: center;">62</th>
<th style="text-align: center;">65</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">下标</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
</tr>
</tbody>
</table>
<p>可以发现规律，设当前下标为<code>x</code>，值为<code>arr[x]</code>：</p>
<p>第一次操作会将<code>x</code>的左侧，某个大于<code>arr[x]</code>的元素<code>A</code>换到<code>x</code>的右侧，且<code>A</code>到达正确下标位置；</p>
<p>第二次操作会将<code>x</code>的右侧，某个小于等于<code>arr[x]</code>的元素<code>B</code>换到<code>x</code>的左侧，且<code>B</code>到达正确下标位置。</p>
<p>每一轮的双向排序，对于<code>x</code>而言，就是维护了一次两边的平衡。</p>
<p>那么统计每个<code>x</code>左边（含自己）有多少个不平衡的下标即可，随后遍历<code>x</code>打擂台取最大值即为最终轮数。</p>
<p>当然，平衡是对称的，你也可以统计每个<code>x</code>右边（含自己）有多少个不平衡的下标。</p>
<hr />
<p>举上面那个例子</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">值</th>
<th style="text-align: center;">65</th>
<th style="text-align: center;">64</th>
<th style="text-align: center;">63</th>
<th style="text-align: center;">62</th>
<th style="text-align: center;">61</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">当前下标</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
</tr>
<tr class="even">
<td style="text-align: center;">应处下标</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>由于平衡是对称的，这里设“不平衡”代表<strong>应处下标大于当前下标</strong></p>
<p>（你也可以反过来，结果一样的）</p>
<p><code>65</code>的左边不平衡数有<code>&#123;65&#125;</code>，数量为1</p>
<p><code>64</code>的左边不平衡数有<code>&#123;65、64&#125;</code>，数量为2</p>
<p><code>63</code>的左边不平衡数有<code>&#123;65、64&#125;</code>，数量为2</p>
<p><code>62</code>和<code>61</code>没有左边不平衡数</p>
<p>那么最终结果就是取最大值，2轮</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>P4552. IncDec Sequence</title>
    <url>/2024/02/24/P4552-IncDec-Sequence/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>差分</li>
<li>贪心</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll arr[maxn], diff[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  ll neg = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; arr[i];</span><br><span class="line">    diff[i] = arr[i] - arr[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">1</span>) diff[i] &lt; <span class="number">0</span> ? neg += -diff[i] : pos += diff[i];</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">max</span>(neg, pos) &lt;&lt; endl &lt;&lt; <span class="built_in">abs</span>(neg - pos) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据原数组建立差分数组<code>diff</code>后，题目的要求就变成了：</p>
<blockquote>
<p>在差分数组<code>diff</code>中，</p>
<p>除下标1以外，每次在2~n中选两个下标，一个值+1，一个值-1，</p>
<p>求能把除下标1以外的其他位置的值都归0的最小次数。</p>
</blockquote>
<p>举个例子，有如下数组：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>求出差分数组<code>diff</code>:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">1</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">-3</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">1</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>为了让归0的次数最少，显然希望每次都是负数+1，正数-1</p>
<p>两轮后变成了：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">1</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">0</th>
<th style="text-align: center;">-1</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">1</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>再一轮：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">1</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">0</th>
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">0</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>现在场上只剩正数了，继续：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">1</th>
<th style="text-align: center;">0</th>
<th style="text-align: center;">0</th>
<th style="text-align: center;">0</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">0</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>此时如果将<code>diff</code>转回正常数组，得到如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">1</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">3</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>在保证最小次数的情况下，也就是只剩2次操作机会，整个序列可以取1或2或3。</p>
<hr />
<p>综上，设差分数组<code>diff</code>中，
除下标1外的负数绝对值和为<code>neg</code>，除下标1外的正数绝对值和为<code>pos</code>；</p>
<p>最大操作次数等于<code>max(neg, pos)</code>；</p>
<p>序列的可能数等于<code>abs(neg - pos) + 1</code>。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>P8218. 求区间和</title>
    <url>/2024/01/13/P8218-%E6%B1%82%E5%8C%BA%E9%97%B4%E5%92%8C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>前缀和</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, l, r, pre[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; pre[i], pre[i] += pre[i - <span class="number">1</span>];</span><br><span class="line">  cin &gt;&gt; m;</span><br><span class="line">  <span class="keyword">while</span> (m--) cin &gt;&gt; l &gt;&gt; r, cout &lt;&lt; pre[r] - pre[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>一维前缀和的模板题，直接上《深进》截图。</p>
<img src="/2024/01/13/P8218-%E6%B1%82%E5%8C%BA%E9%97%B4%E5%92%8C/1.png" class="" title="image-20240113201644608">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>P4378. Out of Sorts S</title>
    <url>/2024/02/23/P4378-Out-of-Sorts-S/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
<li>离散化</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, tot, arr[maxn], dis[maxn], bit[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">    bit[x] += v;</span><br><span class="line">    x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    res += bit[x];</span><br><span class="line">    x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; arr[i], dis[i] = arr[i];</span><br><span class="line">  <span class="built_in">sort</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + n);</span><br><span class="line">  tot = <span class="built_in">unique</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + n) - <span class="number">1</span> - dis;</span><br><span class="line">  <span class="type">int</span> x, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    x = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + tot, arr[i]) - dis;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(n) - <span class="built_in">query</span>(x));</span><br><span class="line">    <span class="built_in">add</span>(x, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>对排序精髓的考验，很好的结论题；以序列<code>5 4 3 2 1</code>为例</p>
<p>逆序对的定义为<span
class="math inline">\(i&lt;j,a_i&gt;a_j\)</span></p>
<p>初始时，元素<code>4</code>有1个，<code>3</code>有2个，<code>2</code>有3个，<code>1</code>有4个</p>
<p>冒泡排序一次后，序列变成了<code>4 3 2 1 5</code></p>
<p>此时，元素<code>4</code>有0个，<code>3</code>有1个，<code>2</code>有2个，<code>1</code>有3个</p>
<p>这意味着，每一次冒泡排序实际上就是减少每个元素的逆序对，冒泡排序的执行次数就等于最大逆序对个数！</p>
<p>套用离散化+树状数组依次求每个元素的逆序对个数，挨个打擂台保存最大逆序对个数即可。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>常见优化技巧_解题技巧</title>
    <url>/2024/01/12/%E5%B8%B8%E8%A7%81%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="双指针">双指针</h1>
<h2 id="技巧">技巧</h2>
<p>使用前提是，该区间<strong>已具有单调性</strong>，一般来说是贪心策略</p>
<p>有两种写法：</p>
<ul>
<li><p>左闭右闭：两边界情况必须可取，当前条件的处理与可行性判定在本次完成</p></li>
<li><p>左闭右开：左边界情况可取，右边界情况不可取；</p>
<p>参考DFS的构造，每次处理当前条件，但可行性判定可留到下一次，精简代码逻辑；</p>
<p>求区间长度方便，<code>r - l</code>即可</p></li>
</ul>
<h2 id="练习题">练习题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1102">P1102</a>
双指针的科普题</li>
<li><a href="https://www.luogu.com.cn/problem/P1638">P1638</a>
滑动窗口模板题</li>
<li><a href="https://www.luogu.com.cn/problem/UVA11572">唯一的雪花</a>
滑动窗口</li>
<li><a href="https://www.luogu.com.cn/problem/P4653">P4653</a>
贪心+前缀和，双指针提高题</li>
<li><a href="https://www.luogu.com.cn/problem/P3143">P3143</a>
双指针提高题</li>
<li><a href="https://www.luogu.com.cn/problem/P3029">P3029</a></li>
</ul>
<h1 id="空间换时间">空间换时间</h1>
<h2 id="练习题-1">练习题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P7072">P7072</a>
计数排序/桶排序，典型的空间换时间</li>
<li><a href="https://www.luogu.com.cn/problem/P2671">P2671</a>
复杂的数学公式展开后，再合并同类项找规律，也很经典</li>
</ul>
<h1 id="排序的优化">排序的优化</h1>
<h2 id="练习题-2">练习题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P7910">P7910</a>
在有序数组内修改一个数，可通过<span class="math inline">\(O\left( n
\right)\)</span>的打擂台将其放在合适的位置</li>
</ul>
<h1 id="最大子矩阵">最大子矩阵</h1>
<h2 id="技巧-1">技巧</h2>
<p>共两种方法：</p>
<ul>
<li>悬线法或单调栈法，依赖于长宽的大小；</li>
<li>障碍物法，依赖于障碍物的个数；</li>
</ul>
<p>上述几个方法都是<span class="math inline">\(O\left( n^2
\right)\)</span>的时间复杂度，所以长宽或障碍物哪个小选择哪个方法即可~</p>
<h2 id="练习题-3">练习题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4147">P4147</a>
单调栈的绝世教学题，悬线法的模板题</li>
<li><a href="https://www.luogu.com.cn/problem/P1950">P1950</a>
P4147的加强版，单调栈+悬线法的绝世教学题</li>
<li><a href="https://www.luogu.com.cn/problem/P5943">P5943</a>
悬线法</li>
<li><a href="https://www.luogu.com.cn/problem/P1578">P1578</a>
障碍物法模板题</li>
</ul>
<h1 id="单调栈">单调栈</h1>
<h2 id="技巧-2">技巧</h2>
<p>维护区间单调性，比如”右边的元素都比我大“</p>
<p>和单调队列不同，偏向于<strong>破坏单调性时，反向更新单调区间内的元素</strong></p>
<h2 id="练习题-4">练习题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4147">P4147</a>
单调栈的绝世教学题</li>
<li><a href="https://www.luogu.com.cn/problem/P1950">P1950</a>
P4147的加强版，单调栈+悬线法的绝世教学题</li>
<li><a href="https://www.luogu.com.cn/problem/P2866">P2866</a>
统计元素出栈时，对答案的贡献</li>
<li><a href="https://www.luogu.com.cn/problem/P3467">P3467</a>
P4147的简化版</li>
</ul>
<h1 id="单调队列">单调队列</h1>
<h2 id="技巧-3">技巧</h2>
<p>维护区间单调性，比如”右边的元素都比我大“；常见于滑动窗口</p>
<p>和单调栈不同，偏向于<strong>维护区间极值</strong></p>
<h2 id="练习题-5">练习题</h2>
<ul>
<li><p><a href="https://www.luogu.com.cn/problem/P2216">P2216</a>
维护区间最大经典例题</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P2032">P2032</a>
维护区间最大，模板题</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P1886">P1886</a>
维护区间最大、维护区间最小的模板题</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P1714">P1714</a>
前缀和+区间最大</p></li>
<li><p><a href="https://www.luogu.com.cn/problem/P1725">P1725</a>
DP+区间最大</p></li>
<li><p><a
href="https://www.acwing.com/problem/content/description/137/">acwing-135</a>
前缀和+区间最小</p></li>
</ul>
<h1 id="前缀和">前缀和</h1>
<h2 id="技巧-4">技巧</h2>
<p>多用于频繁询问<strong>满足容斥原理</strong>区间和的优化</p>
<h2 id="练习题-6">练习题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P8218">P8218</a>
一维前缀和模板题</li>
<li><a href="https://www.luogu.com.cn/problem/P1719">P1719</a>
二维前缀和模板题+最大子段和</li>
<li><a href="https://www.luogu.com.cn/problem/P2004">P2004</a>
二维前缀和模板题</li>
<li><a href="https://www.luogu.com.cn/problem/P1314">P1314</a>
答案二分+前缀和优化</li>
<li><a href="https://www.luogu.com.cn/problem/P3017">P3017</a>
答案二分+前缀和优化</li>
</ul>
<h1 id="差分">差分</h1>
<h2 id="技巧-5">技巧</h2>
<p>用于区间修改，<span class="math inline">\(O\left( 1
\right)\)</span>的区间修改时间复杂度，<span
class="math inline">\(O\left( n \right)\)</span>的区间查询时间复杂度</p>
<h2 id="练习题-7">练习题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P2367">P2367</a>
一维差分模板题</li>
<li><a href="https://www.luogu.com.cn/problem/P3397">P3397</a>
二维差分模板题</li>
<li><a href="https://www.luogu.com.cn/problem/P3406">P3406</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1083">P1083</a>
二分+差分</li>
<li><a href="https://www.luogu.com.cn/problem/P2882">P2882</a>
贪心+差分，贪心的好题，最小反转次数问题</li>
<li><a href="https://www.luogu.com.cn/problem/P4552">P4552</a>
贪心+差分</li>
</ul>
<h1 id="离散化">离散化</h1>
<h2 id="技巧-6">技巧</h2>
<p>数据点范围极其庞大，但只需要用到数据点本身，不需要在数组上表达两点之间的具体区间。</p>
<h2 id="练习题-8">练习题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1496">P1496</a>
离散化的模板题+差分</li>
<li><a href="https://www.luogu.com.cn/problem/P1955">P1955</a>
离散化+并查集</li>
<li><a href="https://www.luogu.com.cn/problem/P5937">P5937</a>
离散化+并查集</li>
<li><a href="https://www.luogu.com.cn/problem/P1884">P1884</a>
P1496的二维升级版本</li>
<li><a href="https://www.luogu.com.cn/problem/P1904">P1904</a>
离散化+扫描线</li>
</ul>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>前缀和</tag>
        <tag>离散化</tag>
        <tag>单调栈</tag>
        <tag>单调队列</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>P5490. 扫描线</title>
    <url>/2024/02/25/P5490-%E6%89%AB%E6%8F%8F%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>扫描线</li>
<li>离散化</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, ytot, ltot, dy[<span class="number">2</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描线</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y1_, y2_, flag_;</span><br><span class="line">  <span class="comment">// 按x轴排序</span></span><br><span class="line">  <span class="comment">// 扫描线重合的情况不用理睬，两线重合时面积总为0，不影响结果</span></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node1 &amp;x) &#123; <span class="keyword">return</span> x_ &lt; x.x_; &#125;</span><br><span class="line">&#125; line[<span class="number">2</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node2</span> &#123;</span><br><span class="line">  <span class="comment">// 当前结点的被访问状态</span></span><br><span class="line">  <span class="type">int</span> status_;</span><br><span class="line">  <span class="comment">// 当前结点的长度</span></span><br><span class="line">  ll sum_;</span><br><span class="line">&#125; seg[<span class="number">4</span> * <span class="number">2</span> * maxn];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> stat(x) seg[x].status_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sum(x) seg[x].sum_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 由于每段区间只取最大的覆盖长度，</span></span><br><span class="line">  <span class="comment">// 当前结点被访问过，长度就等于当前结点的区间范围（父结点的区间范围肯定大于子结点）</span></span><br><span class="line">  <span class="comment">// 如果没被访问过，父结点的长度自然等于子结点们的长度和</span></span><br><span class="line">  <span class="built_in">sum</span>(rt) = <span class="built_in">stat</span>(rt) ? dy[r + <span class="number">1</span>] - dy[l] : (l == r ? <span class="number">0</span> : <span class="built_in">sum</span>(lson) + <span class="built_in">sum</span>(rson));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="built_in">stat</span>(rt) += v, <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= mid) <span class="built_in">update</span>(lson, l, mid, L, R, v);</span><br><span class="line">  <span class="keyword">if</span> (R &gt; mid) <span class="built_in">update</span>(rson, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">  <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">  <span class="comment">// 离散化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">    dy[++ytot] = y1, dy[++ytot] = y2;</span><br><span class="line">    line[++ltot] = &#123;x1, y1, y2, <span class="number">1</span>&#125;, line[++ltot] = &#123;x2, y1, y2, <span class="number">-1</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot), <span class="built_in">sort</span>(line + <span class="number">1</span>, line + <span class="number">1</span> + ltot);</span><br><span class="line">  ytot = <span class="built_in">unique</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot) - <span class="number">1</span> - dy;</span><br><span class="line">  <span class="comment">// 遍历扫描线</span></span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ltot; ++i) &#123;</span><br><span class="line">    y1 = <span class="built_in">lower_bound</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot, line[i].y1_) - dy;</span><br><span class="line">    y2 = <span class="built_in">lower_bound</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot, line[i].y2_) - dy;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, ytot - <span class="number">1</span>, y1, y2 - <span class="number">1</span>, line[i].flag_);</span><br><span class="line">    ans += <span class="built_in">sum</span>(<span class="number">1</span>) * (line[i + <span class="number">1</span>].x_ - line[i].x_);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>扫描线的模板题，直接上图。</p>
<img src="/2024/02/25/P5490-%E6%89%AB%E6%8F%8F%E7%BA%BF/1.jpg" class="" width="1">
<img src="/2024/02/25/P5490-%E6%89%AB%E6%8F%8F%E7%BA%BF/2.jpg" class="" width="2">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>离散化</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>hdoj-1542 Atlantis</title>
    <url>/2024/02/25/hdu-1542-Atlantis/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>扫描线</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e2</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, ytot, ltot;</span><br><span class="line"><span class="type">double</span> dy[<span class="number">2</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span> &#123;</span><br><span class="line">  <span class="type">double</span> x_, y1_, y2_;</span><br><span class="line">  <span class="type">int</span> flag_;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node1 &amp;x) &#123; <span class="keyword">return</span> x_ &lt; x.x_; &#125;</span><br><span class="line">&#125; line[<span class="number">2</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node2</span> &#123;</span><br><span class="line">  <span class="type">int</span> status_;</span><br><span class="line">  <span class="type">double</span> sum_;</span><br><span class="line">&#125; seg[<span class="number">4</span> * <span class="number">2</span> * maxn];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> stat(x) seg[x].status_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sum(x) seg[x].sum_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sum</span>(rt) = <span class="built_in">stat</span>(rt) ? dy[r + <span class="number">1</span>] - dy[l] : (l == r ? <span class="number">0</span> : <span class="built_in">sum</span>(lson) + <span class="built_in">sum</span>(rson));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="built_in">stat</span>(rt) += v, <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= mid) <span class="built_in">update</span>(lson, l, mid, L, R, v);</span><br><span class="line">  <span class="keyword">if</span> (R &gt; mid) <span class="built_in">update</span>(rson, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">  <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> x1, y1, x2, y2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">    dy[++ytot] = y1, dy[++ytot] = y2;</span><br><span class="line">    line[++ltot] = &#123;x1, y1, y2, <span class="number">1</span>&#125;, line[++ltot] = &#123;x2, y1, y2, <span class="number">-1</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot), <span class="built_in">sort</span>(line + <span class="number">1</span>, line + <span class="number">1</span> + ltot);</span><br><span class="line">  ytot = <span class="built_in">unique</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot) - <span class="number">1</span> - dy;</span><br><span class="line">  <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ltot; ++i) &#123;</span><br><span class="line">    y1 = <span class="built_in">lower_bound</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot, line[i].y1_) - dy;</span><br><span class="line">    y2 = <span class="built_in">lower_bound</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot, line[i].y2_) - dy;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, ytot - <span class="number">1</span>, y1, y2 - <span class="number">1</span>, line[i].flag_);</span><br><span class="line">    ans += <span class="built_in">sum</span>(<span class="number">1</span>) * (line[i + <span class="number">1</span>].x_ - line[i].x_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Test case #%d\n&quot;</span>, ++cnt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Total explored area: %.2lf\n&quot;</span>, <span class="built_in">work</span>());</span><br><span class="line">    ytot = ltot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(seg, <span class="number">0</span>, <span class="built_in">sizeof</span>(seg));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>矩形面积并的裸题，直接上扫描线板子，不再赘述。</p>
]]></content>
      <categories>
        <category>hdoj</category>
      </categories>
      <tags>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>hdoj-1255 覆盖的面积</title>
    <url>/2024/02/27/hdu-1255-%E8%A6%86%E7%9B%96%E7%9A%84%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>扫描线</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, ytot, ltot;</span><br><span class="line"><span class="type">double</span> dy[<span class="number">4</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span> &#123;</span><br><span class="line">  <span class="type">double</span> x_, y1_, y2_, flag_;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node1 &amp;x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x_ != x.x_) <span class="keyword">return</span> x_ &lt; x.x_;</span><br><span class="line">    <span class="keyword">return</span> flag_ &gt; x.flag_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; line[<span class="number">2</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node2</span> &#123;</span><br><span class="line">  <span class="comment">// cnt_：当前区间被访问次数</span></span><br><span class="line">  <span class="comment">// once_：大于等于1次的长度和</span></span><br><span class="line">  <span class="comment">// twice_：大于等于2次的长度和</span></span><br><span class="line">  <span class="type">double</span> cnt_, once_, twice_;</span><br><span class="line">&#125; seg[<span class="number">4</span> * <span class="number">2</span> * maxn];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cnt(x) seg[x].cnt_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> once(x) seg[x].once_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> twice(x) seg[x].twice_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">once</span>(rt) =</span><br><span class="line">      <span class="built_in">cnt</span>(rt) ? dy[r + <span class="number">1</span>] - dy[l] : (l == r ? <span class="number">0</span> : <span class="built_in">once</span>(lson) + <span class="built_in">once</span>(rson));</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cnt</span>(rt) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">twice</span>(rt) = dy[r + <span class="number">1</span>] - dy[l];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">cnt</span>(rt) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">twice</span>(rt) = l == r ? <span class="number">0</span> : <span class="built_in">once</span>(lson) + <span class="built_in">once</span>(rson);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">twice</span>(rt) = l == r ? <span class="number">0</span> : <span class="built_in">twice</span>(lson) + <span class="built_in">twice</span>(rson);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="built_in">cnt</span>(rt) += v, <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= mid) <span class="built_in">update</span>(lson, l, mid, L, R, v);</span><br><span class="line">  <span class="keyword">if</span> (R &gt; mid) <span class="built_in">update</span>(rson, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">  <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="type">double</span> ans = <span class="number">0</span>, x1, y1, x2, y2;</span><br><span class="line">  ltot = ytot = <span class="number">0</span>, <span class="built_in">memset</span>(seg, <span class="number">0</span>, <span class="built_in">sizeof</span>(seg));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">    dy[++ytot] = y1, dy[++ytot] = y2;</span><br><span class="line">    line[++ltot] = &#123;x1, y1, y2, <span class="number">1</span>&#125;, line[++ltot] = &#123;x2, y1, y2, <span class="number">-1</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot), <span class="built_in">sort</span>(line + <span class="number">1</span>, line + <span class="number">1</span> + ltot);</span><br><span class="line">  ytot = <span class="built_in">unique</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot) - <span class="number">1</span> - dy;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ltot; ++i) &#123;</span><br><span class="line">    y1 = <span class="built_in">lower_bound</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot, line[i].y1_) - dy;</span><br><span class="line">    y2 = <span class="built_in">lower_bound</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot, line[i].y2_) - dy;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, ytot - <span class="number">1</span>, y1, y2 - <span class="number">1</span>, line[i].flag_);</span><br><span class="line">    ans += <span class="built_in">twice</span>(<span class="number">1</span>) * (line[i + <span class="number">1</span>].x_ - line[i].x_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; <span class="built_in">work</span>() + <span class="number">0.001</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>两个坑点：</p>
<ul>
<li>题面描述错误，给的是左下角坐标和右上角坐标</li>
<li>最终结果要加上0.001</li>
</ul>
<p>扫描线部分请参照<strong>矩形面积并</strong>模板，不再赘述。</p>
<p>设<code>覆盖次数大于等于1的长度和</code>为<code>once</code>，<code>覆盖次数大于等于2的长度和</code>为<code>twice</code></p>
<p><code>once</code>的情况分类如下：</p>
<ul>
<li>当前区间被覆盖任意次，<code>once</code>都等于当前区间长度（废话）</li>
<li>当前区间没被覆盖，<code>once = once(左孩子) + once(右孩子)</code></li>
</ul>
<p><code>twice</code>的情况分类如下：</p>
<ul>
<li><p>当前区间被覆盖大于等于2次，<code>twice</code>等于当前区间长度（显然）</p></li>
<li><p>当前区间被覆盖等于1次，<code>twice = once(左孩子) + once(右孩子)</code></p>
<p>当前区间被覆盖1次之后，要想大于等于2次，肯定是再加“大于等于1”的情况。</p>
<p>况且<code>twice</code>是<code>once</code>的子集，上述式子能保证情况不重不漏，</p>
<p>如果改成<code>twice = twice(左孩子) + twice(右孩子)</code>的话，覆盖次数等于2的情况就被你忽略了。</p></li>
<li><p>当前区间没被覆盖，<code>twice = twice(左孩子) + twice(右孩子)</code></p></li>
</ul>
]]></content>
      <categories>
        <category>hdoj</category>
      </categories>
      <tags>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>P1904. 天际线</title>
    <url>/2024/02/25/P1904-%E5%A4%A9%E9%99%85%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>扫描线</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, ltot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y1_, y2_, flag_;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node1 &amp;x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x_ != x.x_) <span class="keyword">return</span> x_ &lt; x.x_;</span><br><span class="line">    <span class="keyword">return</span> flag_ &gt; x.flag_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; line[<span class="number">2</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node2</span> &#123;</span><br><span class="line">  <span class="type">int</span> sum_, status_;</span><br><span class="line">&#125; tree[<span class="number">4</span> * <span class="number">2</span> * maxn];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sum(x) tree[x].sum_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> stat(x) tree[x].status_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sum</span>(rt) = <span class="built_in">stat</span>(rt) ? r + <span class="number">1</span> - l : (l == r ? <span class="number">0</span> : <span class="built_in">sum</span>(lson) + <span class="built_in">sum</span>(rson));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="built_in">stat</span>(rt) += v, <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= mid) <span class="built_in">update</span>(lson, l, mid, L, R, v);</span><br><span class="line">  <span class="keyword">if</span> (R &gt; mid) <span class="built_in">update</span>(rson, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">  <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x1, x2, h;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; x1 &gt;&gt; h &gt;&gt; x2) &#123;</span><br><span class="line">    line[++ltot] = &#123;x1, <span class="number">0</span>, h, <span class="number">1</span>&#125;, line[++ltot] = &#123;x2, <span class="number">0</span>, h, <span class="number">-1</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(line + <span class="number">1</span>, line + <span class="number">1</span> + ltot);</span><br><span class="line">  <span class="type">int</span> pre_sum = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ltot; ++i) &#123;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">0</span>, maxn, line[i].y1_, line[i].y2_ - <span class="number">1</span>, line[i].flag_);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sum</span>(<span class="number">1</span>) == pre_sum) <span class="keyword">continue</span>;</span><br><span class="line">    cout &lt;&lt; line[i].x_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    pre_sum = <span class="built_in">sum</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>矩形相交的问题考虑使用扫描线。</p>
<p>发现规律，若当前扫描线的长度不等于上一次扫描线的长度，输出当前的<code>x</code>坐标和扫描线长度即可。</p>
<img src="/2024/02/25/P1904-%E5%A4%A9%E9%99%85%E7%BA%BF/1.png" class="" title="image-20240225191856277">
<p>注意！若有重合扫描线（即同一x坐标），应先加后减！先减后加会导致不必要的长度波动。</p>
<p>比如当前x坐标上，有<code>&#123;+1, +1, -1&#125;</code>三根扫描线，且长度均相等。</p>
<p>若先增后减，则变化为<code>+1 -&gt; +1 -&gt; +1</code>，是正确的；</p>
<p>若先减后增，则变化为<code>-1 -&gt; 0 -&gt; +1</code>，尽管结果相同，但中途多出了两次变化，是错误的。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>hdoj-3255 Farming</title>
    <url>/2024/02/29/hdu-3255-Farming/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>扫描线</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">3e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, dy[<span class="number">2</span> * maxn], dz[<span class="number">2</span> * maxn], kind[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span> &#123;</span><br><span class="line">  <span class="type">int</span> x1_, y1_, h1_, x2_, y2_, h2_;</span><br><span class="line">&#125; arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node2</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y1_, y2_, flag_;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node2 &amp;x) &#123; <span class="keyword">return</span> x_ &lt; x.x_; &#125;</span><br><span class="line">&#125; line[<span class="number">2</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node3</span> &#123;</span><br><span class="line">  ll cnt_, sum_;</span><br><span class="line">&#125; seg[<span class="number">4</span> * <span class="number">2</span> * maxn];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cnt(x) seg[x].cnt_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sum(x) seg[x].sum_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sum</span>(rt) = <span class="built_in">cnt</span>(rt) ? dy[r + <span class="number">1</span>] - dy[l] : (l == r ? <span class="number">0</span> : <span class="built_in">sum</span>(lson) + <span class="built_in">sum</span>(rson));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="built_in">cnt</span>(rt) += v;</span><br><span class="line">    <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= mid) <span class="built_in">update</span>(lson, l, mid, L, R, v);</span><br><span class="line">  <span class="keyword">if</span> (R &gt; mid) <span class="built_in">update</span>(rson, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">  <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 离散化</span></span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  ll volume = <span class="number">0</span>, ytot = <span class="number">0</span>, ztot = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> x1, y1, x2, y2, c;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) cin &gt;&gt; kind[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">    arr[i] = &#123;x1, y1, <span class="number">0</span>, x2, y2, kind[c]&#125;;</span><br><span class="line">    dy[++ytot] = y1, dy[++ytot] = y2;</span><br><span class="line">    dz[++ztot] = kind[c];</span><br><span class="line">  &#125;</span><br><span class="line">  dz[++ztot] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">sort</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot), <span class="built_in">sort</span>(dz + <span class="number">1</span>, dz + <span class="number">1</span> + ztot);</span><br><span class="line">  ytot = <span class="built_in">unique</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot) - <span class="number">1</span> - dy;</span><br><span class="line">  ztot = <span class="built_in">unique</span>(dz + <span class="number">1</span>, dz + <span class="number">1</span> + ztot) - <span class="number">1</span> - dz;</span><br><span class="line">  <span class="comment">// 遍历z轴上的扫描线</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ztot; ++i) &#123;</span><br><span class="line">    ll area = <span class="number">0</span>, ltot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(seg, <span class="number">0</span>, <span class="number">8</span> * n * <span class="built_in">sizeof</span>(node3));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j].h1_ &lt;= dz[i] &amp;&amp; arr[j].h2_ &gt; dz[i]) &#123;</span><br><span class="line">        y1 = <span class="built_in">lower_bound</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot, arr[j].y1_) - dy;</span><br><span class="line">        y2 = <span class="built_in">lower_bound</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot, arr[j].y2_) - dy;</span><br><span class="line">        line[++ltot] = &#123;arr[j].x1_, y1, y2, <span class="number">1</span>&#125;;</span><br><span class="line">        line[++ltot] = &#123;arr[j].x2_, y1, y2, <span class="number">-1</span>&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(line + <span class="number">1</span>, line + <span class="number">1</span> + ltot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; ltot; ++j) &#123;</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, ytot - <span class="number">1</span>, line[j].y1_, line[j].y2_ - <span class="number">1</span>, line[j].flag_);</span><br><span class="line">      area += (line[j + <span class="number">1</span>].x_ - line[j].x_) * <span class="built_in">sum</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    volume += area * (dz[i + <span class="number">1</span>] - dz[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> volume;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %lld\n&quot;</span>, i, <span class="built_in">work</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题意是说，一共若干个矩形，每个矩形内的单元格都有权值，矩形相交部分的单元格们取权值更大的，求总权值。</p>
<p>乍一眼，以为和传统板子题一样，只维护y轴上的扫描线，然后算面积乘单元格权值即可。</p>
<p>但是使用线段树的前提就是，<strong>变化量是均分到每个结点，且每个结点的操作一致</strong>；</p>
<p>显然这里是不可以用线段树的，单元格取最大值，而除了单元格都是求和....</p>
<p>二维不行就考虑三维，将权值视作为高，问题就转换为了<strong>体积并</strong>。</p>
<p>比如样例中的第二条数据，作图如下：</p>
<img src="/2024/02/29/hdu-3255-Farming/1.png" class="" title="image-20240229005211850">
<p>先对z轴做扫描线，固定z坐标后，平面问题就是扫描线的经典例题面积并，不再赘述了。</p>
]]></content>
      <categories>
        <category>hdoj</category>
      </categories>
      <tags>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>hdoj-4052 Adding New Machine</title>
    <url>/2024/02/29/hdu-4052-Adding-New-Machine/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>扫描线</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> w, h, n, m, ytot, ltot, dy[<span class="number">2</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span> &#123;</span><br><span class="line">  <span class="type">int</span> x1_, y1_, x2_, y2_;</span><br><span class="line">&#125; arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node2</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y1_, y2_, flag_;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node2 &amp;x) &#123; <span class="keyword">return</span> x_ &lt; x.x_; &#125;</span><br><span class="line">&#125; line[<span class="number">2</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node3</span> &#123;</span><br><span class="line">  ll cnt_, sum_;</span><br><span class="line">&#125; seg[<span class="number">4</span> * <span class="number">2</span> * maxn];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cnt(x) seg[x].cnt_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sum(x) seg[x].sum_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sum</span>(rt) = <span class="built_in">cnt</span>(rt) ? dy[r + <span class="number">1</span>] - dy[l] : (l == r ? <span class="number">0</span> : <span class="built_in">sum</span>(lson) + <span class="built_in">sum</span>(rson));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="built_in">cnt</span>(rt) += v, <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= mid) <span class="built_in">update</span>(lson, l, mid, L, R, v);</span><br><span class="line">  <span class="keyword">if</span> (R &gt; mid) <span class="built_in">update</span>(rson, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">  <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x方向</span></span><br><span class="line"><span class="function">ll <span class="title">xwork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll area = <span class="number">0</span>;</span><br><span class="line">  ltot = ytot = <span class="number">0</span>, <span class="built_in">memset</span>(seg, <span class="number">0</span>, <span class="built_in">sizeof</span>(seg));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    line[++ltot] = &#123;<span class="built_in">max</span>(<span class="number">0</span>, arr[i].x1_ - m + <span class="number">1</span>), arr[i].y1_, arr[i].y2_, <span class="number">1</span>&#125;;</span><br><span class="line">    line[++ltot] = &#123;arr[i].x2_, arr[i].y1_, arr[i].y2_, <span class="number">-1</span>&#125;;</span><br><span class="line">    dy[++ytot] = arr[i].y1_, dy[++ytot] = arr[i].y2_;</span><br><span class="line">  &#125;</span><br><span class="line">  line[++ltot] = &#123;<span class="built_in">max</span>(<span class="number">0</span>, w - m + <span class="number">1</span>), <span class="number">0</span>, h, <span class="number">1</span>&#125;;</span><br><span class="line">  line[++ltot] = &#123;w, <span class="number">0</span>, h, <span class="number">-1</span>&#125;;</span><br><span class="line">  dy[++ytot] = <span class="number">0</span>, dy[++ytot] = h;</span><br><span class="line">  <span class="built_in">sort</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot), <span class="built_in">sort</span>(line + <span class="number">1</span>, line + <span class="number">1</span> + ltot);</span><br><span class="line">  ytot = <span class="built_in">unique</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot) - <span class="number">1</span> - dy;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ltot; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> y1 = <span class="built_in">lower_bound</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot, line[i].y1_) - dy;</span><br><span class="line">    <span class="type">int</span> y2 = <span class="built_in">lower_bound</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot, line[i].y2_) - dy;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, ytot - <span class="number">1</span>, y1, y2 - <span class="number">1</span>, line[i].flag_);</span><br><span class="line">    area += (line[i + <span class="number">1</span>].x_ - line[i].x_) * <span class="built_in">sum</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// y方向</span></span><br><span class="line"><span class="function">ll <span class="title">ywork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll area = <span class="number">0</span>;</span><br><span class="line">  ltot = ytot = <span class="number">0</span>, <span class="built_in">memset</span>(seg, <span class="number">0</span>, <span class="built_in">sizeof</span>(seg));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    line[++ltot] = &#123;<span class="built_in">max</span>(<span class="number">0</span>, arr[i].y1_ - m + <span class="number">1</span>), arr[i].x1_, arr[i].x2_, <span class="number">1</span>&#125;;</span><br><span class="line">    line[++ltot] = &#123;arr[i].y2_, arr[i].x1_, arr[i].x2_, <span class="number">-1</span>&#125;;</span><br><span class="line">    dy[++ytot] = arr[i].x1_, dy[++ytot] = arr[i].x2_;</span><br><span class="line">  &#125;</span><br><span class="line">  line[++ltot] = &#123;<span class="built_in">max</span>(<span class="number">0</span>, h - m + <span class="number">1</span>), <span class="number">0</span>, w, <span class="number">1</span>&#125;;</span><br><span class="line">  line[++ltot] = &#123;h, <span class="number">0</span>, w, <span class="number">-1</span>&#125;;</span><br><span class="line">  dy[++ytot] = <span class="number">0</span>, dy[++ytot] = w;</span><br><span class="line">  <span class="built_in">sort</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot), <span class="built_in">sort</span>(line + <span class="number">1</span>, line + <span class="number">1</span> + ltot);</span><br><span class="line">  ytot = <span class="built_in">unique</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot) - <span class="number">1</span> - dy;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ltot; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> y1 = <span class="built_in">lower_bound</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot, line[i].y1_) - dy;</span><br><span class="line">    <span class="type">int</span> y2 = <span class="built_in">lower_bound</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot, line[i].y2_) - dy;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, ytot - <span class="number">1</span>, y1, y2 - <span class="number">1</span>, line[i].flag_);</span><br><span class="line">    area += (line[i + <span class="number">1</span>].x_ - line[i].x_) * <span class="built_in">sum</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; w &gt;&gt; h &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      cin &gt;&gt; arr[i].x1_ &gt;&gt; arr[i].y1_ &gt;&gt; arr[i].x2_ &gt;&gt; arr[i].y2_;</span><br><span class="line">      --arr[i].x1_, --arr[i].y1_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (w &gt;= m) res += <span class="number">1ll</span> * w * h - <span class="built_in">xwork</span>();</span><br><span class="line">    <span class="comment">// m==1时，x方向和y方向的情况是一样的，不能重复计算！</span></span><br><span class="line">    <span class="keyword">if</span> (h &gt;= m &amp;&amp; m != <span class="number">1</span>) res += <span class="number">1ll</span> * w * h - <span class="built_in">ywork</span>();</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p><code>w</code>和<code>h</code>的范围高达1e7，而矩形个数只有5e4，显然是暗示用扫描线来对矩形做文章。</p>
<p>扫描线需要用到的是矩形的左下角坐标和右上角坐标，</p>
<p>而题目所给的是左下角单位矩形的二维标号和右上角单位矩形的二维标号，</p>
<p>比如样例：</p>
<blockquote>
<p>3 3 1 2 2 2 2 2</p>
</blockquote>
<p>左下角矩形是<code>(2,2)</code>，右上角矩形是<code>(2,2)</code>；那么左下角坐标应该是<code>(1,1)</code>，右上角坐标不变。</p>
<p>由于可以横着放或竖着放，显然有<code>总情况 = 横放情况 + 竖放情况</code>，先只考虑横放。</p>
<p>只考虑横放时，样例作图如下。被覆盖面积是不可选的，而<code>可选的空白部分 = 总面积 - 被覆盖面积</code></p>
<p>而被覆盖面积除了题目所给的<strong>矩形面积并</strong>之外，还有左下角<code>(max(0, w - m + 1),0)</code>，右上角<code>(w,h)</code>构成的矩形。</p>
<img src="/2024/02/29/hdu-4052-Adding-New-Machine/1.png" class="" title="image-20240229161808547">
<p>矩形面积并是扫描线的经典模板，不再赘述；竖着放的情况与横着放类似，也不再赘述。</p>
<p>提示一点，当<code>m == 1</code>时，横放竖放情况一致，不要重复计算。</p>
]]></content>
      <categories>
        <category>hdoj</category>
      </categories>
      <tags>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>hdoj-3642 Get The Treasury</title>
    <url>/2024/02/27/hdu-3642-Get-The-Treasury/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>扫描线</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, dy[<span class="number">4</span> * maxn], dz[<span class="number">4</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span> &#123;</span><br><span class="line">  <span class="type">int</span> x1_, y1_, z1_, x2_, y2_, z2_;</span><br><span class="line">&#125; arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node2</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y1_, y2_, flag_;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node2 &amp;b) &#123; <span class="keyword">return</span> x_ &lt; b.x_; &#125;</span><br><span class="line">&#125; line[<span class="number">2</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node3</span> &#123;</span><br><span class="line">  ll cnt_, once_, twice_, third_;</span><br><span class="line">&#125; seg[<span class="number">4</span> * <span class="number">2</span> * maxn];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cnt(x) seg[x].cnt_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> once(x) seg[x].once_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> twice(x) seg[x].twice_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> third(x) seg[x].third_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 大于等于1的访问次数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cnt</span>(rt)) &#123;</span><br><span class="line">    <span class="built_in">once</span>(rt) = dy[r + <span class="number">1</span>] - dy[l];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">once</span>(rt) = l == r ? <span class="number">0</span> : <span class="built_in">once</span>(lson) + <span class="built_in">once</span>(rson);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 大于等于2的访问次数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cnt</span>(rt) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">twice</span>(rt) = dy[r + <span class="number">1</span>] - dy[l];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">cnt</span>(rt) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">twice</span>(rt) = l == r ? <span class="number">0</span> : <span class="built_in">once</span>(lson) + <span class="built_in">once</span>(rson);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">twice</span>(rt) = l == r ? <span class="number">0</span> : <span class="built_in">twice</span>(lson) + <span class="built_in">twice</span>(rson);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 大于等于3的访问次数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cnt</span>(rt) &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">third</span>(rt) = dy[r + <span class="number">1</span>] - dy[l];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">cnt</span>(rt) == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">third</span>(rt) = l == r ? <span class="number">0</span> : <span class="built_in">once</span>(lson) + <span class="built_in">once</span>(rson);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">cnt</span>(rt) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">third</span>(rt) = l == r ? <span class="number">0</span> : <span class="built_in">twice</span>(lson) + <span class="built_in">twice</span>(rson);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">third</span>(rt) = l == r ? <span class="number">0</span> : <span class="built_in">third</span>(lson) + <span class="built_in">third</span>(rson);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="built_in">cnt</span>(rt) += v, <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= mid) <span class="built_in">update</span>(lson, l, mid, L, R, v);</span><br><span class="line">  <span class="keyword">if</span> (R &gt; mid) <span class="built_in">update</span>(rson, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">  <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="type">int</span> ltot = <span class="number">0</span>, ytot = <span class="number">0</span>, ztot = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> x1, y1, z1, x2, y2, z2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; z1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; z2;</span><br><span class="line">    arr[i] = &#123;x1, y1, z1, x2, y2, z2&#125;;</span><br><span class="line">    dz[++ztot] = z1, dz[++ztot] = z2;</span><br><span class="line">    dy[++ytot] = y1, dy[++ytot] = y2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(dz + <span class="number">1</span>, dz + <span class="number">1</span> + ztot), <span class="built_in">sort</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot);</span><br><span class="line">  ztot = <span class="built_in">unique</span>(dz + <span class="number">1</span>, dz + <span class="number">1</span> + ztot) - <span class="number">1</span> - dz;</span><br><span class="line">  ytot = <span class="built_in">unique</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot) - <span class="number">1</span> - dy;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ztot; ++i) &#123;</span><br><span class="line">    ltot = <span class="number">0</span>, <span class="built_in">memset</span>(seg, <span class="number">0</span>, <span class="built_in">sizeof</span>(seg));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j].z1_ &lt;= dz[i] &amp;&amp; arr[j].z2_ &gt; dz[i]) &#123;</span><br><span class="line">        line[++ltot] = &#123;arr[j].x1_, arr[j].y1_, arr[j].y2_, <span class="number">1</span>&#125;;</span><br><span class="line">        line[++ltot] = &#123;arr[j].x2_, arr[j].y1_, arr[j].y2_, <span class="number">-1</span>&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(line + <span class="number">1</span>, line + <span class="number">1</span> + ltot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; ltot; ++j) &#123;</span><br><span class="line">      y1 = <span class="built_in">lower_bound</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot, line[j].y1_) - dy;</span><br><span class="line">      y2 = <span class="built_in">lower_bound</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot, line[j].y2_) - dy;</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, ytot - <span class="number">1</span>, y1, y2 - <span class="number">1</span>, line[j].flag_);</span><br><span class="line">      ans += <span class="built_in">third</span>(<span class="number">1</span>) * (line[j + <span class="number">1</span>].x_ - line[j].x_) * (dz[i + <span class="number">1</span>] - dz[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %lld\n&quot;</span>, i, <span class="built_in">work</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题意是说，给你若干个长方体，求至少3个长方体相交部分的体积和。</p>
<p>由于是三维，先在z轴上使用扫描线，固定z坐标，使其转换为二维的面积问题。</p>
<p><code>两根z轴上扫描线之间的体积 = 两根z轴上扫描线之间的距离（高） * 两扫描线之间的面积</code></p>
<p>二维上的面积问题则是经典的<strong>求覆盖次数大于等于3的面积和</strong>，参见<a
href="https://acm.hdu.edu.cn/showproblem.php?pid=1255">hdu-1255</a>，不再赘述。</p>
]]></content>
      <categories>
        <category>hdoj</category>
      </categories>
      <tags>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>hdoj-1828 Picture</title>
    <url>/2024/02/26/hdu-1828-Picture/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>扫描线</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路。</p>
<h1 id="思路">思路</h1>
<p>本题有坑，是个多数据题目（但是竟然没告诉你），所以最外层记得再套一层循环！</p>
<p>由于扫描线只是一维的，而周长分为平行y轴与平行x轴两部分，先作图分析平行y轴时的扫描线变化。</p>
<p>能得到规律：所谓周长其实就是扫描线长度的变化量。</p>
<img src="/2024/02/26/hdu-1828-Picture/1.png" class="" title="image-20240226155148505">
<h2 id="方法一">方法一</h2>
<p>先算平行y轴部分的周长，再算平行x轴部分的周长，最后相加即可。</p>
<p>注意！若扫描线重合，应先加后减，否则会引起不必要的变化量！</p>
<p>假设有三根扫描线在同一位置，且长度相等，分别为<code>&#123;+1, -1, +1&#125;</code></p>
<p>若先增后减，即<code>&#123;+1, +1, -1&#125;</code>，那么变化的情况为<code>+1 -&gt; +1 -&gt; +1</code>，对全局来说只有一次<code>+1</code>，是对的；</p>
<p>若先减后增，即<code>&#123;-1, +1, +1&#125;</code>，那么变化的情况为<code>-1 -&gt; 0 -&gt; +1</code>，尽管最终结果也是<code>+1</code>，但是凭空多了两次变化量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, dtot, xtot, ytot, dis[<span class="number">4</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y1_, y2_, flag_;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node1 &amp;x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x_ != x.x_) <span class="keyword">return</span> x_ &lt; x.x_;</span><br><span class="line">    <span class="keyword">return</span> flag_ &gt; x.flag_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; xl[<span class="number">2</span> * maxn], yl[<span class="number">2</span> * maxn];</span><br><span class="line"><span class="comment">// xl：垂直x轴的扫描线</span></span><br><span class="line"><span class="comment">// yl：垂直y轴的扫描线</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node2</span> &#123;</span><br><span class="line">  ll status_, sum_;</span><br><span class="line">&#125; seg[<span class="number">4</span> * <span class="number">2</span> * maxn];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> stat(x) seg[x].status_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sum(x) seg[x].sum_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sum</span>(rt) =</span><br><span class="line">      <span class="built_in">stat</span>(rt) ? dis[r + <span class="number">1</span>] - dis[l] : (l == r ? <span class="number">0</span> : <span class="built_in">sum</span>(lson) + <span class="built_in">sum</span>(rson));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="built_in">stat</span>(rt) += v, <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= mid) <span class="built_in">update</span>(lson, l, mid, L, R, v);</span><br><span class="line">  <span class="keyword">if</span> (R &gt; mid) <span class="built_in">update</span>(rson, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">  <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平行y轴的部分周长</span></span><br><span class="line"><span class="function">ll <span class="title">ywork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> y1, y2;</span><br><span class="line">  <span class="built_in">sort</span>(xl + <span class="number">1</span>, xl + <span class="number">1</span> + xtot);</span><br><span class="line">  ll pre = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= xtot; ++i) &#123;</span><br><span class="line">    y1 = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + dtot, xl[i].y1_) - dis;</span><br><span class="line">    y2 = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + dtot, xl[i].y2_) - dis;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, dtot - <span class="number">1</span>, y1, y2 - <span class="number">1</span>, xl[i].flag_);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sum</span>(<span class="number">1</span>) != pre) ans += <span class="built_in">abs</span>(<span class="built_in">sum</span>(<span class="number">1</span>) - pre);</span><br><span class="line">    pre = <span class="built_in">sum</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(seg, <span class="number">0</span>, <span class="built_in">sizeof</span>(seg));</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平行x轴的部分周长</span></span><br><span class="line"><span class="function">ll <span class="title">xwork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x1, x2;</span><br><span class="line">  <span class="built_in">sort</span>(yl + <span class="number">1</span>, yl + <span class="number">1</span> + ytot);</span><br><span class="line">  ll pre = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ytot; ++i) &#123;</span><br><span class="line">    x1 = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + dtot, yl[i].y1_) - dis;</span><br><span class="line">    x2 = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + dtot, yl[i].y2_) - dis;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, dtot - <span class="number">1</span>, x1, x2 - <span class="number">1</span>, yl[i].flag_);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sum</span>(<span class="number">1</span>) != pre) ans += <span class="built_in">abs</span>(<span class="built_in">sum</span>(<span class="number">1</span>) - pre);</span><br><span class="line">    pre = <span class="built_in">sum</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">    <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">    xtot = ytot = dtot = <span class="number">0</span>, <span class="built_in">memset</span>(seg, <span class="number">0</span>, <span class="built_in">sizeof</span>(seg));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">      xl[++xtot] = &#123;x1, y1, y2, <span class="number">1</span>&#125;, xl[++xtot] = &#123;x2, y1, y2, <span class="number">-1</span>&#125;;</span><br><span class="line">      yl[++ytot] = &#123;y1, x1, x2, <span class="number">1</span>&#125;, yl[++ytot] = &#123;y2, x1, x2, <span class="number">-1</span>&#125;;</span><br><span class="line">      dis[++dtot] = x1, dis[++dtot] = y1, dis[++dtot] = x2, dis[++dtot] = y2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + dtot);</span><br><span class="line">    dtot = <span class="built_in">unique</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + dtot) - <span class="number">1</span> - dis;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">ywork</span>() + <span class="built_in">xwork</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二">方法二</h2>
<p>矩形的上下边界（平行x轴部分）受扫描线控制，所以尽管扫描线是一维的，但本题可以顺带处理二维。</p>
<img src="/2024/02/26/hdu-1828-Picture/2.png" class="" title="image-20240226190249765">
<p>扫描线彼此之间的距离已知，若知道扫描线之间的线段条数，再乘上距离就得到了这部分平行x轴的周长。</p>
<p>构造思路就很清楚了：</p>
<ol type="1">
<li>当前区间被访问过，该区间就只有两条横边（废话）</li>
<li>当前区间没被访问过：
<ol type="1">
<li>当前区间的总条数等于左子区间条数+右子区间条数（上图A情况）</li>
<li>若左子区间的右端点、右子区间的左端点均被覆盖，说明两区间相交，当前区间的总条数应该减去2（上图B情况）</li>
</ol></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, dtot, ltot, dis[<span class="number">4</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y1_, y2_, flag_;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node1 &amp;x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x_ != x.x_) <span class="keyword">return</span> x_ &lt; x.x_;</span><br><span class="line">    <span class="keyword">return</span> flag_ &gt; x.flag_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; line[<span class="number">2</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node2</span> &#123;</span><br><span class="line">  <span class="comment">// vis_l：当前区间左端点是否被访问</span></span><br><span class="line">  <span class="comment">// vis_r：当前区间右端点是否被访问</span></span><br><span class="line">  <span class="comment">// cnt：有几条平行x轴</span></span><br><span class="line">  <span class="type">int</span> vis_l_, vis_r_, state_;</span><br><span class="line">  ll sum_, cnt_;</span><br><span class="line">&#125; seg[<span class="number">4</span> * <span class="number">2</span> * maxn];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> state(x) seg[x].state_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sum(x) seg[x].sum_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> visl(x) seg[x].vis_l_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> visr(x) seg[x].vis_r_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cnt(x) seg[x].cnt_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">state</span>(rt)) &#123;</span><br><span class="line">    <span class="built_in">sum</span>(rt) = dis[r + <span class="number">1</span>] - dis[l];</span><br><span class="line">    <span class="built_in">visl</span>(rt) = <span class="built_in">visr</span>(rt) = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当前区间完全被覆盖时，肯定只有两条平行x轴</span></span><br><span class="line">    <span class="built_in">cnt</span>(rt) = <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      <span class="built_in">sum</span>(rt) = <span class="number">0</span>, <span class="built_in">cnt</span>(rt) = <span class="number">0</span>, <span class="built_in">visl</span>(rt) = <span class="built_in">visr</span>(rt) = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">sum</span>(rt) = <span class="built_in">sum</span>(lson) + <span class="built_in">sum</span>(rson);</span><br><span class="line">      <span class="built_in">cnt</span>(rt) = <span class="built_in">cnt</span>(lson) + <span class="built_in">cnt</span>(rson);</span><br><span class="line">      <span class="built_in">visl</span>(rt) = <span class="built_in">visl</span>(lson), <span class="built_in">visr</span>(rt) = <span class="built_in">visr</span>(rson);</span><br><span class="line">      <span class="comment">// 如果左子区间的右端点已覆盖，右子区间的左端点也覆盖</span></span><br><span class="line">      <span class="comment">// 说明两个子区间相交</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">visr</span>(lson) &amp;&amp; <span class="built_in">visl</span>(rson)) <span class="built_in">cnt</span>(rt) -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="built_in">state</span>(rt) += v, <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= mid) <span class="built_in">update</span>(lson, l, mid, L, R, v);</span><br><span class="line">  <span class="keyword">if</span> (R &gt; mid) <span class="built_in">update</span>(rson, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">  <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> y1, y2;</span><br><span class="line">  <span class="built_in">sort</span>(line + <span class="number">1</span>, line + <span class="number">1</span> + ltot);</span><br><span class="line">  ll pre = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ltot; ++i) &#123;</span><br><span class="line">    y1 = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + dtot, line[i].y1_) - dis;</span><br><span class="line">    y2 = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + dtot, line[i].y2_) - dis;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, dtot - <span class="number">1</span>, y1, y2 - <span class="number">1</span>, line[i].flag_);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sum</span>(<span class="number">1</span>) != pre) ans += <span class="built_in">abs</span>(<span class="built_in">sum</span>(<span class="number">1</span>) - pre);</span><br><span class="line">    pre = <span class="built_in">sum</span>(<span class="number">1</span>);</span><br><span class="line">    ans += <span class="built_in">cnt</span>(<span class="number">1</span>) * (line[i + <span class="number">1</span>].x_ - line[i].x_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后一根扫描线</span></span><br><span class="line">  y1 = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + dtot, line[ltot].y1_) - dis;</span><br><span class="line">  y2 = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + dtot, line[ltot].y2_) - dis;</span><br><span class="line">  <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, dtot - <span class="number">1</span>, y1, y2 - <span class="number">1</span>, line[ltot].flag_);</span><br><span class="line">  ans += <span class="built_in">abs</span>(<span class="built_in">sum</span>(<span class="number">1</span>) - pre);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">    <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">    ltot = dtot = <span class="number">0</span>, <span class="built_in">memset</span>(seg, <span class="number">0</span>, <span class="built_in">sizeof</span>(seg));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">      dis[++dtot] = y1, dis[++dtot] = y2;</span><br><span class="line">      line[++ltot] = &#123;x1, y1, y2, <span class="number">1</span>&#125;, line[++ltot] = &#123;x2, y1, y2, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + dtot);</span><br><span class="line">    dtot = <span class="built_in">unique</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + dtot) - <span class="number">1</span> - dis;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">work</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>hdoj</category>
      </categories>
      <tags>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>hdoj-4419 Colourful Rectangle</title>
    <url>/2024/03/01/hdu-4419-Colourful-Rectangle/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>扫描线</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, ltot, ytot, dy[<span class="number">2</span> * maxn];</span><br><span class="line">ll res[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span> &#123;</span><br><span class="line">  <span class="type">int</span> rgb_[<span class="number">4</span>];  <span class="comment">// 下标1~3，R、G、B的个数</span></span><br><span class="line">  ll len_[<span class="number">8</span>];   <span class="comment">// 下标1~7，RGB的7种状态的长度</span></span><br><span class="line">  <span class="comment">// 000代表当前与父结点颜色相同的个数，默认当前区域全部相同</span></span><br><span class="line">  <span class="comment">// 001代表R、010代表G、011代表RG，以此类推</span></span><br><span class="line">&#125; tree[<span class="number">4</span> * <span class="number">2</span> * maxn];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rgb(x) tree[x].rgb_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> len(x) tree[x].len_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node2</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y1_, y2_, bit_, flag_;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node2 &amp;b) &#123; <span class="keyword">return</span> x_ &lt; b.x_; &#125;</span><br><span class="line">&#125; line[<span class="number">2</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(<span class="built_in">len</span>(rt), <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="built_in">len</span>(rt)));</span><br><span class="line">  <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">rgb</span>(rt)[i]) status |= <span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    <span class="built_in">len</span>(rt)[status] = dy[r + <span class="number">1</span>] - dy[l];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i)</span><br><span class="line">      <span class="built_in">len</span>(rt)[i | status] += <span class="built_in">len</span>(lson)[i] + <span class="built_in">len</span>(rson)[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> bit, <span class="type">int</span> flag)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="built_in">rgb</span>(rt)[bit] += flag;</span><br><span class="line">    <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= mid) <span class="built_in">update</span>(lson, l, mid, L, R, bit, flag);</span><br><span class="line">  <span class="keyword">if</span> (R &gt; mid) <span class="built_in">update</span>(rson, mid + <span class="number">1</span>, r, L, R, bit, flag);</span><br><span class="line">  <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    <span class="built_in">len</span>(rt)[<span class="number">0</span>] = dy[r + <span class="number">1</span>] - dy[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">build</span>(lson, l, mid), <span class="built_in">build</span>(rson, mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">len</span>(rt)[<span class="number">0</span>] = <span class="built_in">len</span>(lson)[<span class="number">0</span>] + <span class="built_in">len</span>(rson)[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="type">int</span> bit, x1, x2, y1, y2;</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; ch &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">      bit = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;G&#x27;</span>) &#123;</span><br><span class="line">      bit = <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      bit = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    line[++ltot] = &#123;x1, y1, y2, bit, <span class="number">1</span>&#125;, line[++ltot] = &#123;x2, y1, y2, bit, <span class="number">-1</span>&#125;;</span><br><span class="line">    dy[++ytot] = y1, dy[++ytot] = y2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot);</span><br><span class="line">  <span class="built_in">sort</span>(line + <span class="number">1</span>, line + <span class="number">1</span> + ltot);</span><br><span class="line">  ytot = <span class="built_in">unique</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot) - dy - <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, ytot - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ltot; ++i) &#123;</span><br><span class="line">    y1 = <span class="built_in">lower_bound</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot, line[i].y1_) - dy;</span><br><span class="line">    y2 = <span class="built_in">lower_bound</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot, line[i].y2_) - dy;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, ytot - <span class="number">1</span>, y1, y2 - <span class="number">1</span>, line[i].bit_, line[i].flag_);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">7</span>; ++j) &#123;</span><br><span class="line">      res[j] += <span class="number">1ll</span> * <span class="built_in">len</span>(<span class="number">1</span>)[j] * (line[i + <span class="number">1</span>].x_ - line[i].x_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    ytot = ltot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(tree, <span class="number">0</span>, <span class="built_in">sizeof</span>(tree));</span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="built_in">sizeof</span>(res));</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; res[<span class="number">1</span>] &lt;&lt; endl &lt;&lt; res[<span class="number">2</span>] &lt;&lt; endl &lt;&lt; res[<span class="number">4</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; res[<span class="number">3</span>] &lt;&lt; endl &lt;&lt; res[<span class="number">5</span>] &lt;&lt; endl &lt;&lt; res[<span class="number">6</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; res[<span class="number">7</span>] &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>矩形面积并的板子题，这不是难点。</p>
<p>本题最难的点，在于如何设计线段树；众所周知，扫描线不需要下放懒标记，只需要上传。</p>
<p>一共有7个状态，当然可以用7个变量...但是那样维护起来太变态了，可以用位运算。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">B(高位)</th>
<th style="text-align: center;">G</th>
<th style="text-align: center;">R(低位)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<p>如上所示，用三位就可以表达8种情况了：</p>
<ul>
<li>R：001</li>
<li>G：010</li>
<li>B：100</li>
<li>RG：011</li>
<li>RB：101</li>
<li>GB：110</li>
<li>RGB：111</li>
</ul>
<p>那么只要建立一个下标为0~7的长度数组，即可保存上述状态各自的长度。</p>
<p>假设当前有线段树如下，考虑子结点<code>(1,2)</code>与父结点<code>(1,3)</code>合并</p>
<img src="/2024/03/01/hdu-4419-Colourful-Rectangle/1.png" class="" title="image-20240301002947894">
<p>显然，先要将父结点的长度数组归零，因为要和子结点的状态重新合并；而状态合并直接用或运算即可。</p>
<p>很显然能想到下列代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; ++i)&#123;</span><br><span class="line">    长度数组[当前状态 | i] += 左孩子的长度数组[i] + 右孩子的长度数组[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后父结点变成了下图的模样：</p>
<img src="/2024/03/01/hdu-4419-Colourful-Rectangle/2.png" class="" title="image-20240301004825294">
<p>发现父结点原来还有一个<code>B</code>被清除了，该怎么办呢？将长度数组里的000状态用起来！</p>
<p>0状态代表<strong>当前与父结点保持一致的个数，默认为当前区间长度（个数）</strong></p>
<p>只需要将上述代码改成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i)&#123;</span><br><span class="line">    长度数组[当前状态 | i] += 左孩子的长度数组[i] + 右孩子的长度数组[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多了一种情况，那就是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">长度数组[当前状态] += 左孩子的长度数组[<span class="number">0</span>] + 右孩子的长度数组[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>以此来维护父结点的原状态个数。</p>
<p>最终的线段树长成这样：</p>
<img src="/2024/03/01/hdu-4419-Colourful-Rectangle/3.png" class="" title="image-20240301010210270">
]]></content>
      <categories>
        <category>hdoj</category>
      </categories>
      <tags>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-2464 Brownie Points II</title>
    <url>/2024/02/28/poj-2464-Brownie-Points-II/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>扫描线</li>
<li>树状数组</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, ytot, dy[maxn], lb[maxn], rb[maxn];</span><br><span class="line">set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> bit[], <span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (x &lt;= n) bit[x] += v, x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> bit[], <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (x &gt; <span class="number">0</span>) res += bit[x], x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y_;</span><br><span class="line">  <span class="built_in">node</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node &amp;x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x.x_ != x_) <span class="keyword">return</span> x_ &lt; x.x_;</span><br><span class="line">    <span class="keyword">return</span> y_ &lt; x.y_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; arr[maxn];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ax(x) arr[x].x_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ay(x) arr[x].y_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    arr[i] = <span class="built_in">node</span>(x, y), dy[++ytot] = y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(arr + <span class="number">1</span>, arr + <span class="number">1</span> + n), <span class="built_in">sort</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot);</span><br><span class="line">  ytot = <span class="built_in">unique</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot) - <span class="number">1</span> - dy;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    y = <span class="built_in">lower_bound</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot, <span class="built_in">ay</span>(i)) - dy;</span><br><span class="line">    <span class="built_in">ay</span>(i) = y, <span class="built_in">add</span>(rb, y, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ytot = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(lb, <span class="number">0</span>, <span class="built_in">sizeof</span>(lb)), <span class="built_in">memset</span>(rb, <span class="number">0</span>, <span class="built_in">sizeof</span>(rb));</span><br><span class="line">  st.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = INT_MIN, head = <span class="number">1</span>, tail = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (head &lt;= n) &#123;</span><br><span class="line">    tail = head;</span><br><span class="line">    <span class="keyword">while</span> (tail &lt;= n &amp;&amp; <span class="built_in">ax</span>(tail) == <span class="built_in">ax</span>(head)) <span class="built_in">add</span>(rb, <span class="built_in">ay</span>(tail++), <span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> Stan = INT_MAX, Ollie = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head; i &lt; tail; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> s = <span class="built_in">query</span>(lb, <span class="built_in">ay</span>(i) - <span class="number">1</span>) + <span class="built_in">query</span>(rb, ytot) - <span class="built_in">query</span>(rb, <span class="built_in">ay</span>(i));</span><br><span class="line">      <span class="type">int</span> o = <span class="built_in">query</span>(lb, ytot) - <span class="built_in">query</span>(lb, <span class="built_in">ay</span>(i)) + <span class="built_in">query</span>(rb, <span class="built_in">ay</span>(i) - <span class="number">1</span>);</span><br><span class="line">      Ollie = <span class="built_in">max</span>(Ollie, o);</span><br><span class="line">      <span class="keyword">if</span> (o == Ollie) Stan = <span class="built_in">min</span>(Stan, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// y轴全部遍历完之后才能和ans比较！</span></span><br><span class="line">    <span class="comment">// 如果每个点都和ans比较，岂不是每个点都被视作最大值了吗？逻辑错误！</span></span><br><span class="line">    <span class="keyword">if</span> (Stan &gt; ans) st.<span class="built_in">clear</span>(), ans = Stan;</span><br><span class="line">    <span class="keyword">if</span> (Stan == ans) st.<span class="built_in">insert</span>(Ollie);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head; i &lt; tail; ++i) <span class="built_in">add</span>(lb, <span class="built_in">ay</span>(i), <span class="number">1</span>);</span><br><span class="line">    head = tail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Stan: %d; Ollie:&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, *it);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) <span class="built_in">init</span>(), <span class="built_in">work</span>(), <span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>平面有若干个点，<code>Stan</code>必经一点垂直画一条线，作为y轴；<code>Ollie</code>必经一点水平画一条线，作为x轴。</p>
<p>其中y轴和x轴上的点不算，<code>Stan</code>分数是一、三象限的点个数，<code>Ollie</code>分数是二、四象限的点个数。</p>
<p><code>Stan</code>和<code>Ollie</code>都要最大化自己的分数，求<code>Stan</code>分数最小值的最大以及最大时对应<code>Ollie</code>的分数。</p>
<hr />
<p>由于没有什么限制条件可以用来答案二分，只能以每个点作为坐标原点来暴力计算。</p>
<p>将所有坐标对x轴排序，那么同一x的坐标就都处在同一扫描线上，即可视作y轴；</p>
<p>随后遍历扫描线上的每一个点，x轴视作经过该点的y坐标。</p>
<hr />
<p>如何快速求出，对于每个点的四个象限的点个数呢？</p>
<p>每个点都处在不同的扫描线上，而扫描线彼此之间是绝对平行的（垂直x轴）；</p>
<p>且总有：</p>
<ul>
<li><code>2、3象限的总个数 = 当前y轴左侧的所有扫描线上个数之和</code></li>
<li><code>1、4象限的总个数 = 当前y轴右侧的所有扫描线上个数之和</code></li>
<li><code>总个数（恒不变） = y轴左侧个数 + y轴轴上个数 + y轴右侧个数</code></li>
</ul>
<p>那么令<code>lb</code>为y轴左侧的权值树状数组，<code>rb</code>为y轴右侧的权值树状数组，代表各范围内的总个数</p>
<p>那么各象限的节点个数就了然了，假设当前原点坐标为<code>(x, y)</code>，y最大范围为<code>ytot</code></p>
<ul>
<li>第一象限：<code>rb中，y+1~ytot的个数 = 1~ytot的总个数 - 1~y的总个数</code></li>
<li>第二象限：<code>lb中，y+1~ytot的个数 = 1~ytot的总个数 - 1~y的总个数</code></li>
<li>第三象限：<code>lb中，1~y-1的个数</code></li>
<li>第四象限：<code>rb中，1~y-1的个数</code></li>
</ul>
<p>初始化时，先令<code>rb</code>为全平面的总点数；每遇到一根新的扫描线时，将其从<code>rb</code>中剔除，再进行计算，最后将该扫描线纳入到<code>lb</code>中。这样就能保证在计算时，<code>rb</code>和<code>lb</code>都不存在扫描线上（y轴）的点。</p>
]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>扫描线</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-2482 Stars in Your Window</title>
    <url>/2024/02/28/poj-2482-Stars-in-Your-Window/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>扫描线</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e4</span> + <span class="number">50</span>;</span><br><span class="line">ll n, w, h, ltot, ytot, dy[<span class="number">2</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span> &#123;</span><br><span class="line">  ll x_, y1_, y2_, v_;</span><br><span class="line">  <span class="built_in">node1</span>(ll x = <span class="number">0</span>, ll y1 = <span class="number">0</span>, ll y2 = <span class="number">0</span>, ll v = <span class="number">0</span>)</span><br><span class="line">      : <span class="built_in">x_</span>(x), <span class="built_in">y1_</span>(y1), <span class="built_in">y2_</span>(y2), <span class="built_in">v_</span>(v) &#123;&#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node1 &amp;x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x_ != x.x_) <span class="keyword">return</span> x_ &lt; x.x_;</span><br><span class="line">    <span class="keyword">return</span> v_ &gt; x.v_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; line[<span class="number">2</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node2</span> &#123;</span><br><span class="line">  ll lz_, mx_;</span><br><span class="line">&#125; seg[<span class="number">8</span> * maxn];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lz(x) seg[x].lz_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mx(x) seg[x].mx_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(ll rt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">lz</span>(rt)) &#123;</span><br><span class="line">    <span class="built_in">lz</span>(lson) += <span class="built_in">lz</span>(rt), <span class="built_in">lz</span>(rson) += <span class="built_in">lz</span>(rt);</span><br><span class="line">    <span class="built_in">mx</span>(lson) += <span class="built_in">lz</span>(rt), <span class="built_in">mx</span>(rson) += <span class="built_in">lz</span>(rt);</span><br><span class="line">    <span class="built_in">lz</span>(rt) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(ll rt)</span> </span>&#123; <span class="built_in">mx</span>(rt) = <span class="built_in">max</span>(<span class="built_in">mx</span>(lson), <span class="built_in">mx</span>(rson)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll rt, ll l, ll r, ll L, ll R, ll v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="built_in">lz</span>(rt) += v, <span class="built_in">mx</span>(rt) += v;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">down</span>(rt);</span><br><span class="line">  ll mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= mid) <span class="built_in">update</span>(lson, l, mid, L, R, v);</span><br><span class="line">  <span class="keyword">if</span> (R &gt; mid) <span class="built_in">update</span>(rson, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">  <span class="built_in">up</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll x, y, v, y1, y2;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; w &gt;&gt; h) &#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ltot = ytot = <span class="number">0</span>, <span class="built_in">memset</span>(seg, <span class="number">0</span>, <span class="built_in">sizeof</span>(seg));</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;</span><br><span class="line">      y1 = y + <span class="number">1</span>, y2 = y + h;</span><br><span class="line">      dy[++ytot] = y1, dy[++ytot] = y2;</span><br><span class="line">      line[++ltot] = <span class="built_in">node1</span>(x + <span class="number">1</span>, y1, y2, v),</span><br><span class="line">      line[++ltot] = <span class="built_in">node1</span>(x + w, y1, y2, -v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot), <span class="built_in">sort</span>(line + <span class="number">1</span>, line + <span class="number">1</span> + ltot);</span><br><span class="line">    ytot = <span class="built_in">unique</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot) - <span class="number">1</span> - dy;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= ltot; ++i) &#123;</span><br><span class="line">      y1 = <span class="built_in">lower_bound</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot, line[i].y1_) - dy;</span><br><span class="line">      y2 = <span class="built_in">lower_bound</span>(dy + <span class="number">1</span>, dy + <span class="number">1</span> + ytot, line[i].y2_) - dy;</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, ytot, y1, y2, line[i].v_);</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, <span class="built_in">mx</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>先上图。</p>
<img src="/2024/02/28/poj-2482-Stars-in-Your-Window/1.jpg" class="" width="1">
<img src="/2024/02/28/poj-2482-Stars-in-Your-Window/2.jpg" class="" width="2">
<p>其中有两个注意点：</p>
<ol type="1">
<li><p>并不需要挪点，我自己用的就是<code>(x+1, y+1)</code>和<code>(x+w, y+h)</code>，这样更好理解。</p></li>
<li><p>若扫描线重合，先增后减。如下图所示，<code>a + b</code>才是真正的可取范围；</p>
<p>一旦先减后增，则可取范围变成<code>a</code>或<code>b</code>，是错误的。</p>
<img src="/2024/02/28/poj-2482-Stars-in-Your-Window/3.png" class="" title="image-20240228015026911"></li>
<li><p>这是采用的是扫描线的思想，线段树维护的是每个点的最大值，而并非段；所以必须要用懒标记！</p></li>
</ol>
]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>zoj-3521 Fairy Wars</title>
    <url>/2024/03/01/zoj-3521-Fairy-Wars/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>扫描线</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, r, l, cx, cy, fa[maxn], val[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">find</span>(fa[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="built_in">find</span>(x), b = <span class="built_in">find</span>(y);</span><br><span class="line">  <span class="keyword">if</span> (a == b) <span class="keyword">return</span>;</span><br><span class="line">  val[a] += val[b];</span><br><span class="line">  fa[b] = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y_;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node1 &amp;x) &#123; <span class="keyword">return</span> x_ &lt; x.x_; &#125;</span><br><span class="line">&#125; arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node2</span> &#123;</span><br><span class="line">  <span class="type">int</span> y_, id_;</span><br><span class="line">  <span class="built_in">node2</span>(<span class="type">int</span> y, <span class="type">int</span> id) : <span class="built_in">y_</span>(y), <span class="built_in">id_</span>(id) &#123;&#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node2 &amp;x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (y_ != x.y_) <span class="keyword">return</span> y_ &lt; x.y_;</span><br><span class="line">    <span class="keyword">return</span> id_ &lt; x.id_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;node2&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; r &gt;&gt; l) &#123;</span><br><span class="line">    l /= <span class="number">2</span>;</span><br><span class="line">    st.<span class="built_in">clear</span>(), <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      cin &gt;&gt; arr[i].x_ &gt;&gt; arr[i].y_;</span><br><span class="line">      fa[i] = i, val[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; cx &gt;&gt; cy;</span><br><span class="line">    <span class="built_in">sort</span>(arr + <span class="number">1</span>, arr + <span class="number">1</span> + n);</span><br><span class="line">    <span class="type">int</span> head = <span class="number">1</span>, tail = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail &amp;&amp; tail &lt;= n) &#123;</span><br><span class="line">      <span class="keyword">while</span> (head &lt;= tail &amp;&amp; arr[tail].x_ - arr[head].x_ &gt; l) &#123;</span><br><span class="line">        st.<span class="built_in">erase</span>(<span class="built_in">node2</span>(arr[head].y_, head));</span><br><span class="line">        ++head;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">auto</span> it = st.<span class="built_in">emplace</span>(arr[tail].y_, tail).first;</span><br><span class="line">      <span class="keyword">if</span> (it != st.<span class="built_in">begin</span>() &amp;&amp; it-&gt;y_ - <span class="built_in">prev</span>(it)-&gt;y_ &lt;= l) &#123;</span><br><span class="line">        <span class="built_in">join</span>(<span class="built_in">prev</span>(it)-&gt;id_, it-&gt;id_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">next</span>(it) != st.<span class="built_in">end</span>() &amp;&amp; <span class="built_in">next</span>(it)-&gt;y_ - it-&gt;y_ &lt;= l) &#123;</span><br><span class="line">        <span class="built_in">join</span>(it-&gt;id_, <span class="built_in">next</span>(it)-&gt;id_);</span><br><span class="line">      &#125;</span><br><span class="line">      ++tail;</span><br><span class="line">    &#125;</span><br><span class="line">    ll x, y, f, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      x = <span class="built_in">abs</span>(arr[i].x_ - cx), y = <span class="built_in">abs</span>(arr[i].y_ - cy);</span><br><span class="line">      <span class="keyword">if</span> (x * x + y * y &lt;= <span class="number">1ll</span> * r * r) &#123;</span><br><span class="line">        f = <span class="built_in">find</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (!vis[f]) vis[f] = <span class="number">1</span>, ans += val[f];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题意是说，若两个点的x坐标相差<code>l/2</code>以内，且y坐标也相差<code>l/2</code>以内，那么这两个点视作同一集合；</p>
<p>若集合内某一点在圆内，则集合内的所有点都视作”冰块“。问你一共有多少冰块。</p>
<p>思路很简单：</p>
<ul>
<li><p>将点集对x轴排序，利用双指针筛选<strong>任意两点的x坐标差都在<code>l/2</code>以内的集合</strong></p></li>
<li><p>上述集合再对y轴排序，每个点比较自己前后位置点的y坐标差</p>
<p>若两点y坐标差也满足题意，则加入到同一个并查集</p>
<p>因为上述集合要满足动态按序增加和删除结构体，选择set实现</p></li>
<li><p>最后遍历所有点，如果该点在圆内，则其所在的并查集的点数加入到答案中</p>
<p>记得开一个标志数组，避免重复统计并查集</p></li>
</ul>
<p>有两个小细节要注意：</p>
<ol type="1">
<li><p>在set的排序函数中，有如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node2 &amp;x) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (y_ != x.y_) <span class="keyword">return</span> y_ &lt; x.y_;</span><br><span class="line">  <span class="keyword">return</span> id_ &lt; x.id_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>id对于排序本身没啥用；</p>
<p>但是由于set的特殊机制，若不将id纳入排序规则中，只要y相同就会被去重删除（但实际上节点都不同）</p></li>
<li><p>若两点已经在同一并查集内，就不要重复合并了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="built_in">find</span>(x), b = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span> (a == b) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>zoj</category>
      </categories>
      <tags>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>zoj-3525 Disappearance</title>
    <url>/2024/03/01/zoj-3525-Disappearance/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>扫描线</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, cnt, B, W, H;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span> &#123;</span><br><span class="line">  <span class="type">int</span> b_, w_, h_, s_;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node1&amp; x) &#123; <span class="keyword">return</span> b_ &lt; x.b_; &#125;</span><br><span class="line">&#125; arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node2</span> &#123;</span><br><span class="line">  <span class="type">int</span> w_, h1_, h2_, flag_;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node2&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (w_ != x.w_) <span class="keyword">return</span> w_ &lt; x.w_;</span><br><span class="line">    <span class="keyword">return</span> flag_ &gt; x.flag_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; line[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node3</span> &#123;</span><br><span class="line">  <span class="type">int</span> val_, mx_;</span><br><span class="line">&#125; seg[<span class="number">8</span> * maxn];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> val(x) seg[x].val_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mx(x) seg[x].mx_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">mx</span>(rt) = l == r ? <span class="built_in">val</span>(rt) : <span class="built_in">max</span>(<span class="built_in">mx</span>(lson), <span class="built_in">mx</span>(rson)) + <span class="built_in">val</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="built_in">val</span>(rt) += v;</span><br><span class="line">    <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= mid) <span class="built_in">update</span>(lson, l, mid, L, R, v);</span><br><span class="line">  <span class="keyword">if</span> (R &gt; mid) <span class="built_in">update</span>(rson, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">  <span class="built_in">up</span>(rt, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> st, <span class="type">int</span> ed)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ltot = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(seg, <span class="number">0</span>, <span class="built_in">sizeof</span>(seg));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = st; i &lt;= ed; ++i) &#123;</span><br><span class="line">    line[++ltot] = &#123;arr[i].w_, arr[i].h_, arr[i].h_ + H, arr[i].s_&#125;;</span><br><span class="line">    line[++ltot] = &#123;arr[i].w_ + W, arr[i].h_, arr[i].h_ + H, -arr[i].s_&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(line + <span class="number">1</span>, line + <span class="number">1</span> + ltot);</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ltot; ++i) &#123;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3080</span>, line[i].h1_, line[i].h2_, line[i].flag_);</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, <span class="built_in">mx</span>(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b, w, h, s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      cin &gt;&gt; b &gt;&gt; w &gt;&gt; h &gt;&gt; s;</span><br><span class="line">      <span class="keyword">if</span> (s &gt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      b += <span class="number">1038</span>, w += <span class="number">1038</span>, h += <span class="number">1038</span>;</span><br><span class="line">      arr[++cnt] = &#123;b, w, h, -s&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr + <span class="number">1</span>, arr + <span class="number">1</span> + cnt);</span><br><span class="line">    cin &gt;&gt; B &gt;&gt; W &gt;&gt; H;</span><br><span class="line">    <span class="keyword">if</span> (!cnt) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Error 404, mahou shoujo not found!&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> head = <span class="number">1</span>, tail = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail &amp;&amp; tail &lt;= cnt) &#123;</span><br><span class="line">      <span class="keyword">while</span> (head &lt;= tail &amp;&amp; arr[tail].b_ - arr[head].b_ &gt; B) ++head;</span><br><span class="line">      <span class="keyword">while</span> (tail &lt;= cnt &amp;&amp; arr[tail].b_ - arr[head].b_ &lt;= B) ++tail;</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, <span class="built_in">calc</span>(head, tail - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; -ans &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>给你一堆b、w、h的三维权值点，求一个集合，该集合的点满足以下条件：</p>
<ul>
<li><code>max(b) - min(b) &lt;= B</code></li>
<li><code>max(w) - min(w) &lt;= W</code></li>
<li><code>max(h) - min(h) &lt;= H</code></li>
</ul>
<p>求这类集合的权值和最小值。</p>
<hr />
<p>假设只有二维的w和h，那么每个点满足条件的取值范围就是下图整个矩形，</p>
<p>如此一来，就是扫描线的经典板子题，线段树维护区间权值最大即可（这里扫描线应该先增后减）</p>
<img src="/2024/03/01/zoj-3525-Disappearance/1.png" class="" title="image-20240301223304427">
<p>还剩一个b维度，那就先按b排序；</p>
<p>用双指针规划一块满足<code>尾的b - 头的b &lt;= B</code>的集合，再对该集合执行上述扫描线操作即可。</p>
]]></content>
      <categories>
        <category>zoj</category>
      </categories>
      <tags>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>扫描线_解题技巧</title>
    <url>/2024/03/01/%E6%89%AB%E6%8F%8F%E7%BA%BF-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="编程技巧">编程技巧</h1>
<h2 id="线段树维护的东西">线段树维护的东西</h2>
<p>在扫描线的应用中，线段树维护的是“段”而不是“点”！</p>
<p>如下图所示，给55、67、79三点，维护的是55点到67点之间的<code>1号段</code>、67点到79点之间的<code>2号段</code>；</p>
<p>55、67、79三点离散化后改为1、2、3三点，</p>
<p>那么自然可以令1点代表其身后的<code>1号段</code>、2点代表其身后的<code>2号段</code>。</p>
<img src="/2024/03/01/%E6%89%AB%E6%8F%8F%E7%BA%BF-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/1.png" class="" title="image-20240225180931388">
<p>若要求更新1、3两点，线段树实际上更新的是<code>l=1, r=3-1</code>，即<code>1号段</code>和<code>2号段</code>；</p>
<p>而真正的区间长度用<code>离散数组[r+1] - 离散数组[l]</code>计算即可。</p>
<p>线段树中，若某结点<code>l=1, r=2</code>，其代表的区间长度等于<code>离散数组[2+1] - 离散数组[1] = 79 - 55 = 24</code></p>
<h2 id="线段树中的懒标记">线段树中的懒标记</h2>
<p>扫描线<strong>不</strong>需要懒标记！<strong>不</strong>需要懒标记！部分题目强用懒标记反而出错！</p>
<p>只有向父结点方向更新的操作，不需要传统线段树那样的标记下传操作！</p>
<p>各结点只保存自己区间的更新状态即可！</p>
<blockquote>
<p>比如我当前是区间<code>[1, 2]</code>，只保存<code>[1, 2]</code>的修改记录即可，毋须关心<code>[1, 1]</code>与<code>[2, 2]</code></p>
</blockquote>
<p>但子结点毕竟隶属于父结点，所以向上更新的编程重心，就在于如何合并子结点与父结点的状态。</p>
<h2 id="重合的扫描线">重合的扫描线</h2>
<p>若干条扫描线重合时，一定要考虑增减的先后顺序！</p>
<h1 id="练习题">练习题</h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P5490">P5490</a>
矩形面积并</li>
<li><a href="https://www.luogu.com.cn/problem/P1884">P1884</a>
矩形面积并</li>
<li><a
href="https://acm.hdu.edu.cn/showproblem.php?pid=1542">hdu-1542</a>
矩形面积并</li>
<li><a href="https://www.luogu.com.cn/problem/P1904">P1904</a>
矩形面积并的升级</li>
<li><a
href="https://acm.hdu.edu.cn/showproblem.php?pid=1828">hdu-1828</a>
矩形周长并</li>
<li><a
href="https://acm.hdu.edu.cn/showproblem.php?pid=1255">hdu-1255</a>
求覆盖大于等于2次的面积</li>
<li><a
href="https://acm.hdu.edu.cn/showproblem.php?pid=3642">hdu-3642</a>
求覆盖大于等于3次的体积，hdu-1255的升级版</li>
<li><a href="http://poj.org/problem?id=2482">poj-2482</a>
扫描线思想的应用</li>
<li><a href="http://poj.org/problem?id=2464">poj-2464</a>
扫描线思想的应用，经典题，求四个象限的个数</li>
<li><a
href="https://acm.hdu.edu.cn/showproblem.php?pid=3255">hdu-3255</a>
矩形体积并</li>
<li><a
href="https://acm.hdu.edu.cn/showproblem.php?pid=4052">hdu-4052</a>
矩形面积并</li>
<li><a
href="https://acm.hdu.edu.cn/showproblem.php?pid=4419">hdu-4419</a>
矩形面积并的升级，经典例题，求7种相交颜色的面积</li>
<li><a
href="https://pintia.cn/problem-sets/91827364500/exam/problems/91827368935?type=7&amp;page=0">zoj-3521</a>
扫描线思想的应用，巧用stl对x轴和y轴维持有序</li>
<li><a
href="https://pintia.cn/problem-sets/91827364500/exam/problems/91827368939">zoj-3525</a>
双指针降维后，扫描线求区间权值最大</li>
</ul>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>LCA_解题技巧</title>
    <url>/2024/03/06/LCA-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="练习题">练习题</h1>
<ul>
<li><a href="https://www.acwing.com/problem/content/393/">聚会</a>
模板题</li>
<li><a
href="https://www.acwing.com/problem/content/description/357/">异象石</a>
时间戳优化</li>
<li><a
href="https://www.acwing.com/problem/content/description/358/">次小生成树</a>
树上倍增优化</li>
<li><a
href="https://www.acwing.com/problem/content/description/359/">疫情控制</a>
贪心+二分优化</li>
</ul>
<h1 id="模板">模板</h1>
<p>以<a
href="https://www.acwing.com/problem/content/393/">聚会</a>为例题</p>
<h2 id="倍增">倍增</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e5</span> + <span class="number">50</span>, lg = (<span class="type">int</span>)(<span class="built_in">log2</span>(maxn)) + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> tot, head[maxn], nxt[maxn &lt;&lt; <span class="number">1</span>], ver[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> d[maxn], f[maxn][lg];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; ver[++tot] = y, nxt[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dis</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123; <span class="keyword">return</span> d[x] + d[y] - <span class="number">2</span> * d[z]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  d[<span class="number">1</span>] = <span class="number">1</span>, q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">      <span class="type">int</span> y = ver[i];</span><br><span class="line">      <span class="keyword">if</span> (d[y]) <span class="keyword">continue</span>;</span><br><span class="line">      q.<span class="built_in">push</span>(y);</span><br><span class="line">      d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">      f[y][<span class="number">0</span>] = x;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; lg; ++j) f[y][j] = f[f[y][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (d[x] &lt; d[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = lg - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[f[x][i]] &gt;= d[y]) x = f[x][i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = lg - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="type">int</span> x, y, z;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">add</span>(x, y), <span class="built_in">add</span>(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="type">int</span> pos, cost;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">    <span class="type">int</span> xy = <span class="built_in">lca</span>(x, y), xz = <span class="built_in">lca</span>(x, z), yz = <span class="built_in">lca</span>(y, z);</span><br><span class="line">    <span class="keyword">if</span> (d[xz] &gt;= d[xy] &amp;&amp; d[xz] &gt;= d[yz]) &#123;</span><br><span class="line">      pos = xz;</span><br><span class="line">      cost = <span class="built_in">dis</span>(x, pos, pos) + <span class="built_in">dis</span>(z, pos, pos) + <span class="built_in">dis</span>(pos, y, xy);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d[yz] &gt;= d[xy] &amp;&amp; d[yz] &gt;= d[xz]) &#123;</span><br><span class="line">      pos = yz;</span><br><span class="line">      cost = <span class="built_in">dis</span>(y, pos, pos) + <span class="built_in">dis</span>(z, pos, pos) + <span class="built_in">dis</span>(pos, x, xy);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pos = xy;</span><br><span class="line">      cost = <span class="built_in">dis</span>(x, pos, pos) + <span class="built_in">dis</span>(y, pos, pos) + <span class="built_in">dis</span>(pos, z, xz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, pos, cost);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tarjan">Tarjan</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> tot, head[maxn], nxt[maxn &lt;&lt; <span class="number">1</span>], ver[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> a[maxn], b[maxn], c[maxn];</span><br><span class="line"><span class="comment">// xy保存在第一维，xz保存在第二维，yz保存在第三维</span></span><br><span class="line"><span class="type">int</span> lca[<span class="number">3</span> * maxn];</span><br><span class="line"><span class="comment">// hq对vq的lca，保存在lca[idx]</span></span><br><span class="line"><span class="type">int</span> tq, hq[maxn], nq[<span class="number">6</span> * maxn], vq[<span class="number">6</span> * maxn], idx[<span class="number">6</span> * maxn];</span><br><span class="line"><span class="type">int</span> fa[maxn], v[maxn], d[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; ver[++tot] = y, nxt[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_q</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 特判一下，因为v[x] == v[y] == 1时，不会更新lca</span></span><br><span class="line">  <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">    lca[i] = x;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  vq[++tq] = y, nq[tq] = hq[x], idx[tq] = i, hq[x] = tq;</span><br><span class="line">  vq[++tq] = x, nq[tq] = hq[y], idx[tq] = i, hq[y] = tq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dis</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123; <span class="keyword">return</span> d[x] + d[y] - <span class="number">2</span> * d[z]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">get</span>(fa[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  v[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">    <span class="type">int</span> y = ver[i];</span><br><span class="line">    <span class="keyword">if</span> (v[y]) <span class="keyword">continue</span>;</span><br><span class="line">    d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">tarjan</span>(y);</span><br><span class="line">    fa[y] = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = hq[x]; i; i = nq[i]) &#123;</span><br><span class="line">    <span class="type">int</span> y = vq[i];</span><br><span class="line">    <span class="keyword">if</span> (v[y] == <span class="number">2</span>) lca[idx[i]] = <span class="built_in">get</span>(y);</span><br><span class="line">  &#125;</span><br><span class="line">  v[x] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="type">int</span> x, y, z;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">add</span>(x, y), <span class="built_in">add</span>(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">    a[i] = x, b[i] = y, c[i] = z;</span><br><span class="line">    <span class="built_in">add_q</span>(x, y, i), <span class="built_in">add_q</span>(x, z, i + m), <span class="built_in">add_q</span>(y, z, i + <span class="number">2</span> * m);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> pos, cost;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> x = a[i], y = b[i], z = c[i];</span><br><span class="line">    <span class="type">int</span> xy = lca[i], xz = lca[i + m], yz = lca[i + <span class="number">2</span> * m];</span><br><span class="line">    <span class="keyword">if</span> (d[xz] &gt;= d[xy] &amp;&amp; d[xz] &gt;= d[yz]) &#123;</span><br><span class="line">      pos = xz;</span><br><span class="line">      cost = <span class="built_in">dis</span>(x, pos, pos) + <span class="built_in">dis</span>(z, pos, pos) + <span class="built_in">dis</span>(pos, y, xy);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d[yz] &gt;= d[xy] &amp;&amp; d[yz] &gt;= d[xz]) &#123;</span><br><span class="line">      pos = yz;</span><br><span class="line">      cost = <span class="built_in">dis</span>(y, pos, pos) + <span class="built_in">dis</span>(z, pos, pos) + <span class="built_in">dis</span>(pos, x, xy);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pos = xy;</span><br><span class="line">      cost = <span class="built_in">dis</span>(x, pos, pos) + <span class="built_in">dis</span>(y, pos, pos) + <span class="built_in">dis</span>(pos, z, xz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, pos, cost);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>P1257. 平面上的最接近点对</title>
    <url>/2024/03/06/P1257-%E5%B9%B3%E9%9D%A2%E4%B8%8A%E7%9A%84%E6%9C%80%E6%8E%A5%E8%BF%91%E7%82%B9%E5%AF%B9/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>分治</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<p>见<strong>P1429. 平面最近点对</strong>，本题是其简化版。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P1429. 平面最近点对</title>
    <url>/2024/03/06/P1429-%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>分治</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<p>分治的经典教学题，OIWiki已经讲得很好了，见<a
href="https://oi-wiki.org/geometry/nearest-points/">链接</a>；其中的<strong>复杂度证明</strong>部分一定要理解！</p>
<p>下面讲一下编程细节：</p>
<h2 id="sort实现">sort实现</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">double</span> x_, y_;</span><br><span class="line">&#125; arr[maxn], t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpx</span><span class="params">(node &amp;a, node &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.x_ &lt; b.x_ || (a.x_ == b.x_ &amp;&amp; a.y_ &lt; b.y_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpy</span><span class="params">(node &amp;a, node &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.y_ &lt; b.y_ || (a.y_ == b.y_ &amp;&amp; a.x_ &lt; b.x_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calc</span><span class="params">(node &amp;a, node &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x_ - b.x_) * (a.x_ - b.x_) + (a.y_ - b.y_) * (a.y_ - b.y_));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>, mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="type">double</span> mi = <span class="built_in">min</span>(<span class="built_in">merge</span>(l, mid), <span class="built_in">merge</span>(mid + <span class="number">1</span>, r));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(arr[i].x_ - arr[mid].x_) &lt; mi) t[++cnt] = arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 一定要按y轴排序！</span></span><br><span class="line">  <span class="built_in">sort</span>(t + <span class="number">1</span>, t + <span class="number">1</span> + cnt, cmpy);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= cnt &amp;&amp; <span class="built_in">fabs</span>(t[i].y_ - t[j].y_) &lt; mi; ++j) &#123;</span><br><span class="line">      mi = <span class="built_in">min</span>(mi, <span class="built_in">calc</span>(t[i], t[j]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; arr[i].x_ &gt;&gt; arr[i].y_;</span><br><span class="line">  <span class="built_in">sort</span>(arr + <span class="number">1</span>, arr + <span class="number">1</span> + n, cmpx);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%.4lf&quot;</span>, <span class="built_in">merge</span>(<span class="number">1</span>, n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点讲一下为什么必须要让新数组<code>t</code>对y轴排序，这也是这部分代码为什么不是平方数量级的原因。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= cnt &amp;&amp; <span class="built_in">fabs</span>(t[i].y_ - t[j].y_) &lt; mi; ++j) &#123;</span><br><span class="line">    mi = <span class="built_in">min</span>(mi, <span class="built_in">calc</span>(t[i], t[j]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为x、y轴方向上都满足的点个数总是常数，其余再多的点都是白瞎，你要想办法去除它们的干扰。</p>
<p>只要在范围内的就判断距离，不在范围内的直接进入下一次循环就好了。</p>
<p>为了满足这种单调性，你必须对y轴排序；乱序你还怎么筛呢？</p>
<h2 id="归并实现">归并实现</h2>
<p>归并实现的时间复杂度为<span class="math inline">\(O\left( n\log n
\right)\)</span>，上面sort实现的时间复杂度为<span
class="math inline">\(O\left( n\log ^2n \right)\)</span></p>
<p>因为sort实现方法每次都调用了sort函数排序，归并实现时主体就是归并，不需要额外排序。</p>
<p>要注意！sort实现时，我们是新开了一个数组<code>t</code>来保存新的集合，并不会对原数组造成影响；</p>
<p>归并实现时，就是对原数组进行归并排序，原先的中值<code>mid</code>位置就乱了！</p>
<p>所以在排序前，<strong>一定要先保存好原始的中值</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pivot = arr[mid].x_</span><br><span class="line">···</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fabs</span>(arr[i].x_ - pivot) &lt; mi) t[++cnt] = arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样才不会影响后续对<code>x</code>轴方向集合的判断！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">double</span> x_, y_;</span><br><span class="line">&#125; arr[maxn], t[maxn], tt[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calc</span><span class="params">(node &amp;a, node &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x_ - b.x_) * (a.x_ - b.x_) + (a.y_ - b.y_) * (a.y_ - b.y_));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = l, j = l, k = mid + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= mid &amp;&amp; k &lt;= r)</span><br><span class="line">    tt[i++] = (arr[j].y_ &lt; arr[k].y_) ? arr[j++] : arr[k++];</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= mid) tt[i++] = arr[j++];</span><br><span class="line">  <span class="keyword">while</span> (k &lt;= r) tt[i++] = arr[k++];</span><br><span class="line">  <span class="keyword">for</span> (i = l; i &lt;= r; ++i) arr[i] = tt[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">  <span class="comment">// pivot保存原本的中间x值</span></span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>, mid = (l + r) / <span class="number">2</span>, pivot = arr[mid].x_;</span><br><span class="line">  <span class="type">double</span> mi = <span class="built_in">min</span>(<span class="built_in">divide</span>(l, mid), <span class="built_in">divide</span>(mid + <span class="number">1</span>, r));</span><br><span class="line">  <span class="comment">// y轴归并排序</span></span><br><span class="line">  <span class="built_in">merge_sort</span>(l, mid, r);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(arr[i].x_ - pivot) &lt; mi) t[++cnt] = arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= cnt &amp;&amp; <span class="built_in">fabs</span>(t[i].y_ - t[j].y_) &lt; mi; ++j) &#123;</span><br><span class="line">      mi = <span class="built_in">min</span>(mi, <span class="built_in">calc</span>(t[i], t[j]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; arr[i].x_ &gt;&gt; arr[i].y_;</span><br><span class="line">  <span class="built_in">sort</span>(arr + <span class="number">1</span>, arr + <span class="number">1</span> + n, [](node &amp;a, node &amp;b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.x_ &lt; b.x_ || (a.x_ == b.x_ &amp;&amp; a.y_ &lt; b.y_);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%.4lf&quot;</span>, <span class="built_in">divide</span>(<span class="number">1</span>, n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P1816. 忠诚</title>
    <url>/2024/03/04/P1816-%E5%BF%A0%E8%AF%9A/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>ST表</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> m, n, a[maxn], log_2[maxn], mi[maxn][<span class="number">17</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> k = log_2[r - l + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">min</span>(mi[l][k], mi[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= m; ++i) log_2[i] = log_2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) mi[i][<span class="number">0</span>] = a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= m; ++j) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= m; ++i) &#123;</span><br><span class="line">      mi[i][j] = <span class="built_in">min</span>(mi[i][j - <span class="number">1</span>], mi[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">query</span>(l, r) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>ST表的模板题，不再赘述。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title>P1908. 逆序对</title>
    <url>/2024/03/02/P1908-%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
<li>树状数组</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<h2 id="归并排序">归并排序</h2>
<p>考虑归并排序时的合并操作，以下图为例，游标j的移动范围为<code>1~4</code>，游标k的移动范围为<code>5~8</code></p>
<p>左边界<code>l</code>为下标1，右边界<code>r</code>为下标8</p>
<img src="/2024/03/02/P1908-%E9%80%86%E5%BA%8F%E5%AF%B9/1.png" class="" title="image-20240302202741504">
<p>第一轮：j = 1，k =
5，<code>a[j] = 1 &lt; a[k] = 2</code>且<code>j &lt; k</code>，<code>a[j]</code>纳入答案且<code>j++</code></p>
<p>第二轮：j = 2，k =
5，<code>a[j] = 3 &gt; a[k] = 2</code>且<code>j &lt; k</code>，<code>a[k]</code>纳入答案且<code>k++</code></p>
<p>注意！这里出现了3个逆序对，<code>a[5]</code>小于<code>&#123;a[2]，a[3]，a[4]&#125;</code>，但下标却大于它们。</p>
<p>这样就能得到逆序对的公式：<code>((l + r) / 2) - j + 1</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, a[maxn], t[maxn];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> i = l, j = l, mid = (l + r) / <span class="number">2</span>, k = mid + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">merge</span>(l, mid), <span class="built_in">merge</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= mid &amp;&amp; k &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[j] &lt;= a[k]) &#123;</span><br><span class="line">      t[i++] = a[j++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      t[i++] = a[k++];</span><br><span class="line">      ans += mid - j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= mid) t[i++] = a[j++];</span><br><span class="line">  <span class="keyword">while</span> (k &lt;= r) t[i++] = a[k++];</span><br><span class="line">  <span class="keyword">for</span> (i = l; i &lt;= r; ++i) a[i] = t[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="built_in">merge</span>(<span class="number">1</span>, n);</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="权值树状数组">权值树状数组</h2>
<p>先离散化，得知每个元素的排名；</p>
<p>倒序遍历数组，统计<strong>比当前元素排名小的个数</strong>，即为逆序对；然后再把该元素添加进树状数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e5</span> + <span class="number">50</span>;</span><br><span class="line">ll n, ans, dtot, a[maxn], bit[maxn], dis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">    bit[x] += v;</span><br><span class="line">    x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  ll res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    res += bit[x];</span><br><span class="line">    x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i], dis[++dtot] = a[i];</span><br><span class="line">  <span class="built_in">sort</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + dtot);</span><br><span class="line">  dtot = <span class="built_in">unique</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + dtot) - <span class="number">1</span> - dis;</span><br><span class="line">  ll res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> rk, i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">    rk = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + dtot, a[i]) - dis;</span><br><span class="line">    res += <span class="built_in">query</span>(rk - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(rk, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; res;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>P1966. 火柴排队</title>
    <url>/2024/03/03/P1966-%E7%81%AB%E6%9F%B4%E6%8E%92%E9%98%9F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>

$$
\sum{\left( a_i-b_i \right) ^2}\rightarrow \sum{{a_i}^2+{b_i}^2-2a_ib_i}\rightarrow \underset{A}{\underbrace{\sum{{a_i}^2+{b_i}^2}}}-\underset{B}{\underbrace{2\sum{a_ib_i}}}
$$


<p>由上述式子展开发现，A式其实是不变的；要让整体最小，a、b数组对应位置的元素乘积就要最大。</p>
<p>由<a
href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E4%B8%8D%E7%AD%89%E5%BC%8F">排序不等式</a>可知，若把两数组排序后，对于每个<code>k</code>，将第<code>k</code>小的a<sub>k</sub>元素与第<code>k</code>小的b<sub>k</sub>元素配对可得到最大乘积。</p>
<p>通俗点说，a<sub>i</sub>在a数组的大小排名应该等于b<sub>i</sub>在b数组的大小排名。</p>
<h2 id="数组转换法必须掌握">数组转换法（必须掌握）</h2>
<p>由于是比较排名，先对a、b两数组进行离散化，得到如下数据：</p>
<p><code>a = &#123;1, 3, 4, 2, 5&#125;</code>，<code>b = &#123;3, 2, 5, 4, 1&#125;</code></p>
<p>此时要求数组a转换为数组b需要交换元素的次数。</p>
<p>正常情况下，数组通过下面的映射规律后再排序（只是平常没有感觉）</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">数组值(值)</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">数组下标(键)</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
</tr>
</tbody>
</table>
<p>如果此时将数组b作为新的映射规律后：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">数组值(值)</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">数组下标(键)</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>那么数组a在b的映射下，就会变成<code>a = &#123;1 -&gt; 5, 3 -&gt; 1, 4 -&gt; 4, 2 -&gt; 2, 5 -&gt; 3&#125;</code>，</p>
<p>即<code>a = &#123;5, 1, 4, 2, 3&#125;</code></p>
<p>接下来就是求此时的数组a排序的交换元素次数，直接累计所有元素的逆序对个数即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e8</span> - <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> n, a[maxn], b[maxn], mp[maxn];</span><br><span class="line"><span class="type">int</span> atot, btot, da[maxn], db[maxn];</span><br><span class="line">ll ans, bit[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (x &lt;= n) bit[x] += v, x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  ll res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (x &gt; <span class="number">0</span>) res += bit[x], x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离散化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i], da[i] = a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; b[i], db[i] = b[i];</span><br><span class="line">  <span class="built_in">sort</span>(da + <span class="number">1</span>, da + <span class="number">1</span> + n), <span class="built_in">sort</span>(db + <span class="number">1</span>, db + <span class="number">1</span> + n);</span><br><span class="line">  atot = <span class="built_in">unique</span>(da + <span class="number">1</span>, da + <span class="number">1</span> + n) - <span class="number">1</span> - da;</span><br><span class="line">  btot = <span class="built_in">unique</span>(db + <span class="number">1</span>, db + <span class="number">1</span> + n) - <span class="number">1</span> - db;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    a[i] = <span class="built_in">lower_bound</span>(da + <span class="number">1</span>, da + <span class="number">1</span> + atot, a[i]) - da;</span><br><span class="line">    b[i] = <span class="built_in">lower_bound</span>(db + <span class="number">1</span>, db + <span class="number">1</span> + btot, b[i]) - db;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) mp[b[i]] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = mp[a[i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">dis</span>();</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">    ans = (ans + <span class="built_in">query</span>(a[i] - <span class="number">1</span>)) % mod;</span><br><span class="line">    <span class="built_in">add</span>(a[i], <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取巧">取巧</h2>
<p>本题可以不用像上面一样更改映射，保持默认的映射即可：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">数组值(值)</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">数组下标(键)</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
</tr>
</tbody>
</table>
<p>用结构体数组a、b分别记录原a、b数组每个元素的值<code>val</code>以及元素的下标<code>pos</code>，</p>
<p>结构体数组a、b分别对<code>val</code>排序，该操作可以理解为，<strong>以默认映射为标准进行对齐</strong>，</p>
<p>对齐之后，a<sub>i</sub>和b<sub>i</sub>的<code>val</code>在各自原数组内的排名都是一致的；</p>
<p>为满足题意要求，按道理a<sub>i</sub>和b<sub>i</sub>的<code>pos</code>也应该一样；如果不一样，须让a[i].pos朝b[i].pos对齐，</p>
<p>那么设新的映射数组<code>mp[b[i].pos] = a[i].pos</code>，mp排序时的逆序对总数即为答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>, mod = <span class="number">1e8</span> - <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> n, mp[maxn], t[maxn];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> val_, pos_;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node &amp;x) &#123; <span class="keyword">return</span> val_ &lt; x.val_; &#125;</span><br><span class="line">&#125; a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> i = l, j = l, mid = (l + r) / <span class="number">2</span>, k = mid + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">merge</span>(l, mid), <span class="built_in">merge</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= mid &amp;&amp; k &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mp[j] &lt;= mp[k]) &#123;</span><br><span class="line">      t[i++] = mp[j++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      t[i++] = mp[k++];</span><br><span class="line">      ans = (ans + mid - j + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= mid) t[i++] = mp[j++];</span><br><span class="line">  <span class="keyword">while</span> (k &lt;= r) t[i++] = mp[k++];</span><br><span class="line">  <span class="keyword">for</span> (i = l; i &lt;= r; ++i) mp[i] = t[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i].val_, a[i].pos_ = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; b[i].val_, b[i].pos_ = i;</span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n), <span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) mp[b[i].pos_] = a[i].pos_;</span><br><span class="line">  <span class="built_in">merge</span>(<span class="number">1</span>, n);</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P2415. 集合求和</title>
    <url>/2024/03/04/P2415-%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>排列组合</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> x, cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; x) &#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    sum += x;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; sum * (<span class="number">1</span> &lt;&lt; (cnt - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>对于每个元素<code>x</code>来说，它对子集和的贡献为： <span
class="math display">\[
x\cdot \left( \underset{\text{只含自己}}{\left( \begin{array}{c}
    n-1\\
    0\\
\end{array} \right)}+\underset{\text{选}1\text{个匹配}}{\left(
\begin{array}{c}
    n-1\\
    1\\
\end{array} \right)}+\underset{\text{选}2\text{个匹配}}{\left(
\begin{array}{c}
    n-1\\
    2\\
\end{array} \right)}+\cdots +\underset{\text{选}n-1\text{个匹配}}{\left(
\begin{array}{c}
    n-1\\
    n-1\\
\end{array} \right)} \right)
\]</span> 显然可以变成： <span class="math display">\[
x\cdot 2^{n-1}
\]</span> 那么最终的子集和就是： <span class="math display">\[
2^{n-1}\cdot \sum{\begin{array}{c}
    n\\
    i=1\\
\end{array}x_i}
\]</span></p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>P2345. MooFest G</title>
    <url>/2024/03/13/P2345-MooFest-G/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>cdq分治</li>
<li>树状数组</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见<a href="https://www.luogu.com.cn/problem/P5094">P5094. MooFest
G</a></p>
<h1 id="思路">思路</h1>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P3810. 三维偏序</title>
    <url>/2024/03/10/P3810-%E4%B8%89%E7%BB%B4%E5%81%8F%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>cdq分治</li>
<li>树状数组</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, k, bit[maxn], ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (x &lt;= k) bit[x] += v, x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (x &gt; <span class="number">0</span>) res += bit[x], x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="comment">// sum_：与本元素不同的元素对其贡献</span></span><br><span class="line">  <span class="comment">// cnt_：与本元素相同的元素有几个（包括本元素）</span></span><br><span class="line">  <span class="type">int</span> sum_, cnt_;</span><br><span class="line">  <span class="type">int</span> a_, b_, c_;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(node &amp;b) &#123; <span class="keyword">return</span> a_ == b.a_ &amp;&amp; b_ == b.b_ &amp;&amp; c_ == b.c_; &#125;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpa</span><span class="params">(node &amp;a, node &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.a_ &lt; b.a_ || (a.a_ == b.a_ &amp;&amp; a.b_ &lt; b.b_) ||</span><br><span class="line">         (a.a_ == b.a_ &amp;&amp; a.b_ == b.b_ &amp;&amp; a.c_ &lt; b.c_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpb</span><span class="params">(node &amp;a, node &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.b_ &lt; b.b_ || (a.b_ == b.b_ &amp;&amp; a.c_ &lt; b.c_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdq</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">cdq</span>(l, mid), <span class="built_in">cdq</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="type">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; a[i].b_ &lt;= a[j].b_) &#123;</span><br><span class="line">      <span class="built_in">add</span>(a[i].c_, a[i].cnt_), ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j].sum_ += <span class="built_in">query</span>(a[j].c_), ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= mid) <span class="built_in">add</span>(a[i].c_, a[i].cnt_), ++i;</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= r) a[j].sum_ += <span class="built_in">query</span>(a[j].c_), ++j;</span><br><span class="line">  <span class="keyword">for</span> (i = l; i &lt;= mid; ++i) <span class="built_in">add</span>(a[i].c_, -a[i].cnt_);</span><br><span class="line">  <span class="built_in">sort</span>(a + l, a + r + <span class="number">1</span>, cmpb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i].a_ &gt;&gt; a[i].b_ &gt;&gt; a[i].c_;</span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, cmpa);</span><br><span class="line">  <span class="type">int</span> m = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 模拟unique函数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    <span class="keyword">if</span> (!(a[i] == a[i + <span class="number">1</span>])) &#123;</span><br><span class="line">      a[++m] = a[i];</span><br><span class="line">      a[m].cnt_ = cnt, cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cdq</span>(<span class="number">1</span>, m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ans[a[i].sum_ + a[i].cnt_ - <span class="number">1</span>] += a[i].cnt_;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>一维偏序是排序，二维偏序是排序+树状数组，三维偏序是排序+cdq+树状数组</p>
<blockquote>
<p>本题下标没有限制，只是说<code>i != j</code>；如果是<code>i &lt; j</code>，那么就是四维了</p>
</blockquote>
<p>先对a排序，那么左半部分<code>[l, mid]</code>的a一定小于等于右半部分<code>[mid+1, r]</code>的a，a条件就成功降维了。</p>
<p>对左右两半各分治，分治之后的合并是最关键的部分；尽管左右两半部分先进行了分治，内部顺序可能是乱的；</p>
<p>但由于一开始我们是对a排序了的，<code>[l, mid]</code>的a还是必小于等于<code>[mid+1, r]</code>的a，不影响。</p>
<hr />
<p>然后分别对<code>[l, mid]</code>、<code>[mid+1, r]</code>的b排序，令游标<code>i</code>归属<code>[l, mid]</code>，游标<code>j</code>归属<code>[mid+1, r]</code>。</p>
<p>只要<code>j</code>的b是大于等于<code>i</code>的b，<code>i</code>就一直往后移，并且把<code>i</code>的c纳入到树状数组去；</p>
<p>那么对于<code>j</code>而言，三维都满足条件的个数显然等于树状数组中<code>[1, j的c]</code>的个数。</p>
<hr />
<p>注意！上述方法只考虑了不同元素之间的贡献，并没有考虑相同元素，举个例子：</p>
<blockquote>
<p>3 2</p>
<p>1 1 1 1 1 1 2 2 2</p>
</blockquote>
<p>如果按照上面的方法，答案是<code>1 1 1</code>，解释如下：</p>
<ul>
<li>第一个元素<code>1 1 1</code>没有满足三维条件的</li>
<li>第二个元素<code>1 1 1</code>有一个满足三维条件的，即第一个元素</li>
<li>第三个元素<code>2 2 2</code>有两个满足三维条件的，即第一、第二个元素</li>
</ul>
<p>但答案应该是<code>0 2 1</code>，解释如下：</p>
<ul>
<li>第一个元素<code>1 1 1</code>有一个满足三维条件的，即第二个元素</li>
<li>第二个元素<code>1 1 1</code>有一个满足三维条件的，即第一个元素</li>
<li>第三个元素<code>2 2 2</code>有两个满足三维条件的，即第一、第二个元素</li>
</ul>
<p>因为题目并没有限制<code>i</code>与<code>j</code>的大小关系所致。</p>
<p>可以发现，相同元素之间的贡献其实就等于<code>相同元素个数 - 1</code></p>
<p>所以在正式做cdq分治之前，应该统计一下每种元素的个数，用<code>cnt</code>保存</p>
<p>所以最终得到式子：</p>
<p><code>本元素受到的贡献 = 不同元素对本元素的贡献 + 相同元素对本元素的贡献 = sum + cnt - 1</code></p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P6648. Triangle The Data Structure</title>
    <url>/2024/03/15/P6648-Triangle-The-Data-Structure/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>st表</li>
<li>单调队列</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">3e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, K, lg, head, tail, q[maxn], st[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= lg; ++k) &#123;</span><br><span class="line">    <span class="type">int</span> r = n - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>, v = <span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">      head = tail = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; ++j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (head &lt; tail &amp;&amp; st[i + v][j] &gt;= st[i + v][q[tail - <span class="number">1</span>]]) --tail;</span><br><span class="line">        q[tail++] = j;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (head &lt; tail &amp;&amp; j + v - q[head] &gt; v) ++head;</span><br><span class="line">        <span class="keyword">while</span> (head &lt; tail &amp;&amp; st[i + v][j + v] &gt;= st[i + v][q[tail - <span class="number">1</span>]])</span><br><span class="line">          --tail;</span><br><span class="line">        q[tail++] = j + v;</span><br><span class="line">        st[i][j] = <span class="built_in">max</span>(st[i][j], st[i + v][q[head]]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> r = n - K + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">    head = tail = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = i + K - (<span class="number">1</span> &lt;&lt; lg), v = cnt - i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; ++j) &#123;</span><br><span class="line">      <span class="keyword">while</span> (head &lt; tail &amp;&amp; st[cnt][j] &gt;= st[cnt][q[tail - <span class="number">1</span>]]) --tail;</span><br><span class="line">      q[tail++] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">      <span class="keyword">while</span> (head &lt; tail &amp;&amp; j + v - q[head] &gt; v) ++head;</span><br><span class="line">      <span class="keyword">while</span> (head &lt; tail &amp;&amp; st[cnt][j + v] &gt;= st[cnt][q[tail - <span class="number">1</span>]]) --tail;</span><br><span class="line">      q[tail++] = j + v;</span><br><span class="line">      ans += <span class="built_in">max</span>(st[i][j], st[cnt][q[head]]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">  lg = <span class="built_in">log2</span>(K);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">      cin &gt;&gt; st[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  cout &lt;&lt; <span class="built_in">work</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>考虑类似ST表的做法。</p>
<p>令<code>st[i][j][k]</code>代表以<code>(i, j)</code>为顶点，边长为2<sup>k</sup>的正三角形的最大值，可以得到：
<span class="math display">\[
st\left[ i \right] \left[ j \right] \left[ k \right] =\max \left(
\begin{matrix}
    st\left[ i \right] \left[ j \right] \left[ k-1 \right]
,&amp;       \max \begin{array}{c}
    j+2^{k-1}\\
    t=j\\
\end{array}st\left[ i+2^{k-1} \right] \left[ t \right] \left[ k-1
\right]\\
\end{matrix} \right)
\]</span> 可能文字有点抽象，我画个图：</p>
<p>每个大的、边长为4的蓝色三角形，由一个边长为2的紫色三角形和若干个边长为2的红色三角形组成。</p>
<p>假设当前大蓝色三角形顶点为<code>(i, j)</code>，长度为2<sup>k</sup>，可以发现以下规律：</p>
<ul>
<li><p>只有一个顶点为<code>(i, j)</code>，长度为2<sup>k-1</sup>的紫色三角形</p></li>
<li><p>从第i + 2<sup>k-1</sup>行、第j列开始，有连续2<sup>k-1</sup> +
1个，长度为2<sup>k-1</sup>的红色三角形</p>
<p>是<strong>1 + 2<sup>k-1</sup></strong>个！</p></li>
<li><p>第<code>i</code>行有<code>i</code>个点</p></li>
</ul>
<p>根据上述规则进行编程，可以发现几个优化点：</p>
<ul>
<li><p>st表数组的第三维可以用滚动数组的思想去掉，毕竟只需要上一次的数据</p></li>
<li><p>幂次枚举到<code>log2(k)</code>即可</p></li>
<li><p>求每个蓝色三角形中红色三角形们的极值，可以用单调队列进行优化</p>
<p>从图上可以显然发现，红色三角形们都是挨着的——</p>
<p>所以可以先填充2<sup>k-1</sup>个红色三角形到单调队列中，然后每右移1个红色三角形，蓝色三角形顶点也右移1个</p>
<p>即可达到线性同步更新的骚操作~</p></li>
</ul>
<img src="/2024/03/15/P6648-Triangle-The-Data-Structure/1.png" class="" title="image-20240315212909811">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title>P7167. Fountain</title>
    <url>/2024/03/06/P7167-Fountain/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>单调栈</li>
<li>倍增</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, q, f[maxn][<span class="number">20</span>], g[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> st[maxn], top;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> d_, v_, nxt_;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i].d_ &gt;&gt; a[i].v_;</span><br><span class="line">  ++n;</span><br><span class="line">  a[n].d_ = a[n].v_ = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">  <span class="comment">// 单调栈求nxt</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; a[i].d_ &gt; a[st[top]].d_) a[st[top--]].nxt_ = i;</span><br><span class="line">    st[++top] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (top &gt; <span class="number">0</span>) a[st[top--]].nxt_ = n;</span><br><span class="line">  <span class="comment">// 倍增</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) f[i][<span class="number">0</span>] = a[i].nxt_, g[i][<span class="number">0</span>] = a[i].v_;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">18</span>; ++j) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      f[i][j] = f[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">      g[i][j] = g[i][j - <span class="number">1</span>] + g[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> r, v;</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    cin &gt;&gt; r &gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">18</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (v &gt; g[r][i]) &#123;</span><br><span class="line">        v -= g[r][i];</span><br><span class="line">        r = f[r][i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (r == n ? <span class="number">0</span> : r) &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>把盘子们倒过来看，俨然是一个结构体数组：</p>
<img src="/2024/03/06/P7167-Fountain/1.png" class="" title="64e7acuq">
<p>设盘子结构体如下，设水池也为一个直径无穷大、容积无穷大的盘子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> d_, v_, nxt_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>d</code>代表直径，<code>v</code>代表容积，<code>nxt</code>代表右侧第一个大于<code>d</code>的盘子。</p>
<p>每个盘子都要向右找第一个大于自己<code>d</code>的盘子（除了水池），维护一个单调不增（单调递减or相等）的单调栈即可。</p>
<p>普通情况下，每次询问都一层层跑<code>nxt</code>，整个过程就是链式的<span
class="math inline">\(O(n)\)</span>复杂度，肯定TLE。</p>
<img src="/2024/03/06/P7167-Fountain/2.png" class="" title="image-20240306015337610">
<p>用LCA的倍增实现跳链，那么水池就是根结点，每个结点的<code>nxt</code>序列抽象为树的路径：</p>
<p>令<code>f[i][j]</code>为盘子<code>i</code>跳2<sup>j</sup>个盘子后到达的盘子，有<code>f[i][j] = f[f[i][j-1]][j-1]</code></p>
<p>显然初始时<code>f[i][0] = 盘子i的nxt</code></p>
<p>令<code>g[i][j]</code>为盘子<code>i</code>跳到<code>f[i][j]</code>所需要的容积，有<code>g[i][j] = g[i][j - 1] + g[f[i][j - 1]][j - 1]</code></p>
<p>显然初始时<code>g[i][0] = 盘子i的v</code>，至少大于当前盘子的容积才能流到下个盘子不是吗？</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>P3509. ZAB-Frog</title>
    <url>/2024/03/13/P3509-ZAB-Frog/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>双指针</li>
<li>倍增</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line">ll n, k, m, a[maxn], nxt[maxn], fa[maxn][<span class="number">62</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 每个元素的第k远</span></span><br><span class="line">  <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1</span> + k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (r + <span class="number">1</span> &lt;= n &amp;&amp; a[r + <span class="number">1</span>] - a[i] &lt; a[i] - a[l]) ++l, ++r;</span><br><span class="line">    nxt[i] = a[r] - a[i] &gt; a[i] - a[l] ? r : l;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 倍增优化跳链，初始化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i][<span class="number">0</span>] = nxt[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">61</span>; ++j) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      fa[i][j] = fa[fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(<span class="type">int</span> bg, ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">61</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= (<span class="number">1ll</span> &lt;&lt; i)) &#123;</span><br><span class="line">      bg = fa[bg][i];</span><br><span class="line">      x -= (<span class="number">1ll</span> &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; k &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cout &lt;&lt; <span class="built_in">jump</span>(i, m) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>最大的难点在于计算每个元素的第k远。</p>
<p>其实翻译的语义是有问题的，英文原话明明是叫你找<strong>第K小</strong>.....</p>
<p>假设对于点A有距离数组<code>&#123;5, 4, 3, A, 1, 2, 8&#125;</code>，</p>
<p>第1小跳到元素<code>1</code>，第2小跳到元素<code>2</code>，第3小跳到元素<code>3</code>，第4小跳到元素<code>4</code>，第5小元素<code>5</code>，第6小元素<code>8</code></p>
<p>以当前元素A做距离数组，用双指针维护一个长度为<code>k + 1</code>的滑动窗口，</p>
<p>在滑动窗口中，A的左边称之为<strong>左半部分</strong>，A的右边称之为<strong>右半部分</strong>，移动流程如下：</p>
<img src="/2024/03/13/P3509-ZAB-Frog/1.png" class="" title="image-20240313172138424">
<p>最后比较左、右两部分谁的最大值更大即可。</p>
<p>还有一个难点，为什么可以用滑动窗口，前一个元素不会影响后一个元素的结果吗？</p>
<p>那就证明一下：</p>
<img src="/2024/03/13/P3509-ZAB-Frog/2.png" class="" title="image-20240313175515000">
<p>假设D的答案是A，那么<span class="math inline">\(\left| ED
\right|&gt;\left| AD \right|\)</span></p>
<p>又因为已知元素C的答案为B，那么<span class="math inline">\(\left| AC
\right|&gt;\left| EC \right|\)</span>，一定有<span
class="math inline">\(\left| AD \right|&gt;\left| ED
\right|\)</span></p>
<p>两者相悖，反证法毕。</p>
<hr />
<p>后续直接用倍增优化跳链即可，不再赘述。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>P4155. 国旗计划</title>
    <url>/2024/03/16/P4155-%E5%9B%BD%E6%97%97%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>倍增</li>
<li>贪心</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e5</span> + <span class="number">50</span>;</span><br><span class="line">ll n1, n2, m, ans[maxn], f[maxn][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  ll id_, c_, d_;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node &amp;b) &#123; <span class="keyword">return</span> c_ &lt; b.c_ || (c_ == b.c_ &amp;&amp; d_ &lt; b.d_); &#125;</span><br><span class="line">&#125; s[<span class="number">2</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 断环为链</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i].d_ &lt; s[i].c_) s[i].d_ += m;</span><br><span class="line">    s[i + n1] = s[i], s[i + n1].c_ += m, s[i + n1].d_ += m;</span><br><span class="line">  &#125;</span><br><span class="line">  n2 = n1 * <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 求每个元素的下一跳</span></span><br><span class="line">  <span class="built_in">sort</span>(s + <span class="number">1</span>, s + <span class="number">1</span> + n2);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n2; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= n2 &amp;&amp; s[j].c_ &lt;= s[i].d_) ++j;</span><br><span class="line">    f[i][<span class="number">0</span>] = j - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 倍增初始化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n1; ++j) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n2; ++i) &#123;</span><br><span class="line">      f[i][j] = f[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  ll bg = x, ed = s[x].c_ + m, cnt = <span class="number">1</span>, nxt;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    nxt = f[x][i];</span><br><span class="line">    <span class="keyword">if</span> (nxt &amp;&amp; s[nxt].d_ &lt; ed) &#123;</span><br><span class="line">      x = f[x][i];</span><br><span class="line">      cnt += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ans[s[bg].id_] = cnt + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n1 &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; ++i) cin &gt;&gt; s[i].c_ &gt;&gt; s[i].d_, s[i].id_ = i;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; ++i) <span class="built_in">work</span>(i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; ++i) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>断环为链+左端点排序后，变成如下模样：</p>
<p>假设从<code>2</code>出发，题目是问你到达<code>2 + 8 = 10</code>最少需要几个人，
即第二圈（断环为链的美妙）</p>
<img src="/2024/03/16/P4155-%E5%9B%BD%E6%97%97%E8%AE%A1%E5%88%92/1.png" class="" title="image-20240315233649468">
<p>题目已经说了，跳跃区间彼此不会包含；</p>
<p>通过对链的左端点排序之后，沿着跳跃区间走，只会前进不会回头，很重要的单调性！</p>
<p>由于题目要寻找最少的人数，每个战士应该把接力棒交给离他尽可能远、但在当前范围内的人，即最远下一跳；</p>
<p>所以利用上述单调性，直接用双指针线性时间复杂度就能处理好，如图所示：</p>
<p><code>a</code>的最远下一跳是<code>c</code>，显然<code>b</code>的最远下一跳至少是<code>c</code>；所以不可能回头，可以用双指针</p>
<img src="/2024/03/16/P4155-%E5%9B%BD%E6%97%97%E8%AE%A1%E5%88%92/2.png" class="" title="image-20240315235644540">
<p>跳跃过程结合上述每个人的最远下一跳，直接套倍增板子即可~</p>
<p>最后一个难点，我跳过终点也算第二圈，刚好跳到终点同样算第二圈，怎么计数？</p>
<p><code>最终答案 = 尽可能逼近终点（不是等于，也不是大于，是小于！）所需的最少人数 + 1</code></p>
<p>因为题目说过<code>数据保证整个边境线都是可被覆盖的</code>，去掉等于或大于终点的最后一人，那之前所有人不都在终点以内吗？</p>
<p>正难则反哟！</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>P7883. 平面最近点对</title>
    <url>/2024/03/06/P7883-%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>分治</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  ll x_, y_;</span><br><span class="line">&#125; arr[maxn], t[maxn], tt[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(node &amp;a, node &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a.x_ - b.x_) * (a.x_ - b.x_) + (a.y_ - b.y_) * (a.y_ - b.y_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = l, j = l, k = mid + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= mid &amp;&amp; k &lt;= r)</span><br><span class="line">    tt[i++] = (arr[j].y_ &lt; arr[k].y_) ? arr[j++] : arr[k++];</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= mid) tt[i++] = arr[j++];</span><br><span class="line">  <span class="keyword">while</span> (k &lt;= r) tt[i++] = arr[k++];</span><br><span class="line">  <span class="keyword">for</span> (i = l; i &lt;= r; ++i) arr[i] = tt[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">divide</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span> LLONG_MAX;</span><br><span class="line">  <span class="comment">// pivot保存原本的中间x值</span></span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>, mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  ll pivot = arr[mid].x_, mi = <span class="built_in">min</span>(<span class="built_in">divide</span>(l, mid), <span class="built_in">divide</span>(mid + <span class="number">1</span>, r));</span><br><span class="line">  <span class="comment">// y轴归并排序</span></span><br><span class="line">  <span class="built_in">merge_sort</span>(l, mid, r);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((arr[i].x_ - pivot) * (arr[i].x_ - pivot) &lt; mi) t[++cnt] = arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">         j &lt;= cnt &amp;&amp; (t[i].y_ - t[j].y_) * (t[i].y_ - t[j].y_) &lt; mi; ++j) &#123;</span><br><span class="line">      mi = <span class="built_in">min</span>(mi, <span class="built_in">calc</span>(t[i], t[j]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; arr[i].x_ &gt;&gt; arr[i].y_;</span><br><span class="line">  <span class="built_in">sort</span>(arr + <span class="number">1</span>, arr + <span class="number">1</span> + n, [](node &amp;a, node &amp;b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.x_ &lt; b.x_ || (a.x_ == b.x_ &amp;&amp; a.y_ &lt; b.y_);</span><br><span class="line">  &#125;);</span><br><span class="line">  cout &lt;&lt; <span class="built_in">divide</span>(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>见<strong>P1429. 平面最近点对</strong>，只是数据类型变了。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>ST表_解题技巧</title>
    <url>/2024/03/04/ST%E8%A1%A8-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="技巧">技巧</h1>
<p>参考<a href="https://oi-wiki.org/ds/sparse-table/">OIWiki</a></p>
<h1 id="练习题">练习题</h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P2880">P2880</a>
掌握ST表的两种写法，很关键！</li>
<li><a href="https://www.luogu.com.cn/problem/P1816">P1816</a>
模板题</li>
<li><a href="https://www.luogu.com.cn/problem/P6648">P6648</a>
绝世好题！三角形ST表+单调队列</li>
</ul>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-135. 最大子序和</title>
    <url>/2024/03/13/acwing-135-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>单调队列</li>
<li>前缀和</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">3e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, head, tail, a[maxn], q[maxn];</span><br><span class="line">ll sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  ll ans = INT_MIN;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i], sum[i] = a[i] + sum[i - <span class="number">1</span>];</span><br><span class="line">  q[tail++] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail &amp;&amp; q[head] &lt; i - m) ++head;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, sum[i] - sum[q[head]]);</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail &amp;&amp; sum[q[tail - <span class="number">1</span>]] &gt;= sum[i]) --tail;</span><br><span class="line">    q[tail++] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>直接上图。</p>
<img src="/2024/03/13/acwing-135-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/1.jpg" class="" title="dbda42c3199a9b780e84ecbb2aa98fa">
<img src="/2024/03/13/acwing-135-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/2.jpg" class="" title="e6261f3c74c964777fa5a7c4ae70acb">
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>cdq分治_解题技巧</title>
    <url>/2024/03/09/cdq%E5%88%86%E6%B2%BB-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="和普通分治的区别">和普通分治的区别</h1>
<p>普通分治是左、右两边各处理各的，然后合并一下结果；</p>
<p>cdq分治是左、右两边各处理各的之后，再处理某一半区间对另一半区间的贡献。</p>
<h1 id="编程技巧">编程技巧</h1>
<p><code>sort</code>排序可以放到最后，以优化时间复杂度，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdq</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">cdq</span>(l, mid), <span class="built_in">cdq</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">sort</span>(a + l, a + r + <span class="number">1</span>, cmpx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="练习题">练习题</h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3810">P3810</a>
三维偏序的模板题</li>
<li><a href="https://www.luogu.com.cn/problem/P5094">P5094</a>、<a
href="https://www.luogu.com.cn/problem/P2345">P2345</a> 也是模板题</li>
</ul>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P5094. MooFest G</title>
    <url>/2024/03/13/P5094-MooFest-G/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>cdq分治</li>
<li>树状数组</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<h2 id="树状数组">树状数组</h2>
<p>先对<code>v</code>排序。</p>
<p>这样一来，当前元素<code>i</code>与其之前的所有元素<code>j</code>相比较，都会取v<sub>i</sub></p>
<p>若x<sub>i</sub>大于x<sub>j</sub>，取x<sub>i</sub> -
x<sub>j</sub>；若x<sub>i</sub>小于等于x<sub>j</sub>，取x<sub>j</sub> -
x<sub>i</sub>；所以要分类讨论不同<code>j</code>对<code>i</code>的贡献。</p>
<p>假设x<sub>j</sub>中小于等于x<sub>i</sub>的个数为<code>cnt1</code>，大于x<sub>i</sub>的个数为<code>cnt2</code>;</p>
<p>x<sub>j</sub>中小于等于x<sub>i</sub>的数字之和为<code>sum1</code>，大于x<sub>i</sub>的数字之和为<code>sum2</code>；</p>
<p>显然，<code>j</code>对<code>i</code>的贡献有如下等式：</p>
<ul>
<li><p>x<sub>j</sub>中小于等于x<sub>i</sub>的部分</p>
<p><code>cnt1 * xi - sum1</code></p></li>
<li><p>x<sub>j</sub>中大于x<sub>i</sub>的部分</p>
<p><code>sum2 - cnt2 * xi</code></p></li>
</ul>
<p>两部分相加即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="comment">// sum：统计和的树状数组；cnt：统计个数的树状数组</span></span><br><span class="line">ll n, ans, sum[maxn], cnt[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll bit[], <span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (x &lt;= maxn) bit[x] += v, x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll bit[], <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  ll res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (x &gt; <span class="number">0</span>) res += bit[x], x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> v_, x_;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node &amp;b) &#123; <span class="keyword">return</span> v_ &lt; b.v_ || (v_ == b.v_ &amp;&amp; x_ &lt; b.x_); &#125;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i].v_ &gt;&gt; a[i].x_;</span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">  <span class="comment">// tot不能改成query(sum, maxn)，会TLE</span></span><br><span class="line">  ll tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="comment">// cnt1：小于等于我的个数；cnt2：大于我的个数</span></span><br><span class="line">    ll cnt1 = <span class="built_in">query</span>(cnt, a[i].x_), cnt2 = i - <span class="number">1</span> - cnt1;</span><br><span class="line">    <span class="comment">// sum1：小于等于我的数字之和，sum2：大于我的数字之和</span></span><br><span class="line">    ll sum1 = <span class="built_in">query</span>(sum, a[i].x_), sum2 = tot - sum1;</span><br><span class="line">    ans += a[i].v_ * (cnt1 * a[i].x_ - sum1);</span><br><span class="line">    ans += a[i].v_ * (sum2 - cnt2 * a[i].x_);</span><br><span class="line">    tot += a[i].x_;</span><br><span class="line">    <span class="built_in">add</span>(sum, a[i].x_, a[i].x_), <span class="built_in">add</span>(cnt, a[i].x_, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cdq分治">cdq分治</h2>
<p>上述思路可以发现，实际上就是将数组拆成两半，计算左半部分对右半部分的贡献，这正是cdq分治的模板题。</p>
<p>先对<code>v</code>排序，左半部分的<code>v</code>肯定小于等于右半部分的<code>v</code>，然后左右部分各执行cdq分治。</p>
<p>左右部分合并时，先各自对<code>x</code>排序，令左半部分游标为<code>j</code>，右半部分游标为<code>k</code>；</p>
<p>每次<code>j</code>找到第一个x值大于<code>k</code>时停止，此时<code>[l, j - 1]</code>区间内的任意x值必小于等于<code>k</code>的x值，该区间和即为<code>sum1</code>;</p>
<p>而<code>sum2 = 左半部分整体和 - sum1</code>，左半部分整体和可以直接扫一遍<code>[l, mid]</code>累加得到，也才线性复杂度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e4</span> + <span class="number">50</span>;</span><br><span class="line">ll n, ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> v_, x_;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpv</span><span class="params">(node &amp;a, node &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.v_ &lt; b.v_ || (a.v_ == b.v_ &amp;&amp; a.x_ &lt; b.x_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpx</span><span class="params">(node &amp;a, node &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.x_ &lt; b.x_ || (a.x_ == b.x_ &amp;&amp; a.v_ &lt; b.v_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdq</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">cdq</span>(l, mid), <span class="built_in">cdq</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="comment">// sum1：左半部分小于等于xk的总和；sum2：左半部分大于xk的总和</span></span><br><span class="line">  ll sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// cnt1：左半部分小于等于xk的个数；cnt2：左半部分大于xk的个数</span></span><br><span class="line">  <span class="type">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// j：左半部分游标；k：右半部分游标</span></span><br><span class="line">  <span class="type">int</span> j = l, k = mid + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= mid; ++i) sum2 += a[i].x_;</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= mid &amp;&amp; k &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= mid &amp;&amp; a[j].x_ &lt;= a[k].x_)</span><br><span class="line">      sum1 += a[j].x_, sum2 -= a[j].x_, ++j;</span><br><span class="line">    cnt1 = j - l, cnt2 = mid - j + <span class="number">1</span>;</span><br><span class="line">    ans += a[k].v_ * (a[k].x_ * cnt1 - sum1);</span><br><span class="line">    ans += a[k].v_ * (sum2 - a[k].x_ * cnt2);</span><br><span class="line">    ++k;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (k &lt;= r) ans += a[k].v_ * ((mid - l + <span class="number">1</span>) * a[k].x_ - sum1), ++k;</span><br><span class="line">  <span class="built_in">sort</span>(a + l, a + r + <span class="number">1</span>, cmpx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i].v_ &gt;&gt; a[i].x_;</span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, cmpv);</span><br><span class="line">  <span class="built_in">cdq</span>(<span class="number">1</span>, n);</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title>倍增_解题技巧</title>
    <url>/2024/03/09/%E5%80%8D%E5%A2%9E-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="练习题">练习题</h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P7167">P7167</a>
单调栈+倍增</li>
<li><a href="https://www.luogu.com.cn/problem/P4155">P4155</a>
贪心+倍增</li>
</ul>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>P1074. 靶形数独</title>
    <url>/2024/03/29/P1074-%E9%9D%B6%E5%BD%A2%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>剪枝</li>
<li>状态压缩</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">-1</span>, a[maxn][maxn];</span><br><span class="line"><span class="type">int</span> row[maxn], col[maxn], grid[maxn], cnt[<span class="number">1</span> &lt;&lt; maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> (x / <span class="number">3</span>) * <span class="number">3</span> + (y / <span class="number">3</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">p</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">min</span>(x, <span class="number">8</span> - x), <span class="built_in">min</span>(y, <span class="number">8</span> - y)) + <span class="number">6</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  row[x] ^= <span class="number">1</span> &lt;&lt; v, col[y] ^= <span class="number">1</span> &lt;&lt; v, grid[<span class="built_in">g</span>(x, y)] ^= <span class="number">1</span> &lt;&lt; v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!num) &#123;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> t = <span class="number">10</span>, x, y, s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; maxn; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!a[i][j]) &#123;</span><br><span class="line">        s = row[i] &amp; col[j] &amp; grid[<span class="built_in">g</span>(i, j)];</span><br><span class="line">        <span class="keyword">if</span> (!s) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt[s] &lt; t) &#123;</span><br><span class="line">          t = cnt[s], x = i, y = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  s = row[x] &amp; col[y] &amp; grid[<span class="built_in">g</span>(x, y)];</span><br><span class="line">  <span class="keyword">while</span> (s) &#123;</span><br><span class="line">    <span class="type">int</span> v = cnt[<span class="built_in">lowbit</span>(s) - <span class="number">1</span>];</span><br><span class="line">    a[x][y] = v + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">flip</span>(x, y, v);</span><br><span class="line">    <span class="built_in">dfs</span>(num - <span class="number">1</span>, sum + <span class="built_in">p</span>(x, y) * (v + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">flip</span>(x, y, v);</span><br><span class="line">    a[x][y] = <span class="number">0</span>;</span><br><span class="line">    s -= <span class="built_in">lowbit</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; maxn); ++i) cnt[i] = cnt[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> tot = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) row[i] = col[i] = grid[i] = (<span class="number">1</span> &lt;&lt; maxn) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; maxn; ++j) &#123;</span><br><span class="line">      cin &gt;&gt; a[i][j];</span><br><span class="line">      <span class="keyword">if</span> (a[i][j]) &#123;</span><br><span class="line">        sum += <span class="built_in">p</span>(i, j) * a[i][j];</span><br><span class="line">        <span class="built_in">flip</span>(i, j, a[i][j] - <span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++tot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(tot, sum);</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>参见poj-3074思路</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>状态压缩</tag>
        <tag>DFS</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>P1092. 虫食算</title>
    <url>/2024/03/29/P1092-%E8%99%AB%E9%A3%9F%E7%AE%97/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>剪枝</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e2</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> N, cnt, mp[maxn], q[maxn];</span><br><span class="line">string a, b, c;</span><br><span class="line"><span class="type">bool</span> v[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 进位，-1代表不确定</span></span><br><span class="line">  <span class="type">int</span> p = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (~mp[a[i]] &amp;&amp; ~mp[b[i]] &amp;&amp; ~mp[c[i]]) &#123;</span><br><span class="line">      <span class="comment">// 如果三者都有映射，可以进行有效性判断</span></span><br><span class="line">      <span class="type">int</span> sum = mp[a[i]] + mp[b[i]];</span><br><span class="line">      <span class="keyword">if</span> (~p) &#123;</span><br><span class="line">        <span class="comment">// 如果进位确定</span></span><br><span class="line">        sum += p;</span><br><span class="line">        p = sum / N, sum %= N;</span><br><span class="line">        <span class="comment">// 可行性剪枝：不等于c[i]的映射显然不满足条件</span></span><br><span class="line">        <span class="keyword">if</span> (sum != mp[c[i]]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 可行性剪枝：最高位有进位也不符合条件</span></span><br><span class="line">        <span class="keyword">if</span> (!i &amp;&amp; p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 进位无非0和1两种情况</span></span><br><span class="line">        <span class="type">int</span> s1 = sum + <span class="number">0</span>, s2 = sum + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 可行性剪枝：不等于c[i]的映射显然不满足条件</span></span><br><span class="line">        <span class="keyword">if</span> ((s1 % N != mp[c[i]]) &amp;&amp; (s2 % N != mp[c[i]])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 可行性剪枝：最高位有进位也不符合条件</span></span><br><span class="line">        <span class="keyword">if</span> (!i &amp;&amp; (s1 % N == mp[c[i]]) &amp;&amp; s1 &gt;= N) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!i &amp;&amp; (s2 % N == mp[c[i]]) &amp;&amp; s2 &gt;= N) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 三者不确定，进位也置不确定</span></span><br><span class="line">      p = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (now == N) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 优化搜索顺序：先从大的搜</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v[i]) <span class="keyword">continue</span>;</span><br><span class="line">    mp[q[now]] = i, v[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pd</span>() &amp;&amp; <span class="built_in">dfs</span>(now + <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    mp[q[now]] = <span class="number">-1</span>, v[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; N &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">  <span class="comment">// 优化枚举顺序：从低位到高位保存DFS顺序</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!v[a[i]]) q[cnt++] = a[i], v[a[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!v[b[i]]) q[cnt++] = b[i], v[b[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!v[c[i]]) q[cnt++] = c[i], v[c[i]] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(mp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(mp));</span><br><span class="line">  <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="string">&#x27;A&#x27;</span>; i &lt; <span class="string">&#x27;A&#x27;</span> + N; ++i) cout &lt;&lt; mp[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>考虑枚举每个数字的映射时，判断整个算式的可能性；如果在枚举完所有的可能性之后才去判断，会超时。</p>
<ul>
<li><p>搜索顺序：算式的运算顺序是低位到高位，所以低位到高位统计依次出现的字母，按这个顺序枚举字母；</p>
<p>枚举每个字母的可能性映射时，从大到小枚举，即从<code>N-1</code>枚举到<code>0</code></p></li>
<li><p>可行性剪枝：分为三种情况</p>
<ol type="1">
<li><p>当前位，三个字母都存在映射时，且进位<code>p</code>确定</p>
<ul>
<li>如果<code>(sum = a + b + p) % N != c</code>，剪枝</li>
<li>如果当前是最高位，且还有进位，剪枝</li>
</ul></li>
<li><p>当前位，三个字母都存在映射时，且进位<code>p</code>不确定</p>
<p><code>p</code>无非只有<code>0</code>和<code>1</code>两种可能，按照上面<code>p</code>确定时的规则分类讨论</p></li>
<li><p>当前位，三个字母有部分不确定</p>
<p><code>a</code>和<code>b</code>和<code>c</code>三者不作比较，进位<code>p</code>置为不确定</p></li>
</ol></li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>P1312. Mayan 游戏</title>
    <url>/2024/03/30/P1312-Mayan-%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
<li>剪枝</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="type">bool</span> v[maxn][maxn];</span><br><span class="line"><span class="type">int</span> g[maxn][maxn], backup_g[maxn][maxn][maxn];  <span class="comment">// 当前布局和布局备份</span></span><br><span class="line"><span class="type">int</span> cnt[maxn], backup_cnt[maxn][maxn];  <span class="comment">// 当前每个方块个数和个数备份</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存结果</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y_, dir_;</span><br><span class="line">&#125; ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backup</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memcpy</span>(backup_g[now], g, <span class="built_in">sizeof</span>(g));</span><br><span class="line">  <span class="built_in">memcpy</span>(backup_cnt[now], cnt, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recover</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memcpy</span>(g, backup_g[now], <span class="built_in">sizeof</span>(backup_g[now]));</span><br><span class="line">  <span class="built_in">memcpy</span>(cnt, backup_cnt[now], <span class="built_in">sizeof</span>(backup_cnt[now]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> dir)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">swap</span>(g[x][y], g[x + dir][y]);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">    <span class="comment">// 处理悬空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">5</span>; ++x) &#123;</span><br><span class="line">      <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">7</span>; ++y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g[x][y]) g[x][t++] = g[x][y];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (t &lt; <span class="number">7</span>) g[x][t++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消消乐</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">5</span>; ++x) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">7</span>; ++y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!g[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> l = x, r = x;</span><br><span class="line">        <span class="comment">// 左右找</span></span><br><span class="line">        <span class="keyword">while</span> (l - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; g[l - <span class="number">1</span>][y] == g[x][y]) --l;</span><br><span class="line">        <span class="keyword">while</span> (r + <span class="number">1</span> &lt; <span class="number">5</span> &amp;&amp; g[r + <span class="number">1</span>][y] == g[x][y]) ++r;</span><br><span class="line">        <span class="keyword">if</span> (r - l + <span class="number">1</span> &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">          v[x][y] = <span class="number">1</span>;</span><br><span class="line">          flag = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 上下找</span></span><br><span class="line">          l = y, r = y;</span><br><span class="line">          <span class="keyword">while</span> (l - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; g[x][l - <span class="number">1</span>] == g[x][y]) --l;</span><br><span class="line">          <span class="keyword">while</span> (r + <span class="number">1</span> &lt; <span class="number">7</span> &amp;&amp; g[x][r + <span class="number">1</span>] == g[x][y]) ++r;</span><br><span class="line">          <span class="keyword">if</span> (r - l + <span class="number">1</span> &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            v[x][y] = <span class="number">1</span>;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 删除消掉的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">5</span>; ++x) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">7</span>; ++y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[x][y]) --cnt[g[x][y]], ++cnt[<span class="number">0</span>], g[x][y] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (now == N) <span class="keyword">return</span> (cnt[<span class="number">0</span>] == <span class="number">35</span>);</span><br><span class="line">  <span class="comment">// 可行性剪枝：只剩1个或2个肯定不能被消掉</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt[i] == <span class="number">1</span> || cnt[i] == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">backup</span>(now);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">5</span>; ++x) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">7</span>; ++y) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!g[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// 向右移动</span></span><br><span class="line">      <span class="keyword">if</span> (x + <span class="number">1</span> &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        ans[now] = &#123;x, y, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">f</span>(x, y, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(now + <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">recover</span>(now);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 向左移动</span></span><br><span class="line">      <span class="comment">// 最优性剪枝：左边没东西才向左走</span></span><br><span class="line">      <span class="keyword">if</span> (x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !g[x - <span class="number">1</span>][y]) &#123;</span><br><span class="line">        ans[now] = &#123;x, y, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="built_in">f</span>(x, y, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(now + <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">recover</span>(now);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; N;</span><br><span class="line">  cnt[<span class="number">0</span>] = <span class="number">35</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> t, y, x = <span class="number">0</span>; x &lt; <span class="number">5</span>; ++x) &#123;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; t &amp;&amp; t) &#123;</span><br><span class="line">      ++cnt[t], --cnt[<span class="number">0</span>];</span><br><span class="line">      g[x][y++] = t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">dfs</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">      cout &lt;&lt; ans[i].x_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans[i].y_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans[i].dir_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>搜索顺序：依次枚举每一步选择哪个方块，向左右哪个方向移动。</p>
<p>等效性剪枝：</p>
<ol type="1">
<li>左侧没方块才向左走，因为<code>当前方块向左走</code>和<code>左侧方块向右走</code>是等价的，没必要重复。</li>
<li>就算右侧方块和当前方块相同，也不能剪枝！因为题目要求<code>恰好n步</code>，有时候需要多余步数充数。</li>
</ol>
<p>可行性剪枝：</p>
<ol type="1">
<li>如果某方块只剩<code>1</code>或<code>2</code>块了，直接剪枝。</li>
</ol>
<p>消消乐大模拟直接看代码注释即可。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>P1120. 小木棍</title>
    <url>/2024/03/21/P1120-%E5%B0%8F%E6%9C%A8%E6%A3%8D/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
<li>剪枝</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">70</span>;</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="type">int</span> n, C, L, a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第cnt根火柴的长度为len，从lst开始枚举</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cnt, <span class="type">int</span> len, <span class="type">int</span> lst)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 全部成功枚举</span></span><br><span class="line">  <span class="keyword">if</span> (cnt &gt; C) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 当前火柴拼凑成功，进入下一根</span></span><br><span class="line">  <span class="keyword">if</span> (len == L) <span class="keyword">return</span> <span class="built_in">dfs</span>(cnt + <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> fail = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = lst; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 当前木棍没被用过，且在范围内，且没被标记失败</span></span><br><span class="line">    <span class="keyword">if</span> (!vis[i] &amp;&amp; len + a[i] &lt;= L &amp;&amp; a[i] != fail) &#123;</span><br><span class="line">      vis[i] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">dfs</span>(cnt, len + a[i], i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      vis[i] = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// i木棍拼不到当前火柴里，所以长度相同的木棍全部跳过</span></span><br><span class="line">      fail = a[i];</span><br><span class="line">      <span class="comment">// 当前是火柴的第一根木棍，都没办法满足L</span></span><br><span class="line">      <span class="comment">// 可以拼完当前火柴，但是剩余木棍无法满足L</span></span><br><span class="line">      <span class="keyword">if</span> (len == <span class="number">0</span> || len + a[i] == L) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), sum += a[i], mx = <span class="built_in">max</span>(mx, a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, cmp);</span><br><span class="line">    <span class="keyword">for</span> (L = mx; L &lt;= sum; ++L) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sum % L) <span class="keyword">continue</span>;</span><br><span class="line">      C = sum / L;</span><br><span class="line">      <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; L &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>直接上图。</p>
<img src="/2024/03/21/P1120-%E5%B0%8F%E6%9C%A8%E6%A3%8D/1.jpg" class="" title="b06687b91ccf46c1114093a3390a4ee">
<img src="/2024/03/21/P1120-%E5%B0%8F%E6%9C%A8%E6%A3%8D/2.jpg" class="" title="f437eaf9326657e53c0f9e81a9654e2">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>P1731. 生日蛋糕</title>
    <url>/2024/03/22/P1731-%E7%94%9F%E6%97%A5%E8%9B%8B%E7%B3%95/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
<li>剪枝</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">ll ans = inf, n, s, v, m, minv[maxn], mins[maxn];</span><br><span class="line"><span class="type">int</span> r[maxn], h[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!now) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == n) ans = <span class="built_in">min</span>(ans, s);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (r[now] = <span class="built_in">min</span>((<span class="type">int</span>)<span class="built_in">sqrt</span>(((<span class="type">double</span>)n - v) / now), r[now + <span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">       r[now] &gt;= now; --r[now]) &#123;</span><br><span class="line">    <span class="keyword">for</span> (h[now] = <span class="built_in">min</span>((<span class="type">int</span>)((<span class="type">double</span>)(n - v) / r[now] / r[now]), h[now + <span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">         h[now] &gt;= now; --h[now]) &#123;</span><br><span class="line">      ll tmpv = r[now] * r[now] * h[now], tmps = <span class="number">2</span> * r[now] * h[now];</span><br><span class="line">      <span class="keyword">if</span> (v + tmpv + minv[now - <span class="number">1</span>] &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (s + tmps + mins[now - <span class="number">1</span>] &gt; ans) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (s + (<span class="type">double</span>)<span class="number">2</span> * (n - v) / r[now] &gt; ans) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (now == m) s += r[now] * r[now];</span><br><span class="line">      s += tmps, v += tmpv;</span><br><span class="line">      <span class="built_in">dfs</span>(now - <span class="number">1</span>);</span><br><span class="line">      s -= tmps, v -= tmpv;</span><br><span class="line">      <span class="keyword">if</span> (now == m) s -= r[now] * r[now];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    mins[i] = mins[i - <span class="number">1</span>] + <span class="number">2</span> * i * i;</span><br><span class="line">    minv[i] = minv[i - <span class="number">1</span>] + i * i * i;</span><br><span class="line">  &#125;</span><br><span class="line">  r[m + <span class="number">1</span>] = h[m + <span class="number">1</span>] = inf;</span><br><span class="line">  <span class="built_in">dfs</span>(m);</span><br><span class="line">  ans == inf ? cout &lt;&lt; <span class="number">-1</span> : cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>上面题解是拿<a
href="https://www.luogu.com.cn/problem/T148457">加强版</a>做的，本题数据很烂</p>
<p>根据题意，第1层是最小的，第m层是最大的</p>
<hr />
<p>从小到大，单独每个圆柱体的上表面积等于<code>s1</code>、<code>s2</code>、<code>s3</code>;</p>
<p>按照题意累堆在一起，那么总上表面积等于<code>s1 + (s2 - s1) + (s3 - s2) = s3</code></p>
<p>所以处理第<code>m</code>层时，就可以直接加上总上表面积，只需要考虑每个部分的侧面积处理</p>
<hr />
<p>根据题意，<code>r[k]</code>代表第<code>k</code>层的半径，<code>h[k]</code>代表第<code>k</code>层的高度，那么有：</p>
<ul>
<li><code>r[0] = h[0] = 0, r[m + 1] = h[m + 1] = inf</code></li>
<li><code>r[1] &lt; r[2] &lt; r[3] &lt; ... &lt; r[m]</code></li>
<li><code>h[1] &lt; h[2] &lt; h[3] &lt; ... &lt; h[m]</code></li>
<li><code>r[k] &gt;= k, h[k] &gt;= k</code></li>
<li>第<code>k</code>层的最小侧面积等于<code>2 * k * k</code>，第<code>k</code>层的最小体积等于<code>k * k * k</code></li>
</ul>
<p>可以用<code>mins[k]</code>、<code>minv[k]</code>预先打表<code>1 ~ k</code>层的最小侧面积、最小体积的前缀和</p>
<hr />
<p>接下来到各种恶心的剪枝环节：</p>
<p>假设当前层数为<code>now</code>，<code>now + 1 ~ m</code>的体积和为<code>v</code>，<code>now + 1 ~ m</code>的侧面积和为<code>s</code></p>
<h2 id="搜索顺序">搜索顺序</h2>
<p>从第<code>m</code>层倒序搜索至第1层，<code>r</code>和<code>h</code>也从大到小遍历，必须记住的剪枝技巧！</p>
<p>逻辑上理解，先固定大的，小的可能性搜索树自然就会少。</p>
<h2 id="r和h的取值范围">r和h的取值范围</h2>
<p>根据公式： <span class="math display">\[
r^2h=\left( n-v \right) \Longrightarrow r=\sqrt{\frac{\left( n-v
\right)}{h}}
\]</span>
而第<code>now</code>层的<code>h</code>最小值为<code>now</code>，那么<code>r</code>的最大值为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sqrt</span>(((<span class="type">double</span>)n - v) / now)</span><br></pre></td></tr></table></figure>
<p>注意！除法操作时先转换成<code>double</code>，避免精度缺失导致<code>WA</code></p>
<p>又因为当前的半径肯定要比上一层的小，所以还有一个最大值备选项：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">r[now + <span class="number">1</span>] - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>所以最终<code>r</code>的取值范围：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (r[now] = <span class="built_in">min</span>((<span class="type">int</span>)<span class="built_in">sqrt</span>(((<span class="type">double</span>)n - v) / now), r[now + <span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">       r[now] &gt;= now; --r[now])</span><br></pre></td></tr></table></figure>
<p><code>h</code>同理得到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (h[now] = <span class="built_in">min</span>((<span class="type">int</span>)((<span class="type">double</span>)(n - v) / r[now] / r[now]), h[now + <span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">     h[now] &gt;= now; --h[now])</span><br></pre></td></tr></table></figure>
<h2 id="卡常与可行性剪枝">卡常与可行性剪枝</h2>
<p><code>1 ~ now</code>的最小体积加上<code>v</code>一定小于等于<code>n</code>，不然就没有意义了，按道理应该这么写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (v + minv[now] &gt; n) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<p>上述写法会把<code>now</code>的改变留到下一次递归判断，正常的DFS也确实是这么标准的模板——</p>
<p>但无疑这样会增加多余的栈开销，本题也会<code>TLE</code>，遂改成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ll tmpv = r[now] * r[now] * h[now];</span><br><span class="line"><span class="keyword">if</span> (v + tmpv + minv[now - <span class="number">1</span>] &gt; n) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<h2 id="最优性剪枝">最优性剪枝</h2>
<p><code>1 ~ now</code>的最小侧面积加上<code>s</code>一定小于等于<code>ans</code>，不然没必要继续搜下去，所以有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ll tmps = <span class="number">2</span> * r[now] * h[now];</span><br><span class="line"><span class="keyword">if</span> (s + tmps + mins[now - <span class="number">1</span>] &gt; ans) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<p>我们的<code>r</code>和<code>h</code>都是利用<code>n - v</code>来剪枝的，尝试利用不等式放缩来剪枝，<code>1 ~ now</code>的最小侧面积和有不等式：
<span class="math display">\[
2\sum{\begin{array}{c}
    now\\
    k=1\\
\end{array}}r\left[ k \right] \cdot h\left[ k \right] =\frac{2}{r\left[
now \right]}\sum{\begin{array}{c}
    now\\
    k=1\\
\end{array}}r\left[ k \right] \cdot h\left[ k \right] \cdot r\left[ now
\right] \geqslant \frac{2}{r\left[ now \right]}\sum{\begin{array}{c}
    now\\
    k=1\\
\end{array}}r\left[ k \right] ^2\cdot h\left[ k \right]
=\frac{2}{r\left[ now \right]}\cdot \left( n-v \right)
\]</span> 也就是说，<code>1 ~ now</code>的侧面积和最小值为<span
class="math inline">\(\frac{2\left( n-v \right)}{r\left[ now
\right]}\)</span>，可以得到：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s + (<span class="type">double</span>)<span class="number">2</span> * (n - v) / r[now] &gt; ans) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>P2960. Invasion of the Milkweed G</title>
    <url>/2024/03/30/P2960-Invasion-of-the-Milkweed-G/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>BFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">200</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">char</span> s[maxn][maxn];</span><br><span class="line"><span class="type">bool</span> v[maxn][maxn];</span><br><span class="line"><span class="type">int</span> r, c, tot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y_, step_;</span><br><span class="line">  <span class="built_in">node</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>, <span class="type">int</span> step = <span class="number">0</span>) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y), <span class="built_in">step_</span>(step) &#123;&#125;</span><br><span class="line">&#125; bg;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; x &lt;= r &amp;&amp; y &lt;= c; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  q.<span class="built_in">push</span>(bg);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    node u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> x = u.x_ + dx[i], y = u.y_ + dy[i];</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">valid</span>(x, y)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (v[x][y] || s[x][y] == <span class="string">&#x27;*&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">      --tot;</span><br><span class="line">      <span class="keyword">if</span> (!tot) &#123;</span><br><span class="line">        cout &lt;&lt; u.step_ + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      q.<span class="built_in">emplace</span>(x, y, u.step_ + <span class="number">1</span>);</span><br><span class="line">      v[x][y] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; c &gt;&gt; r &gt;&gt; bg.y_ &gt;&gt; bg.x_;</span><br><span class="line">  bg.x_ = r + <span class="number">1</span> - bg.x_;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) cin &gt;&gt; (s[i] + <span class="number">1</span>);</span><br><span class="line">  tot = r * c;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;*&#x27;</span>) --tot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>正常的走地图，直接看代码即可。</p>
<p>唯一的坑点就是输入..........所有的横纵坐标都倒过来了，所以有这行代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; c &gt;&gt; r &gt;&gt; bg.y_ &gt;&gt; bg.x_;</span><br></pre></td></tr></table></figure>
<p>关键是这句话：</p>
<blockquote>
<p>(1,1)是左下角的格（也就是说坐标排布跟一般的X,Y坐标相同)</p>
</blockquote>
<p>代码改成这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">bg.x_ = r + <span class="number">1</span> - bg.x_;</span><br></pre></td></tr></table></figure>
<img src="/2024/03/30/P2960-Invasion-of-the-Milkweed-G/1.png" class="" title="image-20240330224442422">
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-164. 可达性统计</title>
    <url>/2024/03/19/acwing-164-%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>拓扑排序</li>
<li>状态压缩</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">3e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, cnt, tot = <span class="number">-1</span>, ind[maxn], head[maxn], seq[maxn];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">bitset&lt;maxn&gt; ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> v_, nxt_;</span><br><span class="line">&#125; e[<span class="number">2</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  e[++tot].v_ = v, e[tot].nxt_ = head[u];</span><br><span class="line">  head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ind[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="comment">// 这里不要使用1 &lt;&lt; u，最多只有32位，而这里是3e4位</span></span><br><span class="line">    ans[u].<span class="built_in">set</span>(u);</span><br><span class="line">    seq[++cnt] = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = e[i].nxt_) &#123;</span><br><span class="line">      <span class="type">int</span> v = e[i].v_;</span><br><span class="line">      <span class="keyword">if</span> (--ind[v] == <span class="number">0</span>) q.<span class="built_in">push</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="type">int</span> u, v;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) cin &gt;&gt; u &gt;&gt; v, <span class="built_in">add</span>(u, v), ++ind[v];</span><br><span class="line">  <span class="built_in">toposort</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = cnt; i; --i) &#123;</span><br><span class="line">    <span class="type">int</span> u = seq[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = head[u]; ~j; j = e[j].nxt_) &#123;</span><br><span class="line">      <span class="type">int</span> v = e[j].v_;</span><br><span class="line">      ans[u] |= ans[v];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cout &lt;&lt; ans[i].<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>直接上图。</p>
<img src="/2024/03/19/acwing-164-%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%BB%9F%E8%AE%A1/1.jpg" class="" title="40e5b66569a0cfd0be4dcc8af37701b">
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>状态压缩</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-165. 小猫爬山</title>
    <url>/2024/03/20/acwing-165-%E5%B0%8F%E7%8C%AB%E7%88%AC%E5%B1%B1/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">19</span>;</span><br><span class="line"><span class="type">int</span> n, cnt, W, ans, a[maxn], cab[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> cnt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cnt &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; n) &#123;</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, cnt);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] + cab[j] &lt;= W) &#123;</span><br><span class="line">      cab[j] += a[i];</span><br><span class="line">      <span class="built_in">dfs</span>(i + <span class="number">1</span>, cnt);</span><br><span class="line">      cab[j] -= a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cab[cnt + <span class="number">1</span>] += a[i];</span><br><span class="line">  <span class="built_in">dfs</span>(i + <span class="number">1</span>, cnt + <span class="number">1</span>);</span><br><span class="line">  cab[cnt + <span class="number">1</span>] -= a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; W;</span><br><span class="line">  ans = n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, [](<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>直接上图。</p>
<img src="/2024/03/20/acwing-165-%E5%B0%8F%E7%8C%AB%E7%88%AC%E5%B1%B1/1.jpg" class="" title="46121a1184eb4432928fb8d14a3f548">
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-171. 送礼物</title>
    <url>/2024/03/23/acwing-171-%E9%80%81%E7%A4%BC%E7%89%A9/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
<li>双向DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">ll n, w, m, ans, half, a[<span class="number">50</span>], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> i, ll s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i == half) &#123;</span><br><span class="line">    b[++m] = s;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s + a[i] &lt;= w) <span class="built_in">dfs1</span>(i + <span class="number">1</span>, s + a[i]);</span><br><span class="line">  <span class="built_in">dfs1</span>(i + <span class="number">1</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> i, ll s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i == n + <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = m, p = w - s;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">      <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (b[mid] &lt;= p)</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, s + b[r]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s + a[i] &lt;= w) <span class="built_in">dfs2</span>(i + <span class="number">1</span>, s + a[i]);</span><br><span class="line">  <span class="built_in">dfs2</span>(i + <span class="number">1</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; w &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">    cout &lt;&lt; a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, [](ll &amp;a, ll &amp;b) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br><span class="line">  half = n / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + m), m = <span class="built_in">unique</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + m) - b - <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">dfs2</span>(half, <span class="number">0</span>);</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>直接看图就好，注意几个坑点：</p>
<ul>
<li>记得开<code>long long</code> ，部分情况会溢出</li>
<li>不要用<code>upper_bound</code>会超时，手写二分快一点</li>
<li><code>half</code>等于<code>n / 2</code>即可，不要玄学剪枝</li>
</ul>
<img src="/2024/03/23/acwing-171-%E9%80%81%E7%A4%BC%E7%89%A9/1.png" class="" title="image-20240323221151542">
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>双向DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-173. 矩阵距离</title>
    <url>/2024/03/24/acwing-173-%E7%9F%A9%E9%98%B5%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>BFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="comment">// 0~3左右上下</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">char</span> s[maxn][maxn];</span><br><span class="line"><span class="type">int</span> n, m, d[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y_;</span><br><span class="line">  <span class="built_in">node</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &lt;= m; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    node u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> x = u.x_ + dx[i], y = u.y_ + dy[i];</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">valid</span>(x, y) || ~d[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">      d[x][y] = d[u.x_][u.y_] + <span class="number">1</span>;</span><br><span class="line">      q.<span class="built_in">emplace</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  <span class="comment">// 必须用字符串或字符，整数型会被吞</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;1&#x27;</span>) q.<span class="built_in">emplace</span>(i, j), d[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i, cout &lt;&lt; endl) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">      cout &lt;&lt; d[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>有多个起始状态的<strong>flood-fill</strong>问题，矩阵中每一个1都看作起点，整个矩阵的所有位置都可以通行；</p>
<p>对于每个位置，在从任何一个起点出发都可以的情况下，求到达该位置所需要的最小步数</p>
<p>（也就是距离该位置最近的起点的距离）</p>
<hr />
<p>根据BFS逐层搜索的性质，BFS的过程就相当于每个起点先扩展1层、再扩展2层、3层，以此类推。</p>
<p>所以当每个位置<code>(x, y)</code>第一次被访问时，就相当于距离它最近的那个起点扩展到了它，</p>
<p>此时从那个起点到<code>(x, y)</code>经历的步数就是最短距离<code>B[x][y]</code></p>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-175. 电路维修</title>
    <url>/2024/03/26/acwing-175-%E7%94%B5%E8%B7%AF%E7%BB%B4%E4%BF%AE/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>双端队列BFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e2</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> r, c, d[maxn][maxn];</span><br><span class="line"><span class="type">char</span> s[maxn][maxn];</span><br><span class="line">vector&lt;pair&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt;&gt; p[maxn][maxn];</span><br><span class="line"><span class="type">bool</span> v[maxn][maxn];</span><br><span class="line">deque&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">  p[x1][y1].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="built_in">make_pair</span>(x2, y2), z));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= c; ++j) &#123;</span><br><span class="line">      p[i][j].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  q.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">add</span>(i - <span class="number">1</span>, j - <span class="number">1</span>, i, j, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(i, j, i - <span class="number">1</span>, j - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(i, j - <span class="number">1</span>, i - <span class="number">1</span>, j, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">add</span>(i - <span class="number">1</span>, j, i, j - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">add</span>(i - <span class="number">1</span>, j - <span class="number">1</span>, i, j, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">add</span>(i, j, i - <span class="number">1</span>, j - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">add</span>(i, j - <span class="number">1</span>, i - <span class="number">1</span>, j, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(i - <span class="number">1</span>, j, i, j - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  q.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> x = q.<span class="built_in">front</span>().first, y = q.<span class="built_in">front</span>().second;</span><br><span class="line">    q.<span class="built_in">pop_front</span>();</span><br><span class="line">    v[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == r &amp;&amp; y == c) &#123;</span><br><span class="line">      cout &lt;&lt; d[r][c] &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : p[x][y]) &#123;</span><br><span class="line">      <span class="type">int</span> nx = it.first.first, ny = it.first.second, nz = it.second;</span><br><span class="line">      <span class="keyword">if</span> (v[nx][ny]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (d[x][y] + nz &lt; d[nx][ny]) &#123;</span><br><span class="line">        d[nx][ny] = d[x][y] + nz;</span><br><span class="line">        <span class="keyword">if</span> (nz) &#123;</span><br><span class="line">          q.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(nx, ny));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          q.<span class="built_in">push_front</span>(<span class="built_in">make_pair</span>(nx, ny));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    cin &gt;&gt; r &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) cin &gt;&gt; (s[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ((r &amp; <span class="number">1</span>) != (c &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;NO SOLUTION&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>(), <span class="built_in">dijkstra</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>双端队列BFS的模板题，直接上图。</p>
<img src="/2024/03/26/acwing-175-%E7%94%B5%E8%B7%AF%E7%BB%B4%E4%BF%AE/1.png" class="" title="image-20240326200646131">
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>双端队列BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-174.推箱子</title>
    <url>/2024/03/26/acwing-174-%E6%8E%A8%E7%AE%B1%E5%AD%90/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>双重BFS</li>
<li>最短路</li>
<li>分层图</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">25</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">char</span> s[maxn][maxn];</span><br><span class="line"><span class="comment">// 0 ~ 3上下左右</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// 箱子、人的上下左右字母</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> A[<span class="number">4</span>] = &#123;<span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125;, a[<span class="number">4</span>] = &#123;<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line"><span class="type">int</span> r, c;</span><br><span class="line">string path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="comment">// b代表box箱子，p代表person人</span></span><br><span class="line">  <span class="type">int</span> bx_, by_, px_, py_;</span><br><span class="line">  <span class="comment">// 经过的路径</span></span><br><span class="line">  string path_;</span><br><span class="line">&#125; bg;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化起点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">        bg.bx_ = i, bg.by_ = j, s[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">        bg.px_ = i, bg.py_ = j, s[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; x &lt;= r &amp;&amp; y &lt;= c &amp;&amp; s[x][y] != <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(string &amp;str)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isupper</span>(str[i])) ++res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs2</span><span class="params">(node from, node to)</span> </span>&#123;</span><br><span class="line">  queue&lt;node&gt; q;</span><br><span class="line">  <span class="type">bool</span> vis[maxn][maxn];</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">  <span class="comment">// 不可能从箱子上碾过去</span></span><br><span class="line">  vis[from.bx_][from.by_] = <span class="number">1</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(from);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    node u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (u.px_ == to.px_ &amp;&amp; u.py_ == to.py_) &#123;</span><br><span class="line">      path = u.path_;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> x = u.px_ + dx[i], y = u.py_ + dy[i];</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">valid</span>(x, y)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (vis[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">      node nxt;</span><br><span class="line">      nxt.px_ = x, nxt.py_ = y, nxt.path_ = u.path_ + a[i];</span><br><span class="line">      vis[x][y] = <span class="number">1</span>;</span><br><span class="line">      q.<span class="built_in">push</span>(nxt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">bfs1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  queue&lt;node&gt; q;</span><br><span class="line">  string ans = <span class="string">&quot;Impossible.&quot;</span>;</span><br><span class="line">  <span class="comment">// 总路径最小值，箱子路径最小值</span></span><br><span class="line">  <span class="comment">// 若直接保存人的路径最小值，两变量相互独立，无法保证箱子路径最小这一前提</span></span><br><span class="line">  <span class="type">int</span> path_len = inf, box_len = inf;</span><br><span class="line">  <span class="comment">// 当前状态下，箱子和人的路径最小值</span></span><br><span class="line">  <span class="type">int</span> box[maxn][maxn][<span class="number">4</span>], people[maxn][maxn][<span class="number">4</span>];</span><br><span class="line">  <span class="built_in">memset</span>(box, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(box)), <span class="built_in">memset</span>(people, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(people));</span><br><span class="line">  q.<span class="built_in">push</span>(bg);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    node u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (s[u.bx_][u.by_] == <span class="string">&#x27;T&#x27;</span>) &#123;</span><br><span class="line">      <span class="type">int</span> pl = u.path_.<span class="built_in">length</span>(), bl = <span class="built_in">calc</span>(u.path_);</span><br><span class="line">      <span class="comment">// 先保证箱子路径最小，再保证人路径最小</span></span><br><span class="line">      <span class="keyword">if</span> (bl &lt; box_len || (bl == box_len &amp;&amp; pl &lt; path_len)) &#123;</span><br><span class="line">        ans = u.path_, path_len = pl, box_len = bl;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> x = u.bx_ + dx[i], y = u.by_ + dy[i];</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">valid</span>(x, y)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// 人应该从people_from跑到people_to的位置才能推箱子</span></span><br><span class="line">      node people_from = u, people_to;</span><br><span class="line">      people_from.path_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        people_to.px_ = u.bx_ + <span class="number">1</span>, people_to.py_ = u.by_;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">        people_to.px_ = u.bx_ - <span class="number">1</span>, people_to.py_ = u.by_;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">        people_to.py_ = u.by_ + <span class="number">1</span>, people_to.px_ = u.bx_;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        people_to.py_ = u.by_ - <span class="number">1</span>, people_to.px_ = u.bx_;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">valid</span>(people_to.px_, people_to.py_)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">bfs2</span>(people_from, people_to)) <span class="keyword">continue</span>;</span><br><span class="line">      node nxt;</span><br><span class="line">      nxt.bx_ = x, nxt.by_ = y, nxt.px_ = u.bx_, nxt.py_ = u.by_;</span><br><span class="line">      nxt.path_ = u.path_ + path + A[i];</span><br><span class="line">      <span class="comment">// SPFA收敛性判断</span></span><br><span class="line">      <span class="type">int</span> bl = <span class="built_in">calc</span>(nxt.path_), pl = nxt.path_.<span class="built_in">length</span>() - bl;</span><br><span class="line">      <span class="keyword">if</span> (box[u.bx_][u.by_][i] &lt; bl || people[u.bx_][u.by_][i] &lt; pl) <span class="keyword">continue</span>;</span><br><span class="line">      box[u.bx_][u.by_][i] = bl, people[u.bx_][u.by_][i] = pl;</span><br><span class="line">      q.<span class="built_in">push</span>(nxt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; r &gt;&gt; c &amp;&amp; r &amp;&amp; c) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) cin &gt;&gt; (s[i] + <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Maze #&quot;</span> &lt;&lt; ++num &lt;&lt; endl &lt;&lt; <span class="built_in">bfs1</span>() &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>双重BFS的经典例题，也是dijkstra和spfa的精髓题，直接上图。</p>
<img src="/2024/03/26/acwing-174-%E6%8E%A8%E7%AE%B1%E5%AD%90/2.jpg" class="" title="aae8b554ad785e99f11a42d51382c79">
<img src="/2024/03/26/acwing-174-%E6%8E%A8%E7%AE%B1%E5%AD%90/3.jpg" class="" title="282ac7bc2a9b759f0837b6c871640d9">
<p>移动方式如下图所示：</p>
<img src="/2024/03/26/acwing-174-%E6%8E%A8%E7%AE%B1%E5%AD%90/1.png" class="" title="image-20240326121517991">
<p>本题最大的难点在于，对dijkstra和spfa算法的理解，否则压根看不懂题解。</p>
<p>题目要求<strong>先</strong>保证箱子的路径最短，<strong>再</strong>保证人的路径最短。</p>
<hr />
<p>人走到箱子旁边这一部分，正常编写BFS是没错的，</p>
<p>因为BFS本质是对一张边权均为1的图作dijkstra，所以第一次遇到终止态时就是答案（显然）；</p>
<p>但箱子的移动部分，你必须采用spfa算法：</p>
<ol type="1">
<li><p>对箱子进行普通BFS确实没错，对箱子的角度而言；其下一步的路径数肯定是不小于上一步的，是线性不减；</p>
<p>但是你能保证人的路径数也线性不减吗？尽管人是跟着箱子动的，但是人的位置是随机变化的啊！</p>
<img src="/2024/03/26/acwing-174-%E6%8E%A8%E7%AE%B1%E5%AD%90/4.png" class="" title="image-20240326131623669"></li>
<li><p>所以正确的做法是，利用spfa的思维，单独开<code>box[x][y][dir]</code>和<code>people[x][y][dir]</code>数组，</p>
<p>分别记录<code>(x,y,dir)</code>状态下箱子的最短路径和人的最短路径，只要有一者会更小，就继续BFS，直到收敛。</p></li>
</ol>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>双重BFS</tag>
        <tag>最短路</tag>
        <tag>分层图</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-178. 第K短路</title>
    <url>/2024/04/03/acwing-178-%E7%AC%ACK%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>Astar</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PI;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, PI&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T, K, tot = <span class="number">-1</span>, head[maxn], rhead[maxn], f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> nxt_, v_, w_;</span><br><span class="line">&#125; e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> head[], <span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">  e[++tot].v_ = v, e[tot].w_ = w, e[tot].nxt_ = head[u];</span><br><span class="line">  head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> vis[maxn];</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis)), <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">  priority_queue&lt;PI, vector&lt;PI&gt;&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, T&#125;);</span><br><span class="line">  f[T] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">top</span>().second;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = rhead[u]; ~i; i = e[i].nxt_) &#123;</span><br><span class="line">      <span class="type">int</span> v = e[i].v_, w = e[i].w_;</span><br><span class="line">      <span class="keyword">if</span> (f[u] + w &lt; f[v]) &#123;</span><br><span class="line">        f[v] = f[u] + w;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;-f[v], v&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">astar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (S == T) ++K;</span><br><span class="line">  priority_queue&lt;PII, vector&lt;PII&gt;&gt; q;</span><br><span class="line">  <span class="type">int</span> cnt[maxn];</span><br><span class="line">  <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">  q.<span class="built_in">push</span>(&#123;<span class="number">0</span> + f[S], &#123;<span class="number">0</span>, S&#125;&#125;);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">top</span>().second.second, d = q.<span class="built_in">top</span>().second.first;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    ++cnt[u];</span><br><span class="line">    <span class="keyword">if</span> (cnt[T] == K) <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = e[i].nxt_) &#123;</span><br><span class="line">      <span class="type">int</span> v = e[i].v_, w = e[i].w_;</span><br><span class="line">      <span class="keyword">if</span> (cnt[v] &gt;= K) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (f[v] &gt;= <span class="number">0x3f3f3f3f</span>) <span class="keyword">continue</span>;</span><br><span class="line">      q.<span class="built_in">push</span>(&#123;-(f[v] + d + w), &#123;d + w, v&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="type">int</span> u, v, w;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head)), <span class="built_in">memset</span>(rhead, <span class="number">-1</span>, <span class="built_in">sizeof</span>(rhead));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    <span class="built_in">add</span>(head, u, v, w), <span class="built_in">add</span>(rhead, v, u, w);</span><br><span class="line">  &#125;</span><br><span class="line">  cin &gt;&gt; S &gt;&gt; T &gt;&gt; K;</span><br><span class="line">  <span class="built_in">dijkstra</span>();</span><br><span class="line">  cout &lt;&lt; <span class="built_in">astar</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>Astar模板题，具体步骤如下：</p>
<ol type="1">
<li><p>先反向建图，以终点T为起点，对反向图做一次<code>dijkstra</code>，每个点对终点的单源最短路记录为<code>f</code></p></li>
<li><p>视角换回正向图。设当前点为<code>u</code>，当前点到起点S的真实距离为<code>dis[u]</code>，</p>
<p>那么状态为三元组<code>(dis[u] + f[u], dis[u], u)</code></p>
<p>第一维很好理解，<strong>当前点到起点S的距离+当前点到终点的最短距离</strong></p>
<p>按照单源最短路的贪心思想，每次取出第一维的最小，最终得到的<code>dis[T]</code>一定是S到T的最短路，因为该条路径的开销相比其他路更小。</p>
<p>第二维记录<strong>当前点到起点S的距离</strong>。</p>
<p>第三维记录<strong>当前点</strong>。</p>
<p>那么初始状态就是<code>(0 + f[S], 0, S)</code>，终态就是<code>(dis[T] + 0, dis[T], T)</code>，最短路就是<code>dis[T]</code></p>
<p>由于题目问的是<code>K短路</code>，所以额外开一个<code>cnt</code>数组记录节点的出队次数就行，第K次出队就是第K短</p></li>
<li><p>实现部分还有几个重要细节：</p>
<ol type="1">
<li>由于求的是K短路，所以节点出队K次后就没必要继续入队，因为不可能用得上K+1短路</li>
<li>如果<code>f[u] &gt;= 0x3f3f3f3f</code>，说明该点到终点不可达，不能塞进队列里</li>
<li>题目要求<strong>每条最短路中至少要包含一条边</strong>，所以若终点起点是同一个点，那么求K短路应改为求第K+1短路，因为第1短路没有边（两个点重合距离为0，是最短的）</li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>Astar</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-179. 八数码</title>
    <url>/2024/04/06/acwing-179-%E5%85%AB%E6%95%B0%E7%A0%81/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>Astar</li>
<li>双向BFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<p>先要判断是否有解，思路请参见<a
href="https://www.acwing.com/problem/content/110/">奇数码问题</a>。</p>
<h2 id="astar">Astar</h2>
<p>估价函数设计为所有数字在当前状态中的位置，与目标状态中的位置的曼哈顿距离之和。</p>
<p>因为每次移动只能把一个数字与空格交换位置，至多把一个数字向它在目标状态中的位置接近一步；即使每一步都有意义，不会产生额外开销，从任何一个状态到目标状态的移动步数也不可能小于所有数字当前位置与目标位置的曼哈顿距离之和。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前状态到目标状态的理想全局曼哈顿距离</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(string state)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; state.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (state[i] == <span class="string">&#x27;x&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> t = state[i] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    res += <span class="built_in">abs</span>(t / <span class="number">3</span> - i / <span class="number">3</span>) + <span class="built_in">abs</span>(t % <span class="number">3</span> - i % <span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; <span class="number">3</span> &amp;&amp; y &lt; <span class="number">3</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">bfs</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">  <span class="type">char</span> op[<span class="number">4</span>] = &#123;<span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">  string T = <span class="string">&quot;12345678x&quot;</span>;</span><br><span class="line">  <span class="comment">// unordered_map&lt;b, d&gt;</span></span><br><span class="line">  <span class="comment">// b到S的开销为d</span></span><br><span class="line">  unordered_map&lt;string, <span class="type">int</span>&gt; dist;</span><br><span class="line">  <span class="comment">// unordered_map&lt;b, pair&lt;a, c&gt;&gt;</span></span><br><span class="line">  <span class="comment">// b由a通过c操作转换得到</span></span><br><span class="line">  unordered_map&lt;string, pair&lt;string, <span class="type">char</span>&gt;&gt; prev;</span><br><span class="line">  priority_queue&lt;pair&lt;<span class="type">int</span>, string&gt;, vector&lt;pair&lt;<span class="type">int</span>, string&gt;&gt;&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(&#123;-<span class="built_in">f</span>(S), S&#125;);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    string now = q.<span class="built_in">top</span>().second;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (now == T) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 找到x的位置</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; now.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (now[i] == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">        x = i / <span class="number">3</span>, y = i % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 四个方向移动</span></span><br><span class="line">    string s = now;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">valid</span>(nx, ny)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="built_in">swap</span>(now[x * <span class="number">3</span> + y], now[nx * <span class="number">3</span> + ny]);</span><br><span class="line">      <span class="comment">// 没被访问过（无穷大）或开销更小，更新</span></span><br><span class="line">      <span class="keyword">if</span> (!dist.<span class="built_in">count</span>(now) || dist[now] &gt; dist[s] + <span class="number">1</span>) &#123;</span><br><span class="line">        dist[now] = dist[s] + <span class="number">1</span>;</span><br><span class="line">        prev[now] = &#123;s, op[i]&#125;;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;-(dist[now] + <span class="built_in">f</span>(now)), now&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">swap</span>(now[x * <span class="number">3</span> + y], now[nx * <span class="number">3</span> + ny]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  string path;</span><br><span class="line">  <span class="keyword">while</span> (T != S) &#123;</span><br><span class="line">    path += prev[T].second;</span><br><span class="line">    T = prev[T].first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">reverse</span>(path.<span class="built_in">begin</span>(), path.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  string str, seq;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; c) &#123;</span><br><span class="line">    str += c;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="string">&#x27;x&#x27;</span>) seq += c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 八数码问题用逆序对数的奇偶性判断是否有解</span></span><br><span class="line">  <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; seq.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (seq[i] &lt; seq[j]) ++num;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ((num &amp; <span class="number">1</span>) ? <span class="string">&quot;unsolvable&quot;</span> : <span class="built_in">bfs</span>(str)) &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双向bfs">双向BFS</h2>
<p>astar的作法很难想，我本人是用双向BFS码的，唯一的难点就在于保存路径！！！</p>
<p>反向BFS的方向数组要取反；</p>
<p>正向BFS的路径<strong>应取反</strong>，求正向BFS路径时，我们是从中间状态朝起始状态遍历；</p>
<p>反向BFS的路径<strong>不可以取反</strong>，求反向BFS路径时，我们是从中间状态朝目标状态遍历。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">// 反向BFS的方向数组取反</span></span><br><span class="line"><span class="type">char</span> opa[<span class="number">4</span>] = &#123;<span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;, opb[<span class="number">4</span>] = &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;;</span><br><span class="line">string mid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; <span class="number">3</span> &amp;&amp; y &lt; <span class="number">3</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">extend</span><span class="params">(queue&lt;string&gt; &amp;aq, unordered_map&lt;string, pair&lt;string, <span class="type">char</span>&gt;&gt; &amp;ap,</span></span></span><br><span class="line"><span class="params"><span class="function">            unordered_map&lt;string, <span class="type">bool</span>&gt; &amp;av, unordered_map&lt;string, <span class="type">bool</span>&gt; &amp;bv,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">char</span> op[])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sz = aq.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">while</span> (sz--) &#123;</span><br><span class="line">    string s = aq.<span class="built_in">front</span>();</span><br><span class="line">    aq.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (bv.<span class="built_in">count</span>(s)) &#123;</span><br><span class="line">      mid = s;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找x的位置</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">        x = i / <span class="number">3</span>, y = i % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 四个方向扩展</span></span><br><span class="line">    string source = s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">valid</span>(nx, ny)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="built_in">swap</span>(s[x * <span class="number">3</span> + y], s[nx * <span class="number">3</span> + ny]);</span><br><span class="line">      <span class="keyword">if</span> (!av.<span class="built_in">count</span>(s)) av[s] = <span class="number">1</span>, ap[s] = &#123;source, op[i]&#125;, aq.<span class="built_in">push</span>(s);</span><br><span class="line">      <span class="built_in">swap</span>(s[x * <span class="number">3</span> + y], s[nx * <span class="number">3</span> + ny]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">bfs</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">  string T = <span class="string">&quot;12345678x&quot;</span>;</span><br><span class="line">  unordered_map&lt;string, <span class="type">bool</span>&gt; av, bv;</span><br><span class="line">  unordered_map&lt;string, pair&lt;string, <span class="type">char</span>&gt;&gt; ap, bp;</span><br><span class="line">  queue&lt;string&gt; aq, bq;</span><br><span class="line">  aq.<span class="built_in">push</span>(S), bq.<span class="built_in">push</span>(T);</span><br><span class="line">  av[S] = <span class="number">1</span>, bv[T] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!aq.<span class="built_in">empty</span>() &amp;&amp; !bq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">    flag = aq.<span class="built_in">size</span>() &lt; bq.<span class="built_in">size</span>() ? <span class="built_in">extend</span>(aq, ap, av, bv, opa)</span><br><span class="line">                                 : <span class="built_in">extend</span>(bq, bp, bv, av, opb);</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  string res, tmp = mid;</span><br><span class="line">  <span class="keyword">while</span> (tmp != S) &#123;</span><br><span class="line">    res += ap[tmp].second;</span><br><span class="line">    tmp = ap[tmp].first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">while</span> (mid != T) &#123;</span><br><span class="line">    res += bp[mid].second;</span><br><span class="line">    mid = bp[mid].first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  string str, seq;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; c) &#123;</span><br><span class="line">    str += c;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="string">&#x27;x&#x27;</span>) seq += c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 八数码问题用逆序对数的奇偶性判断是否有解</span></span><br><span class="line">  <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; seq.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (seq[i] &lt; seq[j]) ++num;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ((num &amp; <span class="number">1</span>) ? <span class="string">&quot;unsolvable&quot;</span> : <span class="built_in">bfs</span>(str)) &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>双向BFS</tag>
        <tag>Astar</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-180. 排书</title>
    <url>/2024/04/08/acwing-180-%E6%8E%92%E4%B9%A6/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
<li>IDAstar</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> n, arr[maxn], backup[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i + <span class="number">1</span>] != arr[i] + <span class="number">1</span>) ++res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向上取整</span></span><br><span class="line">  <span class="keyword">return</span> (res + <span class="number">3</span> - <span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] != i + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> depth, <span class="type">int</span> mx)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 最优性剪枝</span></span><br><span class="line">  <span class="comment">// 当前开销+未来最小开销都大于阈值，剪枝</span></span><br><span class="line">  <span class="keyword">if</span> (depth + <span class="built_in">f</span>() &gt; mx) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">check</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; n; ++l) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = l; r &lt; n; ++r) &#123;</span><br><span class="line">      <span class="comment">// 等效性剪枝，只会朝后交换</span></span><br><span class="line">      <span class="comment">// 先前序列向后交换，和当前序列向前交换是等价的</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = r + <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup[depth], arr, <span class="built_in">sizeof</span>(arr));</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="keyword">for</span> (b = r + <span class="number">1</span>, a = l; b &lt;= k; ++a, ++b) arr[a] = backup[depth][b];</span><br><span class="line">        <span class="keyword">for</span> (b = l; b &lt;= r; ++a, ++b) arr[a] = backup[depth][b];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(depth + <span class="number">1</span>, mx)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(arr, backup[depth], <span class="built_in">sizeof</span>(arr));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (depth &lt; <span class="number">5</span> &amp;&amp; !<span class="built_in">dfs</span>(<span class="number">0</span>, depth)) ++depth;</span><br><span class="line">    <span class="keyword">if</span> (depth &gt;= <span class="number">5</span>)</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;5 or more&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cout &lt;&lt; depth &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>先考虑每一步的决策数量：</p>
<p>当抽取长度为<code>i</code>的一段时，有<code>n - i + 1</code>种抽法，对于每种抽法，有<code>n - i</code>种放法</p>
<p>（原本是<code>n - i + 1</code>种放法，去掉了放回原位那一种）。</p>
<p>另外，将某一段向前移动，等价于将交换的那段向后移动，因此每种移动方式被算了两遍；</p>
<p>所以每个状态总共的分支数量是： <span class="math display">\[
\frac{\sum{\begin{array}{c}
    n\\
    i=1\\
\end{array}\left( n-i \right) \cdot \left( n-i+1
\right)}}{2}=\frac{\left( 14\times 15 \right) +\left( 13\times 14
\right) \cdots +\left( 2\times 1 \right)}{2}=560
\]</span> 题目说最多四步，最多<span
class="math inline">\(560^4\)</span>，有双向BFS和IDAstar两种，但是双向BFS试了N次放弃了，还贼难写...</p>
<p>估价函数设计：</p>
<ul>
<li><p>在最终状态下，每本书后面的书的编号应该比当前书多<code>1</code></p></li>
<li><p>每次移动最多会断开三个相连的位置，再重新加入三个相连的位置，因此最多会将3个错误的连接修正</p>
<p>所以如果当前有<code>tot</code>个连接，那么最少需要<code>tot/3</code>向上取整次操作，估价函数就可以设计成这个：
<span class="math display">\[
f\left( s \right) =\lceil \frac{tot}{3} \rceil
\]</span></p></li>
</ul>
<p>如果当前层数加上<code>f(s)</code>大于迭代加深的层数上限，则直接从当前分支回溯。</p>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>IDAstar</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-181. 回转游戏</title>
    <url>/2024/04/11/acwing-181-%E5%9B%9E%E8%BD%AC%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>IDAstar</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      0     1</span></span><br><span class="line"><span class="comment">      2     3</span></span><br><span class="line"><span class="comment">4  5  6  7  8  9  10</span></span><br><span class="line"><span class="comment">      11    12</span></span><br><span class="line"><span class="comment">13 14 15 16 17 18 19</span></span><br><span class="line"><span class="comment">      20    21</span></span><br><span class="line"><span class="comment">      22    23</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e2</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打表操作序列</span></span><br><span class="line"><span class="type">int</span> op[maxn][maxn] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">22</span>&#125;,    &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">23</span>&#125;,</span><br><span class="line">    &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>&#125;,       &#123;<span class="number">19</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">13</span>&#125;,</span><br><span class="line">    &#123;<span class="number">23</span>, <span class="number">21</span>, <span class="number">17</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>&#125;,    &#123;<span class="number">22</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// 相反的操作序号</span></span><br><span class="line"><span class="type">int</span> opposite[maxn] = &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">// 中心八个编号</span></span><br><span class="line"><span class="type">int</span> center[maxn] = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>&#125;;</span><br><span class="line"><span class="type">int</span> q[maxn], path[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> sum[<span class="number">4</span>];</span><br><span class="line">  <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) sum[q[center[i]]]++;</span><br><span class="line">  <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) s = <span class="built_in">max</span>(s, sum[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">8</span> - s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t = q[op[x][<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) q[op[x][i]] = q[op[x][i + <span class="number">1</span>]];</span><br><span class="line">  q[op[x][<span class="number">6</span>]] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> depth, <span class="type">int</span> max_depth, <span class="type">int</span> last)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 可行性剪枝：初始状态到目前状态的开销 + 未来最小开销都大于阈值，剪枝</span></span><br><span class="line">  <span class="keyword">if</span> (depth + <span class="built_in">f</span>() &gt; max_depth) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 到达目标状态，返回</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">f</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 最优性剪枝：当前操作是上一次操作的反向，剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (opposite[i] == last) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">operation</span>(i);</span><br><span class="line">    path[depth] = i;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dfs</span>(depth + <span class="number">1</span>, max_depth, i)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">operation</span>(opposite[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; q[<span class="number">0</span>] &amp;&amp; q[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">24</span>; ++i) cin &gt;&gt; q[i];</span><br><span class="line">    <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">dfs</span>(<span class="number">0</span>, depth, <span class="number">-1</span>)) ++depth;</span><br><span class="line">    <span class="keyword">if</span> (!depth)</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;No moves needed&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; ++i) cout &lt;&lt; (<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span> + path[i]);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; q[<span class="number">6</span>] &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>八个方向枚举，只能用DFS，要找最少的操作次数，只能是迭代加深，又没什么剪枝性质，只能选择IDAstar</p>
<p>考虑估价函数：</p>
<ul>
<li>统计中间8个方格中，<strong>出现次数最多</strong>的数的次数，记为<code>k</code>次</li>
<li>每次操作会从中间8个方格中移出1个数，再移入1个数，所以最多会减少一个不同的数</li>
<li>所以估价函数设为<code>8 - k</code></li>
</ul>
<p>由于每次操作实际上就是平移数组，可以先打表操作序列以降低编程难度；</p>
<p>还有最优性剪枝，如果当前操作是上一次操作的反向，剪枝；</p>
<p>题目要求字典序最小，按照<code>ABCDEFGH</code>的顺序枚举即可。</p>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>IDAstar</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-193. 算乘方的牛</title>
    <url>/2024/04/11/acwing-193-%E7%AE%97%E4%B9%98%E6%96%B9%E7%9A%84%E7%89%9B/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>IDAstar</li>
<li>剪枝</li>
<li>最大公约数</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e2</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> P;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> f                           \</span></span><br><span class="line"><span class="meta">  x = max(tx, ty), y = min(tx, ty); \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (y &amp;&amp; dfs(x, y, dep + 1, mxdep)) return true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索顺序优化：令a一定大于等于b</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> dep, <span class="type">int</span> mxdep)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 可行性剪枝：当前层数大于阈值，剪枝</span></span><br><span class="line">  <span class="keyword">if</span> (dep &gt; mxdep) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 得到答案，返回</span></span><br><span class="line">  <span class="keyword">if</span> (a == P) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 最优性剪枝：未来剩余所有轮次都选择最大的进行翻倍，都无法到达答案</span></span><br><span class="line">  <span class="keyword">if</span> ((a &lt;&lt; (mxdep - dep)) &lt; P) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 可行性剪枝：必须是gcd(a,b)的倍数</span></span><br><span class="line">  <span class="keyword">if</span> (P % <span class="built_in">gcd</span>(a, b)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="type">int</span> x, y, tx, ty;</span><br><span class="line">  <span class="comment">// 分类讨论</span></span><br><span class="line">  tx = a + a, ty = b, f;</span><br><span class="line">  tx = a + a, ty = a, f;</span><br><span class="line">  tx = b + b, ty = a, f;</span><br><span class="line">  tx = b + b, ty = b, f;</span><br><span class="line">  tx = a + b, ty = b, f;</span><br><span class="line">  tx = a + b, ty = a, f;</span><br><span class="line">  tx = a - b, ty = b, f;</span><br><span class="line">  tx = a - b, ty = a, f;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; P;</span><br><span class="line">  <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, depth)) ++depth;</span><br><span class="line">  cout &lt;&lt; depth;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>只能使用DFS，且要找最少，考虑IDAstar</p>
<p>由于只涉及到乘除法，所以只需要在乎幂次即可，令工作变量1的幂次为<code>a</code>，工作变量2的幂次为<code>b</code>；</p>
<p>那么初始状况下<code>a = 1, b = 0</code></p>
<hr />
<p>搜索顺序优化：</p>
<ul>
<li>同样的扩展分支，显然先扩展大的数更快到达目标，令<code>a</code>一定大于等于<code>b</code></li>
</ul>
<p>可行性剪枝：</p>
<ul>
<li><p>当前搜索层数大于阈值，剪枝</p></li>
<li><p>如果<code>P</code>不是<code>gcd(a, b)</code>的倍数，剪枝</p>
<p>因为很显然，<code>P = ax + by</code>，而<code>gcd(a, b) = e</code>，显然<code>P / e</code>应该是整数</p></li>
</ul>
<p>估价函数：</p>
<ul>
<li><p>如果<code>(a &lt;&lt; (mxdep - dep)) &lt; P</code>，剪枝</p>
<p>当前只剩<code>mxdep - dep</code>次翻倍的机会，每次都翻倍更大的<code>a</code>都无法到达<code>P</code>，显然应该剪掉</p></li>
</ul>
<p>接下来讨论有几种情况：</p>
<p>一共只有以下8种情况，</p>
<p><code>(a + a, a)</code>，<code>(a + a, b)</code>，<code>(b + b, a)</code>，<code>(b + b, b)</code>，<code>(a + b, a)</code>和<code>(a + b, b)</code>，<code>(a - b, a)</code>和<code>(a - b, b)</code></p>
<p><code>a</code>一定大于等于<code>b</code>，而<code>b - a</code>一定是小于等于0的，负数相当于回头，所以<code>(b - a, a)</code>和<code>(b - a, b)</code>舍去；</p>
<p><code>(a - a, a)</code>，<code>(a - a, b)</code>，<code>(b - b, a)</code>,<code>(b - b, b)</code>这四种带0的也舍去，是减法的特例，不需要重复枚举。</p>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>最大公约数</tag>
        <tag>剪枝</tag>
        <tag>IDAstar</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-194. 涂满它</title>
    <url>/2024/04/11/acwing-194-%E6%B6%82%E6%BB%A1%E5%AE%83/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>flood-fill优化</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10</span>, dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">// v数组中，0代表未接触，1代表连通块，2代表连通块边缘</span></span><br><span class="line"><span class="type">int</span> n, g[maxn][maxn], v[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &lt;= n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flood-fill更新v数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">  v[x][y] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">valid</span>(nx, ny)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (v[nx][ny] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (g[nx][ny] == c)</span><br><span class="line">      <span class="built_in">dfs</span>(nx, ny, c);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v[nx][ny] = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 估价函数，连通块之外有几种待处理颜色</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t[<span class="number">6</span>], res = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="built_in">sizeof</span>(t));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (v[i][j] != <span class="number">1</span>) t[g[i][j]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t[i]) ++res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找连通块边缘中可以扩展的部分</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dye</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (g[i][j] == c &amp;&amp; v[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(i, j, c);</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ida</span><span class="params">(<span class="type">int</span> depth, <span class="type">int</span> mxdepth)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (depth + <span class="built_in">f</span>() &gt; mxdepth) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">f</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="type">int</span> backup[maxn][maxn];</span><br><span class="line">  <span class="built_in">memcpy</span>(backup, v, <span class="built_in">sizeof</span>(v));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; ++k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">dye</span>(k)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ida</span>(depth + <span class="number">1</span>, mxdepth)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(v, backup, <span class="built_in">sizeof</span>(v));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        cin &gt;&gt; g[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>, g[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">ida</span>(<span class="number">0</span>, depth)) ++depth;</span><br><span class="line">    cout &lt;&lt; depth &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>flood-fill操作可以使用bfs或者dfs实现，但是枚举左上角的颜色只能DFS，且要找最小步数，考虑IDAstar。</p>
<p>估价函数很简单，由于每次最多处理一种颜色，所以未来最少步数等于<strong>连通块之外有几种待处理颜色</strong>；</p>
<p>这里除了估价函数之外没有额外的剪枝，重点在于flood-fill操作常数的优化；每次都从左上角重头开始会超时。</p>
<p>如图所示，设有点<code>(i, j)</code>，标志数组<code>v[i][j]</code>存储状态，颜色数组<code>g[i][j]</code>存储颜色，</p>
<p>状态分为：</p>
<ul>
<li>等于<code>1</code>代表是连通块</li>
<li>等于<code>2</code>代表是连通块边缘</li>
<li>等于<code>0</code>代表未访问</li>
</ul>
<img src="/2024/04/11/acwing-194-%E6%B6%82%E6%BB%A1%E5%AE%83/1.png" class="" title="image-20240411214717065">
<p>如果当前左上角选择了颜色<code>c</code>，那么只需要找<code>v[i][j] == 2 &amp;&amp; g[i][j] == c</code>的格子进行flood-fill扩展即可，</p>
<p>在每个格子的扩展过程中：</p>
<ul>
<li>如果邻近格子<code>v[x][y] != 1 &amp;&amp; g[x][y] == c</code>，令<code>v[x][y] = 1</code>设为连通块，并递归扩展点<code>(x, y)</code></li>
<li>否则说明该点是连通块边缘，令<code>v[x][y] = 2</code></li>
</ul>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>IDAstar</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-195. 骑士精神</title>
    <url>/2024/04/11/acwing-195-%E9%AA%91%E5%A3%AB%E7%B2%BE%E7%A5%9E/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>双向BFS</li>
<li>IDAstar</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<p>每次其实移动的是空白格，不是棋子</p>
<h2 id="idastar">IDAstar</h2>
<p>题目告诉你最多15步，考虑IDAstar</p>
<p>由于每次最多把一个棋子移到合适的地方，所以估价函数就等于<strong>当前未到目标位置棋子的数量</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> ans[maxn][maxn + <span class="number">1</span>] = &#123;<span class="string">&quot;11111&quot;</span>, <span class="string">&quot;01111&quot;</span>, <span class="string">&quot;00*11&quot;</span>, <span class="string">&quot;00001&quot;</span>, <span class="string">&quot;00000&quot;</span>&#125;;</span><br><span class="line"><span class="type">char</span> g[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (g[i][j] != <span class="string">&#x27;*&#x27;</span> &amp;&amp; g[i][j] != ans[i][j]) ++res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ida</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> depth, <span class="type">int</span> mxdepth)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (depth + <span class="built_in">f</span>() &gt; mxdepth) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">f</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">    <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx &gt; <span class="number">4</span> || ny &gt; <span class="number">4</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">swap</span>(g[x][y], g[nx][ny]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ida</span>(nx, ny, depth + <span class="number">1</span>, mxdepth)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">swap</span>(g[x][y], g[nx][ny]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t, x, y;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++j) &#123;</span><br><span class="line">        cin &gt;&gt; g[i][j];</span><br><span class="line">        <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;*&#x27;</span>) x = i, y = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (depth &lt; <span class="number">16</span> &amp;&amp; !<span class="built_in">ida</span>(x, y, <span class="number">0</span>, depth)) ++depth;</span><br><span class="line">    cout &lt;&lt; (depth &lt; <span class="number">16</span> ? depth : <span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双向bfs">双向BFS</h2>
<p>由于已知起始状态和目标状态，且没有什么有效剪枝，可以考虑双向BFS，直接套模板即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">string a, b = <span class="string">&quot;1111101111002110000100000&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  string state_;</span><br><span class="line">  <span class="type">int</span> x_, y_, step_;</span><br><span class="line">  <span class="built_in">node</span>(string state = <span class="string">&quot;&quot;</span>, <span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>, <span class="type">int</span> step = <span class="number">0</span>)</span><br><span class="line">      : <span class="built_in">state_</span>(state), <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y), <span class="built_in">step_</span>(step) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; <span class="number">5</span> &amp;&amp; y &lt; <span class="number">5</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(queue&lt;node&gt; &amp;aq, queue&lt;node&gt; &amp;bq, unordered_map&lt;string, <span class="type">bool</span>&gt; &amp;av,</span></span></span><br><span class="line"><span class="params"><span class="function">           unordered_map&lt;string, <span class="type">bool</span>&gt; &amp;bv)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sz = aq.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">while</span> (sz--) &#123;</span><br><span class="line">    string s = aq.<span class="built_in">front</span>().state_;</span><br><span class="line">    <span class="type">int</span> x = aq.<span class="built_in">front</span>().x_, y = aq.<span class="built_in">front</span>().y_, step = aq.<span class="built_in">front</span>().step_;</span><br><span class="line">    aq.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">valid</span>(nx, ny)) <span class="keyword">continue</span>;</span><br><span class="line">      string ns = s;</span><br><span class="line">      <span class="built_in">swap</span>(ns[x * <span class="number">5</span> + y], ns[nx * <span class="number">5</span> + ny]);</span><br><span class="line">      <span class="keyword">if</span> (av.<span class="built_in">count</span>(ns)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (bv.<span class="built_in">count</span>(ns)) <span class="keyword">return</span> bq.<span class="built_in">front</span>().step_ + step + <span class="number">1</span>;</span><br><span class="line">      av[ns] = <span class="number">1</span>;</span><br><span class="line">      aq.<span class="built_in">emplace</span>(ns, nx, ny, step + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> ax, <span class="type">int</span> ay)</span> </span>&#123;</span><br><span class="line">  unordered_map&lt;string, <span class="type">bool</span>&gt; av, bv;</span><br><span class="line">  queue&lt;node&gt; aq, bq;</span><br><span class="line">  <span class="keyword">if</span> (a == b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  av[a] = <span class="number">1</span>, bv[b] = <span class="number">1</span>;</span><br><span class="line">  aq.<span class="built_in">push</span>(&#123;a, ax, ay, <span class="number">0</span>&#125;), bq.<span class="built_in">push</span>(&#123;b, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>&#125;);</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (aq.<span class="built_in">size</span>() &amp;&amp; bq.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (aq.<span class="built_in">size</span>() &lt; bq.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      res = <span class="built_in">extend</span>(aq, bq, av, bv);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res = <span class="built_in">extend</span>(bq, aq, bv, av);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (~res) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">if</span> (++cnt &gt; <span class="number">15</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t, x, y, res;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    a = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++j) &#123;</span><br><span class="line">        cin &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>) c = <span class="string">&#x27;2&#x27;</span>, x = i, y = j;</span><br><span class="line">        a += c;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">bfs</span>(x, y);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>双向BFS</tag>
        <tag>IDAstar</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-188. 武士风度的牛</title>
    <url>/2024/03/30/acwing-188-%E6%AD%A6%E5%A3%AB%E9%A3%8E%E5%BA%A6%E7%9A%84%E7%89%9B/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>BFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">200</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">          dy[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">bool</span> v[maxn][maxn];</span><br><span class="line"><span class="type">char</span> s[maxn][maxn];</span><br><span class="line"><span class="type">int</span> r, c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y_, step_;</span><br><span class="line">  <span class="built_in">node</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>, <span class="type">int</span> step = <span class="number">0</span>) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y), <span class="built_in">step_</span>(step) &#123;&#125;</span><br><span class="line">&#125; bg, ed;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; x &lt;= r &amp;&amp; y &lt;= c; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  q.<span class="built_in">push</span>(bg);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    node u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (u.x_ == ed.x_ &amp;&amp; u.y_ == ed.y_) &#123;</span><br><span class="line">      ed.step_ = u.step_;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> x = u.x_ + dx[i], y = u.y_ + dy[i];</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">valid</span>(x, y)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (v[x][y] || s[x][y] == <span class="string">&#x27;*&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">      q.<span class="built_in">emplace</span>(x, y, u.step_ + <span class="number">1</span>);</span><br><span class="line">      v[x][y] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; c &gt;&gt; r;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) cin &gt;&gt; (s[i] + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;K&#x27;</span>) &#123;</span><br><span class="line">        bg.x_ = i, bg.y_ = j, bg.step_ = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;H&#x27;</span>) &#123;</span><br><span class="line">        ed.x_ = i, ed.y_ = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">  cout &lt;&lt; ed.step_ &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>简单的二维走地图，直接看代码即可。</p>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>hdoj-3085 Nightmare Ⅱ</title>
    <url>/2024/03/27/hdoj-3085-Nightmare-%E2%85%A1/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>双向BFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">8e2</span> + <span class="number">50</span>;</span><br><span class="line"><span class="comment">// 0~3上下左右</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">char</span> s[maxn][maxn];</span><br><span class="line"><span class="type">bool</span> M[maxn][maxn], G[maxn][maxn];</span><br><span class="line"><span class="type">int</span> r, c, ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y_;</span><br><span class="line">  <span class="built_in">node</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line">&#125; m, g, z1, z2;</span><br><span class="line">queue&lt;node&gt; mq, gq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">1</span> || y &lt; <span class="number">1</span> || x &gt; r || y &gt; c) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (s[x][y] == <span class="string">&#x27;X&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">abs</span>(x - z1.x_) + <span class="built_in">abs</span>(y - z1.y_) &lt;= <span class="number">2</span> * ans) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">abs</span>(x - z2.x_) + <span class="built_in">abs</span>(y - z2.y_) &lt;= <span class="number">2</span> * ans) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  m = g = z1 = z2 = <span class="built_in">node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">        m.x_ = i, m.y_ = j;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;G&#x27;</span>) &#123;</span><br><span class="line">        g.x_ = i, g.y_ = j;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!z1.x_) &#123;</span><br><span class="line">          z1.x_ = i, z1.y_ = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          z2.x_ = i, z2.y_ = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ans = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(M, <span class="number">0</span>, <span class="built_in">sizeof</span>(M)), <span class="built_in">memset</span>(G, <span class="number">0</span>, <span class="built_in">sizeof</span>(G));</span><br><span class="line">  <span class="keyword">while</span> (!mq.<span class="built_in">empty</span>()) mq.<span class="built_in">pop</span>();</span><br><span class="line">  <span class="keyword">while</span> (!gq.<span class="built_in">empty</span>()) gq.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ms, gs;</span><br><span class="line">  mq.<span class="built_in">push</span>(m), gq.<span class="built_in">push</span>(g);</span><br><span class="line">  M[m.x_][m.y_] = G[g.x_][g.y_] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!mq.<span class="built_in">empty</span>() || !gq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    ++ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">3</span>; ++k) &#123;</span><br><span class="line">      ms = mq.<span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">while</span> (ms--) &#123;</span><br><span class="line">        node u = mq.<span class="built_in">front</span>();</span><br><span class="line">        mq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">valid</span>(u.x_, u.y_)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">          <span class="type">int</span> x = u.x_ + dx[i], y = u.y_ + dy[i];</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">valid</span>(x, y) &amp;&amp; !M[x][y]) &#123;</span><br><span class="line">            M[x][y] = <span class="number">1</span>;</span><br><span class="line">            mq.<span class="built_in">emplace</span>(x, y);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    gs = gq.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (gs--) &#123;</span><br><span class="line">      node u = gq.<span class="built_in">front</span>();</span><br><span class="line">      gq.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">valid</span>(u.x_, u.y_)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> x = u.x_ + dx[i], y = u.y_ + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">valid</span>(x, y) &amp;&amp; !G[x][y]) &#123;</span><br><span class="line">          <span class="keyword">if</span> (M[x][y]) <span class="keyword">return</span> ans;</span><br><span class="line">          G[x][y] = <span class="number">1</span>;</span><br><span class="line">          gq.<span class="built_in">emplace</span>(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    cin &gt;&gt; r &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, (s[i] + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>这道题最难的部分可能就是读题：</p>
<ul>
<li><p>鬼每次占领两步以内可达的点，无视墙；鬼占领区内的点也适用</p>
<img src="/2024/03/27/hdoj-3085-Nightmare-%E2%85%A1/1.png" class="" title="image-20240327191800299"></li>
<li><p>男每次走三步，女每次走一步</p></li>
</ul>
<p>使用双向BFS，建立两个队列，分别从男、女的初始位置开始进行BFS，两边轮流进行。</p>
<p>在每一轮中，男孩BFS三次（模拟移动三步），女孩BFS一次（移动一步），分别用<code>M</code>和<code>G</code>记录男、女的可达性。</p>
<p>每次扩展时，实时计算新状态与鬼之间的曼哈顿距离，如果距离小于等于<code>当前轮数的2倍</code>，那么不合法。</p>
<p>如果过程中<code>G</code>的点也出现在了<code>M</code>，当前轮数就是两人的最短会合时间。</p>
]]></content>
      <categories>
        <category>hdoj</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>双向BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-1167 The Buses</title>
    <url>/2024/04/01/poj-1167-The-Buses/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>迭代加深</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="comment">// n个巴士m条线路</span></span><br><span class="line"><span class="type">int</span> n, m, bus[<span class="number">70</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = a; i &lt; <span class="number">60</span>; i += d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!bus[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="comment">// 序列巴士个数，序列首项，序列公差</span></span><br><span class="line">  <span class="type">int</span> cnt_, a_, d_;</span><br><span class="line">  <span class="built_in">node</span>(<span class="type">int</span> cnt = <span class="number">0</span>, <span class="type">int</span> a = <span class="number">0</span>, <span class="type">int</span> d = <span class="number">0</span>) : <span class="built_in">cnt_</span>(cnt), <span class="built_in">a_</span>(a), <span class="built_in">d_</span>(d) &#123;&#125;</span><br><span class="line">  <span class="comment">// 优化搜索顺序：先从巴士个数多的开始</span></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node &amp;x) &#123;</span><br><span class="line">    <span class="keyword">return</span> cnt_ &gt; x.cnt_ || cnt_ == x.cnt_ &amp;&amp; a_ &lt; x.a_ ||</span><br><span class="line">           cnt_ == x.cnt_ &amp;&amp; a_ == x.a_ &amp;&amp; d_ &lt; x.d_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> depth, <span class="type">int</span> sum, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!depth) <span class="keyword">return</span> sum == n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> a = s[i].a_, d = s[i].d_, cnt = s[i].cnt_;</span><br><span class="line">    <span class="comment">// 可行性剪枝：当前及后续所有路线都取最多车数，都达不到目标值</span></span><br><span class="line">    <span class="keyword">if</span> (cnt * depth + sum &lt; n) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">valid</span>(a, d)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = a; j &lt; <span class="number">60</span>; j += d) --bus[j];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dfs</span>(depth - <span class="number">1</span>, sum + cnt, i)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = a; j &lt; <span class="number">60</span>; j += d) ++bus[j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 按时间分类统计巴士数</span></span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x, i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; x, ++bus[x];</span><br><span class="line">  <span class="comment">// 枚举路线首项</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">60</span>; ++a) &#123;</span><br><span class="line">    <span class="comment">// 枚举路线公差，应满足两个条件</span></span><br><span class="line">    <span class="comment">// d &gt; a，否则a不是首项</span></span><br><span class="line">    <span class="comment">// a + d &lt; 60 ，否则无法保证路线至少两个车</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d = a + <span class="number">1</span>; a + d &lt; <span class="number">60</span>; ++d) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">valid</span>(a, d)) s[m++] = <span class="built_in">node</span>((<span class="number">59</span> - a) / d + <span class="number">1</span>, a, d);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(s, s + m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="type">int</span> dep = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">dfs</span>(dep, <span class="number">0</span>, <span class="number">0</span>)) ++dep;</span><br><span class="line">  cout &lt;&lt; dep &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题目明确说了路线条数不会超过17，所以采用迭代加深。</p>
<p>根据题意，每条路线由<code>(路线巴士个数，首项&lt;第一班车到达时间&gt;，公差&lt;时间间隔&gt;)</code>三元组构成。</p>
<p>所以先枚举出所有可能的路线，然后迭代加深选择即可。</p>
<hr />
<p>枚举路线有两个限制条件：</p>
<ol type="1">
<li><code>时间间隔 &gt; 首项</code>，否则首项就不是首项</li>
<li><code>首项 + 时间间隔 &lt; 60</code>，否则无法保证至少线路上有两辆车</li>
</ol>
<p>线路上的巴士数量就等于<code>(60 - 1 - 首项) / 间隔 + 1</code></p>
<hr />
<p>剪枝主要分两步：</p>
<p>搜索顺序优化：按照巴士数量降序排列，先枚举大的可以减少分支</p>
<p>可行性优化：因为我们是降序排列，所以当前线路的巴士数量一定大于等于后续线路的巴士数量；</p>
<p>如果<code>当前巴士数量 * 后续线路数 + 之前已选的巴士数 &lt; 总巴士数</code>，就剪枝。</p>
]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>迭代加深</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-2044 Weather Forecast</title>
    <url>/2024/03/31/poj-2044-Weather-Forecast/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>BFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">366</span>;</span><br><span class="line"><span class="comment">// 0-4上下左右不变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="comment">// s[i][x][y]：第i天(x,y)是否出行</span></span><br><span class="line"><span class="type">int</span> s[maxn][<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="type">bool</span> v[maxn][<span class="number">4</span>][<span class="number">4</span>][<span class="number">8</span>][<span class="number">8</span>][<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="comment">// 第几天，2*2方格左上角的坐标，左上右上左下右下四个角（连续几天没下雨）</span></span><br><span class="line">  <span class="type">int</span> day_, x_, y_, s0_, s1_, s2_, s3_;</span><br><span class="line">  <span class="built_in">node</span>(<span class="type">int</span> day = <span class="number">0</span>, <span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>, <span class="type">int</span> s0 = <span class="number">0</span>, <span class="type">int</span> s1 = <span class="number">0</span>, <span class="type">int</span> s2 = <span class="number">0</span>,</span><br><span class="line">       <span class="type">int</span> s3 = <span class="number">0</span>)</span><br><span class="line">      : <span class="built_in">day_</span>(day), <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y), <span class="built_in">s0_</span>(s0), <span class="built_in">s1_</span>(s1), <span class="built_in">s2_</span>(s2), <span class="built_in">s3_</span>(s3) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; <span class="number">3</span> &amp;&amp; y &lt; <span class="number">3</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化状态</span></span><br><span class="line">  <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">  <span class="comment">// 第一天不符合要求</span></span><br><span class="line">  <span class="keyword">if</span> (s[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] || s[<span class="number">1</span>][<span class="number">1</span>][<span class="number">2</span>] || s[<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>] || s[<span class="number">1</span>][<span class="number">2</span>][<span class="number">2</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  queue&lt;node&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="built_in">node</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">  v[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    node u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (u.day_ == n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span>; ++j) &#123;</span><br><span class="line">        <span class="type">int</span> day = u.day_ + <span class="number">1</span>, x = u.x_ + j * dx[i], y = u.y_ + j * dy[i];</span><br><span class="line">        <span class="type">int</span> s0 = u.s0_, s1 = u.s1_, s2 = u.s2_, s3 = u.s3_;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">valid</span>(x, y)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 新位置不符合要求</span></span><br><span class="line">        <span class="keyword">if</span> (s[day][x][y] || s[day][x + <span class="number">1</span>][y] || s[day][x][y + <span class="number">1</span>] ||</span><br><span class="line">            s[day][x + <span class="number">1</span>][y + <span class="number">1</span>])</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 判断四个角，是否存在连续七天没下雨</span></span><br><span class="line">        <span class="keyword">if</span> (!x &amp;&amp; !y)</span><br><span class="line">          s0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++s0 == <span class="number">7</span>)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!x &amp;&amp; y == <span class="number">2</span>)</span><br><span class="line">          s1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++s1 == <span class="number">7</span>)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">2</span> &amp;&amp; !y)</span><br><span class="line">          s2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++s2 == <span class="number">7</span>)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">2</span> &amp;&amp; y == <span class="number">2</span>)</span><br><span class="line">          s3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++s3 == <span class="number">7</span>)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (v[day][x][y][s0][s1][s2][s3]) <span class="keyword">continue</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">node</span>(day, x, y, s0, s1, s2, s3));</span><br><span class="line">        v[day][x][y][s0][s1][s2][s3] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">4</span>; ++x) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">4</span>; ++y) &#123;</span><br><span class="line">          cin &gt;&gt; s[i][x][y];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本题最大的难点，在于如何判断全图是否有连续7天没下雨的地方；</p>
<p>可能你想每个状态都直接保存一个图，我也尝试过，然后<code>MLE</code>了。</p>
<p>实际上只需要记录左上<code>s0</code>，右上<code>s1</code>，左下<code>s2</code>，右下<code>s3</code>四个角的连续不下雨天数即可，</p>
<p>因为我们的方块是<code>2*2</code>的，只要上面某个角下过雨，那么该角所在的<code>2*2</code>格子就不会连续干旱。</p>
<img src="/2024/03/31/poj-2044-Weather-Forecast/1.png" class="" title="image-20240331220003843">
<p>所以用<code>(天数, 云左上角的x, 云左上角的y, s0, s1, s2, s3)</code>来表达状态即可。</p>
]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-2248 Addition Chains</title>
    <url>/2024/03/23/poj-2248-Addition-Chains/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
<li>迭代加深</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e2</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="type">int</span> n, m, ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> dep)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dep == m) <span class="keyword">return</span> ans[m] == n;</span><br><span class="line">  <span class="type">int</span> sum;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = dep; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">      sum = ans[i] + ans[j];</span><br><span class="line">      <span class="keyword">if</span> (sum &lt;= n &amp;&amp; sum &gt; ans[dep] &amp;&amp; !vis[sum]) &#123;</span><br><span class="line">        ans[dep + <span class="number">1</span>] = sum;</span><br><span class="line">        vis[sum] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(dep + <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        vis[sum] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ans[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">    m = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">dfs</span>(<span class="number">1</span>)) ++m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>直接上图。</p>
<img src="/2024/03/23/poj-2248-Addition-Chains/1.png" class="" title="image-20240323160053899">
]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>迭代加深</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-2676 Sudoku</title>
    <url>/2024/03/21/poj-2676-Sudoku/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
<li>剪枝</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">9</span>;</span><br><span class="line"><span class="type">char</span> c[maxn][maxn];</span><br><span class="line"><span class="comment">// 每行、每列、每个九宫格的可选数字状态</span></span><br><span class="line"><span class="type">int</span> row[maxn], col[maxn], grid[maxn];</span><br><span class="line"><span class="comment">// 0~(1&lt;&lt;maxn)-1 每个数有多少个1</span></span><br><span class="line"><span class="type">int</span> cnt[<span class="number">1</span> &lt;&lt; maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> (x / <span class="number">3</span>) * <span class="number">3</span> + (y / <span class="number">3</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  row[x] ^= (<span class="number">1</span> &lt;&lt; v), col[y] ^= (<span class="number">1</span> &lt;&lt; v), grid[<span class="built_in">g</span>(x, y)] ^= (<span class="number">1</span> &lt;&lt; v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 所有点都成功搜完</span></span><br><span class="line">  <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="type">int</span> p = <span class="number">10</span>, x, y, s;</span><br><span class="line">  <span class="comment">// 先处理最小可能的点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; maxn; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c[i][j] != <span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">      s = row[i] &amp; col[j] &amp; grid[<span class="built_in">g</span>(i, j)];</span><br><span class="line">      <span class="comment">// 明明是&#x27;.&#x27;，但是没地方放，说明本次搜索失败</span></span><br><span class="line">      <span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (cnt[s] &lt; p) p = cnt[s], x = i, y = j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  s = row[x] &amp; col[y] &amp; grid[<span class="built_in">g</span>(x, y)];</span><br><span class="line">  <span class="keyword">while</span> (s) &#123;</span><br><span class="line">    <span class="comment">// s的lowbit是1向左移动了v位</span></span><br><span class="line">    <span class="type">int</span> v = cnt[<span class="built_in">lowbit</span>(s) - <span class="number">1</span>];</span><br><span class="line">    c[x][y] = <span class="string">&#x27;1&#x27;</span> + v;</span><br><span class="line">    <span class="built_in">flip</span>(x, y, v);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dfs</span>(n - <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">flip</span>(x, y, v);</span><br><span class="line">    c[x][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    s -= <span class="built_in">lowbit</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 打表所有状态的1个数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; maxn); ++i) &#123;</span><br><span class="line">    <span class="type">int</span> j = i;</span><br><span class="line">    <span class="keyword">while</span> (j) ++cnt[i], j -= <span class="built_in">lowbit</span>(j);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始状态下，每个点可以放0~8所有数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) row[i] = col[i] = grid[i] = (<span class="number">1</span> &lt;&lt; maxn) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; maxn; ++j) &#123;</span><br><span class="line">        cin &gt;&gt; c[i][j];</span><br><span class="line">        <span class="keyword">if</span> (c[i][j] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">          <span class="built_in">flip</span>(i, j, c[i][j] - <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ++tot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(tot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i, cout &lt;&lt; endl) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; maxn; ++j) &#123;</span><br><span class="line">        cout &lt;&lt; c[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>本题是poj-3074 Sudoku的简化版，详情见该题。</p>
]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-3074 Sudoku</title>
    <url>/2024/03/20/poj-3074-Sudoku/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>DFS</li>
<li>状态压缩</li>
<li>剪枝</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">9</span>;</span><br><span class="line"><span class="type">char</span> c[maxn][maxn];</span><br><span class="line"><span class="comment">// 每行、每列、每个九宫格的可选数字状态</span></span><br><span class="line"><span class="type">int</span> row[maxn], col[maxn], grid[maxn];</span><br><span class="line"><span class="comment">// 0~(1&lt;&lt;maxn)-1 每个数有多少个1</span></span><br><span class="line"><span class="type">int</span> cnt[<span class="number">1</span> &lt;&lt; maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> (x / <span class="number">3</span>) * <span class="number">3</span> + (y / <span class="number">3</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  row[x] ^= (<span class="number">1</span> &lt;&lt; v), col[y] ^= (<span class="number">1</span> &lt;&lt; v), grid[<span class="built_in">g</span>(x, y)] ^= (<span class="number">1</span> &lt;&lt; v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 所有点都成功搜完</span></span><br><span class="line">  <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="type">int</span> p = <span class="number">10</span>, x, y, s;</span><br><span class="line">  <span class="comment">// 先处理最小可能的点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; maxn; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c[i][j] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">      s = row[i] &amp; col[j] &amp; grid[<span class="built_in">g</span>(i, j)];</span><br><span class="line">      <span class="comment">// 明明是&#x27;.&#x27;，但是没地方放，说明本次搜索失败</span></span><br><span class="line">      <span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (cnt[s] &lt; p) p = cnt[s], x = i, y = j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  s = row[x] &amp; col[y] &amp; grid[<span class="built_in">g</span>(x, y)];</span><br><span class="line">  <span class="keyword">while</span> (s) &#123;</span><br><span class="line">    <span class="comment">// s的lowbit是1向左移动了v位</span></span><br><span class="line">    <span class="type">int</span> v = cnt[<span class="built_in">lowbit</span>(s) - <span class="number">1</span>];</span><br><span class="line">    c[x][y] = <span class="string">&#x27;1&#x27;</span> + v;</span><br><span class="line">    <span class="built_in">flip</span>(x, y, v);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dfs</span>(n - <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">flip</span>(x, y, v);</span><br><span class="line">    c[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    s -= <span class="built_in">lowbit</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string str;</span><br><span class="line">  <span class="comment">// 打表所有状态的1个数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; maxn); ++i) &#123;</span><br><span class="line">    <span class="type">int</span> j = i;</span><br><span class="line">    <span class="keyword">while</span> (j) ++cnt[i], j -= <span class="built_in">lowbit</span>(j);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; str &amp;&amp; str[<span class="number">0</span>] != <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">    <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始状态下，每个点可以放0~8所有数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) row[i] = col[i] = grid[i] = (<span class="number">1</span> &lt;&lt; maxn) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; maxn; ++j) &#123;</span><br><span class="line">        c[i][j] = str[i * <span class="number">9</span> + j];</span><br><span class="line">        <span class="keyword">if</span> (c[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">          <span class="built_in">flip</span>(i, j, c[i][j] - <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ++tot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(tot);</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; maxn; ++j) &#123;</span><br><span class="line">        ans += c[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>直接上图，实现的具体细节见注释就好了~</p>
<img src="/2024/03/20/poj-3074-Sudoku/1.jpg" class="" title="102e376a760843ac3d97e01703fac7f">
<img src="/2024/03/20/poj-3074-Sudoku/2.jpg" class="" title="1aa30f7b65f8e81a760e3ec7fef37ad">
]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>状态压缩</tag>
        <tag>DFS</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-3322 Bloxorz I</title>
    <url>/2024/03/24/poj-3322-Bloxorz-I/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>BFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e2</span> + <span class="number">50</span>;</span><br><span class="line"><span class="comment">// lie=0,长方体立在(x,y)</span></span><br><span class="line"><span class="comment">// lie=1,长方体的左半部分在(x,y)</span></span><br><span class="line"><span class="comment">// lie=2,长方体的上半部分在(x,y)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y_, lie_;</span><br><span class="line">  <span class="built_in">node</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>, <span class="type">int</span> lie = <span class="number">0</span>) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y), <span class="built_in">lie_</span>(lie) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 0~3左右上下的方向数组</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// nxt_x[i][j]表示lie=i时，朝方向j滚动x的变化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> nxt_x[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// nxt_y[i][j]表示lie=i时，朝方向j滚动y的变化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> nxt_y[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">-2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// nxt_lie[i][j]表示lie=i时，朝方向j滚动后lie的新值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> nxt_lie[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> r, c, steps[maxn][maxn][<span class="number">3</span>];</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line"><span class="type">char</span> mp[maxn][maxn];</span><br><span class="line">node bg, ed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= r &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= c; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(node x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">valid</span>(x.x_, x.y_)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (mp[x.x_][x.y_] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (x.lie_ == <span class="number">0</span> &amp;&amp; mp[x.x_][x.y_] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (x.lie_ == <span class="number">1</span> &amp;&amp; mp[x.x_][x.y_ + <span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (x.lie_ == <span class="number">2</span> &amp;&amp; mp[x.x_ + <span class="number">1</span>][x.y_] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理起点和终点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mp[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">        bg = <span class="built_in">node</span>(i, j, <span class="number">0</span>), mp[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mp[i][j] == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">          <span class="type">int</span> x = i + dx[k], y = j + dy[k];</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">valid</span>(x, y) &amp;&amp; mp[x][y] == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">            ed.x_ = <span class="built_in">min</span>(x, i), ed.y_ = <span class="built_in">min</span>(y, j);</span><br><span class="line">            ed.lie_ = k &lt; <span class="number">2</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">            mp[i][j] = mp[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mp[i][j] == <span class="string">&#x27;X&#x27;</span>) ed = <span class="built_in">node</span>(i, j, <span class="number">0</span>), mp[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">  steps[bg.x_][bg.y_][bg.lie_] = <span class="number">0</span>, q.<span class="built_in">push</span>(bg);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    node u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">      node nxt;</span><br><span class="line">      nxt.x_ = u.x_ + nxt_x[u.lie_][i];</span><br><span class="line">      nxt.y_ = u.y_ + nxt_y[u.lie_][i];</span><br><span class="line">      nxt.lie_ = nxt_lie[u.lie_][i];</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">valid</span>(nxt)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (~steps[nxt.x_][nxt.y_][nxt.lie_]) <span class="keyword">continue</span>;</span><br><span class="line">      steps[nxt.x_][nxt.y_][nxt.lie_] = steps[u.x_][u.y_][u.lie_] + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (nxt.x_ == ed.x_ &amp;&amp; nxt.y_ == ed.y_ &amp;&amp; nxt.lie_ == ed.lie_)</span><br><span class="line">        <span class="keyword">return</span> steps[nxt.x_][nxt.y_][nxt.lie_];</span><br><span class="line">      q.<span class="built_in">push</span>(nxt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; r &gt;&gt; c &amp;&amp; r &amp;&amp; c) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(steps, <span class="number">-1</span>, <span class="built_in">sizeof</span>(steps));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, mp[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">bfs</span>();</span><br><span class="line">    ~res ? cout &lt;&lt; res : cout &lt;&lt; <span class="string">&quot;Impossible&quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>用一个三元组<code>(x, y, lie)</code>代表一个状态（搜索树中的一个节点），其中：</p>
<ul>
<li><code>lie = 0</code>表示长方体立在<code>(x, y)</code></li>
<li><code>lie = 1</code>表示长方体横向躺着，左半部分位置在<code>(x, y)</code></li>
<li><code>lie = 2</code>表示长方体纵向躺着，上半部分在<code>(x, y)</code></li>
</ul>
<p>数组<code>steps[x][y][lie]</code>记录从起始状态到达每个状态的最小步数</p>
<p>其余细节见代码即可</p>
]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-3635 Full Tank</title>
    <url>/2024/03/27/poj-3635-Full-Tank/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>最短路</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="comment">// d[city][fuel]：(city,fuel)状态下的最小开销</span></span><br><span class="line"><span class="type">int</span> n, m, C, S, E, tot = <span class="number">-1</span>, p[maxn], d[maxn][maxn], head[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> v_, w_, nxt_;</span><br><span class="line">&#125; e[(<span class="type">int</span>)<span class="number">1e4</span> &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> d_, city_, fuel_;</span><br><span class="line">  <span class="built_in">node</span>(<span class="type">int</span> d = <span class="number">0</span>, <span class="type">int</span> city = <span class="number">0</span>, <span class="type">int</span> fuel = <span class="number">0</span>)</span><br><span class="line">      : <span class="built_in">d_</span>(d), <span class="built_in">city_</span>(city), <span class="built_in">fuel_</span>(fuel) &#123;&#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> d_ &gt; x.d_ || (d_ == x.d_ &amp;&amp; city_ &gt; x.city_) ||</span><br><span class="line">           (d_ == x.d_ &amp;&amp; city_ == x.city_ &amp;&amp; fuel_ &gt; x.fuel_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">  e[++tot].v_ = v, e[tot].w_ = w, e[tot].nxt_ = head[u];</span><br><span class="line">  head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d)), <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">  d[S][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="built_in">node</span>(<span class="number">0</span>, S, <span class="number">0</span>));</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    node u = q.<span class="built_in">top</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> city = u.city_, fuel = u.fuel_;</span><br><span class="line">    <span class="keyword">if</span> (vis[city][fuel]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[city][fuel] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u.city_ == E) &#123;</span><br><span class="line">      cout &lt;&lt; d[city][fuel] &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fuel &lt; C &amp;&amp; d[city][fuel + <span class="number">1</span>] &gt; d[city][fuel] + p[city]) &#123;</span><br><span class="line">      d[city][fuel + <span class="number">1</span>] = d[city][fuel] + p[city];</span><br><span class="line">      q.<span class="built_in">push</span>(<span class="built_in">node</span>(d[city][fuel] + p[city], city, fuel + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[city]; ~i; i = e[i].nxt_) &#123;</span><br><span class="line">      <span class="type">int</span> nxt = e[i].v_, w = e[i].w_;</span><br><span class="line">      <span class="keyword">if</span> (fuel &gt;= w &amp;&amp; d[nxt][fuel - w] &gt; d[city][fuel]) &#123;</span><br><span class="line">        d[nxt][fuel - w] = d[city][fuel];</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">node</span>(d[city][fuel], nxt, fuel - w));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;impossible&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="type">int</span> u, v, w, t;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; p[i];</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    <span class="built_in">add</span>(u, v, w), <span class="built_in">add</span>(v, u, w);</span><br><span class="line">  &#125;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    cin &gt;&gt; C &gt;&gt; S &gt;&gt; E;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>二元组<code>(city, fuel)</code>表示每个状态，其中<code>city</code>为城市编号，<code>fuel</code>为油箱中剩余的汽油量，并使用记录数组<code>d[city][fuel]</code>存储最少花费。</p>
<p>对于每个问题，单独进行一次优先队列BFS（Dijkstra），起始状态为<code>(S, 0)</code>，每个状态的分支有：</p>
<ol type="1">
<li>若<code>fuel</code> &lt;
<code>C</code>，可以加1升油，扩展到新状态<code>(city, fuel + 1)</code>，花费在城市<code>city</code>加1升油的钱；</li>
<li>对于每条从<code>city</code>出发的边<code>(city, next)</code>，若边权大小<code>w</code>不超过<code>fuel</code>，可以开车前往城市<code>next</code>，扩展到新状态<code>(next, fuel - w)</code></li>
</ol>
<p>每次不断取出优先队列中<strong>当前花费最少</strong>的状态（堆顶）进行扩展，更新扩展到的新状态在记录数组<code>d</code>中存储的值，直到终点<code>T</code>的某个状态第一次被取出，输出答案。</p>
]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>最短路</tag>
        <tag>优先队列BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-3700 Missile Defence System</title>
    <url>/2024/04/02/poj-3700-Missile-Defence-System/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>贪心</li>
<li>迭代加深</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<p>设<code>ascend[i]代表第i个升序序列的结尾数字</code>，设<code>descend[i]代表第i个降序序列的结尾数字</code></p>
<p>每个数字可以选择去组成升序序列，还是降序序列；乍一看复杂度高达2<sup>50</sup>，实际上蕴含着贪心：</p>
<p>以升序序列为例，所有升序序列的结尾数字按下标排列后必定是降序形式的；</p>
<blockquote>
<p>当前4插入到升序序列，有{4}</p>
<p>插入6，显然{6}更优，而不是{4, 6}</p>
<p>插入5，{6, 5}</p>
<p>插入4，{6, 5, 4}</p>
<p>插入7，可以选择插入第一个升序序列变为{7, 5, 4}，或者{6, 7,
4}，或者{6, 5, 7}</p>
<p>但显然{7, 5,
4}更优，因为接在6后面需要大于6、接在5的后面需要大于5、接在4的后面需要大于4，</p>
<p>后两者的可能性更大，更容易填满当前数量的升序序列，而不用开一个新的升序序列。</p>
<p>所以，只需要插入到第一个满足条件的序列即可，其他满足条件的序列也能插，但是不会更优。</p>
</blockquote>
<p>但由于DFS性质，不能直接找最短路，所以有两种实现方式：</p>
<ol type="1">
<li><p>迭代加深，模拟BFS</p></li>
<li><p>朴素法，定义一个全局变量<code>ans</code>，与其打擂台</p>
<p><strong>只要不比<code>ans</code>更优就剪枝，比<code>ans</code>更优才更新</strong></p></li>
</ol>
<h2 id="迭代加深实现">迭代加深实现</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e2</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, missile[maxn], ascend[maxn], descend[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最多几个序列总数，当前下标，上升序列个数，下降序列个数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> depth, <span class="type">int</span> now, <span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 迭代加深，控制最大序列总数</span></span><br><span class="line">  <span class="keyword">if</span> (p + q &gt; depth) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (now == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 已有上升序列中，能不能插进去</span></span><br><span class="line">  <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (missile[now] &gt; ascend[i]) &#123;</span><br><span class="line">      flag = <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> t = ascend[i];</span><br><span class="line">      ascend[i] = missile[now];</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">dfs</span>(depth, now + <span class="number">1</span>, p, q)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      ascend[i] = t;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 已有的上升序列插不进去，那就新建</span></span><br><span class="line">  <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">    ascend[p + <span class="number">1</span>] = missile[now];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dfs</span>(depth, now + <span class="number">1</span>, p + <span class="number">1</span>, q)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 已有的下降序列中，能不能插进去</span></span><br><span class="line">  flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (missile[now] &lt; descend[i]) &#123;</span><br><span class="line">      flag = <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> t = descend[i];</span><br><span class="line">      descend[i] = missile[now];</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">dfs</span>(depth, now + <span class="number">1</span>, p, q)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      descend[i] = t;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 已有的下降序列插不进去，那就新建</span></span><br><span class="line">  <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">    descend[q + <span class="number">1</span>] = missile[now];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dfs</span>(depth, now + <span class="number">1</span>, p, q + <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; missile[i];</span><br><span class="line">    <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">dfs</span>(depth, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)) ++depth;</span><br><span class="line">    cout &lt;&lt; depth &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="朴素实现全局变量打擂台">朴素实现（全局变量打擂台）</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e2</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, ans, missile[maxn], ascend[maxn], descend[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前下标，上升序列个数，下降序列个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p + q &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (now == n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p + q &lt; ans) ans = p + q;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 已有上升序列中，能不能插进去</span></span><br><span class="line">  <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (missile[now] &gt; ascend[i]) &#123;</span><br><span class="line">      flag = <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> t = ascend[i];</span><br><span class="line">      ascend[i] = missile[now];</span><br><span class="line">      <span class="built_in">dfs</span>(now + <span class="number">1</span>, p, q);</span><br><span class="line">      ascend[i] = t;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 已有的上升序列插不进去，那就新建</span></span><br><span class="line">  <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">    ascend[p + <span class="number">1</span>] = missile[now];</span><br><span class="line">    <span class="built_in">dfs</span>(now + <span class="number">1</span>, p + <span class="number">1</span>, q);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 已有的下降序列中，能不能插进去</span></span><br><span class="line">  flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (missile[now] &lt; descend[i]) &#123;</span><br><span class="line">      flag = <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> t = descend[i];</span><br><span class="line">      descend[i] = missile[now];</span><br><span class="line">      <span class="built_in">dfs</span>(now + <span class="number">1</span>, p, q);</span><br><span class="line">      descend[i] = t;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 已有的下降序列插不进去，那就新建</span></span><br><span class="line">  <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">    descend[q + <span class="number">1</span>] = missile[now];</span><br><span class="line">    <span class="built_in">dfs</span>(now + <span class="number">1</span>, p, q + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">    ans = <span class="number">51</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; missile[i];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>贪心</tag>
        <tag>迭代加深</tag>
      </tags>
  </entry>
  <entry>
    <title>CF525E. Anya and Cubes</title>
    <url>/2024/04/14/CF525E-Anya-and-Cubes/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>双向DFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line">ll N, K, S, ans, a[maxn], v[maxn], p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打表判断每个位置上的数字阶乘对于S是否有效</span></span><br><span class="line"><span class="function">ll <span class="title">pd</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  ll fact = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fact * x &gt; S) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    fact *= x--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fact;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map&lt;pair&lt;<span class="type">int</span>, ll&gt;, <span class="type">int</span>&gt; f;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll cnt = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v[i] == <span class="number">1</span>)</span><br><span class="line">      sum += a[i];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v[i] == <span class="number">2</span>) &#123;</span><br><span class="line">      ll s = p[i];</span><br><span class="line">      <span class="keyword">if</span> ((s == <span class="number">-1</span>) || ((s + sum) &gt; S)) <span class="keyword">return</span>;</span><br><span class="line">      ++cnt;</span><br><span class="line">      sum += s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ++f[&#123;cnt, sum&#125;];</span><br><span class="line">  <span class="comment">// 由于同一个sum会有很多种cnt，单独开一个(-1,sum)确认sum是否存在</span></span><br><span class="line">  ++f[&#123;<span class="number">-1</span>, sum&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左半边递归</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; N / <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">check1</span>();</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">0</span> || i == <span class="number">1</span>) &#123;</span><br><span class="line">        v[x] = i;</span><br><span class="line">        <span class="built_in">dfs1</span>(x + <span class="number">1</span>, k);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span> &amp;&amp; k) &#123;</span><br><span class="line">        <span class="comment">// 可行性剪枝：只有k大于0的时候才能选阶乘</span></span><br><span class="line">        v[x] = i;</span><br><span class="line">        <span class="built_in">dfs1</span>(x + <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记忆化搜索优化</span></span><br><span class="line">map&lt;pair&lt;<span class="type">int</span>, ll&gt;, ll&gt; g;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x, ll s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (g.<span class="built_in">count</span>(&#123;x, s&#125;)) <span class="keyword">return</span> g[&#123;x, s&#125;];</span><br><span class="line">  <span class="keyword">return</span> g[&#123;x, s&#125;] = f[&#123;x, s&#125;] + (x ? <span class="built_in">query</span>(x - <span class="number">1</span>, s) : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll cnt = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = N / <span class="number">2</span> + <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v[i] == <span class="number">1</span>)</span><br><span class="line">      sum += a[i];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v[i] == <span class="number">2</span>) &#123;</span><br><span class="line">      ll s = p[i];</span><br><span class="line">      <span class="keyword">if</span> ((s == <span class="number">-1</span>) || ((sum + s) &gt; S)) <span class="keyword">return</span>;</span><br><span class="line">      ++cnt;</span><br><span class="line">      sum += s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (f.<span class="built_in">count</span>(&#123;<span class="number">-1</span>, S - sum&#125;)) ans += <span class="built_in">query</span>(K - cnt, S - sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右半边递归</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x, ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; N)</span><br><span class="line">    <span class="built_in">check2</span>();</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">0</span> || i == <span class="number">1</span>) &#123;</span><br><span class="line">        v[x] = i;</span><br><span class="line">        <span class="built_in">dfs2</span>(x + <span class="number">1</span>, k);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span> &amp;&amp; k) &#123;</span><br><span class="line">        v[x] = i;</span><br><span class="line">        <span class="built_in">dfs2</span>(x + <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; N &gt;&gt; K &gt;&gt; S;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) cin &gt;&gt; a[i], p[i] = <span class="built_in">pd</span>(a[i]);</span><br><span class="line">  <span class="built_in">dfs1</span>(<span class="number">1</span>, K), <span class="built_in">dfs2</span>(N / <span class="number">2</span> + <span class="number">1</span>, K);</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>每个位置上的元素有三种状态，不选、选但不加阶乘，选且阶乘，总复杂度高达<span
class="math inline">\(O\left( 3^{25}
\right)\)</span>，考虑双向DFS，可降到$ O( 3^{12} )$</p>
<p>每个状态是一个二元组，<code>(阶乘个数，总和)</code></p>
<p>所以用一个红黑树来记录<strong>左半部分</strong>每个状态的出现次数<code>map&lt;pair&lt;int, ll&gt;, int&gt; f</code></p>
<p>左右部分各自求出总和在<code>S</code>以内，阶乘个数在<code>K</code>以内的所有状态后，</p>
<p>假设当前右部分状态为<code>(阶乘个数cnt, 总和sum, 出现次数a)</code>，去寻找左半部分的所有状态<code>f</code>中，满足<code>阶乘个数小于等于K - cnt, 总和等于S - sum</code>的方案总数，累计起来就是答案。</p>
<p>有两个重要优化点：</p>
<ul>
<li><p>由于<code>K</code>并没要求一定要用完，那么需要找<code>K - 1</code>，<code>K - 2</code>一直到<code>0</code>为止的所有可能性</p>
<p>所以采用记忆化搜索来优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记忆化搜索优化</span></span><br><span class="line">map&lt;pair&lt;<span class="type">int</span>, ll&gt;, ll&gt; g;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x, ll s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (g.<span class="built_in">count</span>(&#123;x, s&#125;)) <span class="keyword">return</span> g[&#123;x, s&#125;];</span><br><span class="line">  <span class="keyword">return</span> g[&#123;x, s&#125;] = f[&#123;x, s&#125;] + (x ? <span class="built_in">query</span>(x - <span class="number">1</span>, s) : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>因为<code>S</code>最大只有<code>1e7</code>，可以提前打表每个位置上的数字的阶乘，如果大于<code>1e7</code>就没必要使用</p></li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>双向DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1379. 八数码难题</title>
    <url>/2024/04/15/P1379-%E5%85%AB%E6%95%B0%E7%A0%81%E9%9A%BE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>双向BFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 字符串，空格的位置，到达本状态的步数</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;string, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; PI;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">string a, b = <span class="string">&quot;123804765&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(queue&lt;PI&gt; &amp;aq, queue&lt;PI&gt; &amp;bq, unordered_map&lt;string, <span class="type">bool</span>&gt; &amp;av,</span></span></span><br><span class="line"><span class="params"><span class="function">           unordered_map&lt;string, <span class="type">bool</span>&gt; &amp;bv)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sz = aq.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">while</span> (sz--) &#123;</span><br><span class="line">    string str = aq.<span class="built_in">front</span>().first;</span><br><span class="line">    <span class="type">int</span> z = aq.<span class="built_in">front</span>().second.first, step = aq.<span class="built_in">front</span>().second.second;</span><br><span class="line">    aq.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> nx = (z / <span class="number">3</span>) + dx[i], ny = (z % <span class="number">3</span>) + dy[i];</span><br><span class="line">      <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx &gt; <span class="number">2</span> || ny &gt; <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">      string ns = str;</span><br><span class="line">      <span class="type">int</span> nz = nx * <span class="number">3</span> + ny;</span><br><span class="line">      <span class="built_in">swap</span>(ns[z], ns[nz]);</span><br><span class="line">      <span class="keyword">if</span> (bv.<span class="built_in">count</span>(ns)) <span class="keyword">return</span> step + bq.<span class="built_in">front</span>().second.second + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (av.<span class="built_in">count</span>(ns)) <span class="keyword">continue</span>;</span><br><span class="line">      av[ns] = <span class="number">1</span>;</span><br><span class="line">      aq.<span class="built_in">push</span>(&#123;ns, &#123;nz, step + <span class="number">1</span>&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a == b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  queue&lt;PI&gt; aq, bq;</span><br><span class="line">  unordered_map&lt;string, <span class="type">bool</span>&gt; av, bv;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">      aq.<span class="built_in">push</span>(&#123;a, &#123;i, <span class="number">0</span>&#125;&#125;);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  bq.<span class="built_in">push</span>(&#123;b, &#123;<span class="number">4</span>, <span class="number">0</span>&#125;&#125;);</span><br><span class="line">  av[a] = bv[b] = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> res;</span><br><span class="line">  <span class="keyword">while</span> (aq.<span class="built_in">size</span>() &amp;&amp; bq.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (aq.<span class="built_in">size</span>() &lt; bq.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      res = <span class="built_in">extend</span>(aq, bq, av, bv);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res = <span class="built_in">extend</span>(bq, aq, bv, av);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (~res) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; a;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>这道题是<a
href="https://www.acwing.com/problem/content/submission/181/">acwing-179.
八数码</a>的低配版，详见该题的笔记</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>双向BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P2324. 骑士精神</title>
    <url>/2024/04/15/P2324-%E9%AA%91%E5%A3%AB%E7%B2%BE%E7%A5%9E/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>IDAstar</li>
<li>双向BFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<p>acwing-195. 骑士精神的低配版，请看该题题解。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>双向BFS</tag>
        <tag>IDAstar</tag>
      </tags>
  </entry>
  <entry>
    <title>P4799. 世界冰球锦标赛</title>
    <url>/2024/04/17/P4799-%E4%B8%96%E7%95%8C%E5%86%B0%E7%90%83%E9%94%A6%E6%A0%87%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>双向DFS</li>
<li>双指针</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">5e7</span> + <span class="number">50</span>;</span><br><span class="line">ll n, m, alen, blen, a[maxn], b[maxn], in[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(ll idx, ll sum)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (idx &gt; n / <span class="number">2</span>) &#123;</span><br><span class="line">    a[++alen] = sum;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum + i * in[idx] &gt; m) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(idx + <span class="number">1</span>, sum + i * in[idx]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(ll idx, ll sum)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (idx &gt; n) &#123;</span><br><span class="line">    b[++blen] = sum;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum + i * in[idx] &gt; m) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(idx + <span class="number">1</span>, sum + i * in[idx]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; in[i];</span><br><span class="line">  <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">dfs2</span>(n / <span class="number">2</span> + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + alen), <span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + blen);</span><br><span class="line">  ll cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">1</span>, j = blen; i &lt;= alen; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">1</span> &amp;&amp; a[i] &gt; m - b[j]) --j;</span><br><span class="line">    cnt += j;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>采用双向DFS，左半部分票价情况保存至<code>a</code>，右半部分票价情况保存至<code>b</code>。</p>
<p>对<code>a</code>和<code>b</code>排序之后，令<code>a</code>的游标<code>i</code>从<code>1</code>开始，令<code>b</code>的游标<code>j</code>从<code>blen</code>开始，使用双指针：</p>
<p>只要<code>a[i] + b[j] &gt; m</code>，就<code>--j</code>；</p>
<p>遇到第一次两部分和小于等于<code>m</code>时，<code>j</code>就等于有<code>a[i]</code>存在的所有情况中满足题意的个数。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>DFS</tag>
        <tag>二分</tag>
        <tag>双向DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>CF912E. Prime Gift</title>
    <url>/2024/04/17/CF912E-Prime-Gift/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>双向DFS</li>
<li>二分</li>
<li>双指针</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e7</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">const</span> ll inf = <span class="number">1e18</span>;</span><br><span class="line"><span class="type">int</span> n, k, alen, blen, in[<span class="number">20</span>];</span><br><span class="line">ll a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 奇数位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> idx, ll sum)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (idx &gt; n) &#123;</span><br><span class="line">    a[++alen] = sum;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (ll now = <span class="number">1</span>;; now *= in[idx]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inf / now &lt; sum) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(idx + <span class="number">2</span>, sum * now);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偶数位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> idx, ll sum)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (idx &gt; n) &#123;</span><br><span class="line">    b[++blen] = sum;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (ll now = <span class="number">1</span>;; now *= in[idx]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inf / now &lt; sum) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(idx + <span class="number">2</span>, sum * now);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll mid)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = blen; i &lt;= alen; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">1</span> &amp;&amp; mid / a[i] &lt; b[j]) --j;</span><br><span class="line">    cnt += j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt &lt; k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; in[i];</span><br><span class="line">  cin &gt;&gt; k;</span><br><span class="line">  <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="built_in">dfs2</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + alen), alen = <span class="built_in">unique</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + alen) - <span class="number">1</span> - a;</span><br><span class="line">  <span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + blen), blen = <span class="built_in">unique</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + blen) - <span class="number">1</span> - b;</span><br><span class="line">  ll l = <span class="number">0</span>, r = <span class="number">1e18</span>;</span><br><span class="line">  <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">    ll mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 如果不够k个，就向右扩张</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      r = mid - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>由于暴力枚举的数字大小顺序是完全打乱的，你不可能即时知道当前的枚举结果到底在整体结果当中排第几。</p>
<p>所以只能考虑二分答案，去直接找哪个数字有<code>k</code>个小于等于它的。</p>
<hr />
<p>使用双向DFS进行枚举。</p>
<p>以前常用的是以长度对半分，比如一共16个数，先枚举前8个数的情况，再枚举后8个数的情况，最后组合合并。</p>
<p>在本题中，同样也是拆分成两个最多有8个质因子的子集合，子集合内枚举不超过<code>1e18</code>的数字，最后两个子集合的枚举情况合并。</p>
<p>但是这里不能使用长度对半分，而要按照下标奇偶性均分，否则会超时！</p>
<p>这是因为题目所给的输入已经是有序且不重的，那么前8个数一定小于后8个数，前8个数的枚举情况显然远大于后8个数，</p>
<p>为了平衡时间复杂度，按照下标奇偶性均分即可。</p>
<hr />
<p>得到了奇数位置的枚举情况<code>a</code>，长度为<code>alen</code>；偶数位置的枚举情况<code>b</code>，长度为<code>blen</code>；且两个数组都是有序且去重的。</p>
<p>要判断有多少个数小于等于<code>mid</code>，直接用双指针思想：</p>
<p><code>a</code>的游标<code>i</code>从<code>1</code>出发，为外层循环；<code>b</code>的游标<code>j</code>从<code>blen</code>出发，为内层循环；<code>a[i] * b[j]</code>大于<code>mid</code>，就<code>--j</code></p>
<p>直到第一个乘积小于等于<code>mid</code>，此时<code>j</code>就等于<code>a[i]</code>所有情况中，小于等于<code>mid</code>的情况个数。</p>
<p>可以使用双指针，是因为<code>j</code>不可能回头，因为<code>a[i + 1]</code>一定大于<code>a[i]</code>，那么<code>a[i + 1] * b[j] &gt; a[i] * b[j]</code>，</p>
<p>你要找小于等于<code>mid</code>的情况，为什么还要往大的方向回头找呢？</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>DFS</tag>
        <tag>二分</tag>
        <tag>双向DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>P1763 埃及分数</title>
    <url>/2024/04/13/P1763-%E5%9F%83%E5%8F%8A%E5%88%86%E6%95%B0/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>迭代加深</li>
<li>剪枝</li>
<li>最大公约数</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line">ll depth, path[maxn], ans[maxn];</span><br><span class="line"><span class="type">bool</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll a, ll b, ll d)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 倒数第二位和倒数第一位优化</span></span><br><span class="line">  <span class="keyword">if</span> (d == depth - <span class="number">1</span>) &#123;</span><br><span class="line">    ll k = <span class="number">4</span> * b / (a * a);</span><br><span class="line">    <span class="keyword">for</span> (;; ++k) &#123;</span><br><span class="line">      <span class="type">double</span> delta = a * a * k * k - <span class="number">4</span> * b * k;</span><br><span class="line">      ll t = <span class="built_in">sqrt</span>(delta), r = <span class="number">-1</span>;</span><br><span class="line">      <span class="comment">// 如果开根号后，t是整数，说明有整数解</span></span><br><span class="line">      <span class="keyword">if</span> (t * t == delta)</span><br><span class="line">        r = t;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((t - <span class="number">1</span>) * (t - <span class="number">1</span>) == delta)</span><br><span class="line">        r = t - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((t + <span class="number">1</span>) * (t + <span class="number">1</span>) == delta)</span><br><span class="line">        r = t + <span class="number">1</span>;</span><br><span class="line">      ll x = (a * k - r) / <span class="number">2</span>, y = (a * k + r) / <span class="number">2</span>;</span><br><span class="line">      <span class="comment">// 大于1e7，退出</span></span><br><span class="line">      <span class="keyword">if</span> (y &gt; <span class="number">1e7</span>) <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 最优性剪枝：当前的b比答案最小值都小，退出</span></span><br><span class="line">      <span class="keyword">if</span> (flag &amp;&amp; y &gt;= ans[depth]) <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 可行性剪枝：没有整数解或者两个解相同，剪枝</span></span><br><span class="line">      <span class="keyword">if</span> (r &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// 可行性剪枝：x和y必须都是整数</span></span><br><span class="line">      <span class="keyword">if</span> ((a * k + r) &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// 记录答案</span></span><br><span class="line">      path[d] = x, path[d + <span class="number">1</span>] = y;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= depth; ++i) ans[i] = path[i];</span><br><span class="line">      flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 优化搜索顺序：从大到小</span></span><br><span class="line">  ll l = <span class="built_in">max</span>(b / a + <span class="number">1</span>, path[d - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">  ll r = <span class="built_in">min</span>((ll)<span class="number">1e7</span>, (depth - d + <span class="number">1</span>) * b / a);</span><br><span class="line">  <span class="comment">// 最优性剪枝：如果有答案，则以答案为上限</span></span><br><span class="line">  <span class="keyword">if</span> (flag) r = <span class="built_in">min</span>(r, ans[depth] - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (ll i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">    path[d] = i;</span><br><span class="line">    <span class="comment">// 每次都要约分，因为a和b运算后不一定是最简</span></span><br><span class="line">    ll ta = a * i - b, tb = b * i, g = <span class="built_in">gcd</span>(ta, tb);</span><br><span class="line">    <span class="built_in">dfs</span>(ta / g, tb / g, d + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll a, b;</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  ll g = <span class="built_in">gcd</span>(a, b);</span><br><span class="line">  a /= g, b /= g, path[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  depth = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(a, b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= depth; ++i) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++depth;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题意：</p>
<ul>
<li><p>加数少的比加数多的好</p>
<p><strong>选择迭代加深，控制枚举位数</strong></p></li>
<li><p>加数个数相同的，最小的分数越大越好</p>
<p><strong>枚举每一位置的分数时，从大到小枚举优化搜素顺序</strong></p>
<p>因为很显然，大数中找最大值与小数中找最大值，显然前者可能性更大</p></li>
</ul>
<p>在这里，不要妄想同时枚举分子和分母，因为最大范围有<code>1e7</code>，是天文数字；只考虑枚举分母即可</p>
<h2 id="分母的下界">分母的下界</h2>
<p><strong>在枚举分母之前一定要对<code>a / b</code>进行约分保证最简</strong></p>
<p>假设当前有<code>a / b</code>，需要将其转换为<code>1 / i</code></p>
<p>由于<code>a / b</code>已经约分后最简了，那么必然有： <span
class="math display">\[
\frac{a}{b}&gt;\frac{1}{i}\Rightarrow i&gt;\frac{b}{a}
\]</span>
又因为我们是从大到小枚举，且题目声明分母不准相同，那么本次的分母<code>i</code>应该大于上一次的分母：
<span class="math display">\[
i&gt;path\left[ d-1 \right]
\]</span> 所以得到分母的下界：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ll l = <span class="built_in">max</span>(b / a + <span class="number">1</span>, path[d - <span class="number">1</span>] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h2 id="分母的上界">分母的上界</h2>
<p>因为<code>1 / i</code>小于<code>a / b</code>，那么肯定还有剩余，剩余部分就作为下一次递归的输入；</p>
<p>算上当前位置，最多还有<code>depth - d + 1</code>个位置，而后续每个位置的分母必大于<code>i</code>，取极值的话，必有：
<span class="math display">\[
\frac{1}{i}\cdot \left( depth-d+1 \right) \leqslant \frac{a}{b}
\]</span>
由于题目要找最小值的最大，假设当前<code>i</code>都比<code>ans[depth]</code>都大，说明<code>1 / i</code>比答案都小，那么直接用答案来剪枝即可</p>
<p>最终得到了上界</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ll r = <span class="built_in">min</span>((ll)<span class="number">1e7</span>, (depth - d + <span class="number">1</span>) * b / a);</span><br><span class="line"><span class="comment">// 最优性剪枝：如果有答案，则以答案为上限</span></span><br><span class="line"><span class="keyword">if</span> (flag) r = <span class="built_in">min</span>(r, ans[depth] - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h2 id="递归输入">递归输入</h2>
<p>综上，因为<code>1 / i</code>必小于<code>a / b</code>，所以还有剩余，剩余部分的分子就等于<code>a * i - b</code>，分母就等于<code>b * i</code></p>
<p>得到如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (ll i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">  path[d] = i;</span><br><span class="line">  <span class="comment">// 每次都要约分，因为a和b运算后不一定是最简</span></span><br><span class="line">  ll ta = a * i - b, tb = b * i, g = <span class="built_in">gcd</span>(ta, tb);</span><br><span class="line">  <span class="built_in">dfs</span>(ta / g, tb / g, d + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="答案">答案</h2>
<p>枚举到最后两位时，考虑用数学进行优化 <span class="math display">\[
\frac{ak}{bk}=\frac{1}{x}+\frac{1}{y}
\]</span>
倒数第二位置的分母为<code>x</code>，倒数第一位置的分母为<code>y</code>，消去<code>y</code>后得到二元一次不等式
<span class="math display">\[
\begin{cases}
    ak=x+y\\
    bk=xy\\
\end{cases}\Rightarrow x^2-akx+bk=0
\]</span>
那么可以通过枚举<code>k</code>，通过求根公式得到<code>x</code>和<code>y</code>的值；由于题目说了不能有重复分母，可以得到<code>k</code>的范围：
<span class="math display">\[
\varDelta =a^2k^2-4bk&gt;0\Rightarrow k&gt;\frac{4b}{a^2}
\]</span> 令<span
class="math inline">\(\sqrt{a^2k^2-4bk}\)</span>为<code>r</code>，根据求根公式：
<span class="math display">\[
\frac{ak\pm \sqrt{a^2k^2-4bk}}{2}
\]</span>
得到<code>x = (a * k - r) / 2</code>，<code>y = (a * k + r) / 2</code></p>
<p>需要满足以下条件即可：</p>
<ul>
<li><code>y &lt; 1e7</code></li>
<li><code>r</code>是整数且大于0，小于0说明无解，等于0说明两根相同</li>
<li><code>(a * k - r)</code>可以整除2，保证<code>x</code>和<code>y</code>都是整数</li>
</ul>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>最大公约数</tag>
        <tag>剪枝</tag>
        <tag>迭代加深</tag>
      </tags>
  </entry>
  <entry>
    <title>P5507. 机关</title>
    <url>/2024/04/16/P5507-%E6%9C%BA%E5%85%B3/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>Astar</li>
<li>双向BFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路。</p>
<h1 id="思路">思路</h1>
<p>尽管数据范围已经告诉你，但是依旧不能使用IDAstar，搜索树过大会超时。</p>
<p>这题纯纯是在考位运算的奇技淫巧...原题给的<code>1 - 4</code>下标与状态不好编程，统一降低成<code>0 - 3</code></p>
<p>假设当前状态为<code>s</code>，那么正扭的下个状态是<code>(s + 1) &amp; 3</code>，反扭（实际上就是扭三次）的下个状态是<code>(s + 3) &amp; 3</code></p>
<p>如果要取下标为<code>idx</code>的按钮状态，那么应该是<code>(s &gt;&gt; (idx &lt;&lt; 1)) &amp; 3</code></p>
<p>假设当前下标为<code>x</code>，状态为<code>sx</code>，新状态为<code>nsx</code>：</p>
<ul>
<li><p>先要从<code>s</code>中清除<code>x</code>的旧状态，应该为<code>s -= (sx &lt;&lt; (x &lt;&lt; 1))</code>，</p></li>
<li><p>再添加新状态<code>s |= (nsx &lt;&lt; (x &lt;&lt; 1))</code></p></li>
</ul>
<h2 id="双向bfs">双向BFS</h2>
<p>双向BFS有几个坑，坑了我一整天：</p>
<ul>
<li><p>非常非常非常非常非常<strong>卡常数时间</strong>，除了输入和输出一律改为<code>scanf/printf</code>外，</p>
<p>记录状态不能用哈希表，要用普通数组；记录路径也不能用哈希表，要用<code>vector</code>代替</p></li>
<li><p>假设当前是<code>x</code>下标的按钮，状态为<code>sx</code>：</p>
<p>正扭影响到的按钮下标为<code>nxt[x][sx]</code></p>
<p><strong>反扭影响到的按钮下标为<code>nxt[x][(sx + 3) &amp; 3]</code></strong></p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line"><span class="type">int</span> st, ed, mid, nxt[<span class="number">14</span>][<span class="number">6</span>], out[maxn];</span><br><span class="line"><span class="type">bool</span> av[maxn], bv[maxn];</span><br><span class="line"><span class="comment">// ap[f]&lt;pair&lt;g, h&gt;，f状态是由g状态选了h旋钮转换得来</span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">ap</span>(maxn), <span class="built_in">bp</span>(maxn);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; &amp;aq, queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; &amp;bq, <span class="type">bool</span> av[],</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">bool</span> bv[], vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; &amp;ap, <span class="type">int</span> dir)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sz = aq.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">while</span> (sz--) &#123;</span><br><span class="line">    <span class="type">int</span> state = aq.<span class="built_in">front</span>().first, step = aq.<span class="built_in">front</span>().second;</span><br><span class="line">    aq.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="comment">// x：当前旋钮，y：受牵引的旋钮，sx：x的状态，sy：y的状态</span></span><br><span class="line">    <span class="comment">// nsx：x的下一次状态，nsy：y的下一次状态，ns：全局下一次状态</span></span><br><span class="line">    <span class="type">int</span> x, y, sx, sy, nsx, nsy, ns;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">12</span>; ++x) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dir == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 正向</span></span><br><span class="line">        sx = (state &gt;&gt; (x &lt;&lt; <span class="number">1</span>)) &amp; <span class="number">3</span>, y = nxt[x][sx];</span><br><span class="line">        sy = (state &gt;&gt; (y &lt;&lt; <span class="number">1</span>)) &amp; <span class="number">3</span>;</span><br><span class="line">        nsx = (sx + <span class="number">1</span>) &amp; <span class="number">3</span>, nsy = (sy + <span class="number">1</span>) &amp; <span class="number">3</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 反向，注意受牵引的按钮不是sx，是(sx + 3) &amp; 3</span></span><br><span class="line">        sx = (state &gt;&gt; (x &lt;&lt; <span class="number">1</span>)) &amp; <span class="number">3</span>, y = nxt[x][(sx + <span class="number">3</span>) &amp; <span class="number">3</span>];</span><br><span class="line">        sy = (state &gt;&gt; (y &lt;&lt; <span class="number">1</span>)) &amp; <span class="number">3</span>;</span><br><span class="line">        nsx = (sx + <span class="number">3</span>) &amp; <span class="number">3</span>, nsy = (sy + <span class="number">3</span>) &amp; <span class="number">3</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ns = state;</span><br><span class="line">      ns -= (sx &lt;&lt; (x &lt;&lt; <span class="number">1</span>)), ns |= (nsx &lt;&lt; (x &lt;&lt; <span class="number">1</span>));</span><br><span class="line">      ns -= (sy &lt;&lt; (y &lt;&lt; <span class="number">1</span>)), ns |= (nsy &lt;&lt; (y &lt;&lt; <span class="number">1</span>));</span><br><span class="line">      <span class="keyword">if</span> (av[ns]) <span class="keyword">continue</span>;</span><br><span class="line">      ap[ns] = &#123;state, x + <span class="number">1</span>&#125;;</span><br><span class="line">      <span class="keyword">if</span> (bv[ns]) &#123;</span><br><span class="line">        mid = ns;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + step + bq.<span class="built_in">front</span>().second;</span><br><span class="line">      &#125;</span><br><span class="line">      av[ns] = <span class="number">1</span>;</span><br><span class="line">      aq.<span class="built_in">push</span>(&#123;ns, step + <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// queue&lt;pair&lt;f, g&gt;&gt;到达f状态走了g步</span></span><br><span class="line">  queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; aq, bq;</span><br><span class="line">  aq.<span class="built_in">push</span>(&#123;st, <span class="number">0</span>&#125;), bq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">  av[st] = <span class="number">1</span>, bv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> res;</span><br><span class="line">  <span class="keyword">while</span> (!aq.<span class="built_in">empty</span>() &amp;&amp; !bq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (aq.<span class="built_in">size</span>() &lt;= bq.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      res = <span class="built_in">extend</span>(aq, bq, av, bv, ap, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res = <span class="built_in">extend</span>(bq, aq, bv, av, bp, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">  <span class="comment">// 正向搜索部分，从中间态到初始态倒序输出路径</span></span><br><span class="line">  <span class="type">int</span> idx = <span class="number">0</span>, tmp = mid;</span><br><span class="line">  <span class="keyword">while</span> (tmp != st) &#123;</span><br><span class="line">    out[++idx] = ap[tmp].second;</span><br><span class="line">    tmp = ap[tmp].first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (idx) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, out[idx--]);</span><br><span class="line">  <span class="comment">// 反向搜索部分，从中间态到终态正序输出路径</span></span><br><span class="line">  <span class="keyword">while</span> (mid != <span class="number">0</span>) &#123;</span><br><span class="line">    out[++idx] = bp[mid].second;</span><br><span class="line">    mid = bp[mid].first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= idx; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, out[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> button, i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;button);</span><br><span class="line">    st |= (button - <span class="number">1</span>) &lt;&lt; (i &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;nxt[i][j]);</span><br><span class="line">      nxt[i][j] -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="astar">Astar</h2>
<p>如果当前某个按钮的状态为<code>2</code>，那么扭到<code>0</code>还需要走2步</p>
<p>统计所有按钮需要的步数之和<code>tot</code>，那么估价函数就可以设为<code>向上取整(tot / 2)</code>，</p>
<p>因为每次还会带动另一个按钮转动，所以除2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line"><span class="type">int</span> st, ed, nxt[<span class="number">14</span>][<span class="number">6</span>], d[maxn], out[maxn];</span><br><span class="line"><span class="comment">// p[a], pair&lt;b, c&gt;：当前a状态是由b状态选了c转换</span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">p</span>(maxn);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((s &gt;&gt; (i &lt;&lt; <span class="number">1</span>)) &amp; <span class="number">3</span>) res += <span class="number">4</span> - ((s &gt;&gt; (i &lt;&lt; <span class="number">1</span>)) &amp; <span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记得向上取整</span></span><br><span class="line">  <span class="keyword">return</span> (res + <span class="number">2</span> - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  <span class="comment">// pair&lt;a, b&gt;</span></span><br><span class="line">  <span class="comment">// a：初始态到当前状态的最小开销+未来最小开销，b：当前状态</span></span><br><span class="line">  priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; q;</span><br><span class="line">  d[st] = <span class="number">0</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(&#123;-<span class="built_in">f</span>(st), st&#125;);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> state = q.<span class="built_in">top</span>().second;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (state == ed) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d[ed]);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">12</span>; ++x) &#123;</span><br><span class="line">      <span class="type">int</span> sx = (state &gt;&gt; (x &lt;&lt; <span class="number">1</span>)) &amp; <span class="number">3</span>, nsx = (sx + <span class="number">1</span>) &amp; <span class="number">3</span>;</span><br><span class="line">      <span class="type">int</span> y = nxt[x][sx], sy = (state &gt;&gt; (y &lt;&lt; <span class="number">1</span>)) &amp; <span class="number">3</span>, nsy = (sy + <span class="number">1</span>) &amp; <span class="number">3</span>;</span><br><span class="line">      <span class="type">int</span> ns = state;</span><br><span class="line">      ns -= (sx &lt;&lt; (x &lt;&lt; <span class="number">1</span>)), ns |= (nsx &lt;&lt; (x &lt;&lt; <span class="number">1</span>));</span><br><span class="line">      ns -= (sy &lt;&lt; (y &lt;&lt; <span class="number">1</span>)), ns |= (nsy &lt;&lt; (y &lt;&lt; <span class="number">1</span>));</span><br><span class="line">      <span class="keyword">if</span> (d[ns] == <span class="number">0x3f3f3f3f</span> || d[ns] &gt; d[state] + <span class="number">1</span>) &#123;</span><br><span class="line">        d[ns] = d[state] + <span class="number">1</span>;</span><br><span class="line">        p[ns] = &#123;state, x + <span class="number">1</span>&#125;;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;-(d[ns] + <span class="built_in">f</span>(ns)), ns&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 倒序输出路径</span></span><br><span class="line">  <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (ed != st) &#123;</span><br><span class="line">    out[++idx] = p[ed].second;</span><br><span class="line">    ed = p[ed].first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (idx) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, out[idx--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> button, i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;button);</span><br><span class="line">    st |= (button - <span class="number">1</span>) &lt;&lt; (i &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;nxt[i][j]);</span><br><span class="line">      nxt[i][j] -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>双向BFS</tag>
        <tag>Astar</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-205. 斐波那契</title>
    <url>/2024/04/21/acwing-205-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>矩阵乘法</li>
<li>快速幂</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mulself</span><span class="params">(ll a[<span class="number">2</span>][<span class="number">2</span>])</span> </span>&#123;</span><br><span class="line">  ll t[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">  <span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="built_in">sizeof</span>(t));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; ++k) &#123;</span><br><span class="line">        t[i][j] = (t[i][j] + a[i][k] * a[k][j]) % mod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memcpy</span>(a, t, <span class="built_in">sizeof</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(ll f[<span class="number">2</span>], ll a[<span class="number">2</span>][<span class="number">2</span>])</span> </span>&#123;</span><br><span class="line">  ll t[<span class="number">2</span>];</span><br><span class="line">  <span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="built_in">sizeof</span>(t));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; ++k) &#123;</span><br><span class="line">      t[i] = (t[i] + f[k] * a[k][i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memcpy</span>(f, t, <span class="built_in">sizeof</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; ~n) &#123;</span><br><span class="line">    ll f[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, a[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">// 矩阵快速幂</span></span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">      <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="built_in">mul</span>(f, a);</span><br><span class="line">      <span class="built_in">mulself</span>(a);</span><br><span class="line">      n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>递推时只保存最近的两个斐波那契数，即可得到下一个斐波那契数。</p>
<p>设<span class="math inline">\(F\left( n
\right)\)</span>表示一个<code>1 * 2</code>的矩阵，<span
class="math inline">\(F\left( n \right) =\left[ Fib_n\,\,Fib_{n+1}
\right]\)</span>，</p>
<p>我们希望根据<span class="math inline">\(F\left( n-1 \right) =\left[
Fib_{n-1}\,\,Fib_n \right]\)</span>计算出<span
class="math inline">\(F\left( n \right)\)</span>，</p>
<p>构造一个矩阵<code>A</code>，设计如下矩阵乘法： <span
class="math display">\[
F\left( n \right) =F\left( n-1 \right) \cdot A\Longleftrightarrow \left[
Fib_n\,\,Fib_{n+1} \right] =\left[ Fib_{n-1}\,\,Fib_n \right] \cdot
\left[ \begin{matrix}
    0&amp;      1\\
    1&amp;      1\\
\end{matrix} \right]
\]</span> 根据题意，初值为<span class="math inline">\(F\left( 0 \right)
=\left[ 0 1 \right]\)</span>，目标为<span class="math inline">\(F\left(
n \right) =F\left( 0 \right) \cdot A^n\)</span></p>
<p>由于矩阵乘法满足结合律，所以可以用快速幂计算上述式子，得到的矩阵第1列上的数就是<span
class="math inline">\(Fib_n\)</span></p>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-342. 道路与航线</title>
    <url>/2024/04/21/acwing-342-%E9%81%93%E8%B7%AF%E4%B8%8E%E8%88%AA%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>flood-fill找连通块</li>
<li>拓扑排序</li>
<li>最短路</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">3e4</span> + <span class="number">50</span>, maxm = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, p, st, tot = <span class="number">-1</span>, head[maxn], d[maxn];</span><br><span class="line"><span class="comment">// block：每个点所在的连通块，cnt：一共多少连通块，ind：每个连通块的入度</span></span><br><span class="line"><span class="type">int</span> block[maxn], cnt, ind[maxn];</span><br><span class="line"><span class="comment">// arr[k]：第k个连通块有哪些元素</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr[maxn];</span><br><span class="line"><span class="comment">// 拓扑排序的队列</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="comment">// flag为0代表是道路，1代表是航线</span></span><br><span class="line">  <span class="type">int</span> v_, w_, nxt_, flag_;</span><br><span class="line">&#125; g[maxm &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w, <span class="type">int</span> flag)</span> </span>&#123;</span><br><span class="line">  g[++tot].v_ = v, g[tot].w_ = w, g[tot].flag_ = flag, g[tot].nxt_ = head[u],</span><br><span class="line">  head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  block[u] = k, arr[k].<span class="built_in">push_back</span>(u);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = g[i].nxt_) &#123;</span><br><span class="line">    <span class="type">int</span> v = g[i].v_, w = g[i].w_, flag = g[i].flag_;</span><br><span class="line">    <span class="keyword">if</span> (block[v] || flag) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v, k);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> u, v, w;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head)), <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    <span class="built_in">add</span>(u, v, w, <span class="number">0</span>), <span class="built_in">add</span>(v, u, w, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    <span class="built_in">add</span>(u, v, w, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q2;</span><br><span class="line">  <span class="type">bool</span> vis[maxn];</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> u : arr[k]) &#123;</span><br><span class="line">    q2.<span class="built_in">push</span>(&#123;-d[u], u&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!q2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q2.<span class="built_in">top</span>().second;</span><br><span class="line">    q2.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = g[i].nxt_) &#123;</span><br><span class="line">      <span class="type">int</span> v = g[i].v_, w = g[i].w_, flag = g[i].flag_;</span><br><span class="line">      <span class="comment">// 处理航线</span></span><br><span class="line">      <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        d[v] = <span class="built_in">min</span>(d[v], d[u] + w);</span><br><span class="line">        <span class="keyword">if</span> (--ind[block[v]] == <span class="number">0</span>) q1.<span class="built_in">push</span>(block[v]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[v] &gt; d[u] + w) &#123;</span><br><span class="line">          d[v] = d[u] + w;</span><br><span class="line">          q2.<span class="built_in">push</span>(&#123;-d[v], v&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历所有航线，统计所有连通块的入度</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> u : arr[i]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = head[u]; ~j; j = g[j].nxt_) &#123;</span><br><span class="line">        <span class="type">int</span> v = g[j].v_, flag = g[j].flag_;</span><br><span class="line">        <span class="keyword">if</span> (flag) ++ind[block[v]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 入度为0的塞进队列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ind[i]) q1.<span class="built_in">push</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 起点最短路初始化</span></span><br><span class="line">  d[st] = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 拓扑排序</span></span><br><span class="line">  <span class="keyword">while</span> (!q1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> k = q1.<span class="built_in">front</span>();</span><br><span class="line">    q1.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">dijkstra</span>(k);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; st;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="comment">// 求连通块</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!block[i]) &#123;</span><br><span class="line">      <span class="built_in">dfs</span>(i, ++cnt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对连通块进行拓扑排序</span></span><br><span class="line">  <span class="built_in">toposort</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 因为有负边，0x3f3f3f3f - x显然小于0x3f3f3f3f，会被错误更新</span></span><br><span class="line">    <span class="comment">// 两种办法，第一种如果起点就是0x3f3f3f3f就不要往下更新，但会增加部分码量</span></span><br><span class="line">    <span class="comment">// 第二种设置一个路径理想最大值，比如结点数 * 最大边权，推荐这种方式</span></span><br><span class="line">    <span class="keyword">if</span> (d[i] &gt; n * <span class="number">10000</span>)</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;NO PATH&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cout &lt;&lt; d[i] &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>SPFA的时间复杂度是<span class="math inline">\(O\left( nm
\right)\)</span>，直接用显然会超时。</p>
<p>根据题意，道路双向边均非负，航线单向边可能为负数，且<strong>航线单向边不构成环</strong>。</p>
<p>双向边会形成若干个连通块，而单向边则负责连接不同连通块，整个图就变成了DAG有向无环图。</p>
<p>使用拓扑排序的框架顺序处理每个连通块，而每个连通块的内部使用Dijkstra求最短路即可。</p>
<p>详细的算法流程如下：</p>
<ol type="1">
<li><p>用dfs的flood-fill操作划分连通块，<code>block[x]</code>代表每个点<code>x</code>所处的连通块，<code>vector&lt;int&gt; arr[k]</code>存储第<code>k</code>个连通块有哪些点。</p></li>
<li><p>遍历所有航线，统计每个连通块的总入度，<code>ind[x]</code>代表连通块<code>x</code>的入度数</p></li>
<li><p>建立拓扑排序队列<code>q1</code>，如果连通块入度为<code>0</code>就插入队列</p></li>
<li><p>取出队头的连通块<code>k</code>，执行Dijkstra算法：</p>
<ol type="1">
<li><p>建立一个堆，把<code>arr[k]</code>所有元素塞入，即连通块<code>k</code>的所有节点</p></li>
<li><p>从堆上取出<code>d[u]</code>最小的节点<code>u</code></p></li>
<li><p>若<code>u</code>被扩展过，回到步骤2，否则下一步</p></li>
<li><p>扫描从<code>u</code>出发的所有边<code>(v, w, flag)</code>，用<code>d[u] + w</code>更新<code>d[v]</code></p></li>
<li><p>如果<code>flag == 0</code>，说明该条边不是航线，还在连通块内；若<code>d[v]</code>被更新，则把<code>v</code>塞入堆</p></li>
<li><p>如果<code>flag == 1</code>，说明该条边是航线，令<code>ind[block[v]]</code>减去<code>1</code>，</p>
<p>若入度减为0，把连通块<code>block[v]</code>塞入<code>q1</code>的队列末尾</p></li>
<li><p>重复2-6操作，直到堆为空</p></li>
</ol></li>
</ol>
<hr />
<p>输出时，不能简单地判断<code>d[x] == 0x3f3f3f3f</code>，举个例子：</p>
<p><code>a</code>点和<code>b</code>点都是<code>0x3f3f3f3f</code>，两者组成连通块，边权为负数，且该连通块不与其它连通块相通。</p>
<p>然而因为有负边，<code>0x3f3f3f3f - x</code>显然小于<code>0x3f3f3f3f</code>，<code>d[b]</code>会被错误更新。</p>
<p>两种办法，第一种如果起点就是<code>0x3f3f3f3f</code>就不要往下更新，但会增加部分码量和提高错误率；</p>
<p>第二种设置一个路径理想最大值，比如<strong>结点数 *
最大边权</strong>，推荐这种方式！</p>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-341. 最优贸易</title>
    <url>/2024/04/20/acwing-341-%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>最短路</li>
<li>后效性处理</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<p>某一条路径上选<code>p</code>和<code>q</code>两个点，<code>p</code>在前<code>q</code>在后，<code>p</code>买<code>q</code>卖，求最大值。</p>
<h2 id="双向spfa">双向SPFA</h2>
<p>很朴素的思路，枚举每个点<code>x</code>作为所有经过它的路径的中点。</p>
<p>正向SPFA从<code>1</code>出发，求到达<code>x</code>的最小点，记为<code>mi[x]</code>；逆向SPFA从<code>n</code>出发，求达到<code>x</code>的最大点，记为<code>mx[x]</code>；</p>
<p>最后找出<code>mx[x] - mi[x]</code>的最大值即可。</p>
<p>之所以不能用<code>dijkstra</code>，是因为找最小、最大点是有后效性，不满足贪心策略的：</p>
<p>比如有<code>5 -&gt; 6</code>，<code>6 -&gt; 7</code>，<code>7 -&gt; 5</code>三条边，假设有<code>mi[5] = 10</code>，然后<code>mi[6] = 5</code>，接着<code>mi[7] = 3</code>，最后<code>mi[5] = 3</code>，<code>5</code>节点完全不可能只出队一次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>, maxm = <span class="number">5e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="comment">// mi[x]：以x为中点的所有路径中，x左侧最小的（包含自己）</span></span><br><span class="line"><span class="comment">// mx[x]：以x为中点的所有路径中，x右侧最大的（包含自己）</span></span><br><span class="line"><span class="type">int</span> n, m, tot = <span class="number">-1</span>, head[maxn], a[maxn], mi[maxn], mx[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> v_, w_, nxt_;</span><br><span class="line">&#125; g[maxm &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">  g[++tot].v_ = v, g[tot].w_ = w, g[tot].nxt_ = head[u], head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> d[], <span class="type">int</span> st, <span class="type">int</span> W)</span> </span>&#123;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  d[st] = a[st], vis[st] = <span class="number">1</span>, q.<span class="built_in">push</span>(st);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    vis[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = g[i].nxt_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (g[i].w_ == W || g[i].w_ == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="type">int</span> v = g[i].v_, w = g[i].w_;</span><br><span class="line">        <span class="type">int</span> val = W == <span class="number">1</span> ? <span class="built_in">min</span>(d[u], a[v]) : <span class="built_in">max</span>(d[u], a[v]);</span><br><span class="line">        <span class="keyword">if</span> (W == <span class="number">1</span> &amp;&amp; val &lt; d[v] || W == <span class="number">-1</span> &amp;&amp; val &gt; d[v]) &#123;</span><br><span class="line">          d[v] = val;</span><br><span class="line">          <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">            vis[v] = <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(v);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">  <span class="comment">// 边权1代表1~n的正向遍历，边权-1代表n~1的反向遍历，边权2代表双向皆可</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> u, v, w, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    <span class="built_in">add</span>(u, v, w), <span class="built_in">add</span>(v, u, w == <span class="number">1</span> ? <span class="number">-1</span> : w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(mi, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(mi)), <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">  <span class="built_in">spfa</span>(mi, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">memset</span>(mx, <span class="number">0xc0</span>, <span class="built_in">sizeof</span>(mx)), <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">  <span class="built_in">spfa</span>(mx, n, <span class="number">-1</span>);</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans = <span class="built_in">max</span>(ans, mx[i] - mi[i]);</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分层图spfa">分层图+SPFA</h2>
<p>也可以用dp的思路，设<code>D[x, j]</code>代表从<code>1</code>点<code>0</code>层出发，到达<code>x</code>点<code>j</code>层的最大值，有如下转移方程：</p>
<ul>
<li><code>D[y, j] = max(D[y, j], D[x, j])</code>，同一层边权均为0</li>
<li><code>D[x, j + 1] = max(D[x, j + 1], D[x, j] - a[x])</code>，第0层向第1层转移时，必须先买入商品，边权均为负</li>
<li><code>D[x, j + 1] = max(D[x, j + 1], D[x, j] + a[x])</code>，第1层向第2层转移时，必须卖掉商品赚钱，边权均为正</li>
</ul>
<p>所以直接对下图用SPFA求最大路，最后输出<code>D[n, 2]</code>即可</p>
<img src="/2024/04/20/acwing-341-%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93/1.png" class="" title="image-20240420000643697">
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>, maxm = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, tot = <span class="number">-1</span>, head[maxn], a[maxn], d[maxn][<span class="number">3</span>];</span><br><span class="line"><span class="type">bool</span> vis[maxn][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> v_, w_, nxt_;</span><br><span class="line">&#125; g[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  g[++tot].v_ = v, g[tot].w_ = w, g[tot].nxt_ = head[u], head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">  d[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>, vis[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>, q.<span class="built_in">push</span>(&#123;<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>().first, f = q.<span class="built_in">front</span>().second;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    vis[u][f] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 同层扩展</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = g[i].nxt_) &#123;</span><br><span class="line">      <span class="type">int</span> v = g[i].v_;</span><br><span class="line">      <span class="keyword">if</span> (d[v][f] &lt; d[u][f]) &#123;</span><br><span class="line">        d[v][f] = d[u][f];</span><br><span class="line">        <span class="keyword">if</span> (!vis[v][f]) &#123;</span><br><span class="line">          vis[v][f] = <span class="number">1</span>;</span><br><span class="line">          q.<span class="built_in">push</span>(&#123;v, f&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第0层向第1层扩展</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="number">0</span> &amp;&amp; d[u][f + <span class="number">1</span>] &lt; d[u][f] - a[u]) &#123;</span><br><span class="line">      d[u][f + <span class="number">1</span>] = d[u][f] - a[u];</span><br><span class="line">      <span class="keyword">if</span> (!vis[u][f + <span class="number">1</span>]) &#123;</span><br><span class="line">        vis[u][f + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;u, f + <span class="number">1</span>&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第1层向第2层扩展</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="number">1</span> &amp;&amp; d[u][f + <span class="number">1</span>] &lt; d[u][f] + a[u]) &#123;</span><br><span class="line">      d[u][f + <span class="number">1</span>] = d[u][f] + a[u];</span><br><span class="line">      <span class="keyword">if</span> (!vis[u][f + <span class="number">1</span>]) &#123;</span><br><span class="line">        vis[u][f + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;u, f + <span class="number">1</span>&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; d[n][<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> u, v, w, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    <span class="built_in">add</span>(u, v);</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="number">2</span>) <span class="built_in">add</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">spfa</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>后效性处理</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-345. 牛站</title>
    <url>/2024/04/24/acwing-345-%E7%89%9B%E7%AB%99/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>Floyd</li>
<li>矩阵乘法</li>
<li>快速幂</li>
<li>线性DP</li>
<li>离散化</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<h2 id="普通dp">普通DP</h2>
<h3 id="代码一">代码一</h3>
<p>设<code>dp[i][j]</code>代表到达点<code>j</code>恰好经过<code>i</code>条边的最短路，显然有如下状态转移方程：</p>
<p><code>dp[i][j] = min(dp[i][j], dp[i - 1][k] + edge(k, j))</code>，其中<code>k</code>点与<code>j</code>点有连边。</p>
<p>第一份代码构思如下，显然会MLE，因为数组接近上亿。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e2</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, t, s, e, m, tot = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> head[maxn], nxt[maxn], edge[maxn], ver[maxn];</span><br><span class="line"><span class="type">int</span> a[maxn], b[maxn], c[maxn], dis[maxn];</span><br><span class="line"><span class="type">int</span> dp[(<span class="type">int</span>)<span class="number">1e6</span> + <span class="number">50</span>][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">  ver[++tot] = v, edge[tot] = w, nxt[tot] = head[u], head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离散化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dis[++m] = s, dis[++m] = e;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> u, v, w, i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;w, &amp;u, &amp;v);</span><br><span class="line">    dis[++m] = u, dis[++m] = v;</span><br><span class="line">    a[i] = u, b[i] = v, c[i] = w;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m);</span><br><span class="line">  m = <span class="built_in">unique</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m) - <span class="number">1</span> - dis;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">  s = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m, s) - dis;</span><br><span class="line">  e = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m, e) - dis;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m, a[i]) - dis;</span><br><span class="line">    <span class="type">int</span> v = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m, b[i]) - dis;</span><br><span class="line">    <span class="built_in">add</span>(u, v, c[i]), <span class="built_in">add</span>(v, u, c[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;t, &amp;s, &amp;e);</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">  dp[<span class="number">0</span>][s] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= m; ++u) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = head[u]; ~j; j = nxt[j]) &#123;</span><br><span class="line">        <span class="type">int</span> v = ver[j], w = edge[j];</span><br><span class="line">        dp[i][u] = <span class="built_in">min</span>(dp[i][u], dp[(i - <span class="number">1</span>)][v] + w);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; dp[n][e] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码二">代码二</h3>
<p>第二份代码修改如下，使用滚动数组去掉第一维后，出现TLE，说明常数过大</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e2</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, t, s, e, m, tot = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> head[maxn], nxt[maxn], edge[maxn], ver[maxn];</span><br><span class="line"><span class="type">int</span> a[maxn], b[maxn], c[maxn], dis[maxn];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">2</span>][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">  ver[++tot] = v, edge[tot] = w, nxt[tot] = head[u], head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离散化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dis[++m] = s, dis[++m] = e;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> u, v, w, i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;w, &amp;u, &amp;v);</span><br><span class="line">    dis[++m] = u, dis[++m] = v;</span><br><span class="line">    a[i] = u, b[i] = v, c[i] = w;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m);</span><br><span class="line">  m = <span class="built_in">unique</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m) - <span class="number">1</span> - dis;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">  s = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m, s) - dis;</span><br><span class="line">  e = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m, e) - dis;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m, a[i]) - dis;</span><br><span class="line">    <span class="type">int</span> v = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m, b[i]) - dis;</span><br><span class="line">    <span class="built_in">add</span>(u, v, c[i]), <span class="built_in">add</span>(v, u, c[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin), <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;t, &amp;s, &amp;e);</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">  dp[<span class="number">0</span>][s] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= m; ++u) &#123;</span><br><span class="line">      <span class="comment">// 覆盖旧数据</span></span><br><span class="line">      dp[i &amp; <span class="number">1</span>][u] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = head[u]; ~j; j = nxt[j]) &#123;</span><br><span class="line">        <span class="type">int</span> v = ver[j], w = edge[j];</span><br><span class="line">        dp[i &amp; <span class="number">1</span>][u] = <span class="built_in">min</span>(dp[i &amp; <span class="number">1</span>][u], dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][v] + w);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; dp[n &amp; <span class="number">1</span>][e] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码三">代码三</h3>
<p>常数优化在如下方面：</p>
<ol type="1">
<li>滚动数组本质是用两个数组交替保存结果，那么直接额外开<code>p</code>和<code>q</code>两个数组，以减少上亿次<code>&amp;</code>运算的开销</li>
<li>上亿次的<code>min</code>操作常数开销也极大，部分情况<code>min</code>的内部实现会变成递归；改用<code>if</code>判断</li>
<li>去掉不必要的中间变量定义</li>
</ol>
<p>得到AC代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e2</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, t, s, e, m, tot = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> head[maxn], nxt[maxn], edge[maxn], ver[maxn];</span><br><span class="line"><span class="type">int</span> a[maxn], b[maxn], c[maxn], dis[maxn];</span><br><span class="line"><span class="type">int</span> p[maxn], q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">  ver[++tot] = v, edge[tot] = w, nxt[tot] = head[u], head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离散化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dis[++m] = s, dis[++m] = e;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> u, v, w, i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;w, &amp;u, &amp;v);</span><br><span class="line">    dis[++m] = u, dis[++m] = v;</span><br><span class="line">    a[i] = u, b[i] = v, c[i] = w;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m);</span><br><span class="line">  m = <span class="built_in">unique</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m) - <span class="number">1</span> - dis;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">  s = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m, s) - dis;</span><br><span class="line">  e = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m, e) - dis;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m, a[i]) - dis;</span><br><span class="line">    <span class="type">int</span> v = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m, b[i]) - dis;</span><br><span class="line">    <span class="built_in">add</span>(u, v, c[i]), <span class="built_in">add</span>(v, u, c[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;t, &amp;s, &amp;e);</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="built_in">memset</span>(p, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(p));</span><br><span class="line">  p[s] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(q, p, <span class="built_in">sizeof</span>(q));</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(p));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= m; ++u) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = head[u]; ~j; j = nxt[j]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[u] &gt; q[ver[j]] + edge[j]) p[u] = q[ver[j]] + edge[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; p[e] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码四">代码四</h3>
<p>根据代码三得知，实际上就是一个广义的Bellman-Ford算法。</p>
<p>所以不用耗时去建图，直接对全图所有边遍历<code>n</code>次即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e2</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, t, s, e, m, tot = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> a[maxn], b[maxn], c[maxn], dis[maxn];</span><br><span class="line"><span class="type">int</span> p[maxn], q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离散化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dis[++m] = s, dis[++m] = e;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> u, v, w, i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;w, &amp;u, &amp;v);</span><br><span class="line">    dis[++m] = u, dis[++m] = v;</span><br><span class="line">    a[i] = u, b[i] = v, c[i] = w;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m);</span><br><span class="line">  m = <span class="built_in">unique</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m) - <span class="number">1</span> - dis;</span><br><span class="line">  s = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m, s) - dis;</span><br><span class="line">  e = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m, e) - dis;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    a[i] = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m, a[i]) - dis;</span><br><span class="line">    b[i] = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m, b[i]) - dis;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;t, &amp;s, &amp;e);</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="built_in">memset</span>(p, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(p));</span><br><span class="line">  p[s] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(q, p, <span class="built_in">sizeof</span>(q));</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(p));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u, v, w, j = <span class="number">1</span>; j &lt;= t; ++j) &#123;</span><br><span class="line">      u = a[j], v = b[j], w = c[j];</span><br><span class="line">      <span class="comment">// 双向边，所以两个方向</span></span><br><span class="line">      <span class="keyword">if</span> (p[u] &gt; q[v] + w) p[u] = q[v] + w;</span><br><span class="line">      <span class="keyword">if</span> (p[v] &gt; q[u] + w) p[v] = q[u] + w;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; p[e] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="边为对象的floyd">边为对象的Floyd</h2>
<p>如果用邻接矩阵<code>A</code>存边时，每次取：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A[a[i]][b[i]] = <span class="built_in">min</span>(A[a[i]][b[i]], c[i]);</span><br><span class="line">A[b[i]][a[i]] = <span class="built_in">min</span>(A[b[i]][a[i]], c[i]);</span><br></pre></td></tr></table></figure>
<p>那么初始时的<code>A[i][j]</code>显然代表<code>i到j刚好经过1条边的最短路</code></p>
<p>假设我们去寻找一个<code>i到j</code>的中间点<code>k</code>，一定有：
<span class="math display">\[
\forall i,j\in \left[ 1,m \right] ,     B\left[ i,j \right]
=\min_{1\leqslant k\leqslant m} \left\{ A\left[ i,k \right] +A\left[ k,j
\right] \right\}
\]</span>
<code>A[i][k]</code>代表点<code>i</code>到点<code>k</code>刚好经过1条边的最短路，<code>A[k][j]</code>代表点<code>k</code>到点<code>j</code>刚好经过1条边的最短路，两个矩阵合并得到的新矩阵<code>B</code>就代表<code>i到j刚好经过2条边的最短路</code>，且该合并操作显然满足结合律，<code>(AB)C</code>和<code>A(BC)</code>显然没区别。</p>
<p>以此类推，1条边、2条边、4条边、8条边...显然可以采用快速幂的方式加速矩阵运算，将<code>n</code>拆分成若干个2的幂次即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e2</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, t, s, e, m;</span><br><span class="line"><span class="type">int</span> a[maxn], b[maxn], c[maxn], dis[maxn];</span><br><span class="line"><span class="type">int</span> A[maxn][maxn], ans[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离散化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dis[++m] = s, dis[++m] = e;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> u, v, w, i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;w, &amp;u, &amp;v);</span><br><span class="line">    dis[++m] = u, dis[++m] = v;</span><br><span class="line">    a[i] = u, b[i] = v, c[i] = w;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m);</span><br><span class="line">  m = <span class="built_in">unique</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m) - <span class="number">1</span> - dis;</span><br><span class="line">  s = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m, s) - dis;</span><br><span class="line">  e = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m, e) - dis;</span><br><span class="line">  <span class="built_in">memset</span>(A, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(A));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    a[i] = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m, a[i]) - dis;</span><br><span class="line">    b[i] = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + m, b[i]) - dis;</span><br><span class="line">    <span class="comment">// i到j刚好走了1条边时的最短路</span></span><br><span class="line">    A[a[i]][b[i]] = <span class="built_in">min</span>(A[a[i]][b[i]], c[i]);</span><br><span class="line">    A[b[i]][a[i]] = <span class="built_in">min</span>(A[b[i]][a[i]], c[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a = a * b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a[maxn][maxn], <span class="type">int</span> b[maxn][maxn])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> res[maxn][maxn];</span><br><span class="line">  <span class="built_in">memset</span>(res, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(res));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= m; ++k)</span><br><span class="line">        <span class="keyword">if</span> (res[i][j] &gt; a[i][k] + b[k][j]) res[i][j] = a[i][k] + b[k][j];</span><br><span class="line">  <span class="built_in">memcpy</span>(a, res, <span class="built_in">sizeof</span>(res));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;t, &amp;s, &amp;e), <span class="built_in">init</span>();</span><br><span class="line">  <span class="comment">// 初始时,i到j刚好走了0条边的最短路,点到点本身距离为0</span></span><br><span class="line">  <span class="built_in">memset</span>(ans, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(ans));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">      <span class="keyword">if</span> (i == j) ans[i][i] = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 矩阵快速幂</span></span><br><span class="line">  <span class="keyword">while</span> (n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="built_in">mul</span>(ans, A);</span><br><span class="line">    <span class="built_in">mul</span>(A, A);</span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans[s][e] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
        <tag>离散化</tag>
        <tag>线性DP</tag>
        <tag>最短路</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-3662. Telephone Lines</title>
    <url>/2024/04/18/poj-3662-Telephone-Lines/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>后效性处理</li>
<li>最短路</li>
<li>二分</li>
<li>双端队列BFS</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<h2 id="分层图最短路">分层图最短路</h2>
<p>用动态规划的思想，设<code>D[x, p]</code>表示从<code>1</code>号节点到达基站<code>x</code>，途中已经指定了<code>p</code>条电缆免费时，经过的路径上最贵的电缆的花费最小是多少（选择一条从<code>1</code>到<code>x</code>的路径，使路径上第<code>p + 1</code>大的边权尽量小）。</p>
<p>假设节点<code>x</code>到节点<code>y</code>有一长度为<code>z</code>的无向边，有两种状态转移方式：</p>
<ul>
<li><p>该边不免费。</p>
<p>那么应该用<code>max(D[x, p], z)</code>更新<code>D[y, p]</code>的最小值</p></li>
<li><p>该边免费。</p>
<p>用<code>D[x, p]</code>更新<code>D[y, p + 1]</code>的最小值</p></li>
</ul>
<p>通过作图可以发现，若以免费电缆数<code>p</code>分层，整个动态规划的转移其实就是一张分层图：</p>
<img src="/2024/04/18/poj-3662-Telephone-Lines/1.png" class="" title="image-20240418221511114">
<p>每一层的图可能是有环的，也就是后效性；所以不能按照常规dp的方式做，要套SPFA，直至所有状态收敛。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">50</span>, maxm = <span class="number">1e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, p, k, head[maxn], tot = <span class="number">-1</span>, d[maxn][maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> v_, w_, nxt_;</span><br><span class="line">&#125; g[maxm &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">  g[++tot].v_ = v, g[tot].w_ = w, g[tot].nxt_ = head[u], head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">  <span class="comment">// d[u][t]：截止到u基站，有t个免费的情况下的最大值最小</span></span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x7f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">0</span>)), d[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>, vis[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>().first, t = q.<span class="built_in">front</span>().second;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    vis[u][t] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = g[i].nxt_) &#123;</span><br><span class="line">      <span class="type">int</span> v = g[i].v_, w = g[i].w_;</span><br><span class="line">      <span class="keyword">if</span> (d[v][t] &gt; <span class="built_in">max</span>(d[u][t], w)) &#123;</span><br><span class="line">        d[v][t] = <span class="built_in">max</span>(d[u][t], w);</span><br><span class="line">        <span class="keyword">if</span> (!vis[v][t]) &#123;</span><br><span class="line">          vis[v][t] = <span class="number">1</span>;</span><br><span class="line">          q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(v, t));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (t &lt; k &amp;&amp; d[v][t + <span class="number">1</span>] &gt; d[u][t]) &#123;</span><br><span class="line">        d[v][t + <span class="number">1</span>] = d[u][t];</span><br><span class="line">        <span class="keyword">if</span> (!vis[v][t + <span class="number">1</span>]) &#123;</span><br><span class="line">          vis[v][t + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">          q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(v, t + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) ans = <span class="built_in">min</span>(ans, d[n][i]);</span><br><span class="line">  cout &lt;&lt; (ans == <span class="number">0x7f7f7f7f</span> ? <span class="number">-1</span> : ans) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; p &gt;&gt; k;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> u, v, w, i = <span class="number">1</span>; i &lt;= p; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    <span class="built_in">add</span>(u, v, w), <span class="built_in">add</span>(v, u, w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">spfa</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分-双端队列bfs">二分 + 双端队列BFS</h2>
<p>很难想的二分.........考虑直接枚举第<code>k + 1</code>大的边权<code>mid</code>。</p>
<p>因为必须是<code>k + 1</code>大，应该存在一条路径，大于<code>mid</code>的边权数量必须小于等于<code>k</code>。</p>
<hr />
<p>如何去在当前图里寻找一条满足条件的路径呢？</p>
<p>把所有升级价格大于<code>mid</code>的电缆看作长度为<code>1</code>的边，小于等于<code>mid</code>的电缆看作长度为<code>0</code>的边，然后求<code>1</code>到<code>n</code>的最短路是否小于等于<code>k</code>即可，<code>01边权</code>的最短路使用双端队列BFS进行求解。</p>
<p>如果最短路的开销小于等于<code>k</code>，说明至少有一条路（最短路）满足条件，就可以继续向左边界收缩；</p>
<p>如果最短路的开销都大于<code>k</code>，说明当前<code>mid</code>太小了，比<code>mid</code>大的数超过了<code>k</code>个，需要向右边界扩张。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">50</span>, maxm = <span class="number">1e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, p, k, head[maxn], tot = <span class="number">-1</span>, d[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> v_, w_, nxt_;</span><br><span class="line">&#125; g[maxm &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">  g[++tot].v_ = v, g[tot].w_ = w, g[tot].nxt_ = head[u], head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d)), <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">  d[<span class="number">1</span>] = <span class="number">0</span>, q.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = g[i].nxt_) &#123;</span><br><span class="line">      <span class="type">int</span> v = g[i].v_, w = g[i].w_ &gt; mid;</span><br><span class="line">      <span class="keyword">if</span> (d[v] &gt; d[u] + w) &#123;</span><br><span class="line">        d[v] = d[u] + w;</span><br><span class="line">        <span class="keyword">if</span> (w)</span><br><span class="line">          q.<span class="built_in">push_back</span>(v);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          q.<span class="built_in">push_front</span>(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d[n] &lt;= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; p &gt;&gt; k;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> u, v, w, i = <span class="number">1</span>; i &lt;= p; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    <span class="built_in">add</span>(u, v, w), <span class="built_in">add</span>(v, u, w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1e6</span>;</span><br><span class="line">  <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">      r = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; (l &gt; <span class="number">1e6</span> ? <span class="number">-1</span> : l) &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>双端队列BFS</tag>
        <tag>最短路</tag>
        <tag>后效性处理</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-206. 石头游戏</title>
    <url>/2024/04/22/acwing-206-%E7%9F%B3%E5%A4%B4%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>矩阵乘法</li>
<li>快速幂</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">70</span>;</span><br><span class="line"><span class="comment">// 一维向量、60次幂的循环节、转移矩阵</span></span><br><span class="line">ll f[maxn], sixty[maxn][maxn], A[maxn][maxn][maxn];</span><br><span class="line"><span class="comment">// 保存操作序列</span></span><br><span class="line">string seq[maxn];</span><br><span class="line"><span class="type">int</span> n, m, t, act;</span><br><span class="line"><span class="comment">// 每个点对应的操作序列下标</span></span><br><span class="line"><span class="type">int</span> a[maxn][maxn];</span><br><span class="line"><span class="comment">// 每个点当前其操作序列中执行的哪个操作</span></span><br><span class="line"><span class="type">int</span> state[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i - <span class="number">1</span>) * m + j; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mulself</span><span class="params">(ll a[maxn][maxn], ll b[maxn][maxn])</span> </span>&#123;</span><br><span class="line">  ll res[maxn][maxn];</span><br><span class="line">  <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="built_in">sizeof</span>(res));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n * m; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n * m; ++j)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= n * m; ++k) res[i][j] += a[i][k] * b[k][j];</span><br><span class="line">  <span class="built_in">memcpy</span>(a, res, <span class="built_in">sizeof</span>(res));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(ll a[maxn], ll b[maxn][maxn])</span> </span>&#123;</span><br><span class="line">  ll res[maxn];</span><br><span class="line">  <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="built_in">sizeof</span>(res));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n * m; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n * m; ++j) res[i] += a[j] * b[j][i];</span><br><span class="line">  <span class="built_in">memcpy</span>(f, res, <span class="built_in">sizeof</span>(res));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打表1-60次幂的转移矩阵</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">60</span>; ++k) &#123;</span><br><span class="line">    A[k][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">        <span class="comment">// 当前执行第x个操作序列的第y个行动</span></span><br><span class="line">        <span class="type">int</span> x = a[i][j], y = state[i][j];</span><br><span class="line">        <span class="type">char</span> chr = seq[x][y];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(chr)) &#123;</span><br><span class="line">          A[k][<span class="number">0</span>][<span class="built_in">num</span>(i, j)] = chr - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">          A[k][<span class="built_in">num</span>(i, j)][<span class="built_in">num</span>(i, j)] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chr == <span class="string">&#x27;N&#x27;</span> &amp;&amp; i &gt; <span class="number">1</span>)</span><br><span class="line">          A[k][<span class="built_in">num</span>(i, j)][<span class="built_in">num</span>(i - <span class="number">1</span>, j)] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (chr == <span class="string">&#x27;W&#x27;</span> &amp;&amp; j &gt; <span class="number">1</span>)</span><br><span class="line">          A[k][<span class="built_in">num</span>(i, j)][<span class="built_in">num</span>(i, j - <span class="number">1</span>)] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (chr == <span class="string">&#x27;S&#x27;</span> &amp;&amp; i &lt; n)</span><br><span class="line">          A[k][<span class="built_in">num</span>(i, j)][<span class="built_in">num</span>(i + <span class="number">1</span>, j)] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (chr == <span class="string">&#x27;E&#x27;</span> &amp;&amp; j &lt; m)</span><br><span class="line">          A[k][<span class="built_in">num</span>(i, j)][<span class="built_in">num</span>(i, j + <span class="number">1</span>)] = <span class="number">1</span>;</span><br><span class="line">        state[i][j] = (y + <span class="number">1</span>) % seq[x].<span class="built_in">length</span>();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; t &gt;&gt; act;</span><br><span class="line">  <span class="type">char</span> chr;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">      cin &gt;&gt; chr;</span><br><span class="line">      a[i][j] = chr - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; act; ++i) cin &gt;&gt; seq[i];</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="built_in">memcpy</span>(sixty, A[<span class="number">1</span>], <span class="built_in">sizeof</span>(A[<span class="number">1</span>]));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">60</span>; ++i) <span class="built_in">mulself</span>(sixty, A[i]);</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> q = t / <span class="number">60</span>, r = t % <span class="number">60</span>;</span><br><span class="line">  <span class="comment">// 矩阵快速幂</span></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">    <span class="keyword">if</span> (q &amp; <span class="number">1</span>) <span class="built_in">mul</span>(f, sixty);</span><br><span class="line">    <span class="built_in">mulself</span>(sixty, sixty);</span><br><span class="line">    q &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) <span class="built_in">mul</span>(f, A[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * m; ++i) ans = <span class="built_in">max</span>(ans, f[i]);</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>单看题意其实是纯模拟<code>t</code>次，然而<code>t</code>的范围高达<code>1e9</code>，如果执行线性模拟会超时；</p>
<p>整个题目只有加法操作和乘一个系数操作，考虑矩阵乘法+快速幂加速。</p>
<p>把<code>n * m</code>的网格看作长度为<code>n * m</code>的一维向量，定义<code>1</code>行
<code>(n * m + 1)</code>的状态矩阵<code>F</code>，下标为<code>0 ~ n * m</code>；</p>
<p>已知<span class="math inline">\(\forall i\in \left[ 1,n \right] ,j\in
\left[ 1,m
\right]\)</span>，网格原<code>(i, j)</code>的点映射到<code>F</code>的下标为<code>num(i, j) = (i - 1) * m + j</code>，</p>
<p>令<code>F[num(i, j)]</code>记录格子<code>(i, j)</code>中石头的个数，其中<code>F[0] = 1</code>。</p>
<p>设<span
class="math inline">\(F_k\)</span>表示<code>k</code>秒之后的状态矩阵，根据题意，初始时有<span
class="math inline">\(F_0=\left[ \begin{matrix}  1&amp; 0&amp; 0&amp;
\cdots&amp; 0\\ \end{matrix}
\right]\)</span>，除了0位置之外的所有点石头数均为0。</p>
<hr />
<p>接下来考虑构造转移矩阵<code>A</code>，矩阵行、列下标都是<code>0 ~ n * m</code></p>
<p>假设有网格<span class="math inline">\(\left[ \begin{matrix}  a_1&amp;
a_2\\  a_3&amp; a_4\\ \end{matrix}
\right]\)</span>，转换成状态矩阵变成$F_0=$，其中<code>a0</code>作为新增的常数项位置，恒为1。</p>
<p>假设<code>a1</code>加5，<code>a2</code>、<code>a3</code>、<code>a4</code>均不动，那么有如下等式：
<span class="math display">\[
\begin{cases}
    a_1=5\times a_0+1\times a_1+0\times a_2+0\times a_3+0\times a_4\\
    a_2=0\times a_0+0\times a_1+1\times a_2+0\times a_3+0\times a_4\\
    a_3=0\times a_0+0\times a_1+0\times a_2+1\times a_3+0\times a_4\\
    a_4=0\times a_0+0\times a_1+0\times a_2+0\times a_3+1\times a_4\\
\end{cases}
\]</span>
这里就体现了常数项<code>a0</code>的作用了，可以很方便地累加；得到转移矩阵如下：
<span class="math display">\[
\left[ \begin{matrix}
    1&amp;      5&amp;      0&amp;      0&amp;      0\\
    0&amp;      1&amp;      0&amp;      0&amp;      0\\
    0&amp;      0&amp;      1&amp;      0&amp;      0\\
    0&amp;      0&amp;      0&amp;      1&amp;      0\\
    0&amp;      0&amp;      0&amp;      0&amp;      1\\
\end{matrix} \right]
\]</span> 假设<code>a3</code>向上推，其余保持不变，有如下等式： <span
class="math display">\[
\begin{cases}
    a_1=0\times a_0+1\times a_1+0\times a_2+1\times a_3+0\times a_4\\
    a_2=0\times a_0+0\times a_1+1\times a_2+0\times a_3+0\times a_4\\
    a_3=0\times a_0+0\times a_1+0\times a_2+1\times a_3+0\times a_4\\
    a_4=0\times a_0+0\times a_1+0\times a_2+0\times a_3+1\times a_4\\
\end{cases}
\]</span> 得到转移矩阵如下： <span class="math display">\[
\left[ \begin{matrix}
    1&amp;      0&amp;      0&amp;      0&amp;      0\\
    0&amp;      1&amp;      0&amp;      0&amp;      0\\
    0&amp;      0&amp;      1&amp;      0&amp;      0\\
    0&amp;      1&amp;      0&amp;      1&amp;      0\\
    0&amp;      0&amp;      0&amp;      0&amp;      1\\
\end{matrix} \right]
\]</span></p>
<hr />
<p>由于<code>1 - 6</code>之间的数字的最小公倍数是60，意味着最多60次幂的时候，所有的操作序列都会重新回到最开始的1次幂处。</p>
<p>根据快速幂的思路，可以把每60次幂作为一个循环节，预先打表出60次幂得到的转移矩阵<code>sixty</code>；</p>
<p>一共是<code>t</code>次幂，可以拆分成<code>t= q * 60 + r</code>，对于<code>sixty</code>的<code>q</code>次幂，可以直接使用矩阵快速幂进行求解，</p>
<p>而<code>r</code>小于60，直接暴力运算即可。</p>
<hr />
<p>整理一下最终的转移矩阵构造规律：</p>
<ol type="1">
<li>若网格<code>(i, j)</code>第<code>k</code>秒的操作字符为<code>N</code>，且<code>i &gt; 1</code>，那么令<code>A[num(i, j)][num(i - 1, j)] = 1</code>，其余方向类似</li>
<li>若网格<code>(i, j)</code>第<code>k</code>秒的操作字符是一个数字<code>x</code>，令<code>A[0][num(i, j)] = x</code>，<code>A[num(i, j)][num(i, j)] = 1</code>，表示格子里本来的格子不动，再拿<code>x</code>块石头</li>
<li>令<code>A[0][0] = 1</code></li>
<li>其余部分置<code>0</code></li>
</ol>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数_解题技巧</title>
    <url>/2024/04/21/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="矩阵乘法快速幂">矩阵乘法+快速幂</h1>
<ul>
<li><a href="https://www.acwing.com/problem/content/207/">acwing-205</a>
科普题</li>
<li><a href="https://www.acwing.com/problem/content/208/">acwing-206</a>
经典！</li>
</ul>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
  </entry>
  <entry>
    <title>acwing-343. 排序</title>
    <url>/2024/04/25/acwing-343-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>最短路</li>
<li>传递闭包</li>
<li>拓扑排序</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<h2 id="floyd传递闭包">Floyd传递闭包</h2>
<p>对于每个<code>i &lt; j</code>的不等式，令<code>d[i, j] = 1</code>，除此以外的情况均令<code>d[i, j] = 0</code></p>
<p>使用Floyd算法对<code>d</code>进行传递闭包</p>
<p>传递闭包完成后若存在变量<code>i, j</code>，使得<code>d[i, j]</code>和<code>d[j, i]</code>均为1，说明存在环，关系矛盾：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (f[i][j] == <span class="number">1</span> &amp;&amp; f[j][i] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>如果存在变量<code>i, j</code>，使得<code>d[i, j]</code>和<code>d[j, i]</code>均为0，说明不能确定每一对变量之间的大小：</p>
<p>注意要在<code>i != j</code>的情况下判定，因为自己不可能小于自己，<code>d[i, i]</code>应恒为0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i != j &amp;&amp; f[i][j] == <span class="number">0</span> &amp;&amp; f[j][i] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>只有对于每队变量<code>i, j</code>，<code>d[i, j]</code>和<code>d[j, i]</code>有且仅有一个为1，才能说明能确定每队变量之间的大小关系。</p>
<p>这里最大的难点其实是如何输出。假设有关系<code>B &lt; A &lt; D &lt; C</code>，通过观察floyd后的结果可以发现：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
<th style="text-align: center;">C</th>
<th style="text-align: center;">D</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">D</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>关系个数越少的，值越大，根据这个来进行输出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> d[maxn][maxn], f[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memcpy</span>(f, d, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        f[i][j] |= f[i][k] &amp; f[k][j];</span><br><span class="line">        <span class="comment">// 存在环，矛盾</span></span><br><span class="line">        <span class="keyword">if</span> (f[i][j] == <span class="number">1</span> &amp;&amp; f[j][i] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i != j &amp;&amp; f[i][j] == <span class="number">0</span> &amp;&amp; f[j][i] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// pair&lt;字符的关系个数，字符&gt;</span></span><br><span class="line">  pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; ans[maxn];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) ans[i].first = <span class="number">0</span>, ans[i].second = <span class="string">&#x27;A&#x27;</span> + i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">      <span class="keyword">if</span> (f[i][j]) ++ans[i].first;</span><br><span class="line">  <span class="built_in">sort</span>(ans, ans + n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) cout &lt;&lt; ans[i].second;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">6</span>];</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  <span class="type">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    u = s[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>, v = s[<span class="number">2</span>] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="comment">// 尽管本轮得到了答案，但是要继续读入剩余无用数据</span></span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">continue</span>;</span><br><span class="line">    d[u][v] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">floyd</span>();</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Inconsistency found after %d relations.\n&quot;</span>, i), flag = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Sorted sequence determined after %d relations: &quot;</span>, i), flag = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flag) <span class="built_in">puts</span>(<span class="string">&quot;Sorted sequence cannot be determined.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> ((cin &gt;&gt; n &gt;&gt; m) &amp;&amp; n) <span class="built_in">work</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序">拓扑排序</h2>
<p>令<code>小于关系</code>抽象为一条有向边，那么题目要求的是一条<strong>有向无环且最长路等于<code>n</code>的链式</strong>拓扑序列。</p>
<p>如果有环，代表大小关系存在矛盾；如果拓扑序列不唯一，拓扑序列的最长路不等于<code>n</code>。</p>
<p>实现方式如下：</p>
<ol type="1">
<li>如果出队元素个数不等于<code>n</code>，说明存在环</li>
<li>如果最长路不等于<code>n</code>，说明拓扑序列不唯一</li>
<li>或者，当前队列入度等于0的节点个数是否大于1，大于1说明最长路不可能等于<code>n</code></li>
</ol>
<h3 id="最长路">最长路</h3>
<p>最长路写法，常数稍大但是逻辑好想：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">int</span> n, m, tot = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> head[<span class="number">30</span>], ver[maxn], nxt[maxn], edge[maxn];</span><br><span class="line"><span class="type">int</span> tind[maxn], ind[maxn], step[maxn];</span><br><span class="line">string ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">  ver[++tot] = v, edge[tot] = w, nxt[tot] = head[u], head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memcpy</span>(tind, ind, <span class="built_in">sizeof</span>(ind));</span><br><span class="line">  <span class="comment">// 每个节点默认的最长路为1，就是它自己</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) step[i] = <span class="number">1</span>;</span><br><span class="line">  ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (!tind[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    ++cnt;</span><br><span class="line">    ans += (<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span> + u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = nxt[i]) &#123;</span><br><span class="line">      <span class="type">int</span> v = ver[i];</span><br><span class="line">      <span class="keyword">if</span> (--tind[v] == <span class="number">0</span>) q.<span class="built_in">push</span>(v), step[v] = <span class="built_in">max</span>(step[v], step[u] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 有环，代表矛盾</span></span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> mx = INT_MIN;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) mx = <span class="built_in">max</span>(mx, step[i]);</span><br><span class="line">  <span class="keyword">if</span> (mx == n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">6</span>];</span><br><span class="line">  <span class="built_in">memset</span>(ind, <span class="number">0</span>, <span class="built_in">sizeof</span>(ind)), <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head)), tot = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    u = s[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>, v = s[<span class="number">2</span>] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="comment">// 尽管本轮得到了答案，但是要继续读入剩余无用数据</span></span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">add</span>(u, v, <span class="number">1</span>), ++ind[v];</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">toposort</span>();</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Inconsistency found after %d relations.\n&quot;</span>, i), flag = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Sorted sequence determined after %d relations: %s.\n&quot;</span>, i,</span><br><span class="line">             ans.<span class="built_in">c_str</span>()),</span><br><span class="line">          flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flag) <span class="built_in">puts</span>(<span class="string">&quot;Sorted sequence cannot be determined.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> ((cin &gt;&gt; n &gt;&gt; m) &amp;&amp; n) <span class="built_in">work</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断队列元素个数">判断队列元素个数</h3>
<p>判断队列中入度为0的元素个数，但是要注意一个逻辑坑点：</p>
<p>在<strong>有环且最长路不等于<code>n</code></strong>的情况下，有环情况的判定的优先级是大于最长路判定的，所以代码中使用<code>flag</code>进行延后：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) flag = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 节点没有全部出队，代表有环</span></span><br><span class="line"><span class="keyword">if</span> (cnt &lt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (flag &amp;&amp; ans.<span class="built_in">length</span>() == n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>完整代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">int</span> n, m, tot = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> head[<span class="number">30</span>], ver[maxn], nxt[maxn], edge[maxn];</span><br><span class="line"><span class="type">int</span> tind[maxn], ind[maxn];</span><br><span class="line">string ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">  ver[++tot] = v, edge[tot] = w, nxt[tot] = head[u], head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memcpy</span>(tind, ind, <span class="built_in">sizeof</span>(ind));</span><br><span class="line">  ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (!tind[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="type">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// 同一时刻有多个入度为0的节点，说明拓扑序不唯一，最长路必不可能等于n</span></span><br><span class="line">    <span class="comment">// 但不能直接return 0，同时有环和拓扑序列的情况下，有环的优先级更高</span></span><br><span class="line">    <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) flag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    ++cnt;</span><br><span class="line">    ans += (<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span> + u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = nxt[i]) &#123;</span><br><span class="line">      <span class="type">int</span> v = ver[i];</span><br><span class="line">      <span class="keyword">if</span> (--tind[v] == <span class="number">0</span>) q.<span class="built_in">push</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 节点没有全部出队，代表有环</span></span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (flag &amp;&amp; ans.<span class="built_in">length</span>() == n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">6</span>];</span><br><span class="line">  <span class="built_in">memset</span>(ind, <span class="number">0</span>, <span class="built_in">sizeof</span>(ind)), <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head)), tot = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    u = s[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>, v = s[<span class="number">2</span>] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="comment">// 尽管本轮得到了答案，但是要继续读入剩余无用数据</span></span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">add</span>(u, v, <span class="number">1</span>), ++ind[v];</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">toposort</span>();</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Inconsistency found after %d relations.\n&quot;</span>, i), flag = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Sorted sequence determined after %d relations: %s.\n&quot;</span>, i,</span><br><span class="line">             ans.<span class="built_in">c_str</span>()),</span><br><span class="line">          flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flag) <span class="built_in">puts</span>(<span class="string">&quot;Sorted sequence cannot be determined.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> ((cin &gt;&gt; n &gt;&gt; m) &amp;&amp; n) <span class="built_in">work</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
        <tag>最短路</tag>
        <tag>传递闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-344. 观光之旅</title>
    <url>/2024/04/26/acwing-344-%E8%A7%82%E5%85%89%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>最短路</li>
<li>最小环问题</li>
<li>Floyd的路径输出</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e2</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[maxn][maxn], d[maxn][maxn], pos[maxn][maxn];</span><br><span class="line">ll ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历输出路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_path</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pos[i][j] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">get_path</span>(i, pos[i][j]);</span><br><span class="line">  path.<span class="built_in">push_back</span>(pos[i][j]);</span><br><span class="line">  <span class="built_in">get_path</span>(pos[i][j], j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">    <span class="comment">// 遍历两个小于k的节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; k; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ll)d[i][j] + a[j][k] + a[k][i] &lt; ans) &#123;</span><br><span class="line">          ans = d[i][j] + a[j][k] + a[k][i];</span><br><span class="line">          path.<span class="built_in">clear</span>();</span><br><span class="line">          path.<span class="built_in">push_back</span>(i);</span><br><span class="line">          <span class="built_in">get_path</span>(i, j);</span><br><span class="line">          path.<span class="built_in">push_back</span>(j);</span><br><span class="line">          path.<span class="built_in">push_back</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// floyd代码，并记录中间点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i][j] &gt; d[i][k] + d[k][j]) &#123;</span><br><span class="line">          d[i][j] = d[i][k] + d[k][j];</span><br><span class="line">          pos[i][j] = k;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">memset</span>(a, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i][i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> u, v, w, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    a[u][v] = a[v][u] = <span class="built_in">min</span>(a[u][v], w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memcpy</span>(d, a, <span class="built_in">sizeof</span>(a));</span><br><span class="line">  <span class="built_in">floyd</span>();</span><br><span class="line">  <span class="keyword">if</span> (ans == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;No solution.&quot;</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : path) cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>之所以题目规定了至少包含3个点的环，是因为无向图的边本身就是双向的，<code>a -&gt; b</code>自然也可以<code>b -&gt; a</code>，显然这不是一个环，但是却可以回到原点，所以强制设定至少包含3个点。</p>
<p>如果是有向图的情况下，枚举起点<code>s = 1 ~ n</code>，执行堆优化的Dijkstra算法求解单源最短路径，每个<code>s</code>一定是第一个被从堆中取出的节点，扫描<code>s</code>的所有出边，当扩展、更新完成后，令<code>d[s] = 正无穷</code>，然后继续求解。当<code>s</code>第二次被从堆中取出时，说明绕回了点<code>s</code>，那么<code>d[s]</code>就是经过点<code>s</code>的最小环长度。</p>
<hr />
<p>考虑floyd算法的过程，当外层循环<code>k</code>刚开始时，<code>d[i, j]</code>保存着<code>经过编号不超过k - 1的节点</code>从<code>i</code>到<code>j</code>的最短路长度。</p>
<p>显然，<span class="math inline">\(\min_{1\leqslant i&lt;j&lt;k}
\left\{ d\left[ i,j \right] +a\left[ j,k \right] +a\left[ k,i \right]
\right\}\)</span>就是满足以下两个条件的最小环长度。</p>
<ol type="1">
<li>由编号不超过<code>k</code>的节点构成</li>
<li>经过节点<code>k</code></li>
</ol>
<p>可以画图表示：</p>
<img src="/2024/04/26/acwing-344-%E8%A7%82%E5%85%89%E4%B9%8B%E6%97%85/1.png" class="" title="image-20240426173925878">
<hr />
<p>为了输出floyd的路径，每次都要保存中间点<code>mid</code>到<code>pos[i][j] = mid</code></p>
<p>由于方向是<code>i -&gt; mid -&gt; j</code>，先输出左边<code>i ~ mid</code>部分，再输出中间点<code>mid</code>，最后输出右边<code>mid ~ j</code>部分，满足二叉树的中序遍历；</p>
<p>故而直接套用二叉树的中序遍历模板即可输出。</p>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-383. 观光</title>
    <url>/2024/04/27/acwing-383-%E8%A7%82%E5%85%89/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>次短路</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">50</span>, maxm = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, s, f, tot, head[maxn], ver[maxm], edge[maxm], nxt[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">  ver[++tot] = v, edge[tot] = w, nxt[tot] = head[u], head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 第一维代表最短路，第二维代表次短路</span></span><br><span class="line">  <span class="type">int</span> d[maxn][<span class="number">2</span>], cnt[maxn][<span class="number">2</span>];</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d)), <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">  <span class="type">bool</span> vis[maxn][<span class="number">2</span>];</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">  <span class="comment">// &lt;路径开销，&lt;节点，类型&gt;&gt;</span></span><br><span class="line">  priority_queue&lt;pair&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; q;</span><br><span class="line">  d[s][<span class="number">0</span>] = <span class="number">0</span>, cnt[s][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, &#123;s, <span class="number">0</span>&#125;&#125;);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> dis = q.<span class="built_in">top</span>().first, u = q.<span class="built_in">top</span>().second.first,</span><br><span class="line">        type = q.<span class="built_in">top</span>().second.second;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (vis[u][type]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u][type] = <span class="number">1</span>;</span><br><span class="line">    dis = -dis;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = nxt[i]) &#123;</span><br><span class="line">      <span class="type">int</span> v = ver[i], w = edge[i];</span><br><span class="line">      <span class="keyword">if</span> (d[v][<span class="number">0</span>] &gt; dis + w) &#123;</span><br><span class="line">        d[v][<span class="number">1</span>] = d[v][<span class="number">0</span>], cnt[v][<span class="number">1</span>] = cnt[v][<span class="number">0</span>], q.<span class="built_in">push</span>(&#123;-d[v][<span class="number">1</span>], &#123;v, <span class="number">1</span>&#125;&#125;);</span><br><span class="line">        d[v][<span class="number">0</span>] = dis + w, cnt[v][<span class="number">0</span>] = cnt[u][type], q.<span class="built_in">push</span>(&#123;-d[v][<span class="number">0</span>], &#123;v, <span class="number">0</span>&#125;&#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d[v][<span class="number">0</span>] == dis + w) &#123;</span><br><span class="line">        cnt[v][<span class="number">0</span>] += cnt[u][type];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d[v][<span class="number">1</span>] &gt; dis + w) &#123;</span><br><span class="line">        d[v][<span class="number">1</span>] = dis + w;</span><br><span class="line">        cnt[v][<span class="number">1</span>] = cnt[u][type];</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;-d[v][<span class="number">1</span>], &#123;v, <span class="number">1</span>&#125;&#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d[v][<span class="number">1</span>] == dis + w) &#123;</span><br><span class="line">        cnt[v][<span class="number">1</span>] += cnt[u][type];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; (d[f][<span class="number">1</span>] == d[f][<span class="number">0</span>] + <span class="number">1</span> ? cnt[f][<span class="number">0</span>] + cnt[f][<span class="number">1</span>] : cnt[f][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head)), tot = <span class="number">-1</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u, v, w, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">      cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">      <span class="built_in">add</span>(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; f;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>次短路的提升题，难点在于要同时记录最短路和次短路的个数。</p>
<p>设第一维代表最短路，第二维代表次短路，</p>
<p>那么<code>d[u][0]</code>和<code>d[u][1]</code>分别代表点<code>u</code>的最短路和次短路长度，</p>
<p><code>cnt[u][0]</code>和<code>cnt[u][1]</code>分别代表点<code>u</code>的最短路个数和次短路个数。</p>
<p>由于每个点的最短路和次短路的个数不一定相同，</p>
<p>所以还需要在堆中新增一个变量<code>type</code>代表当前点使用的是最短路还是次短路：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;路径开销，&lt;节点，类型&gt;&gt;</span></span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; q;</span><br></pre></td></tr></table></figure>
<p>设当前节点<code>u</code>，使用类型<code>type</code>的长度为<code>dis</code>，要扩展到节点<code>v</code>，边权为<code>w</code>，有如下情况：</p>
<ol type="1">
<li><p>如果<code>d[v][0] &gt; dis + w</code>，即最短路会被更新</p>
<p>那么当前最短路就会变成次短路，当前最短路的个数就会变成次短路的个数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">d[v][<span class="number">1</span>] = d[v][<span class="number">0</span>], cnt[v][<span class="number">1</span>] = cnt[v][<span class="number">0</span>], q.<span class="built_in">push</span>(&#123;-d[v][<span class="number">1</span>], &#123;v, <span class="number">1</span>&#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>当前最短路变成<code>dis + w</code>，个数等于<code>cnt[u][type]</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">d[v][<span class="number">0</span>] = dis + w, cnt[v][<span class="number">0</span>] = cnt[u][type], q.<span class="built_in">push</span>(&#123;-d[v][<span class="number">0</span>], &#123;v, <span class="number">0</span>&#125;&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>如果<code>d[v][0] == dis + w</code>，当前开销等于最短路，直接新增最短路个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cnt[v][<span class="number">0</span>] += cnt[u][type];</span><br></pre></td></tr></table></figure></li>
<li><p>如果<code>d[v][1] &gt; dis + w</code> 且
<code>d[v][0] &lt; dis + w</code>，即次短路会被更新</p>
<p>次短路变成<code>dis + w</code>，个数等于<code>cnt[u][type]</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">d[v][<span class="number">1</span>] = dis + w, cnt[v][<span class="number">1</span>] = cnt[u][type], q.<span class="built_in">push</span>(&#123;-d[v][<span class="number">1</span>], &#123;v, <span class="number">1</span>&#125;&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>如果<code>d[v][1] == dis + w</code>，当前开销等于次短路，直接新增次短路个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cnt[v][<span class="number">1</span>] += cnt[u][type];</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>次短路</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-385. GF和猫咪的玩具</title>
    <url>/2024/04/28/acwing-385-GF%E5%92%8C%E7%8C%AB%E5%92%AA%E7%9A%84%E7%8E%A9%E5%85%B7/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>最短路</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e2</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, d[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="comment">// 正环没有最长路，和负环没有最短路一样，可以无限循环</span></span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) d[i][i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    d[u][v] = d[v][u] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, d[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p><code>绳索</code>可以抽象为一条边权为<code>1</code>的双向边，代表<code>数量1</code>，其余部分设置为极大值，然后用<code>floyd</code>求任意两点间最短路。</p>
<p>不要妄图求最长路！你在正环求最长路、负环求最短路都是逻辑错误，因为根本上可以无限循环！</p>
<p>顺带解释一下题意，以样例举例，<code>1 - 2 - 4 - 3 - 5 - 6 - 1</code>拉紧<code>1</code>和<code>4</code>时只有<code>1 - 2 - 4</code>是紧的，其余部分都是松的，所以才要去找最短路，因为一个环的结果只由短的那部分决定。</p>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-384. 升降梯上</title>
    <url>/2024/04/27/acwing-384-%E5%8D%87%E9%99%8D%E6%A2%AF%E4%B8%8A/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>最短路</li>
<li>分层图</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<p>设<code>f</code>代表层下标，<code>k</code>代表槽下标，<code>c[k]</code>代表第<code>k</code>个槽的变量，起点等于<code>(第一层, 槽变量等于0的下标) = (1, st)</code></p>
<p><code>d[f][k]</code>代表从起点<code>(1, st)</code>到<code>(f, k)</code>的单源最短路，题目要找的是<code>d[n][...]</code>的最小值</p>
<p>很显然这是一个分层图最短路，每一个状态有以下分支：</p>
<ol type="1">
<li><p>选择扳手柄</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (d[f][i] &gt; d[f][k] + <span class="built_in">abs</span>(i - k)) &#123;</span><br><span class="line">        d[f][i] = d[f][k] + <span class="built_in">abs</span>(i - k);</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;-d[f][i], &#123;f, i&#125;&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>选择升降电梯</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">valid</span>(f, k) &amp;&amp; d[f + c[k]][k] &gt; d[f][k] + <span class="built_in">abs</span>(<span class="number">2</span> * c[k])) &#123;</span><br><span class="line">  d[f + c[k]][k] = d[f][k] + <span class="built_in">abs</span>(<span class="number">2</span> * c[k]);</span><br><span class="line">  q.<span class="built_in">push</span>(&#123;-d[f + c[k]][k], &#123;f + c[k], k&#125;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="spfa实现">SPFA实现</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">30</span>, maxm = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, st;</span><br><span class="line"><span class="comment">// d[f][k]：层下标f槽下标k，求(1,st)到(n,...)的单源最短路</span></span><br><span class="line"><span class="type">int</span> c[maxn], d[maxm][maxn];</span><br><span class="line"><span class="type">bool</span> v[maxm][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> f, <span class="type">int</span> k)</span> </span>&#123; <span class="keyword">return</span> f + c[k] &gt;= <span class="number">1</span> &amp;&amp; f + c[k] &lt;= n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">  d[<span class="number">1</span>][st] = <span class="number">0</span>, v[<span class="number">1</span>][st] = <span class="number">1</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(&#123;<span class="number">1</span>, st&#125;);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> f = q.<span class="built_in">front</span>().first, k = q.<span class="built_in">front</span>().second;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    v[f][k] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 改变槽的情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (d[f][i] &gt; d[f][k] + <span class="built_in">abs</span>(i - k)) &#123;</span><br><span class="line">        d[f][i] = d[f][k] + <span class="built_in">abs</span>(i - k);</span><br><span class="line">        <span class="keyword">if</span> (!v[f][i]) &#123;</span><br><span class="line">          v[f][i] = <span class="number">1</span>;</span><br><span class="line">          q.<span class="built_in">push</span>(&#123;f, i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改变电梯的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">valid</span>(f, k) &amp;&amp; d[f + c[k]][k] &gt; d[f][k] + <span class="built_in">abs</span>(<span class="number">2</span> * c[k])) &#123;</span><br><span class="line">      d[f + c[k]][k] = d[f][k] + <span class="built_in">abs</span>(<span class="number">2</span> * c[k]);</span><br><span class="line">      <span class="keyword">if</span> (!v[f + c[k]][k]) &#123;</span><br><span class="line">        v[f + c[k]][k] = <span class="number">1</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;f + c[k], k&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ans = <span class="built_in">min</span>(ans, d[n][i]);</span><br><span class="line">  cout &lt;&lt; (ans == <span class="number">0x3f3f3f3f</span> ? <span class="number">-1</span> : ans) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; c[i];</span><br><span class="line">    <span class="keyword">if</span> (c[i] == <span class="number">0</span>) st = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">spfa</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dijkstra实现">Dijkstra实现</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">30</span>, maxm = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, st;</span><br><span class="line"><span class="comment">// d[f][k]：层下标f槽下标k，求(1,st)到(n,...)的单源最短路</span></span><br><span class="line"><span class="type">int</span> c[maxn], d[maxm][maxn];</span><br><span class="line"><span class="type">bool</span> v[maxm][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> f, <span class="type">int</span> k)</span> </span>&#123; <span class="keyword">return</span> f + c[k] &gt;= <span class="number">1</span> &amp;&amp; f + c[k] &lt;= n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  priority_queue&lt;pair&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; q;</span><br><span class="line">  d[<span class="number">1</span>][st] = <span class="number">0</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, &#123;<span class="number">1</span>, st&#125;&#125;);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> f = q.<span class="built_in">top</span>().second.first, k = q.<span class="built_in">top</span>().second.second;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (v[f][k]) <span class="keyword">continue</span>;</span><br><span class="line">    v[f][k] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 改变槽的情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (d[f][i] &gt; d[f][k] + <span class="built_in">abs</span>(i - k)) &#123;</span><br><span class="line">        d[f][i] = d[f][k] + <span class="built_in">abs</span>(i - k);</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;-d[f][i], &#123;f, i&#125;&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改变电梯的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">valid</span>(f, k) &amp;&amp; d[f + c[k]][k] &gt; d[f][k] + <span class="built_in">abs</span>(<span class="number">2</span> * c[k])) &#123;</span><br><span class="line">      d[f + c[k]][k] = d[f][k] + <span class="built_in">abs</span>(<span class="number">2</span> * c[k]);</span><br><span class="line">      q.<span class="built_in">push</span>(&#123;-d[f + c[k]][k], &#123;f + c[k], k&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ans = <span class="built_in">min</span>(ans, d[n][i]);</span><br><span class="line">  cout &lt;&lt; (ans == <span class="number">0x3f3f3f3f</span> ? <span class="number">-1</span> : ans) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; c[i];</span><br><span class="line">    <span class="keyword">if</span> (c[i] == <span class="number">0</span>) st = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dijkstra</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路_解题技巧</title>
    <url>/2024/04/29/%E6%9C%80%E7%9F%AD%E8%B7%AF-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="使用">使用</h1>
<h2 id="spfa与dijkstra的选择">SPFA与Dijkstra的选择</h2>
<p>如果dp存在后效性，即状态转移存在环形，就需要使用单源最短路算法进行解决。</p>
<p>Dijkstra由于使用贪心策略，只会出队一次；SPFA则会出队若干次，直到所有条件收敛。</p>
<p>判断Dijkstra还是SPFA的常用办法，自己创造一个环，根据节点定义走一遍，看看初始节点是否会被重复更新。</p>
<p>举个例子，有<code>1</code>、<code>2</code>、<code>3</code>三个点，<code>1 -&gt; 2</code>，<code>2 -&gt; 3</code>，<code>3 -&gt; 1</code>三条边构成一个环</p>
<p>如果定义<code>d[x]</code>代表到达<code>x</code>的最短路径开销，设<code>d[1] = 5</code></p>
<ul>
<li>如果边权不为负，不管怎样点<code>1</code>都不会被重复更新，设三条边边权都为<code>0</code>，<code>d[1] = 5</code>，就算转一圈开销也还是<code>5</code>，不会被更新。</li>
<li>如果边权为负，设三条边边权均为<code>-1</code>，转一圈后<code>d[1] = 5 - 3 = 2</code>，显然只出一次队列是不够的，这也是为什么负权边要用SPFA而不是Dijkstra</li>
</ul>
<p>再举一个例子，定义<code>d[x]</code>代表到达<code>x</code>的最小值，设<code>d[1] = 5</code></p>
<p>设节点<code>2</code>的值为<code>2</code>，节点<code>3</code>的值为<code>1</code>，转一圈回到节点<code>1</code>后<code>d[1] = 1</code>，也说明Dijkstra是不够用的。</p>
<h2 id="bellman-ford的核心">Bellman-Ford的核心</h2>
<p>根据最短路的定义，最短路的边数不会超过<code>n - 1</code>，否则存在负环，那么每个节点最多扩展<code>n - 1</code>次。</p>
<p><code>Bellman-Ford</code>就是暴力地遍历全图所有边<code>n - 1</code>次，<code>SPFA</code>只是使用队列稍微规避了一些不必要的扩展，是可以构造数据退化为暴力的。</p>
<h1 id="练习题">练习题</h1>
<ul>
<li><a href="http://poj.org/problem?id=3662">poj-3662</a>
DP+后效性处理+最短路，或者二分+双端队列BFS</li>
<li><a
href="https://atcoder.jp/contests/abc363/tasks/abc363_e">atcoder-abc363-e</a>
网格图的广义最短路</li>
<li><a
href="https://www.acwing.com/problem/content/description/343/">acwing-341</a>
后效性处理+最短路</li>
<li><a
href="https://www.acwing.com/problem/content/description/344/">acwing-342</a>
flood-fill找连通块+拓扑排序+最短路</li>
<li><a
href="https://www.acwing.com/problem/content/description/347/">acwing-345</a>
边角度实现的Floyd + 矩阵乘法快速幂</li>
<li><a href="https://www.acwing.com/problem/content/345/">acwing-343</a>
利用Floyd实现传递闭包</li>
<li><a
href="https://www.acwing.com/problem/content/description/346/">acwing-344</a>
Floyd的最小环问题，Floyd的路径，最短路经过的点，经典</li>
<li><a href="https://www.acwing.com/problem/content/385/">acwing-383</a>
次短路的提升题</li>
<li><a
href="https://www.acwing.com/problem/content/description/386/">acwing-384</a>
分层图最短路</li>
<li><a href="https://www.acwing.com/problem/content/387/">acwing-385</a>
Floyd模板题</li>
<li><a
href="https://www.acwing.com/problem/content/description/388/">acwing-386</a>
Floyd的路径，判断点是否在最短路上，经典</li>
</ul>
<h1 id="模板">模板</h1>
<h2 id="dijkstra邻接矩阵暴力">Dijkstra（邻接矩阵暴力）</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, a[<span class="number">505</span>][<span class="number">505</span>], d[<span class="number">505</span>];</span><br><span class="line"><span class="type">bool</span> v[<span class="number">505</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">memset</span>(a, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">    a[x][y] = <span class="built_in">min</span>(a[x][y], z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i][i] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">1</span>; cnt &lt;= n; cnt++) &#123;</span><br><span class="line">    <span class="type">int</span> min_val = <span class="number">1</span> &lt;&lt; <span class="number">30</span>, x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">      <span class="keyword">if</span> (!v[i] &amp;&amp; d[i] &lt; min_val) min_val = d[i], x = i;</span><br><span class="line">    v[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt;= n; y++) d[y] = <span class="built_in">min</span>(d[y], d[x] + a[x][y]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (d[n] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; d[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dijkstra堆优化">Dijkstra（堆优化）</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_N = <span class="number">150005</span>, MAX_M = <span class="number">150005</span>;</span><br><span class="line"><span class="type">int</span> head[MAX_N], ver[MAX_M], edge[MAX_M], nxt[MAX_M], tot;</span><br><span class="line"><span class="type">int</span> n, m, d[MAX_N];</span><br><span class="line"><span class="type">bool</span> v[MAX_N];</span><br><span class="line"><span class="comment">// pair&lt;-dist[x], x&gt;</span></span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一条从x到y长度z的有向边</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    ver[tot] = y;</span><br><span class="line">    edge[tot] = z;</span><br><span class="line">    nxt[tot] = head[x]; <span class="comment">// 在head[x]这条链的开头插入新点</span></span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        <span class="built_in">add</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x7f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">top</span>().second;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (v[x]) <span class="keyword">continue</span>;</span><br><span class="line">        v[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="type">int</span> y = ver[i], z = edge[i];</span><br><span class="line">            <span class="keyword">if</span> (d[y] &gt; d[x] + z) &#123;</span><br><span class="line">                d[y] = d[x] + z;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-d[y], y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d[n] == <span class="number">0x7f7f7f7f</span>) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; d[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bellman-ford">Bellman-Ford</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_N = <span class="number">150005</span>, MAX_M = <span class="number">150005</span>;</span><br><span class="line"><span class="type">int</span> head[MAX_N], ver[MAX_M], edge[MAX_M], nxt[MAX_M], tot;</span><br><span class="line"><span class="type">int</span> n, m, d[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一条从x到y长度z的有向边</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    ver[tot] = y;</span><br><span class="line">    edge[tot] = z;</span><br><span class="line">    nxt[tot] = head[x]; <span class="comment">// 在head[x]这条链的开头插入新点</span></span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        <span class="built_in">add</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x7f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">1</span>; cnt &lt;= n - <span class="number">1</span>; cnt++) &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">                <span class="type">int</span> y = ver[i], z = edge[i];</span><br><span class="line">                <span class="keyword">if</span> (d[y] &gt; d[x] + z) &#123;</span><br><span class="line">                    d[y] = d[x] + z;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d[n] == <span class="number">0x7f7f7f7f</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; d[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spfa">SPFA</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_N = <span class="number">150005</span>, MAX_M = <span class="number">150005</span>;</span><br><span class="line"><span class="type">int</span> head[MAX_N], ver[MAX_M], edge[MAX_M], nxt[MAX_M], tot;</span><br><span class="line"><span class="type">int</span> n, m, d[MAX_N];</span><br><span class="line"><span class="type">bool</span> v[MAX_N]; <span class="comment">// 点是否在队列中</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一条从x到y长度z的有向边</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    ver[tot] = y;</span><br><span class="line">    edge[tot] = z;</span><br><span class="line">    nxt[tot] = head[x]; <span class="comment">// 在head[x]这条链的开头插入新点</span></span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        <span class="built_in">add</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x7f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>); v[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>(); v[x] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="type">int</span> y = ver[i], z = edge[i];</span><br><span class="line">            <span class="keyword">if</span> (d[y] &gt; d[x] + z) &#123;</span><br><span class="line">                d[y] = d[x] + z;</span><br><span class="line">                <span class="keyword">if</span> (!v[y]) &#123; q.<span class="built_in">push</span>(y); v[y] = <span class="literal">true</span>; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d[n] == <span class="number">0x7f7f7f7f</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; d[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-386. 社交网络</title>
    <url>/2024/04/28/acwing-386-%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>最短路</li>
<li>Floyd的路径</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e2</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll d[maxn][maxn], c[maxn][maxn];</span><br><span class="line"><span class="type">double</span> ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> u, v, w, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    c[u][v] = c[v][u] = <span class="number">1</span>, d[u][v] = d[v][u] = w;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        <span class="keyword">if</span> (i != j &amp;&amp; i != k &amp;&amp; j != k) &#123;</span><br><span class="line">          <span class="keyword">if</span> (d[i][j] &gt; d[i][k] + d[k][j]) &#123;</span><br><span class="line">            c[i][j] = c[i][k] * c[k][j];</span><br><span class="line">            d[i][j] = d[i][k] + d[k][j];</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d[i][j] == d[i][k] + d[k][j]) &#123;</span><br><span class="line">            c[i][j] += c[i][k] * c[k][j];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        <span class="keyword">if</span> (i != j &amp;&amp; i != k &amp;&amp; j != k &amp;&amp; d[i][j] == d[i][k] + d[k][j])</span><br><span class="line">          ans[k] += (<span class="type">double</span>)c[i][k] * c[k][j] / c[i][j];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>, ans[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>注意审题，本题中<code>i, j, k</code>即两端点和中间点都不能相同！</p>
<p>所以没有<code>d[i][i] = 0, c[i][i] = 1</code>的常规初始化，且所有的最短路更新和次数记录也必须都在<code>i != j &amp;&amp; i != k &amp;&amp; j != k</code>的条件下进行！</p>
<p>点<code>k</code>是否经过<code>(i, j)</code>的最短路，判断<code>d[i][j] == d[i][k] + d[k][j]</code>即可</p>
<p>如图所示，假设<code>k</code>是<code>(i, j)</code>的中间点，<code>k0</code>是<code>(i, k)</code>的中间点，那么有：</p>
<ul>
<li><code>d[i][j] = d[i][k] + d[k][j]</code>，而<code>d[i][k] = d[i][k0] + d[k0][k]</code></li>
<li>后式代入前式，显然有<code>d[i][j] = d[i][k0] + d[k0][k] + d[k][j] = d[i][k0] + d[k0][j]</code></li>
</ul>
<img src="/2024/04/28/acwing-386-%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C/1.png" class="" title="image-20240428175105771">
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-346. 走廊泼水节</title>
    <url>/2024/04/29/acwing-346-%E8%B5%B0%E5%BB%8A%E6%B3%BC%E6%B0%B4%E8%8A%82/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>最小生成树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">6e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, fa[maxn], s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y_, z_;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node &amp;a) &#123; <span class="keyword">return</span> z_ &lt; a.z_; &#125;</span><br><span class="line">&#125; e[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sort</span>(e + <span class="number">1</span>, e + n);</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">find</span>(e[i].x_), y = <span class="built_in">find</span>(e[i].y_);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">continue</span>;</span><br><span class="line">    ans += ((ll)s[x] * s[y] - <span class="number">1</span>) * (e[i].z_ + <span class="number">1</span>);</span><br><span class="line">    fa[y] = x;</span><br><span class="line">    s[x] += s[y];</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t, x, y, z;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i, s[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">      e[i] = &#123;x, y, z&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">kruskal</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>完全图代表节点两两都有边。</p>
<p>把这<code>n - 1</code>条边按照权值从小到大排序，依次扫描每个边，执行一个类似Kruskal的算法。</p>
<p>随后考察的是对Kruskal的流程掌握：</p>
<ol type="1">
<li>初始时，每个点都是一个只有它自己的集合</li>
<li>寻找所有集合彼此之间（<strong>集合内部忽略</strong>）边权最小的边，将这条最小边的两端点所在集合合并，成为一个新集合</li>
<li>重复2</li>
</ol>
<p>如图所示，Sx和Sy两个集合内部已经是完全图，且内部所有边权必大于<code>DE</code>。</p>
<p>现根据<code>DE</code>边进行合并，<code>DE</code>边权为<code>z</code>。</p>
<p>以点<code>C</code>为例子，显然需要新增的<code>CF</code>、<code>CE</code>、<code>CG</code>三条边的边权最小为<code>z + 1</code>；</p>
<p>如果为<code>z</code>甚至更小，那么<code>DE</code>边就不是两集合合并的唯一可选项，这与唯一性矛盾。</p>
<p>根据乘法原理，两集合合并需要新增的边数为<span
class="math inline">\(\left| S_x \right|\times \left| S_y
\right|-1\)</span>，去掉了<code>DE</code>边；新增边权均为<code>z + 1</code></p>
<p>得到最小边权总和<span class="math inline">\(\left( z+1 \right) \times
\left( \left| S_x \right|\times \left| S_y \right|-1
\right)\)</span></p>
<img src="/2024/04/29/acwing-346-%E8%B5%B0%E5%BB%8A%E6%B3%BC%E6%B0%B4%E8%8A%82/1.png" class="" title="image-20240429203443713">
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-348. 沙漠之王</title>
    <url>/2024/05/09/acwing-348-%E6%B2%99%E6%BC%A0%E4%B9%8B%E7%8E%8B/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>最小生成树</li>
<li>01分数规划</li>
<li>二分</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">50</span>, inf = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="comment">// a代表成本，b代表长度</span></span><br><span class="line"><span class="type">double</span> a[maxn][maxn], b[maxn][maxn];</span><br><span class="line"><span class="type">double</span> c[maxn][maxn], d[maxn];</span><br><span class="line"><span class="type">bool</span> v[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y_, z_;</span><br><span class="line">&#125; p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((p[i].x_ - p[j].x_) * (p[i].x_ - p[j].x_) +</span><br><span class="line">              (p[i].y_ - p[j].y_) * (p[i].y_ - p[j].y_));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> mid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; ++j)</span><br><span class="line">      <span class="keyword">if</span> (i == j)</span><br><span class="line">        c[i][j] = inf;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        c[i][j] = c[j][i] = a[i][j] - mid * b[i][j];</span><br><span class="line">  <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) d[i] = inf;</span><br><span class="line">  d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="keyword">if</span> (!v[i] &amp;&amp; (!x || d[x] &gt; d[i])) x = i;</span><br><span class="line">    v[x] = <span class="number">1</span>;</span><br><span class="line">    ans += d[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt;= n; ++y)</span><br><span class="line">      <span class="keyword">if</span> (!v[y] &amp;&amp; d[y] &gt; c[x][y]) d[y] = c[x][y];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x, y, z, i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    p[i].x_ = x, p[i].y_ = y, p[i].z_ = z;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">double</span> mx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">      a[i][j] = a[j][i] = <span class="built_in">abs</span>(p[i].z_ - p[j].z_);</span><br><span class="line">      b[i][j] = b[j][i] = <span class="built_in">f</span>(i, j);</span><br><span class="line">      mx += a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="type">double</span> l = <span class="number">0</span>, r = mx;</span><br><span class="line">  <span class="keyword">while</span> (r - l &gt; eps) &#123;</span><br><span class="line">    <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">      l = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      r = mid;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>, l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) <span class="built_in">work</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>01分数规划的模板题。</p>
<p>题意是说有<code>n</code>个点，每个点有<code>(x, y, z)</code>三个属性，<code>(x, y)</code>代表该点坐标，<code>z</code>代表该点高度，</p>
<p>两点<code>i</code>和<code>j</code>之间的欧氏距离保存到<code>b[i][j]</code>，开销等于<code>abs(zi - zj)</code>保存到<code>a[i][j]</code>，点间两两都存在无向边。</p>
<p>设第<code>i</code>条边的开销等于<code>ai</code>，距离等于<code>bi</code>，选任意<code>n - 1</code>条边作为生成树，找出下列式子的最小值：
<span class="math display">\[
\frac{\sum_{i=1}^n{a_i\cdot x_i}}{\sum_{i=1}^n{b_i\cdot
x_i}}\text{，其中}x_i\in \left\{ 0,1 \right\}
\]</span> 使用实数二分进行求解。</p>
<p>假设当前有<code>mid</code>小于等于答案<code>ans</code>，由于答案是式子的最小值，你比最小值都小，那么对于任意<code>x</code>都有下式成立：
<span class="math display">\[
mid\leqslant ans=\frac{\sum{\begin{array}{c}
    n\\
    i=1\\
\end{array}a_ix_i}}{\sum{\begin{array}{c}
    n\\
    i=1\\
\end{array}b_ix_i}}\Longrightarrow \sum{\begin{array}{c}
    n\\
    i=1\\
\end{array}x_i\cdot \left( mid\cdot b_i-a_i \right)}\leqslant
0\text{，对任意}x\text{成立}
\]</span>
如果<code>mid</code>大于答案<code>ans</code>，<code>ans</code>只是最小值，只大于最小值并不能说明式子其他解的情况，只能说存在<code>x</code>有下式成立：
<span class="math display">\[
mid&gt;ans=\frac{\sum{\begin{array}{c}
    n\\
    i=1\\
\end{array}a_ix_i}}{\sum{\begin{array}{c}
    n\\
    i=1\\
\end{array}b_ix_i}}\Longrightarrow \sum{\begin{array}{c}
    n\\
    i=1\\
\end{array}x_i\cdot \left( mid\cdot b_i-a_i
\right)}&gt;0\text{，存在}x\text{成立}
\]</span> 把上面式子的正负号修改后，整理如下： <span
class="math display">\[
\begin{cases}
    mid\leqslant ans\text{时，有}\sum{\begin{array}{c}
    n\\
    i=1\\
\end{array}x_i\cdot \left( a_i-mid\cdot b_i \right)}\geqslant
0\text{，任意}x\text{成立}\\
    mid&gt;ans\text{时，有}\sum{\begin{array}{c}
    n\\
    i=1\\
\end{array}x_i\cdot \left( a_i-mid\cdot b_i
\right)}&lt;0\text{，存在}x\text{成立}\\
\end{cases}
\]</span>
对上述不等式左侧求最小值<code>min</code>即可，也就是最小生成树：</p>
<ol type="1">
<li><code>min &gt;= 0</code>，说明<code>mid &lt;= ans</code>，<code>mid</code>不够大，那么<code>mid</code>向右边界移动</li>
<li><code>min &lt; 0</code>，说明<code>mid &gt; ans</code>，<code>mid</code>大于答案，那么<code>mid</code>向左边界移动</li>
<li>最后返回左边界<code>l</code>，因为求的是符合条件中的更小值</li>
</ol>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>最小生成树</tag>
        <tag>01分数规划</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-387. 北极网络</title>
    <url>/2024/08/12/acwing-387-%E5%8C%97%E6%9E%81%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>最小生成树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e2</span> + <span class="number">50</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, s;</span><br><span class="line"><span class="type">int</span> d[maxn], a[maxn][maxn];</span><br><span class="line"><span class="type">bool</span> v[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line">&#125; p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x1 = p[i].x, x2 = p[j].x, y1 = p[i].y, y2 = p[j].y;</span><br><span class="line">  <span class="keyword">return</span> (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; s &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x, y, i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    p[i].x = x, p[i].y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">      <span class="keyword">if</span> (i == j)</span><br><span class="line">        a[i][j] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        a[i][j] = a[i][j] = <span class="built_in">f</span>(i, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v)), <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="keyword">if</span> (!v[i] &amp;&amp; (!x || d[x] &gt; d[i])) x = i;</span><br><span class="line">    v[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt;= n; ++y)</span><br><span class="line">      <span class="keyword">if</span> (!v[y] &amp;&amp; d[y] &gt; a[x][y]) &#123;</span><br><span class="line">        d[y] = a[x][y];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(d + <span class="number">1</span>, d + <span class="number">1</span> + n);</span><br><span class="line">  cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; <span class="built_in">sqrt</span>(d[n - s + <span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) <span class="built_in">init</span>(), <span class="built_in">prim</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>最小生成树的裸题。</p>
<p>题目要让前哨站连通，先用<code>prim</code>求出最小生成树，再对最小生成树排序；</p>
<p>卫星能免<code>s - 1</code>条边，那么答案就是<code>sqrt(d[n - s + 1])</code></p>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-349. 黑暗城堡</title>
    <url>/2024/05/06/acwing-349-%E9%BB%91%E6%9A%97%E5%9F%8E%E5%A0%A1/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>最短路径生成树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">const</span> ll mod = (<span class="number">1ll</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>;</span><br><span class="line">ll ans = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n, m, d[maxn], a[maxn][maxn];</span><br><span class="line"><span class="type">bool</span> v[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵的暴力Dijkstra</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="keyword">if</span> (!v[i] &amp;&amp; (x == <span class="number">0</span> || d[x] &gt; d[i])) x = i;</span><br><span class="line">    v[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt;= n; ++y) d[y] = <span class="built_in">min</span>(d[y], a[x][y] + d[x]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">  v[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="keyword">if</span> (!v[i] &amp;&amp; (x == <span class="number">0</span> || d[x] &gt; d[i])) x = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt;= n; ++y)</span><br><span class="line">      <span class="keyword">if</span> (v[y] &amp;&amp; d[x] == d[y] + a[x][y]) ++cnt;</span><br><span class="line">    v[x] = <span class="number">1</span>;</span><br><span class="line">    ans = (ans * cnt) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">memset</span>(a, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x, y, z, i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    a[x][y] = a[y][x] = <span class="built_in">min</span>(a[x][y], z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dijkstra</span>(), <span class="built_in">prim</span>();</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>最短路径生成树的模板题。</p>
<p>先用Dijkstra算法求出1号房间到每个房间<code>x</code>的单源最短路，保存到<code>dist[x]</code>。</p>
<p>把树形城堡看作以1为根的有根树后，</p>
<p>若<code>x</code>是<code>y</code>的父节点，<code>x，y</code>之间的通道长度为<code>z</code>，则应该有：<code>dist[y] = dist[x] + z</code>。</p>
<p>这种树结构称为图的一颗<strong>最短路径生成树</strong>。</p>
<p>所以结合Dijkstra和Prim算法，</p>
<ol type="1">
<li><p>从未被使用过的点中，取<code>dist</code>值最小的点<code>p</code></p></li>
<li><p>点<code>p</code>与所有已被使用过的点<code>x</code>判断是否有<code>d[p] == d[x] + edge(x, p)</code>，有则<code>++cnt</code></p>
<p>该操作是计算点<code>p</code>有多少条最短路径边</p></li>
<li><p>用<code>cnt</code>更新答案后，点<code>p</code>标记为已被使用</p></li>
</ol>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>最小生成树</tag>
        <tag>最短路径生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-347. 野餐规划</title>
    <url>/2024/05/05/acwing-347-%E9%87%8E%E9%A4%90%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>最小生成树</li>
<li>flood-fill找连通块</li>
<li>树形DP</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<p>给定一张<code>N</code>个点<code>M</code>条边的无向图，求出无向图的一颗最小生成树，满足1号节点（公园）的度数不超过给定的整数<code>S</code></p>
<h2 id="删边">删边</h2>
<p>最容易想到的办法就是模拟题意进行删边，由于题目没说无解的情况，那么1号节点的入度<code>deg</code>一定大于等于<code>s</code></p>
<ol type="1">
<li><p>原图保存至邻接矩阵<code>a</code>，用<code>prim</code>算法求出最小生成树并保存至邻接矩阵<code>tree</code></p></li>
<li><p>枚举<code>tree</code>中1号节点的所有出边，从中删除<strong>某一条</strong><code>(1, i)</code>的同时，还需要从<code>a</code>中选一条新边加进<code>tree</code>以保证最小生成树的结构。</p>
<p>设<code>min_val = min_edge - tree[1][i]</code>，<code>min_edge</code>是新增的边权，<code>tree[1][i]</code>是删除的边权，<code>min_val</code>称为<code>增加程度</code>，显然<code>min_val</code>尽可能小，那么新的最小生成树总权值就会尽可能小。</p>
<p>对比删不同边的<code>min_val</code>，取最小值。</p></li>
<li><p><code>tree</code>删除边<code>(1, i)</code>后，整个生成树会变成两个连通块，<code>v[1]</code>和<code>v[0]</code>两种，假设删除边的另一点<code>i</code>所在连通块设为<code>v[1]</code>，那么1号节点（公园）也要放入<code>v[1]</code>。</p></li>
<li><p>遍历<code>v[1]</code>连通块的所有点（除了1号节点），是否与<code>v[0]</code>某个点有边，类似的边求权值最小即可得到<code>min_edge</code>。</p></li>
<li><p>回到2继续循环，直到出度<code>deg</code>不超过<code>s</code></p></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">35</span>;</span><br><span class="line"><span class="type">int</span> n, m, s, deg, ans, a[maxn][maxn], d[maxn];</span><br><span class="line"><span class="type">bool</span> v[maxn];</span><br><span class="line"><span class="comment">// tree：最小生成树的邻接矩阵</span></span><br><span class="line"><span class="comment">// conn[i]记录最小生成树的一条边(i, conn[i]），权值为d[i]</span></span><br><span class="line"><span class="type">int</span> tree[maxn][maxn], conn[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  unordered_map&lt;string, <span class="type">int</span>&gt; h;</span><br><span class="line">  <span class="built_in">memset</span>(a, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">  cin &gt;&gt; m;</span><br><span class="line">  h[<span class="string">&quot;Park&quot;</span>] = <span class="number">1</span>, n = <span class="number">1</span>;</span><br><span class="line">  string x, y;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> z, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    <span class="keyword">if</span> (!h.<span class="built_in">count</span>(x)) h[x] = ++n;</span><br><span class="line">    <span class="keyword">if</span> (!h.<span class="built_in">count</span>(y)) h[y] = ++n;</span><br><span class="line">    a[h[x]][h[y]] = a[h[y]][h[x]] = <span class="built_in">min</span>(a[h[x]][h[y]], z);</span><br><span class="line">  &#125;</span><br><span class="line">  cin &gt;&gt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d)), <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">  d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">      <span class="keyword">if</span> (!v[j] &amp;&amp; (x == <span class="number">0</span> || d[x] &gt; d[j])) x = j;</span><br><span class="line">    v[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt;= n; ++y)</span><br><span class="line">      <span class="keyword">if</span> (!v[y] &amp;&amp; d[y] &gt; a[x][y]) &#123;</span><br><span class="line">        d[y] = a[x][y], conn[y] = x;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(tree, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(tree));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    ans += d[i];</span><br><span class="line">    <span class="keyword">if</span> (conn[i] == <span class="number">1</span>) ++deg;</span><br><span class="line">    tree[conn[i]][i] = tree[i][conn[i]] = d[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  v[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">2</span>; y &lt;= n; ++y)</span><br><span class="line">    <span class="keyword">if</span> (!v[y] &amp;&amp; tree[x][y] != <span class="number">0x3f3f3f3f</span>) <span class="built_in">dfs</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 能连接两个连通块的最小边</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_min</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> min_edge = <span class="number">0x3f3f3f3f</span>, mix, miy;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!v[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (v[j]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (a[i][j] != <span class="number">0x3f3f3f3f</span> &amp;&amp; a[i][j] &lt; min_edge) &#123;</span><br><span class="line">        min_edge = a[i][j];</span><br><span class="line">        x = i, y = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> min_edge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 减少的程度</span></span><br><span class="line">  <span class="type">int</span> min_val = <span class="number">0x3f3f3f3f</span>, mix, miy, mii;</span><br><span class="line">  <span class="comment">// 枚举最小生成树中1的所有出边</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[<span class="number">1</span>][i] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 删除当前出边，最小生成树变成两个连通块，v[0]和v[1]两种</span></span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">    <span class="comment">// 假设删除边的另一点所在连通块设为v[1]，那么公园要提前放入v[1]</span></span><br><span class="line">    <span class="comment">// 后续在两连通块之间寻找最小边时，可以避免v[1]连通块与公园相连</span></span><br><span class="line">    v[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> min_edge = <span class="built_in">find_min</span>(x, y);</span><br><span class="line">    <span class="keyword">if</span> (min_edge != <span class="number">0x3f3f3f3f</span> &amp;&amp; min_edge - tree[<span class="number">1</span>][i] &lt; min_val) &#123;</span><br><span class="line">      min_val = min_edge - tree[<span class="number">1</span>][i];</span><br><span class="line">      mix = x, miy = y, mii = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ans += min_val;</span><br><span class="line">  tree[<span class="number">1</span>][mii] = tree[mii][<span class="number">1</span>] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">  tree[mix][miy] = tree[miy][mix] = a[miy][mix];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">read</span>();</span><br><span class="line">  <span class="built_in">prim</span>();</span><br><span class="line">  <span class="keyword">while</span> (deg &gt; s) &#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    --deg;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Total miles driven: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="加边">加边</h2>
<p>首先，去掉1号节点之后，无向图可能会分成若干个连通块。可以用深度优先遍历划分出图中的每个连通块，设连通块共有<code>T</code>个，若<code>T &gt; S</code>，此题无解，因为每个连通块至少与1号节点有一条连边。</p>
<p>对于每个连通块，在这个连通块内部求出它的最小生成树，然后从连通块中选出一个节点<code>p</code>与1号节点相连，其中无向边<code>(1, p)</code>的权值尽量小。</p>
<p>此时已经得到了原无向图的一颗生成树，1号节点的度数为<code>T</code>，还有<code>S - T</code>个与1号节点的连边机会可以用于优化：</p>
<p>假设当前某连通块内的最小生成树有<code>xu</code>、<code>uv</code>两条边，连通块与1号节点的连边为<code>1v</code>，还有一条连边<code>1x</code>不选是因为权值比<code>1v</code>大。</p>
<p>找到点<code>x</code>到点<code>1</code>的所有最小生成树路径中，权值最大的边，即<code>uv</code>，而<code>uv</code>的权值是远大于<code>1x</code>的。</p>
<p>故而可以把<code>uv</code>去除，转而去连接<code>1x</code>，连通块内部的最小生成树就一拆为二，整体的最小生成树权值和也降低了。</p>
<p>每次遍历所有点，选择降低程度最大的那个即可，直到不能再优化或者机会用完。</p>
<p><img src="/2024/05/05/acwing-347-%E9%87%8E%E9%A4%90%E8%A7%84%E5%88%92/1.png" class="" title="image-20240505172220997"></p>
<p>可以使用树形DP提前打表，在生成树上求出每个点<code>x</code>到1号节点路径上权值最大的边<code>(u, v)</code>。</p>
<p>然而，如上图所示，每次选择新接入一个边<code>(1, x)</code>时，<code>x</code>所在的生成树会被拆分，</p>
<p>一个<code>v</code>为根的子树和一个以<code>x</code>为根的子树，前者所在的DP值不变，而后者需要重新DP一次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">35</span>;</span><br><span class="line"><span class="type">int</span> n, m, s, deg, ans, p, a[maxn][maxn], d[maxn], ver[maxn];</span><br><span class="line"><span class="type">bool</span> v[maxn], c[maxn];</span><br><span class="line"><span class="comment">// tree：全图最小生成树</span></span><br><span class="line"><span class="comment">// conn[i]记录全图最小生成树的一条边(i, conn[i]），权值为d[i]</span></span><br><span class="line"><span class="type">int</span> tree[maxn][maxn], conn[maxn];</span><br><span class="line"><span class="comment">// (fx[i], fy[i])就是1~i路径上的最大边，边权是f[i]</span></span><br><span class="line"><span class="type">int</span> f[maxn], fx[maxn], fy[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; m;</span><br><span class="line">  map&lt;string, <span class="type">int</span>&gt; h;</span><br><span class="line">  h[<span class="string">&quot;Park&quot;</span>] = <span class="number">1</span>, n = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 原图的邻接矩阵</span></span><br><span class="line">  <span class="built_in">memset</span>(a, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">  string x, y;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> z, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    <span class="keyword">if</span> (!h.<span class="built_in">count</span>(x)) h[x] = ++n;</span><br><span class="line">    <span class="keyword">if</span> (!h.<span class="built_in">count</span>(y)) h[y] = ++n;</span><br><span class="line">    a[h[x]][h[y]] = a[h[y]][h[x]] = <span class="built_in">min</span>(a[h[x]][h[y]], z);</span><br><span class="line">  &#125;</span><br><span class="line">  cin &gt;&gt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  c[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 当前连通块有哪些点</span></span><br><span class="line">  ver[++p] = x;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt;= n; ++y) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c[y] || a[x][y] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 连通块内部找最小生成树</span></span><br><span class="line">  d[root] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= p; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!v[ver[j]] &amp;&amp; (x == <span class="number">0</span> || d[ver[j]] &lt; d[x])) x = ver[j];</span><br><span class="line">    &#125;</span><br><span class="line">    v[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= p; ++j) &#123;</span><br><span class="line">      <span class="type">int</span> y = ver[j];</span><br><span class="line">      <span class="keyword">if</span> (!v[y] &amp;&amp; d[y] &gt; a[x][y]) &#123;</span><br><span class="line">        d[y] = a[x][y], conn[y] = x;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 选一条连通块到1节点的最短边加入到最小生成树中</span></span><br><span class="line">  <span class="comment">// 顺带把当前最小生成树合并到全图最小生成树</span></span><br><span class="line">  <span class="type">int</span> closest = root;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> x = ver[i];</span><br><span class="line">    <span class="keyword">if</span> (x == root) <span class="keyword">continue</span>;</span><br><span class="line">    ans += d[x];</span><br><span class="line">    tree[x][conn[x]] = tree[conn[x]][x] = d[x];</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">1</span>][x] &lt; a[<span class="number">1</span>][closest]) closest = x;</span><br><span class="line">  &#125;</span><br><span class="line">  ++deg;</span><br><span class="line">  ans += a[<span class="number">1</span>][closest];</span><br><span class="line">  tree[<span class="number">1</span>][closest] = tree[closest][<span class="number">1</span>] = a[<span class="number">1</span>][closest];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim_for_all_comp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d)), <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">  <span class="built_in">memset</span>(tree, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(tree));</span><br><span class="line">  c[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!c[i]) &#123;</span><br><span class="line">      p = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 寻找连通块</span></span><br><span class="line">      <span class="built_in">dfs</span>(i);</span><br><span class="line">      <span class="comment">// 对当前连通块内部执行prim</span></span><br><span class="line">      <span class="built_in">prim</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树形dp打表，求x到1所有路径的最长边</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  v[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">2</span>; y &lt;= n; ++y) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!v[y] &amp;&amp; tree[x][y] != <span class="number">0x3f3f3f3f</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (f[x] &gt; tree[x][y]) &#123;</span><br><span class="line">        f[y] = f[x];</span><br><span class="line">        fx[y] = fx[x], fy[y] = fy[x];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        f[y] = tree[x][y];</span><br><span class="line">        fx[y] = x, fy[y] = y;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">dp</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 记录改变的最小程度值</span></span><br><span class="line">  <span class="type">int</span> min_val = <span class="number">1</span> &lt;&lt; <span class="number">30</span>, mini;</span><br><span class="line">  <span class="comment">// 枚举所有的非全图最小生成树边(1,i)，看加哪一条</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[<span class="number">1</span>][i] != <span class="number">0x3f3f3f3f</span> || a[<span class="number">1</span>][i] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 加入非树边(1, i)，删去树边(fx[i], fy[i])</span></span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">1</span>][i] - tree[fx[i]][fy[i]] &lt; min_val) &#123;</span><br><span class="line">      min_val = a[<span class="number">1</span>][i] - tree[fx[i]][fy[i]];</span><br><span class="line">      mini = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果反而大了，说明不需要优化</span></span><br><span class="line">  <span class="keyword">if</span> (min_val &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  ans += min_val;</span><br><span class="line">  tree[<span class="number">1</span>][mini] = tree[mini][<span class="number">1</span>] = a[<span class="number">1</span>][mini];</span><br><span class="line">  tree[fx[mini]][fy[mini]] = tree[fy[mini]][fx[mini]] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">  <span class="comment">// 树断开一边后变成两个子树，所以要重新计算mini为根的子树dp状态</span></span><br><span class="line">  f[mini] = a[<span class="number">1</span>][mini];</span><br><span class="line">  fx[mini] = <span class="number">1</span>, fy[mini] = mini;</span><br><span class="line">  <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">  v[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">dp</span>(mini);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">read</span>();</span><br><span class="line">  <span class="comment">// 删掉1号点，分出若干个连通块，各自内部求prim</span></span><br><span class="line">  <span class="built_in">prim_for_all_comp</span>();</span><br><span class="line">  <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">  <span class="built_in">dp</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (deg &lt; s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">solve</span>()) <span class="keyword">break</span>;</span><br><span class="line">    ++deg;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Total miles driven: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>最小生成树</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>atcoder-abc363_e</title>
    <url>/2024/07/22/atcoder-abc363-e/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>最短路</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">50</span>, maxm = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, p, ans, cnt[maxm], v[maxm], d[maxm], a[maxn][maxn];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> id = q.<span class="built_in">top</span>().second;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (v[id]) <span class="keyword">continue</span>;</span><br><span class="line">    v[id] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = id / m, y = id % m, i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">      <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[nx * m + ny] &gt; <span class="built_in">max</span>(d[x * m + y], a[nx][ny])) &#123;</span><br><span class="line">          d[nx * m + ny] = <span class="built_in">max</span>(d[x * m + y], a[nx][ny]);</span><br><span class="line">          q.<span class="built_in">push</span>(&#123;-d[nx * m + ny], nx * m + ny&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line">  ans = n * m;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">      cin &gt;&gt; a[i][j];</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">0</span> || i == n - <span class="number">1</span> || j == <span class="number">0</span> || j == m - <span class="number">1</span>) &#123;</span><br><span class="line">        d[i * m + j] = a[i][j];</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;-a[i][j], i * m + j&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dijkstra</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">      cnt[d[i * m + j]]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) &#123;</span><br><span class="line">    ans -= cnt[i];</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>网格图的广义最短路问题。把外面一圈的海洋，看作图的一个起点。</p>
<p>从起点走到任何一个格子，都有若干条路径；只有路径上的最大方格都被淹了，本格子才会被淹。</p>
<p>如图所示，第一条路径格子3被淹了才行；第二条路径格子10被淹了才行。</p>
<img src="/2024/07/22/atcoder-abc363-e/1.png" class="" title="image-20240722133344891">
<p>最短路模型中，每个方格枚举了起点走到本方格的路径长度，并保存所有路径长度中最短的。</p>
<p>本问题中，所谓的”<strong>路径长度</strong>“的定义，修改为<strong>”路径中的最大格子</strong>“；每个格子保存所有”<strong>路径中的最大格子</strong>“的<strong>最小值</strong>。</p>
<p>相对于原版dijkstra，要修改的代码只有这一行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">d[nx * m + ny] &gt; <span class="built_in">max</span>(d[x * m + y], a[nx][ny])</span><br></pre></td></tr></table></figure>
<p>因为还是保存最小值，依旧是大于号；修改定义即可。</p>
]]></content>
      <categories>
        <category>atcoder</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树_解题技巧</title>
    <url>/2024/08/12/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="模板">模板</h1>
<h2 id="kruskal">Kruskal</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e3</span> + <span class="number">50</span>, maxm = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, ans, cnt, fa[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y_, z_;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> z_ &lt; a.z_; &#125;</span><br><span class="line">&#125; e[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sort</span>(e + <span class="number">1</span>, e + <span class="number">1</span> + m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x, y, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    x = <span class="built_in">find</span>(e[i].x_), y = <span class="built_in">find</span>(e[i].y_);</span><br><span class="line">    <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">      ++cnt, ans += e[i].z_, fa[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x, y, z, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    e[i] = &#123;x, y, z&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">kruskal</span>();</span><br><span class="line">  <span class="comment">// 若连通，最小生成树只有n-1条边</span></span><br><span class="line">  <span class="keyword">if</span> (cnt == n - <span class="number">1</span>)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;orz&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prim">Prim</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e3</span> + <span class="number">50</span>, maxm = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, ans, cnt, a[maxn][maxn], d[maxn], v[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!v[j] &amp;&amp; (x == <span class="number">0</span> || d[j] &lt; d[x])) x = j;</span><br><span class="line">    &#125;</span><br><span class="line">    v[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt;= n; ++y) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!v[y] &amp;&amp; d[y] &gt; a[x][y]) &#123;</span><br><span class="line">        d[y] = a[x][y];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[i] == <span class="number">0x3f3f3f3f</span>) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;orz&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += d[i];</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">memset</span>(a, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(a)), <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x, y, z, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    a[x][y] = a[y][x] = <span class="built_in">min</span>(a[x][y], z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">prim</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="核心">核心</h1>
<p>以最小的代价，让集合内部连通</p>
<p>Kruskal更倾向以集合的方式建模，Prim则更方便地记录最小生成树</p>
<h1 id="练习题">练习题</h1>
<ul>
<li><a
href="https://www.acwing.com/problem/content/description/348/">acwing-346</a>
Kruskal的经典例题</li>
<li><a
href="https://www.acwing.com/problem/content/description/349/">acwing-347</a>
Prim例题，保存、修改生成树，flood-fill找连通块，树形DP</li>
<li><a
href="https://www.acwing.com/problem/content/description/351/">acwing-349</a>
最短路径生成树模板题</li>
<li><a
href="https://www.acwing.com/problem/content/description/350/">acwing-348</a>
01分数规划的模板题</li>
<li><a
href="https://www.acwing.com/problem/content/description/390/">acwing-388</a>
最小生成树 + 状态压缩DP</li>
<li><a
href="https://www.acwing.com/problem/content/description/389/">acwing-387</a>
最小生成树裸题</li>
</ul>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-388. 四叶草魔杖</title>
    <url>/2024/08/12/acwing-388-%E5%9B%9B%E5%8F%B6%E8%8D%89%E9%AD%94%E6%9D%96/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>最小生成树</li>
<li>状态压缩DP</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">16</span>, maxm = (<span class="number">1</span> &lt;&lt; <span class="number">16</span>), inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[maxn], s[maxm], d[maxm], fa[maxn], dp[maxm];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_, y_, z_;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;x) <span class="type">const</span> &#123; <span class="keyword">return</span> z_ &lt; x.z_; &#125;</span><br><span class="line">&#125; e[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">(<span class="type">int</span> state)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; i) &amp; state) fa[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x, y, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (((<span class="number">1</span> &lt;&lt; e[i].x_) &amp; state) &amp;&amp; ((<span class="number">1</span> &lt;&lt; e[i].y_) &amp; state)) &#123;</span><br><span class="line">      x = <span class="built_in">find</span>(e[i].x_), y = <span class="built_in">find</span>(e[i].y_);</span><br><span class="line">      <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">        ans += e[i].z_;</span><br><span class="line">        fa[x] = y;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最终所有人的祖先应该是一样的</span></span><br><span class="line">  <span class="type">int</span> ancestor = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; i) &amp; state) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ancestor == <span class="number">-1</span>) &#123;</span><br><span class="line">        ancestor = <span class="built_in">find</span>(i);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ancestor != <span class="built_in">find</span>(i)) &#123;</span><br><span class="line">        <span class="keyword">return</span> inf;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x, y, z, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    e[i].x_ = x, e[i].y_ = y, e[i].z_ = z;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 状态压缩，每一位代表每个点选还是不选，0不选1选</span></span><br><span class="line">  <span class="comment">// 每个状态由若干个连通块组成</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; j) &amp; i) s[i] += a[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对所有连通块求最小生成树</span></span><br><span class="line">  <span class="comment">// 每个大的连通块，当然有可能拆分成若干个内部的小连通块，它们的开销和可能更小</span></span><br><span class="line">  <span class="comment">// 但小连通块们及其组合的情况一定会被先算出来，</span></span><br><span class="line">  <span class="comment">// 所以每次只需要把当前的大连通块当做整体看就行</span></span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  <span class="built_in">sort</span>(e + <span class="number">1</span>, e + <span class="number">1</span> + m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i]) <span class="keyword">continue</span>;</span><br><span class="line">    d[i] = <span class="built_in">kruskal</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 一个点都没有当然没开销</span></span><br><span class="line">  <span class="built_in">memcpy</span>(dp, d, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k, j = i; j; j = (j - <span class="number">1</span>) &amp; i) &#123;</span><br><span class="line">      k = i ^ j;</span><br><span class="line">      <span class="keyword">if</span> ((j &amp; k) || s[j] || s[k]) <span class="keyword">continue</span>;</span><br><span class="line">      dp[i] = <span class="built_in">min</span>(dp[i], dp[j] + dp[k]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>] == inf)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题意，最终目的是要让所有宝石的能量值归零。</p>
<p>很容易想到以下步骤：</p>
<ol type="1">
<li><p>先找出所有总和等于0的选取情况。</p>
<p>因为最多只有16个宝石，可以使用状态压缩进行保存，0表示不取1表示取。</p>
<p>每个状态的总和保存在<code>s[state]</code>，比如<code>s[0110]</code>代表选取第2、第3个宝石的情况。</p></li>
<li><p>对上述每一种合法的选取状态求最小生成树。</p>
<p>当然，某些时候该状态并不是连通的，此时最小生成树返回<code>inf</code>即可。</p>
<p>每个状态的最小生成树保存至<code>d[state]</code></p></li>
<li><p>设<code>dp[state]</code>代表<code>state</code>选取情况下，让所选宝石的能量值都归0的最小开销。</p>
<p>初始状态<code>dp[state]</code>就等于<code>d[state]</code>，且<code>dp[0]=0</code>，没选任何宝石肯定没有任何开销。</p>
<p>那么<code>dp[i] = min(dp[i], dp[j] + dp[k])</code>，其中<code>j</code>和<code>k</code>互斥，且<code>j | k</code>等于<code>i</code>，相当于遍历<code>i</code>的所有子集组成。</p>
<p>互斥是因为选取方案不可能有相交，同一个点怎么可能出现两次呢？</p>
<p>最终答案就等于<code>dp[(1 &lt;&lt; n) - 1]</code></p></li>
</ol>
<p><code>dp</code>正常都有两种写法，本题的另一种写法就是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)</span><br><span class="line">  <span class="keyword">if</span> (!s[i])</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j++)</span><br><span class="line">      <span class="keyword">if</span> (!(i &amp; j) &amp;&amp; !s[j] &amp;&amp; !s[i | j]) dp[i | j] = <span class="built_in">min</span>(dp[i | j], dp[i] + dp[j]);</span><br></pre></td></tr></table></figure>
<p>但显然这样会超时，高达1亿的时间复杂度</p>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>状态压缩DP</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>CF19D Points</title>
    <url>/2024/09/15/CF19D-Points/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线段树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc p &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="type">int</span> n, dis[maxn];</span><br><span class="line"><span class="comment">// 线段树</span></span><br><span class="line"><span class="comment">// mx：区间最大值</span></span><br><span class="line"><span class="comment">// st：每个叶子节点保存的set，set保存相同x上的y</span></span><br><span class="line"><span class="type">int</span> mx[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line">set&lt;<span class="type">int</span>&gt; st[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line">  string op;</span><br><span class="line">&#125; req[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0：新增</span></span><br><span class="line"><span class="comment">// 1：删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> op, <span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r &amp;&amp; x == l) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!op)</span><br><span class="line">      st[p].<span class="built_in">emplace</span>(v);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      st[p].<span class="built_in">erase</span>(v);</span><br><span class="line">    mx[p] = st[p].<span class="built_in">empty</span>() ? <span class="number">0</span> : *(st[p].<span class="built_in">rbegin</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">update</span>(lc, l, mid, op, x, v);</span><br><span class="line">  <span class="keyword">if</span> (x &gt; mid) <span class="built_in">update</span>(rc, mid + <span class="number">1</span>, r, op, x, v);</span><br><span class="line">  mx[p] = <span class="built_in">max</span>(mx[lc], mx[rc]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分，大于v的最小x</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R &amp;&amp; l == r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mx[p] &gt; v) <span class="keyword">return</span> &#123;l, p&#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">-1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= mid &amp;&amp; mx[lc] &gt; v) ans = <span class="built_in">ask</span>(lc, l, mid, L, R, v);</span><br><span class="line">  <span class="keyword">if</span> (ans.first != <span class="number">-1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">  <span class="keyword">if</span> (R &gt; mid &amp;&amp; mx[rc] &gt; v) ans = <span class="built_in">ask</span>(rc, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> q;</span><br><span class="line">  cin &gt;&gt; q;</span><br><span class="line">  <span class="comment">// 离散化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; req[i].op &gt;&gt; req[i].x &gt;&gt; req[i].y;</span><br><span class="line">    dis[++n] = req[i].x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + n);</span><br><span class="line">  n = <span class="built_in">unique</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + n) - <span class="number">1</span> - dis;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + n, req[i].x) - dis;</span><br><span class="line">    <span class="keyword">if</span> (req[i].op[<span class="number">0</span>] == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">0</span>, x, req[i].y);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req[i].op[<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, x, req[i].y);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ans = <span class="built_in">ask</span>(<span class="number">1</span>, <span class="number">1</span>, n, x + <span class="number">1</span>, n, req[i].y);</span><br><span class="line">      <span class="keyword">if</span> (ans.first == <span class="number">-1</span>)</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; dis[ans.first] &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; *(st[ans.second].<span class="built_in">lower_bound</span>(req[i].y + <span class="number">1</span>)) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>线性复杂度肯定不行，那么<code>x</code>、<code>y</code>两轴的搜索必须都是<code>logn</code>复杂度，假设要找<code>(A, B)</code></p>
<p>将所有请求读入后，先对<code>x</code>轴进行离散化，得到<code>n</code>个排名。</p>
<p>对每个<code>x</code>开一个<code>set</code>，以保存该x轴上的<code>y</code>，不仅仅能得到<code>y</code>的极大值<code>mx</code>，</p>
<p>还可使用<code>lower_bound</code>函数以<code>logn</code>的复杂度，检索在同一x坐标的情况下，第一个大于等于<code>B + 1</code>的<code>y</code>。</p>
<p>取最大值是有单调不减的性质的，固定左端点时，右端点一直向右移动，区间内的极大值维持单调不减，</p>
<p>所以开一个线段树，把每个<code>x</code>作为叶子节点，叶子节点的值就设为<code>x</code>对应<code>set</code>的极大值<code>mx</code>，然后区间取极大值，</p>
<p>对线段树进行二分，在<code>[A + 1, n]</code>的<code>x</code>范围内，找到<code>y</code>大于<code>B</code>的最小<code>x</code>：</p>
<ol type="1">
<li>如果左孩子的<code>y</code>极大值大于<code>B</code>，向左孩子搜索（因为要找最小，肯定先走左孩子）</li>
<li>左孩子如果得到答案，就直接返回</li>
<li>否则向右孩子走</li>
</ol>
<p>二分后得到的<code>x</code>，就是满足<code>y</code>一定存在大于<code>B</code>条件的最小<code>x</code></p>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-353 雨天的尾巴</title>
    <url>/2024/09/19/353-%E9%9B%A8%E5%A4%A9%E7%9A%84%E5%B0%BE%E5%B7%B4/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>树上差分</li>
<li>线段树合并</li>
<li>LCA</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, d[maxn], f[maxn][<span class="number">18</span>];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="comment">// 离散化</span></span><br><span class="line"><span class="type">int</span> cnt, dis[maxn];</span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">int</span> x, y, z;</span><br><span class="line">&#125; req[maxn];</span><br><span class="line"><span class="type">int</span> tot, head[maxn], nxt[maxn * <span class="number">2</span>], ver[maxn * <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 线段树，保存区间最大值和最大值的位置</span></span><br><span class="line"><span class="type">int</span> num, rt[maxn];</span><br><span class="line"><span class="type">int</span> lc[maxn * <span class="number">4</span> * <span class="number">18</span>], rc[maxn * <span class="number">4</span> * <span class="number">18</span>], mx[maxn * <span class="number">4</span> * <span class="number">18</span>], pos[maxn * <span class="number">4</span> * <span class="number">18</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; ver[++tot] = y, nxt[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (d[x] &lt; d[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[f[x][i]] &gt;= d[y]) x = f[x][i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">1</span>), d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">      <span class="type">int</span> y = ver[i];</span><br><span class="line">      <span class="keyword">if</span> (d[y]) <span class="keyword">continue</span>;</span><br><span class="line">      q.<span class="built_in">push</span>(y);</span><br><span class="line">      d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">      f[y][<span class="number">0</span>] = x;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">17</span>; ++j) &#123;</span><br><span class="line">        f[y][j] = f[f[y][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  mx[p] = <span class="built_in">max</span>(mx[lc[p]], mx[rc[p]]);</span><br><span class="line">  pos[p] = mx[lc[p]] &gt;= mx[rc[p]] ? pos[lc[p]] : pos[rc[p]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p) p = ++cnt;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    mx[p] += v;</span><br><span class="line">    pos[p] = mx[p] ? x : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">    <span class="built_in">update</span>(lc[p], l, mid, x, v);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">update</span>(rc[p], mid + <span class="number">1</span>, r, x, v);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> p + q;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    mx[p] += mx[q];</span><br><span class="line">    pos[p] = mx[p] ? l : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  lc[p] = <span class="built_in">merge</span>(lc[p], lc[q], l, mid);</span><br><span class="line">  rc[p] = <span class="built_in">merge</span>(rc[p], rc[q], mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">    <span class="type">int</span> y = ver[i];</span><br><span class="line">    <span class="keyword">if</span> (d[x] &gt;= d[y]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(y);</span><br><span class="line">    rt[x] = <span class="built_in">merge</span>(rt[x], rt[y], <span class="number">1</span>, num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x, y, z;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">add</span>(x, y), <span class="built_in">add</span>(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="comment">// 每个节点新建一个子树</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rt[i] = ++cnt;</span><br><span class="line">  <span class="comment">// 离散化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">    req[i].x = x, req[i].y = y, req[i].z = z;</span><br><span class="line">    dis[++num] = z;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + num);</span><br><span class="line">  num = <span class="built_in">unique</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + num) - <span class="number">1</span> - dis;</span><br><span class="line">  <span class="comment">// 修改节点线段树</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x, y, z, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    x = req[i].x, y = req[i].y;</span><br><span class="line">    z = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + num, req[i].z) - dis;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">lca</span>(x, y);</span><br><span class="line">    <span class="built_in">update</span>(rt[x], <span class="number">1</span>, num, z, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">update</span>(rt[u], <span class="number">1</span>, num, z, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">update</span>(rt[y], <span class="number">1</span>, num, z, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (u != <span class="number">1</span>) <span class="built_in">update</span>(rt[f[u][<span class="number">0</span>]], <span class="number">1</span>, num, z, <span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子树合并</span></span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dis[pos[rt[i]]]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>先将所有请求离线保存后，对<code>z</code>进行离散化，得到<code>num</code>个排名。</p>
<p>那么树的每个节点都是一个长度为<code>num</code>的计数数组，记录不同物品的个数，</p>
<p>那么最坏情况下空间开销就是<code>n * m -&gt; 1e5 * 1e5 -&gt; 1e10</code>，时间复杂度也是如此，双炸。</p>
<p>考虑树上差分，每个节点的数组换成长度为<code>num</code>的差分数组，记录每个物品的变化量，整棵树求和一次就能得到最终的值；但数组每次合并还是需要<code>num</code>的时间复杂度，整棵树也是<code>n * num</code>量级的。</p>
<p>所以将每个节点开一颗权值线段树，叶子节点下标代表物品种类，值代表不同物品的变化量之和，</p>
<p>操作则是记录区间最大值至<code>mx</code>，记录最大值的下标至<code>pos</code>；</p>
<p>两个节点合并，那么也就是两颗权值线段树合并，叶子节点的值相加，就满足了子树求和这一操作；</p>
<p>加上线段树的区间最大值操作，很容易维护答案。</p>
<p>这里作图描述一下树上差分，假设有<code>(x, y, z)</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> u = <span class="built_in">lca</span>(x, y);</span><br><span class="line"><span class="built_in">update</span>(rt[x], <span class="number">1</span>, num, z, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">update</span>(rt[u], <span class="number">1</span>, num, z, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">update</span>(rt[y], <span class="number">1</span>, num, z, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (u != <span class="number">1</span>) <span class="built_in">update</span>(rt[f[u][<span class="number">0</span>]], <span class="number">1</span>, num, z, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<img src="/2024/09/19/353-%E9%9B%A8%E5%A4%A9%E7%9A%84%E5%B0%BE%E5%B7%B4/1.png" class="" title="image-20240919205730058">
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>LCA</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title>CF915E Physical Education Lessons</title>
    <url>/2024/09/09/CF915E-Physical-Education-Lessons/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线段树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">3e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, q, tot, root;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c：0的个数</span></span><br><span class="line"><span class="comment">// tag：0变0,1变1</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">int</span> lc, rc, c, tag = <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc(x) tr[x].lc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc(x) tr[x].rc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> c(x) tr[x].c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tag(x) tr[x].tag</span></span><br><span class="line">&#125; tr[<span class="number">50</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">lc</span>(p)) <span class="built_in">lc</span>(p) = ++tot;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">rc</span>(p)) <span class="built_in">rc</span>(p) = ++tot;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">tag</span>(p) == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">tag</span>(p) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">c</span>(<span class="built_in">lc</span>(p)) = mid - l + <span class="number">1</span>, <span class="built_in">c</span>(<span class="built_in">rc</span>(p)) = r - mid;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">c</span>(<span class="built_in">lc</span>(p)) = <span class="built_in">c</span>(<span class="built_in">rc</span>(p)) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">tag</span>(<span class="built_in">lc</span>(p)) = <span class="built_in">tag</span>(<span class="built_in">rc</span>(p)) = <span class="built_in">tag</span>(p);</span><br><span class="line">  <span class="built_in">tag</span>(p) = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> opt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="built_in">c</span>(p) = opt == <span class="number">0</span> ? r - l + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">tag</span>(p) = opt;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">down</span>(p, l, r);</span><br><span class="line">  <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= mid) <span class="built_in">update</span>(<span class="built_in">lc</span>(p), l, mid, L, R, opt);</span><br><span class="line">  <span class="keyword">if</span> (R &gt; mid) <span class="built_in">update</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r, L, R, opt);</span><br><span class="line">  <span class="built_in">c</span>(p) = <span class="built_in">c</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">c</span>(<span class="built_in">rc</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">  root = ++tot;</span><br><span class="line">  <span class="type">int</span> l, r, opt;</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;opt);</span><br><span class="line">    --opt;</span><br><span class="line">    <span class="built_in">update</span>(root, <span class="number">1</span>, n, l, r, opt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n - <span class="built_in">c</span>(root));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>动态开点线段树的裸题，见代码即可。</p>
<p>要注意的是，本题非常卡常，功能尽量浓缩在一起，不要拆分成不同函数。</p>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P1253 扶苏的问题</title>
    <url>/2024/09/01/P1253-%E6%89%B6%E8%8B%8F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线段树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// mx：最大值</span></span><br><span class="line"><span class="comment">// v：覆盖标签是否有效</span></span><br><span class="line"><span class="comment">// tag_add：新增标签</span></span><br><span class="line"><span class="comment">// tag_cover：覆盖标签</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">int</span> l, r, v;</span><br><span class="line">  ll mx, tag_add, tag_cover;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> v(x) tr[x].v</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mx(x) tr[x].mx</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tag_add(x) tr[x].tag_add</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tag_cover(x) tr[x].tag_cover</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc(x) x * 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc(x) x * 2 + 1</span></span><br><span class="line">&#125; tr[<span class="number">4</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; <span class="built_in">mx</span>(p) = <span class="built_in">max</span>(<span class="built_in">mx</span>(<span class="built_in">lc</span>(p)), <span class="built_in">mx</span>(<span class="built_in">rc</span>(p))); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    <span class="built_in">mx</span>(p) = a[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid), <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p, ll k)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 新增</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">v</span>(p)) &#123;</span><br><span class="line">    <span class="comment">// 如果之前有覆盖</span></span><br><span class="line">    <span class="built_in">mx</span>(p) += k, <span class="built_in">tag_add</span>(p) = <span class="number">0</span>, <span class="built_in">tag_cover</span>(p) += k;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果之前没覆盖</span></span><br><span class="line">    <span class="built_in">mx</span>(p) += k, <span class="built_in">tag_add</span>(p) += k;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cover</span><span class="params">(<span class="type">int</span> p, ll k)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">tag_add</span>(p) = <span class="number">0</span>, <span class="built_in">tag_cover</span>(p) = k, <span class="built_in">v</span>(p) = <span class="number">1</span>, <span class="built_in">mx</span>(p) = k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">v</span>(p)) &#123;</span><br><span class="line">    <span class="built_in">cover</span>(<span class="built_in">lc</span>(p), <span class="built_in">tag_cover</span>(p)), <span class="built_in">cover</span>(<span class="built_in">rc</span>(p), <span class="built_in">tag_cover</span>(p));</span><br><span class="line">    <span class="built_in">v</span>(p) = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">tag_add</span>(p)) &#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="built_in">lc</span>(p), <span class="built_in">tag_add</span>(p)), <span class="built_in">add</span>(<span class="built_in">rc</span>(p), <span class="built_in">tag_add</span>(p));</span><br><span class="line">    <span class="built_in">tag_add</span>(p) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, ll k, <span class="type">int</span> opt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= <span class="built_in">l</span>(p) &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) &#123;</span><br><span class="line">    opt == <span class="number">1</span> ? <span class="built_in">cover</span>(p, k) : <span class="built_in">add</span>(p, k);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">update</span>(<span class="built_in">lc</span>(p), l, r, k, opt);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) <span class="built_in">update</span>(<span class="built_in">rc</span>(p), l, r, k, opt);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= <span class="built_in">l</span>(p) &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) <span class="keyword">return</span> <span class="built_in">mx</span>(p);</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  ll ans = LLONG_MIN;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) ans = <span class="built_in">max</span>(ans, <span class="built_in">ask</span>(<span class="built_in">lc</span>(p), l, r));</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) ans = <span class="built_in">max</span>(ans, <span class="built_in">ask</span>(<span class="built_in">rc</span>(p), l, r));</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="type">int</span> opt, l, r, x;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;opt);</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;x);</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, l, r, x, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;x);</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, l, r, x, <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">ask</span>(<span class="number">1</span>, l, r));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>因为本身也可以用<code>0</code>去覆盖，所以需要额外新建一个变量<code>v</code>来表示当前覆盖标记<code>tag_cover</code>是否有效；</p>
<p>累加标记<code>tag_add</code>则可以用<code>0</code>和非<code>0</code>来代表是否有效。</p>
<p>多标记处理主要分以下几种情况，注意，不可能同时两种标记都有效，这样一来就不知道标记处理的先后顺序了。</p>
<ol type="1">
<li><p>覆盖操作</p>
<p>之前不管有覆盖标签还是新增标签，都给清除咯！</p>
<p>所以得到下述代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tag_add</span>(p) = <span class="number">0</span>, <span class="built_in">tag_cover</span>(p) = k, <span class="built_in">v</span>(p) = <span class="number">1</span>, <span class="built_in">mx</span>(p) = k;</span><br></pre></td></tr></table></figure></li>
<li><p>新增操作</p>
<ol type="1">
<li><p>之前有覆盖标签，即<code>v(p) == 1</code></p>
<p>直接把覆盖的数值新增即可，其余不变，很容易得到下述代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mx</span>(p) += k, <span class="built_in">tag_add</span>(p) = <span class="number">0</span>, <span class="built_in">tag_cover</span>(p) += k;</span><br></pre></td></tr></table></figure></li>
<li><p>之前有新增标签，即<code>tag_add(p)</code>不等于<code>0</code></p>
<p>所有的内容新增<code>k</code>即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mx</span>(p) += k, <span class="built_in">tag_add</span>(p) += k;</span><br></pre></td></tr></table></figure></li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P1438 无聊的数列</title>
    <url>/2024/08/31/P1438-%E6%97%A0%E8%81%8A%E7%9A%84%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线段树</li>
<li>差分</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  ll s, tag;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> s(x) tr[x].s</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tag(x) tr[x].tag</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc(x) x * 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc(x) x * 2 + 1</span></span><br><span class="line">&#125; tr[<span class="number">4</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid), <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; <span class="built_in">s</span>(p) = <span class="built_in">s</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">s</span>(<span class="built_in">rc</span>(p)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">tag</span>(p)) &#123;</span><br><span class="line">    <span class="built_in">s</span>(<span class="built_in">lc</span>(p)) += <span class="built_in">tag</span>(p) * (<span class="built_in">r</span>(<span class="built_in">lc</span>(p)) - <span class="built_in">l</span>(<span class="built_in">lc</span>(p)) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">s</span>(<span class="built_in">rc</span>(p)) += <span class="built_in">tag</span>(p) * (<span class="built_in">r</span>(<span class="built_in">rc</span>(p)) - <span class="built_in">l</span>(<span class="built_in">rc</span>(p)) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">tag</span>(<span class="built_in">lc</span>(p)) += <span class="built_in">tag</span>(p), <span class="built_in">tag</span>(<span class="built_in">rc</span>(p)) += <span class="built_in">tag</span>(p);</span><br><span class="line">    <span class="built_in">tag</span>(p) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) &#123;</span><br><span class="line">    <span class="built_in">s</span>(p) += k * (<span class="built_in">r</span>(p) - <span class="built_in">l</span>(p) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">tag</span>(p) += k;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">add</span>(<span class="built_in">lc</span>(p), l, r, k);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) <span class="built_in">add</span>(<span class="built_in">rc</span>(p), l, r, k);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) <span class="keyword">return</span> <span class="built_in">s</span>(p);</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) ans += <span class="built_in">ask</span>(<span class="built_in">lc</span>(p), l, r);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) ans += <span class="built_in">ask</span>(<span class="built_in">rc</span>(p), l, r);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="type">int</span> opt, x, y, k, d;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;opt);</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;k, &amp;d);</span><br><span class="line">      <span class="built_in">add</span>(<span class="number">1</span>, x, x, k);</span><br><span class="line">      <span class="keyword">if</span> (x &lt; y) <span class="built_in">add</span>(<span class="number">1</span>, x + <span class="number">1</span>, y, d);</span><br><span class="line">      <span class="keyword">if</span> (y &lt; n) <span class="built_in">add</span>(<span class="number">1</span>, y + <span class="number">1</span>, y + <span class="number">1</span>, -(k + (y - x) * d));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (ll)a[x] + <span class="built_in">ask</span>(<span class="number">1</span>, <span class="number">1</span>, x));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>线段树要求变化量可以均分，而等差数列的变化值恰好可以均分，也就是差分数组。</p>
<p>假设有数组<code>&#123;1, 2, 3, 4, 5, 6&#125;</code>，要在第<code>2 - 4</code>的位置加上等差数列<code>&#123;1, 3, 5&#125;</code>，第<code>4 - 5</code>的位置加上等差数列<code>&#123;2, 4&#125;</code></p>
<p>新增一个数组<code>a</code>，记录每个位置变化量的差分，初始时<code>&#123;0, 0, 0, 0, 0, 0&#125;</code></p>
<p>第一个等差数列<code>&#123;1, 3, 5&#125;</code>，差分变成<code>&#123;1, 2, 2, -5&#125;</code>，加到<code>a</code>上，变成<code>&#123;0, 1, 2, 2, -5, 0&#125;</code></p>
<p>其中<code>-5</code>是为了求差分数组前缀和时，抵消对第<code>5</code>、<code>6</code>位置的影响</p>
<p>同理，第二个等差数列<code>&#123;2, 4&#125;</code>，差分变成<code>&#123;2, 2, -4&#125;</code>，加到<code>a</code>上，变成<code>&#123;0, 1, 2, 4, -3, -4&#125;</code></p>
<p>对<code>a</code>求前缀和，得到每个位置的变化量数组<code>b</code>，<code>&#123;0, 1, 3, 7, 4, 0&#125;</code></p>
<hr />
<p>综上，对数组<code>a</code>开线段树即可，每次修改执行三次操作</p>
<ol type="1">
<li><code>l</code>加<code>k</code></li>
<li><code>l+1 ~ r</code>加<code>d</code></li>
<li><code>r + 1</code>加<code>-(k + (y - x) * d)</code></li>
</ol>
<p>每次对<code>1 ~ x</code>求前缀和，就能得到第<code>x</code>位置的变化量</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>P1471 方差</title>
    <url>/2024/09/03/P1471-%E6%96%B9%E5%B7%AE/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线段树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">double</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// s1：普通和</span></span><br><span class="line"><span class="comment">// s2: 平方和</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  <span class="type">double</span> s1, s2, tag;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> s1(x) tr[x].s1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> s2(x) tr[x].s2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tag(x) tr[x].tag</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc(x) x * 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc(x) x * 2 + 1</span></span><br><span class="line">&#125; tr[<span class="number">4</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">s1</span>(p) = <span class="built_in">s1</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">s1</span>(<span class="built_in">rc</span>(p));</span><br><span class="line">  <span class="built_in">s2</span>(p) = <span class="built_in">s2</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">s2</span>(<span class="built_in">rc</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    <span class="built_in">s1</span>(p) = a[l], <span class="built_in">s2</span>(p) = a[l] * a[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid), <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p, <span class="type">double</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">s2</span>(p) += (<span class="built_in">r</span>(p) - <span class="built_in">l</span>(p) + <span class="number">1</span>) * v * v + <span class="number">2</span> * v * <span class="built_in">s1</span>(p);</span><br><span class="line">  <span class="built_in">s1</span>(p) += (<span class="built_in">r</span>(p) - <span class="built_in">l</span>(p) + <span class="number">1</span>) * v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">tag</span>(p)) &#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="built_in">lc</span>(p), <span class="built_in">tag</span>(p)), <span class="built_in">add</span>(<span class="built_in">rc</span>(p), <span class="built_in">tag</span>(p));</span><br><span class="line">    <span class="built_in">tag</span>(<span class="built_in">lc</span>(p)) += <span class="built_in">tag</span>(p), <span class="built_in">tag</span>(<span class="built_in">rc</span>(p)) += <span class="built_in">tag</span>(p);</span><br><span class="line">    <span class="built_in">tag</span>(p) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">double</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) &#123;</span><br><span class="line">    <span class="built_in">add</span>(p, v);</span><br><span class="line">    <span class="built_in">tag</span>(p) += v;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">r</span>(p) + <span class="built_in">l</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">update</span>(<span class="built_in">lc</span>(p), l, r, v);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) <span class="built_in">update</span>(<span class="built_in">rc</span>(p), l, r, v);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> opt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= <span class="built_in">l</span>(p) &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">s1</span>(p);</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">s2</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  <span class="type">double</span> s = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) s += <span class="built_in">ask</span>(<span class="built_in">lc</span>(p), l, r, opt);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) s += <span class="built_in">ask</span>(<span class="built_in">rc</span>(p), l, r, opt);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="type">int</span> opt, x, y, len;</span><br><span class="line">  <span class="type">double</span> k, s1, s2, av, t;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;opt, &amp;x, &amp;y);</span><br><span class="line">    len = (y - x + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;k);</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, x, y, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">      t = <span class="built_in">ask</span>(<span class="number">1</span>, x, y, <span class="number">1</span>) / len;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%.4lf\n&quot;</span>, t);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s1 = <span class="built_in">ask</span>(<span class="number">1</span>, x, y, <span class="number">1</span>), s2 = <span class="built_in">ask</span>(<span class="number">1</span>, x, y, <span class="number">2</span>);</span><br><span class="line">      av = s1 / len;</span><br><span class="line">      t = (s2 - <span class="number">2</span> * av * s1 + len * av * av) / len;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%.4lf\n&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>一道数学题。</p>
<p>假设有<code>&#123;x1, x2, x3, x4&#125;</code>序列，</p>
<p>长度为<code>n</code>，区间和等于<code>x1 + x2 + x3 + x4 = s1</code>，均值等于<code>s1 / n = y</code>，那么方差等于：
<span class="math display">\[
\frac{\left( x_1-y \right) ^2+\left( x_2-y \right) ^2+\left( x_3-y
\right) ^2+\left( x_4-y \right) ^2}{n}
\]</span> 只看分子，展开得到 <span class="math display">\[
\left( {x_1}^2-2x_1y+y^2 \right) +\left( {x_2}^2-2x_2y+y^2 \right)
+\left( {x_3}^2-2x_3y+y^2 \right) +\left( {x_4}^2-2x_4y+y^2 \right)
\]</span> 整理一下得到 <span class="math display">\[
\left( {x_1}^2+{x_2}^2+{x_3}^2+{x_4}^2 \right) +ny^2-2y\left(
x_1+x_2+x_3+x_4 \right)
\]</span> 设区间平方和为<code>s2</code>，那么上述式子可以简化为 <span
class="math display">\[
s_2-2ys_1+ny^2
\]</span>
所以线段树维护区间和<code>s1</code>和区间平方和<code>s2</code>即可</p>
<hr />
<p>假设现在，每个单位都要新增<code>k</code>，设当前某个位置的原值为<code>x</code>
<span class="math display">\[
\text{之前的平方值：}x^2
\]</span></p>
<p><span class="math display">\[
\text{现在的平方值：}\left( x+k \right) ^2=x^2+2xk+k^2
\]</span></p>
<p>那么对于整个区间而言，区间平方和增长了： <span
class="math display">\[
nk^2+2ks_1
\]</span></p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P1637 三元上升子序列</title>
    <url>/2024/09/04/P1637-%E4%B8%89%E5%85%83%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线段树</li>
<li>树状数组</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">3e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, tot, dis[maxn], a[maxn], bit[maxn];</span><br><span class="line"><span class="type">int</span> l[maxn], r[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">    bit[x] += v;</span><br><span class="line">    x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    s += bit[x];</span><br><span class="line">    x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i], dis[i] = a[i];</span><br><span class="line">  <span class="built_in">sort</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + n);</span><br><span class="line">  tot = <span class="built_in">unique</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + n) - <span class="number">1</span> - dis;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + tot, a[i]) - dis;</span><br><span class="line">    a[i] = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] - <span class="number">1</span>) l[i] = <span class="built_in">ask</span>(a[i] - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(a[i], <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(bit, <span class="number">0</span>, <span class="built_in">sizeof</span>(bit));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] + <span class="number">1</span> &lt;= n) r[i] = <span class="built_in">ask</span>(tot) - <span class="built_in">ask</span>(a[i]);</span><br><span class="line">    <span class="built_in">add</span>(a[i], <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans += (ll)l[i] * r[i];</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>假设离散化后，<code>1</code>是最小数字的排名，<code>n</code>是最大数字的排名，把原来的数字用排名替代。</p>
<p>遍历时使用权值树状数组记录每个排名的出现次数，</p>
<p>从左向右遍历，对于每个当前排名a<sub>i</sub>，比它小的排名区间为1到a<sub>i</sub>
- 1，那么比它小的个数就等于<code>ask(a[i] - 1)</code></p>
<p>结果保存到<code>l[i]</code>。</p>
<p>从右往左遍历，对于每个当前排名a<sub>i</sub>，比它大的排名区间为a<sub>i</sub>
+ 1 到
<code>n</code>，那么比它大的个数就等于<code>ask(n) - ask(a[i])</code></p>
<p>结果保存到<code>r[i]</code>。</p>
<p>根据乘法原理，答案就等于<code>l[i] * r[i]</code>之和</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>P1558 色板游戏</title>
    <url>/2024/09/05/P1558-%E8%89%B2%E6%9D%BF%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>状态压缩</li>
<li>线段树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s：种类的状态压缩</span></span><br><span class="line"><span class="comment">// cnt：种类个数</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">int</span> l, r, s, cnt, tag;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> s(x) tr[x].s</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cnt(x) tr[x].cnt</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tag(x) tr[x].tag</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc(x) x * 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc(x) x * 2 + 1</span></span><br><span class="line">&#125; tr[<span class="number">4</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (s) ++cnt, s = s &amp; (s - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">s</span>(p) = <span class="built_in">s</span>(<span class="built_in">lc</span>(p)) | <span class="built_in">s</span>(<span class="built_in">rc</span>(p));</span><br><span class="line">  <span class="built_in">cnt</span>(p) = <span class="built_in">count</span>(<span class="built_in">s</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    <span class="built_in">s</span>(p) = <span class="built_in">cnt</span>(p) = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid), <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">tag</span>(p)) &#123;</span><br><span class="line">    <span class="built_in">s</span>(<span class="built_in">lc</span>(p)) = <span class="number">1</span> &lt;&lt; (<span class="built_in">tag</span>(p) - <span class="number">1</span>), <span class="built_in">s</span>(<span class="built_in">rc</span>(p)) = <span class="number">1</span> &lt;&lt; (<span class="built_in">tag</span>(p) - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cnt</span>(<span class="built_in">lc</span>(p)) = <span class="number">1</span>, <span class="built_in">cnt</span>(<span class="built_in">rc</span>(p)) = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">tag</span>(<span class="built_in">lc</span>(p)) = <span class="built_in">tag</span>(<span class="built_in">rc</span>(p)) = <span class="built_in">tag</span>(p);</span><br><span class="line">    <span class="built_in">tag</span>(p) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) &#123;</span><br><span class="line">    <span class="built_in">s</span>(p) = <span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>), <span class="built_in">cnt</span>(p) = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">tag</span>(p) = k;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">update</span>(<span class="built_in">lc</span>(p), l, r, k);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) <span class="built_in">update</span>(<span class="built_in">rc</span>(p), l, r, k);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) <span class="keyword">return</span> <span class="built_in">s</span>(p);</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) ans |= <span class="built_in">ask</span>(<span class="built_in">lc</span>(p), l, r);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) ans |= <span class="built_in">ask</span>(<span class="built_in">rc</span>(p), l, r);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;t, &amp;m);</span><br><span class="line">  <span class="type">int</span> x, y, k;</span><br><span class="line">  <span class="type">char</span> opt[<span class="number">2</span>];</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, opt);</span><br><span class="line">    <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;k);</span><br><span class="line">      <span class="keyword">if</span> (x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, x, y, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">      <span class="keyword">if</span> (x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">count</span>(<span class="built_in">ask</span>(<span class="number">1</span>, x, y)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>颜色最多只有30种，暗示你使用状态压缩，每一位代表一个颜色种类，<code>int</code>类型有32位足够用了。</p>
<p>后续就是基础的线段树区间操作，不再赘述。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>状态压缩</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>CF689D Friends and Subsequences</title>
    <url>/2024/09/10/CF689D-Friends-and-Subsequences/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线段树</li>
<li>二分</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0：代表mx</span></span><br><span class="line"><span class="comment">// 1：代表mi</span></span><br><span class="line"><span class="type">int</span> mx[<span class="number">4</span> * maxn], mi[<span class="number">4</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_mx</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    mx[p] = a[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build_mx</span>(p &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build_mx</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">  mx[p] = <span class="built_in">max</span>(mx[p &lt;&lt; <span class="number">1</span>], mx[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_mi</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    mi[p] = b[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build_mi</span>(p &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build_mi</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">  mi[p] = <span class="built_in">min</span>(mi[p &lt;&lt; <span class="number">1</span>], mi[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask_mx</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> mx[p];</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (R &lt;= mid)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ask_mx</span>(p &lt;&lt; <span class="number">1</span>, l, mid, L, R);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (L &gt; mid)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ask_mx</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">ask_mx</span>(p &lt;&lt; <span class="number">1</span>, l, mid, L, R),</span><br><span class="line">               <span class="built_in">ask_mx</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, L, R));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask_mi</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> mi[p];</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (R &lt;= mid)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ask_mi</span>(p &lt;&lt; <span class="number">1</span>, l, mid, L, R);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (L &gt; mid)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ask_mi</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">ask_mi</span>(p &lt;&lt; <span class="number">1</span>, l, mid, L, R),</span><br><span class="line">               <span class="built_in">ask_mi</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, L, R));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; b[i];</span><br><span class="line">  <span class="built_in">build_mx</span>(<span class="number">1</span>, <span class="number">1</span>, n), <span class="built_in">build_mi</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> mid, mx, mi, ans_l, ans_r;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 找左边界</span></span><br><span class="line">    <span class="type">int</span> l = i, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">      mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      mx = <span class="built_in">ask_mx</span>(<span class="number">1</span>, <span class="number">1</span>, n, i, mid), mi = <span class="built_in">ask_mi</span>(<span class="number">1</span>, <span class="number">1</span>, n, i, mid);</span><br><span class="line">      <span class="keyword">if</span> (mx - mi &gt;= <span class="number">0</span>)</span><br><span class="line">        r = mid - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans_l = l;</span><br><span class="line">    <span class="comment">// 找右边界</span></span><br><span class="line">    l = i, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">      mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      mx = <span class="built_in">ask_mx</span>(<span class="number">1</span>, <span class="number">1</span>, n, i, mid), mi = <span class="built_in">ask_mi</span>(<span class="number">1</span>, <span class="number">1</span>, n, i, mid);</span><br><span class="line">      <span class="keyword">if</span> (mx - mi &lt;= <span class="number">0</span>)</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans_r = r;</span><br><span class="line">    ans += ans_r - ans_l + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>使用线段树的时间复杂度是<span class="math inline">\(n\log
^2n\)</span>，需要非常卡常才能过，建议使用ST表进行优化，毕竟只需要求区间极值而不需要动态修改。</p>
<p>固定左端点<code>l</code>，移动右端点<code>r</code>，可以发现一个数学规律：
<span class="math display">\[
\mathop {\small{\overset{r+1}{\max}}} \limits_{i=l}\,\,a_i\,\,\geqslant
\,\,\mathop {\small{\overset{r}{\max}}} \limits_{i=l}\,\,a_i
\]</span></p>
<p><span class="math display">\[
\mathop {\small{\overset{r+1}{\min}}} \limits_{i=l}\,\,b_i\,\,\leqslant
\,\,\mathop {\small{\overset{r}{\min}}} \limits_{i=l}\,\,b_i
\]</span></p>
<p>两者结合，变成： <span class="math display">\[
\mathop {\small{\overset{r+1}{\max}}} \limits_{i=l}\,\,a_i-\mathop
{\small{\overset{r+1}{\min}}} \limits_{i=l}\,\,b_i\,\,\geqslant \mathop
{\small{\overset{r}{\max}}} \limits_{i=l}\,\,a_i-\mathop
{\small{\overset{r}{\min}}} \limits_{i=l}\,\,b_i
\]</span> 抽象一下，变成： <span class="math display">\[
f\left( i+1, j+1 \right) -f\left( i, j \right) \geqslant 0
\]</span>
也就是说，固定左端点<code>l</code>，右端点<code>r</code>向右移动时，<code>f</code>函数的值是单调不减的。</p>
<p>现在的目标，是找到能让函数<code>f</code>的值为0的区间有多少个。</p>
<p>由于存在单调性，外循环每一次固定一个<code>l</code>，内循环对右端点<code>r</code>进行二分，找到等于<code>0</code>的左右边界即可。</p>
<p><code>0</code>区间的左边界：</p>
<p>如果<code>f &gt;= 0</code>，就向左边界移动，否则向右边界，得到左边界<code>L</code></p>
<p><code>0</code>区间的右边界：</p>
<p>如果<code>f &lt;= 0</code>，就向右边界移动，否则向左边界，得到右边界<code>R</code></p>
<p>那么本轮外循环对答案的贡献就是<code>R - L + 1</code>，开启下一轮外循环</p>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P2572 序列操作</title>
    <url>/2024/09/07/P2572-%E5%BA%8F%E5%88%97%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线段树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  <span class="comment">// 0和1的个数</span></span><br><span class="line">  <span class="type">int</span> c0, c1;</span><br><span class="line">  <span class="comment">// 从左/右端点开始的最长连续0序列长度，最终的最长连续0序列长度</span></span><br><span class="line">  <span class="type">int</span> lx0, rx0, mx0;</span><br><span class="line">  <span class="comment">// 从左/右端点开始的最长连续1序列长度，最终的最长连续1序列长度</span></span><br><span class="line">  <span class="type">int</span> lx1, rx1, mx1;</span><br><span class="line">  <span class="comment">// 覆盖标签，默认-1代表不覆盖；取反标签，默认0代表不取反</span></span><br><span class="line">  <span class="type">int</span> tag_cover, tag_inverse;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> c0(x) tr[x].c0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> c1(x) tr[x].c1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lx0(x) tr[x].lx0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rx0(x) tr[x].rx0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lx1(x) tr[x].lx1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rx1(x) tr[x].rx1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mx0(x) tr[x].mx0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mx1(x) tr[x].mx1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tag_cover(x) tr[x].tag_cover</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tag_inverse(x) tr[x].tag_inverse</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc(x) x * 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc(x) x * 2 + 1</span></span><br><span class="line">&#125; tr[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cover</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> cnt, <span class="type">int</span> opt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (opt == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">c0</span>(p) = cnt;</span><br><span class="line">    <span class="built_in">lx0</span>(p) = <span class="built_in">rx0</span>(p) = <span class="built_in">mx0</span>(p) = cnt;</span><br><span class="line">    <span class="built_in">c1</span>(p) = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">lx1</span>(p) = <span class="built_in">rx1</span>(p) = <span class="built_in">mx1</span>(p) = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">c0</span>(p) = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">lx0</span>(p) = <span class="built_in">rx0</span>(p) = <span class="built_in">mx0</span>(p) = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">c1</span>(p) = cnt;</span><br><span class="line">    <span class="built_in">lx1</span>(p) = <span class="built_in">rx1</span>(p) = <span class="built_in">mx1</span>(p) = cnt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inverse</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">swap</span>(<span class="built_in">c0</span>(p), <span class="built_in">c1</span>(p));</span><br><span class="line">  <span class="built_in">swap</span>(<span class="built_in">lx0</span>(p), <span class="built_in">lx1</span>(p));</span><br><span class="line">  <span class="built_in">swap</span>(<span class="built_in">rx0</span>(p), <span class="built_in">rx1</span>(p));</span><br><span class="line">  <span class="built_in">swap</span>(<span class="built_in">mx0</span>(p), <span class="built_in">mx1</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> lcnt, <span class="type">int</span> rcnt)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// lcnt为左孩子区间长度，rcnt为右孩子区间长度</span></span><br><span class="line">  <span class="comment">// 放置覆盖标志时，前面若有取反标志，可直接令其去除</span></span><br><span class="line">  <span class="comment">// 反之不行，所以取反标志一定在覆盖标志之后，那么应先处理覆盖标志</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">tag_cover</span>(p) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">cover</span>(<span class="built_in">lc</span>(p), lcnt, <span class="built_in">tag_cover</span>(p));</span><br><span class="line">    <span class="built_in">cover</span>(<span class="built_in">rc</span>(p), rcnt, <span class="built_in">tag_cover</span>(p));</span><br><span class="line">    <span class="built_in">tag_cover</span>(<span class="built_in">lc</span>(p)) = <span class="built_in">tag_cover</span>(<span class="built_in">rc</span>(p)) = <span class="built_in">tag_cover</span>(p);</span><br><span class="line">    <span class="built_in">tag_inverse</span>(<span class="built_in">lc</span>(p)) = <span class="built_in">tag_inverse</span>(<span class="built_in">rc</span>(p)) = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">tag_cover</span>(p) = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">tag_inverse</span>(p) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">inverse</span>(<span class="built_in">lc</span>(p));</span><br><span class="line">    <span class="built_in">inverse</span>(<span class="built_in">rc</span>(p));</span><br><span class="line">    <span class="built_in">tag_inverse</span>(<span class="built_in">lc</span>(p)) ^= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">tag_inverse</span>(<span class="built_in">rc</span>(p)) ^= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">tag_inverse</span>(p) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> lcnt, <span class="type">int</span> rcnt)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">c0</span>(p) = <span class="built_in">c0</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">c0</span>(<span class="built_in">rc</span>(p));</span><br><span class="line">  <span class="built_in">c1</span>(p) = <span class="built_in">c1</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">c1</span>(<span class="built_in">rc</span>(p));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">lx0</span>(p) = (<span class="built_in">mx0</span>(<span class="built_in">lc</span>(p)) == lcnt ? lcnt + <span class="built_in">lx0</span>(<span class="built_in">rc</span>(p)) : <span class="built_in">lx0</span>(<span class="built_in">lc</span>(p)));</span><br><span class="line">  <span class="built_in">rx0</span>(p) = (<span class="built_in">mx0</span>(<span class="built_in">rc</span>(p)) == rcnt ? rcnt + <span class="built_in">rx0</span>(<span class="built_in">lc</span>(p)) : <span class="built_in">rx0</span>(<span class="built_in">rc</span>(p)));</span><br><span class="line">  <span class="built_in">mx0</span>(p) = <span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">mx0</span>(<span class="built_in">lc</span>(p)), <span class="built_in">mx0</span>(<span class="built_in">rc</span>(p))), <span class="built_in">rx0</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">lx0</span>(<span class="built_in">rc</span>(p)));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">lx1</span>(p) = (<span class="built_in">mx1</span>(<span class="built_in">lc</span>(p)) == lcnt ? lcnt + <span class="built_in">lx1</span>(<span class="built_in">rc</span>(p)) : <span class="built_in">lx1</span>(<span class="built_in">lc</span>(p)));</span><br><span class="line">  <span class="built_in">rx1</span>(p) = (<span class="built_in">mx1</span>(<span class="built_in">rc</span>(p)) == rcnt ? rcnt + <span class="built_in">rx1</span>(<span class="built_in">lc</span>(p)) : <span class="built_in">rx1</span>(<span class="built_in">rc</span>(p)));</span><br><span class="line">  <span class="built_in">mx1</span>(p) = <span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">mx1</span>(<span class="built_in">lc</span>(p)), <span class="built_in">mx1</span>(<span class="built_in">rc</span>(p))), <span class="built_in">rx1</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">lx1</span>(<span class="built_in">rc</span>(p)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r, <span class="built_in">tag_cover</span>(p) = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    <span class="built_in">cover</span>(p, <span class="number">1</span>, a[l]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> lcnt = mid - l + <span class="number">1</span>, rcnt = r - mid;</span><br><span class="line">  <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid), <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">up</span>(p, lcnt, rcnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> opt)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> lcnt = <span class="built_in">r</span>(<span class="built_in">lc</span>(p)) - <span class="built_in">l</span>(<span class="built_in">lc</span>(p)) + <span class="number">1</span>, rcnt = <span class="built_in">r</span>(<span class="built_in">rc</span>(p)) - <span class="built_in">l</span>(<span class="built_in">rc</span>(p)) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="built_in">r</span>(p) - <span class="built_in">l</span>(p) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">cover</span>(p, cnt, <span class="number">0</span>);</span><br><span class="line">      <span class="built_in">tag_cover</span>(p) = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">tag_inverse</span>(p) = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">cover</span>(p, cnt, <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">tag_cover</span>(p) = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">tag_inverse</span>(p) = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">inverse</span>(p);</span><br><span class="line">      <span class="built_in">tag_inverse</span>(p) ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">down</span>(p, lcnt, rcnt);</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">update</span>(<span class="built_in">lc</span>(p), l, r, opt);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) <span class="built_in">update</span>(<span class="built_in">rc</span>(p), l, r, opt);</span><br><span class="line">  <span class="built_in">up</span>(p, lcnt, rcnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask_c1</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> lcnt = <span class="built_in">r</span>(<span class="built_in">lc</span>(p)) - <span class="built_in">l</span>(<span class="built_in">lc</span>(p)) + <span class="number">1</span>, rcnt = <span class="built_in">r</span>(<span class="built_in">rc</span>(p)) - <span class="built_in">l</span>(<span class="built_in">rc</span>(p)) + <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) <span class="keyword">return</span> <span class="built_in">c1</span>(p);</span><br><span class="line">  <span class="built_in">down</span>(p, lcnt, rcnt);</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) ans += <span class="built_in">ask_c1</span>(<span class="built_in">lc</span>(p), l, r);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) ans += <span class="built_in">ask_c1</span>(<span class="built_in">rc</span>(p), l, r);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">ask_mx</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> lcnt = <span class="built_in">r</span>(<span class="built_in">lc</span>(p)) - <span class="built_in">l</span>(<span class="built_in">lc</span>(p)) + <span class="number">1</span>, rcnt = <span class="built_in">r</span>(<span class="built_in">rc</span>(p)) - <span class="built_in">l</span>(<span class="built_in">rc</span>(p)) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) <span class="keyword">return</span> tr[p];</span><br><span class="line">  <span class="built_in">down</span>(p, lcnt, rcnt);</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &gt; mid)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ask_mx</span>(<span class="built_in">rc</span>(p), l, r);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (r &lt;= mid)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ask_mx</span>(<span class="built_in">lc</span>(p), l, r);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    node ans, a = <span class="built_in">ask_mx</span>(<span class="built_in">lc</span>(p), l, r), b = <span class="built_in">ask_mx</span>(<span class="built_in">rc</span>(p), l, r);</span><br><span class="line">    ans.mx1 = <span class="built_in">max</span>(<span class="built_in">max</span>(a.mx1, b.mx1), a.rx1 + b.lx1);</span><br><span class="line">    ans.lx1 = a.mx1 == lcnt ? lcnt + b.lx1 : a.lx1;</span><br><span class="line">    ans.rx1 = b.mx1 == rcnt ? rcnt + a.rx1 : b.rx1;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> opt, x, y;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;opt, &amp;x, &amp;y);</span><br><span class="line">    ++x, ++y;</span><br><span class="line">    <span class="keyword">if</span> (opt &lt; <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, x, y, opt);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">3</span>) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="built_in">ask_c1</span>(<span class="number">1</span>, x, y) &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cout &lt;&lt; <span class="built_in">ask_mx</span>(<span class="number">1</span>, x, y).mx1 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>线段树的模板题，直接参考代码，注意细节即可。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P3224 永无乡</title>
    <url>/2024/09/22/P3224-%E6%B0%B8%E6%97%A0%E4%B9%A1/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>并查集</li>
<li>线段树合并</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[maxn], fa[maxn], root[maxn];</span><br><span class="line"><span class="comment">// 动态开点权值线段树，保存不同重要度的个数</span></span><br><span class="line"><span class="comment">// lc：左孩子</span></span><br><span class="line"><span class="comment">// rc：右孩子</span></span><br><span class="line"><span class="comment">// s：区间个数和</span></span><br><span class="line"><span class="comment">// id：只会保存在叶子节点，相同排名保存一个就行了</span></span><br><span class="line"><span class="type">int</span> tot, lc[<span class="number">30</span> * maxn], rc[<span class="number">30</span> * maxn], s[<span class="number">30</span> * maxn], id[<span class="number">30</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">find</span>(fa[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> i, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p) p = ++tot;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    s[p]++;</span><br><span class="line">    id[p] = i;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (v &lt;= mid) lc[p] = <span class="built_in">build</span>(lc[p], l, mid, i, v);</span><br><span class="line">  <span class="keyword">if</span> (v &gt; mid) rc[p] = <span class="built_in">build</span>(rc[p], mid + <span class="number">1</span>, r, i, v);</span><br><span class="line">  s[p] = s[lc[p]] + s[rc[p]];</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p) <span class="keyword">return</span> q;</span><br><span class="line">  <span class="keyword">if</span> (!q) <span class="keyword">return</span> p;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    s[p] += s[q];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  lc[p] = <span class="built_in">merge</span>(lc[p], lc[q], l, mid);</span><br><span class="line">  rc[p] = <span class="built_in">merge</span>(rc[p], rc[q], mid + <span class="number">1</span>, r);</span><br><span class="line">  s[p] = s[lc[p]] + s[rc[p]];</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span> id[p];</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, ans = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (lc[p] &amp;&amp; v &lt;= s[lc[p]])</span><br><span class="line">    ans = <span class="built_in">ask</span>(lc[p], l, mid, v);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (rc[p])</span><br><span class="line">    ans = <span class="built_in">ask</span>(rc[p], mid + <span class="number">1</span>, r, v - s[lc[p]]);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">    fa[i] = i;</span><br><span class="line">    <span class="comment">// 每个点都开一个线段树</span></span><br><span class="line">    root[i] = <span class="built_in">build</span>(root[i], <span class="number">1</span>, n, i, a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">continue</span>;</span><br><span class="line">    fa[y] = x;</span><br><span class="line">    root[x] = <span class="built_in">merge</span>(root[x], root[y], <span class="number">1</span>, n);</span><br><span class="line">  &#125;</span><br><span class="line">  cin &gt;&gt; m;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    cin &gt;&gt; c &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">      x = <span class="built_in">find</span>(x);</span><br><span class="line">      cout &lt;&lt; <span class="built_in">ask</span>(root[x], <span class="number">1</span>, n, y) &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">      <span class="keyword">if</span> (x == y) <span class="keyword">continue</span>;</span><br><span class="line">      fa[y] = x;</span><br><span class="line">      root[x] = <span class="built_in">merge</span>(root[x], root[y], <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>根据题意，每个值的范围仅仅在<code>1 ~ 1e5</code>之间，且同时问你第k大，可以直接使用权值线段树。</p>
<p>每个点都开一个权值线段树，线段树合并时，并到并查集的祖先即可，</p>
<p>这样一来就可以直接检索并查集祖先，来查到该集合的第k大。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P3372 线段树 1</title>
    <url>/2024/08/29/P3372-%E7%BA%BF%E6%AE%B5%E6%A0%91-1/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线段树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  ll sum, tag;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sum(x) tr[x].sum</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tag(x) tr[x].tag</span></span><br><span class="line">&#125; tr[<span class="number">4</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    <span class="built_in">sum</span>(p) = a[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">build</span>(p * <span class="number">2</span>, l, mid), <span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">sum</span>(p) = <span class="built_in">sum</span>(p * <span class="number">2</span>) + <span class="built_in">sum</span>(p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下传递标签</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">tag</span>(p)) &#123;</span><br><span class="line">    <span class="built_in">sum</span>(p * <span class="number">2</span>) += <span class="built_in">tag</span>(p) * (<span class="built_in">r</span>(p * <span class="number">2</span>) - <span class="built_in">l</span>(p * <span class="number">2</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sum</span>(p * <span class="number">2</span> + <span class="number">1</span>) += <span class="built_in">tag</span>(p) * (<span class="built_in">r</span>(p * <span class="number">2</span> + <span class="number">1</span>) - <span class="built_in">l</span>(p * <span class="number">2</span> + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">tag</span>(p * <span class="number">2</span>) += <span class="built_in">tag</span>(p), <span class="built_in">tag</span>(p * <span class="number">2</span> + <span class="number">1</span>) += <span class="built_in">tag</span>(p);</span><br><span class="line">    <span class="built_in">tag</span>(p) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= <span class="built_in">l</span>(p) &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) &#123;</span><br><span class="line">    <span class="built_in">sum</span>(p) += (ll)k * (<span class="built_in">r</span>(p) - <span class="built_in">l</span>(p) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">tag</span>(p) += k;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">update</span>(p * <span class="number">2</span>, l, r, k);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) <span class="built_in">update</span>(p * <span class="number">2</span> + <span class="number">1</span>, l, r, k);</span><br><span class="line">  <span class="built_in">sum</span>(p) = <span class="built_in">sum</span>(p * <span class="number">2</span>) + <span class="built_in">sum</span>(p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= <span class="built_in">l</span>(p) &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) <span class="keyword">return</span> <span class="built_in">sum</span>(p);</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) ans += <span class="built_in">ask</span>(p * <span class="number">2</span>, l, r);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) ans += <span class="built_in">ask</span>(p * <span class="number">2</span> + <span class="number">1</span>, l, r);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="type">int</span> opt, x, y, k;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;opt);</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;k);</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, x, y, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">ask</span>(<span class="number">1</span>, x, y));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>线段树的模板题，不再赘述。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P3373 线段树 2</title>
    <url>/2024/09/02/P3373-%E7%BA%BF%E6%AE%B5%E6%A0%91-2/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线段树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, mod, a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  ll s, tag_add, tag_mul;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> s(x) tr[x].s</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tag_add(x) tr[x].tag_add</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tag_mul(x) tr[x].tag_mul</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc(x) x &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc(x) (x &lt;&lt; 1) + 1</span></span><br><span class="line">&#125; tr[<span class="number">4</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; <span class="built_in">s</span>(p) = (<span class="built_in">s</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">s</span>(<span class="built_in">rc</span>(p))) % mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r;</span><br><span class="line">  <span class="built_in">s</span>(p) = <span class="number">0</span>, <span class="built_in">tag_add</span>(p) = <span class="number">0</span>, <span class="built_in">tag_mul</span>(p) = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    <span class="built_in">s</span>(p) = a[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid), <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p, ll v)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">s</span>(p) = (<span class="built_in">s</span>(p) + (<span class="built_in">r</span>(p) - <span class="built_in">l</span>(p) + <span class="number">1</span>) * v) % mod;</span><br><span class="line">  <span class="built_in">tag_add</span>(p) = (<span class="built_in">tag_add</span>(p) + v) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> p, ll v)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">s</span>(p) = (<span class="built_in">s</span>(p) * v) % mod;</span><br><span class="line">  <span class="built_in">tag_mul</span>(p) = (<span class="built_in">tag_mul</span>(p) * v) % mod;</span><br><span class="line">  <span class="built_in">tag_add</span>(p) = (<span class="built_in">tag_add</span>(p) * v) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">tag_mul</span>(p) != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">mul</span>(<span class="built_in">lc</span>(p), <span class="built_in">tag_mul</span>(p)), <span class="built_in">mul</span>(<span class="built_in">rc</span>(p), <span class="built_in">tag_mul</span>(p));</span><br><span class="line">    <span class="built_in">tag_mul</span>(p) = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">tag_add</span>(p)) &#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="built_in">lc</span>(p), <span class="built_in">tag_add</span>(p)), <span class="built_in">add</span>(<span class="built_in">rc</span>(p), <span class="built_in">tag_add</span>(p));</span><br><span class="line">    <span class="built_in">tag_add</span>(p) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, ll v, <span class="type">int</span> opt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= <span class="built_in">l</span>(p) &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">1</span>) <span class="built_in">mul</span>(p, v);</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">2</span>) <span class="built_in">add</span>(p, v);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">update</span>(<span class="built_in">lc</span>(p), l, r, v, opt);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) <span class="built_in">update</span>(<span class="built_in">rc</span>(p), l, r, v, opt);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= <span class="built_in">l</span>(p) &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) <span class="keyword">return</span> <span class="built_in">s</span>(p);</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) ans = (ans + <span class="built_in">ask</span>(<span class="built_in">lc</span>(p), l, r)) % mod;</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) ans = (ans + <span class="built_in">ask</span>(<span class="built_in">rc</span>(p), l, r)) % mod;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;mod);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="type">int</span> opt, x, y;</span><br><span class="line">  ll k;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;opt);</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">1</span> || opt == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;x, &amp;y, &amp;k);</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, x, y, k, opt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">ask</span>(<span class="number">1</span>, x, y));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>增加的操作，相当于 <span class="math display">\[
s\prime=s+nk
\\
s\prime\text{新区间和，}s\text{旧区间和，}n\text{区间个数，}k\text{单位变化量}
\]</span>
举个例子，有区间<code>&#123;1, 2, 3&#125;</code>，原区间和等于<code>6</code></p>
<p>新增<code>k</code>等于<code>2</code>，相等于<code>新s = 6 + 3 * 2 = 12</code></p>
<p>乘法的操作，相当于 <span class="math display">\[
s\prime=sk
\\
s\prime\text{新区间和，}s\text{旧区间和，}k\text{单位变化量}
\]</span>
还是上述那个例子，新乘<code>k</code>等于<code>2</code>，相等于<code>新s = 6 * 2 = 12</code></p>
<hr />
<p>所以可以模拟以下流程，假设原和为<code>s</code></p>
<ol type="1">
<li><p>增<code>k1</code> <span class="math display">\[
s\prime=s+nk_1
\]</span></p></li>
<li><p>乘<code>k2</code> <span class="math display">\[
s\prime=sk_2+nk_1k_2
\]</span></p></li>
<li><p>增<code>k3</code> <span class="math display">\[
s\prime=sk_2+n\left( k_1k_2+k_3 \right)
\]</span></p></li>
<li><p>乘<code>k4</code> <span class="math display">\[
s\prime=sk_2k_4+n\left( k_1k_2+k_3 \right) k_4
\]</span></p></li>
</ol>
<p>根据上述规律可以得到抽象式子，<code>新s = s * tag_mul + n * 单位变化量</code>，</p>
<p>单位变化量同时被<code>tag_add</code>累加、<code>tag_mul</code>累乘影响。</p>
<p>所以每次如果有新的乘法，除了累乘到<code>tag_mul</code>之外，还要<strong>同时</strong>对<code>tag_add</code>执行乘法</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P3521 ROT-Tree Rotations</title>
    <url>/2024/09/22/P3521-ROT-Tree-Rotations/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线段树合并</li>
<li>逆序对</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n, in;</span><br><span class="line"><span class="type">int</span> cnt, lc[maxn * <span class="number">20</span>], rc[maxn * <span class="number">20</span>], sz[maxn * <span class="number">20</span>];</span><br><span class="line"><span class="comment">// u：不交换子树</span></span><br><span class="line"><span class="comment">// v：交换子树</span></span><br><span class="line">ll ans, u, v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> p + q;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    sz[p] += sz[q];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  u += <span class="number">1ll</span> * sz[rc[p]] * sz[lc[q]];</span><br><span class="line">  v += <span class="number">1ll</span> * sz[lc[p]] * sz[rc[q]];</span><br><span class="line">  lc[p] = <span class="built_in">merge</span>(lc[p], lc[q], l, mid);</span><br><span class="line">  rc[p] = <span class="built_in">merge</span>(rc[p], rc[q], mid + <span class="number">1</span>, r);</span><br><span class="line">  sz[p] = sz[lc[p]] + sz[rc[p]];</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p) p = ++cnt;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    sz[p] += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">    <span class="built_in">update</span>(lc[p], l, mid, x);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">update</span>(rc[p], mid + <span class="number">1</span>, r, x);</span><br><span class="line">  sz[p] = sz[lc[p]] + sz[rc[p]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> &amp;p)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;in);</span><br><span class="line">  <span class="keyword">if</span> (!in) &#123;</span><br><span class="line">    <span class="type">int</span> lp = <span class="number">0</span>, rp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(lp), <span class="built_in">dfs</span>(rp);</span><br><span class="line">    u = <span class="number">0</span>, v = <span class="number">0</span>;</span><br><span class="line">    p = <span class="built_in">merge</span>(lp, rp, <span class="number">1</span>, n);</span><br><span class="line">    ans += <span class="built_in">min</span>(u, v);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">update</span>(p, <span class="number">1</span>, n, in);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">dfs</span>(x);</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>通过观察可以发现，子树之间的交换并不会影响到父树，如图所示：</p>
<img src="/2024/09/22/P3521-ROT-Tree-Rotations/1.png" class="" title="image-20240922144812059">
<p>交换<code>A</code>的子树，会影响后续<code>345</code>的逆序对吗？并不会。</p>
<p>交换<code>C</code>的子树，会影响前面<code>123</code>的逆序对吗？也不会。</p>
<p>交换<code>B</code>的子树，会影响后续<code>45</code>的逆序对吗？还是不会，但是会影响<code>A</code>和<code>3</code>的逆序对。</p>
<p>所以总的思路出来了：</p>
<p>自底向上，枚举所有节点，其交换、或不交换子树得到的逆序对个数，取二者较小值为结果，所有节点的结果求和就得到了答案。</p>
<p>由于需要知道每个点的俩子树值域组成，且题目也说值域只有<code>2e5</code>，那么对每个点开权值线段树，向父结点依次合并即可。</p>
<hr />
<p>现在的关键是，我知道左、右子树的权值线段树，怎样计算左子树对右子树的逆序对贡献呢？</p>
<p>假设当前有序列<code>12345 12345</code>，当前结点区间为<code>[1, 10]</code>，那么左子树区间为<code>[1, 5]</code>，右子树区间为<code>[6, 10]</code>，</p>
<p>在两子树的线段树合并过程中可以发现，逆序对可以即时得出。</p>
<img src="/2024/09/22/P3521-ROT-Tree-Rotations/2.png" class="" title="image-20240922151036339">
<p>每一层的<code>红色区域个数 * 绿色区域个数</code>就等于该层的逆序对贡献，也就是<code>左子树的右孩子 * 右子树的左孩子</code>；</p>
<p>我们自上而下看看。</p>
<p>左子树的<code>4</code>、<code>5</code>肯定对右子树的<code>[1, 3]</code>有贡献；</p>
<p>左子树的<code>3</code>也对右子树的<code>[1, 2]</code>有贡献，左子树的<code>5</code>也对右子树的<code>4</code>有贡献；</p>
<p>左子树的<code>2</code>也对右子树的<code>1</code>有贡献。</p>
<p>自此，左子树对右子树的所有贡献不重不漏地整理完了，非常巧妙！</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P3605 Promotion Counting P</title>
    <url>/2024/09/22/P3605-Promotion-Counting-P/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>离散化</li>
<li>线段树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="comment">// num：离散后的排名</span></span><br><span class="line"><span class="type">int</span> n, num, rt[maxn], dis[maxn], a[maxn], ans[maxn];</span><br><span class="line"><span class="type">int</span> tot, head[maxn], ver[maxn &lt;&lt; <span class="number">1</span>], nxt[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 权值线段树</span></span><br><span class="line"><span class="type">int</span> cnt, lc[maxn * <span class="number">18</span>], rc[maxn * <span class="number">18</span>], s[maxn * <span class="number">18</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; ver[++tot] = y, nxt[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p) p = ++cnt;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    s[p] += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">update</span>(lc[p], l, mid, x);</span><br><span class="line">  <span class="keyword">if</span> (x &gt; mid) <span class="built_in">update</span>(rc[p], mid + <span class="number">1</span>, r, x);</span><br><span class="line">  s[p] = s[lc[p]] + s[rc[p]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= L &amp;&amp; r &lt;= R) <span class="keyword">return</span> s[p];</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= mid &amp;&amp; lc[p]) ans += <span class="built_in">ask</span>(lc[p], l, mid, L, R);</span><br><span class="line">  <span class="keyword">if</span> (R &gt; mid &amp;&amp; rc[p]) ans += <span class="built_in">ask</span>(rc[p], mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> p + q;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    s[p] += s[q];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  lc[p] = <span class="built_in">merge</span>(lc[p], lc[q], l, mid);</span><br><span class="line">  rc[p] = <span class="built_in">merge</span>(rc[p], rc[q], mid + <span class="number">1</span>, r);</span><br><span class="line">  s[p] = s[lc[p]] + s[rc[p]];</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">    <span class="type">int</span> y = ver[i];</span><br><span class="line">    <span class="keyword">if</span> (y == f) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(y, x);</span><br><span class="line">    rt[x] = <span class="built_in">merge</span>(rt[x], rt[y], <span class="number">1</span>, num);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (a[x] &lt; num) ans[x] = <span class="built_in">ask</span>(rt[x], <span class="number">1</span>, num, a[x] + <span class="number">1</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    dis[i] = a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + n);</span><br><span class="line">  num = <span class="built_in">unique</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + n) - <span class="number">1</span> - dis;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    a[i] = <span class="built_in">lower_bound</span>(dis + <span class="number">1</span>, dis + <span class="number">1</span> + num, a[i]) - dis;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">update</span>(rt[<span class="number">1</span>], <span class="number">1</span>, num, a[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x, i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="built_in">add</span>(x, i), <span class="built_in">add</span>(i, x);</span><br><span class="line">    <span class="built_in">update</span>(rt[i], <span class="number">1</span>, num, a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>求每个点，其子树下有多少人的值是大于它的；直接每个节点开权值线段树，然后向上合并即可。</p>
<p>由于合并时会对已经合并后的子树造成影响，所以每个节点合并完成时需要即刻记录答案，而不能延后！</p>
<p>题目说了每个人的值都不一样，尽管值域高达<code>1e9</code>，但是可以通过离散化压到<code>1e5</code></p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>离散化</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P3870 开关</title>
    <url>/2024/08/30/P3870-%E5%BC%80%E5%85%B3/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线段树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s：1的个数总和</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">int</span> l, r, s, tag;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> s(x) tr[x].s</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tag(x) tr[x].tag</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc(x) x * 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc(x) x * 2 + 1</span></span><br><span class="line">&#125; tr[<span class="number">4</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; <span class="built_in">s</span>(p) = <span class="built_in">s</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">s</span>(<span class="built_in">rc</span>(p)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid), <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">tag</span>(p)) &#123;</span><br><span class="line">    <span class="built_in">s</span>(<span class="built_in">lc</span>(p)) = <span class="built_in">r</span>(<span class="built_in">lc</span>(p)) - <span class="built_in">l</span>(<span class="built_in">lc</span>(p)) + <span class="number">1</span> - <span class="built_in">s</span>(<span class="built_in">lc</span>(p));</span><br><span class="line">    <span class="built_in">s</span>(<span class="built_in">rc</span>(p)) = <span class="built_in">r</span>(<span class="built_in">rc</span>(p)) - <span class="built_in">l</span>(<span class="built_in">rc</span>(p)) + <span class="number">1</span> - <span class="built_in">s</span>(<span class="built_in">rc</span>(p));</span><br><span class="line">    <span class="built_in">tag</span>(<span class="built_in">lc</span>(p)) ^= <span class="number">1</span>, <span class="built_in">tag</span>(<span class="built_in">rc</span>(p)) ^= <span class="number">1</span>, <span class="built_in">tag</span>(p) ^= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) &#123;</span><br><span class="line">    <span class="built_in">s</span>(p) = <span class="built_in">r</span>(p) - <span class="built_in">l</span>(p) + <span class="number">1</span> - <span class="built_in">s</span>(p);</span><br><span class="line">    <span class="built_in">tag</span>(p) ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">update</span>(<span class="built_in">lc</span>(p), l, r);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) <span class="built_in">update</span>(<span class="built_in">rc</span>(p), l, r);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) <span class="keyword">return</span> <span class="built_in">s</span>(p);</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) ans += <span class="built_in">ask</span>(<span class="built_in">lc</span>(p), l, r);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) ans += <span class="built_in">ask</span>(<span class="built_in">rc</span>(p), l, r);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="type">int</span> opt, x, y;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;opt, &amp;x, &amp;y);</span><br><span class="line">    <span class="keyword">if</span> (!opt) &#123;</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, x, y);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">ask</span>(<span class="number">1</span>, x, y));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>假设当前区间为<code>[1, 4]</code>，<code>1</code>的个数<code>s</code>为<code>3</code>，那么<code>0</code>的个数等于<code>4 - 3 = 1</code></p>
<p>如果对该区间取反，那么<code>1</code>的个数<code>s</code>等于<code>4 - 3 = 1</code>，<code>0</code>的个数等于<code>4 - 1 = 3</code></p>
<p>延迟标记<code>tag</code>应该使用异或，因为取反的取反就是保持原样。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P3899 更为厉害</title>
    <url>/2024/09/19/P3899-%E6%9B%B4%E4%B8%BA%E5%8E%89%E5%AE%B3/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线段树合并</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">3e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> tot, head[maxn], ver[<span class="number">2</span> * maxn], nxt[<span class="number">2</span> * maxn];</span><br><span class="line"><span class="comment">// 每个点的深度d、子树大小（包含自己）sz、线段树根结点rt</span></span><br><span class="line"><span class="type">int</span> d[maxn], sz[maxn], rt[maxn];</span><br><span class="line"><span class="comment">// 线段树，下标是d，值是区间sz - 1之和</span></span><br><span class="line"><span class="type">int</span> cnt, lc[maxn * <span class="number">50</span>], rc[maxn * <span class="number">50</span>];</span><br><span class="line">ll sum[maxn * <span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; ver[++tot] = y, nxt[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p) p = ++cnt;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    sum[p] += v;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">    <span class="built_in">update</span>(lc[p], l, mid, x, v);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">update</span>(rc[p], mid + <span class="number">1</span>, r, x, v);</span><br><span class="line">  sum[p] = sum[lc[p]] + sum[rc[p]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建节点方式合并</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> p + q;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    sum[++cnt] = sum[p] + sum[q];</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> u = ++cnt;</span><br><span class="line">  lc[u] = <span class="built_in">merge</span>(lc[p], lc[q], l, mid);</span><br><span class="line">  rc[u] = <span class="built_in">merge</span>(rc[p], rc[q], mid + <span class="number">1</span>, r);</span><br><span class="line">  sum[u] = sum[lc[u]] + sum[rc[u]];</span><br><span class="line">  <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">  d[x] = d[f] + <span class="number">1</span>;</span><br><span class="line">  sz[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">    <span class="type">int</span> y = ver[i];</span><br><span class="line">    <span class="keyword">if</span> (y == f) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(y, x);</span><br><span class="line">    sz[x] += sz[y];</span><br><span class="line">    rt[x] = <span class="built_in">merge</span>(rt[x], rt[y], <span class="number">1</span>, n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">update</span>(rt[x], <span class="number">1</span>, n, d[x], sz[x] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> sum[p];</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= mid) ans += <span class="built_in">ask</span>(lc[p], l, mid, L, R);</span><br><span class="line">  <span class="keyword">if</span> (R &gt; mid) ans += <span class="built_in">ask</span>(rc[p], mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> q;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x, y; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">add</span>(x, y), <span class="built_in">add</span>(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, a, k; i &lt;= q; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;k);</span><br><span class="line">    ll ans = <span class="number">1ll</span> * <span class="built_in">min</span>(k, d[a] - <span class="number">1</span>) * (sz[a] - <span class="number">1</span>) +</span><br><span class="line">             <span class="built_in">ask</span>(rt[a], <span class="number">1</span>, n, d[a] + <span class="number">1</span>, <span class="built_in">min</span>(d[a] + k, n));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>由于<code>a</code>和<code>b</code>都是<code>c</code>的祖先，显然<code>a</code>和<code>b</code>这两个点在同一条链上，</p>
<p><code>a</code>和<code>b</code>的位置关系无非只有两种情况，假设根结点的深度从1开始，也就是<code>d[1] = 1</code>，</p>
<p><code>b</code>在<code>a</code>上，根据乘法原理显然等于<code>min(k, d[a] - 1) * (sz[a] - 1)</code></p>
<img src="/2024/09/19/P3899-%E6%9B%B4%E4%B8%BA%E5%8E%89%E5%AE%B3/1.png" class="" title="image-20240919214045480">
<p><code>b</code>在<code>a</code>下，显然满足以下公式： <span
class="math display">\[
\sum_{d\left[ a \right] +1\leqslant d\left[ b \right] \leqslant d\left[
a \right] +k}^{}{sz\left[ b \right] -1}
\]</span> 看见维护区间和，想到线段树；</p>
<p>但这道题是问每个节点满足上述式子的答案，那么对每个节点单独建立线段树即可，</p>
<p>父结点的线段树不仅仅可以记录自身，还可以通过线段树合并操作，将所有孩子的线段树信息一起并入自身。</p>
<p><code>d[x]</code>作为线段树的下标，<code>sz[x] - 1</code>作为线段树叶子结点的值，操作为区间求和。</p>
<hr />
<p>要注意！！！！本题不能使用合并思路的线段树合并写法，即不允许使用这个：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> p + q;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  lc[p] = <span class="built_in">merge</span>(lc[p], lc[q], l, mid);</span><br><span class="line">  rc[p] = <span class="built_in">merge</span>(rc[p], rc[q], mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么呢？假设有<code>A</code>、<code>B</code>、<code>C</code>三个树，<code>B</code>和<code>C</code>都要合并到<code>A</code>树</p>
<p>如果<code>A</code>变成下图这样，那么与<code>C</code>合并时，很有可能直接篡改了节点<code>X</code>，</p>
<p>此刻，如果通过<code>B</code>树访问它的子区间<code>X</code>，那不就完蛋了？</p>
<img src="/2024/09/19/P3899-%E6%9B%B4%E4%B8%BA%E5%8E%89%E5%AE%B3/2.png" class="" title="image-20240919231915885">
<p>而本题恰恰需要访问子区间，所以必须使用类似主席树的思维，每次都得新建节点（除非空），这样才能保证树原有的姿态。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P4145 花神游历各国</title>
    <url>/2024/09/06/P4145-%E8%8A%B1%E7%A5%9E%E6%B8%B8%E5%8E%86%E5%90%84%E5%9B%BD/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线段树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  ll mx, sum;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mx(x) tr[x].mx</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sum(x) tr[x].sum</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc(x) x * 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc(x) x * 2 + 1</span></span><br><span class="line">&#125; tr[<span class="number">4</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sum</span>(p) = <span class="built_in">sum</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">sum</span>(<span class="built_in">rc</span>(p));</span><br><span class="line">  <span class="built_in">mx</span>(p) = <span class="built_in">max</span>(<span class="built_in">mx</span>(<span class="built_in">lc</span>(p)), <span class="built_in">mx</span>(<span class="built_in">rc</span>(p)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    <span class="built_in">mx</span>(p) = <span class="built_in">sum</span>(p) = a[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid), <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= <span class="built_in">l</span>(p) &amp;&amp; <span class="built_in">r</span>(p) &lt;= r &amp;&amp; <span class="built_in">l</span>(p) == <span class="built_in">r</span>(p)) &#123;</span><br><span class="line">    <span class="built_in">mx</span>(p) = <span class="built_in">sqrt</span>(<span class="built_in">mx</span>(p));</span><br><span class="line">    <span class="built_in">sum</span>(p) = <span class="built_in">sqrt</span>(<span class="built_in">sum</span>(p));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid &amp;&amp; <span class="built_in">mx</span>(<span class="built_in">lc</span>(p)) &gt; <span class="number">1</span>) <span class="built_in">update</span>(<span class="built_in">lc</span>(p), l, r);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid &amp;&amp; <span class="built_in">mx</span>(<span class="built_in">rc</span>(p)) &gt; <span class="number">1</span>) <span class="built_in">update</span>(<span class="built_in">rc</span>(p), l, r);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) <span class="keyword">return</span> <span class="built_in">sum</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) ans += <span class="built_in">ask</span>(<span class="built_in">lc</span>(p), l, r);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) ans += <span class="built_in">ask</span>(<span class="built_in">rc</span>(p), l, r);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">  <span class="type">int</span> opt, x, y;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;opt, &amp;x, &amp;y);</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, x, y);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">ask</span>(<span class="number">1</span>, x, y));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>开方操作并不能直接对求和操作进行修改。</p>
<p>但根据题意，每个数字最大只有10<sup>12</sup>，只需要开方6次就能变成1；</p>
<p>就算每个数字都暴力开方至1，总共的时间复杂度也不过<code>6*logn*n</code>，小的可怜</p>
<p>所以设置一个区间最大值，假设该区间的最大值等于1，相当于整个区间都为1，就没有开方的必要。</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P4198 楼房重建</title>
    <url>/2024/09/15/P4198-%E6%A5%BC%E6%88%BF%E9%87%8D%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线段树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<h2 id="普通想法">普通想法</h2>
<p>单点修改，区间询问，考虑线段树。</p>
<p>设斜率等于<code>h(y) / y</code>，如果点<code>(y, h(y))</code>要被看到，那么斜率肯定比之前的最大斜率还大。</p>
<p>设<code>s</code>代表当前区间最大值，<code>c</code>代表当前区间，从区间左端点仰望可以看见的建筑数量。</p>
<p>合并时，左孩子的<code>c</code>可以直接继承到父结点，因为左孩子的左端点是<code>l</code>，父结点的左端点也是<code>l</code>，</p>
<p>右孩子的<code>c</code>则不可以直接继承到父结点，因为右孩子是以<code>mid + 1</code>为左端点，而父结点的左端点是<code>l</code>，</p>
<p>即这行代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c[p] = c[lc] + <span class="built_in">f</span>(rc, mid + <span class="number">1</span>, r, id[lc]);</span><br></pre></td></tr></table></figure>
<p>也就是说，左孩子的加入会对右孩子的答案有如下影响：</p>
<p>假设当前父结点的区间为<code>[l, r]</code>，左孩子为<code>lc</code>，区间为<code>[l, mid]</code>；
右孩子为<code>rc</code>，区间为<code>[mid + 1, r]</code></p>
<ol type="1">
<li><p>如果<code>lc</code>的斜率最大值，大于<code>rc</code>的左孩子斜率最大值。</p>
<p>显然是无法从父结点的左端点<code>l</code>看见<code>rc</code>左孩子的任一房子，因为全被挡住了；但右孩子情况未知。</p>
<p>这种情况下，<code>rc</code>的左孩子无法对答案有贡献，递归进<code>rc</code>的右孩子，也就是这行代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">0</span> + <span class="built_in">f</span>(rc, mid + <span class="number">1</span>, r, x);</span><br></pre></td></tr></table></figure></li>
<li><p>如果<code>lc</code>的斜率最大值，小于<code>rc</code>的左孩子斜率最大值。</p>
<p>此时<code>lc</code>就无法对<code>rc</code>的右孩子有影响，且<code>rc</code>的右孩子根据的左端点就是<code>mid + 1</code>，</p>
<p>那么就可以把<code>rc</code>的右孩子的贡献并入答案中，然后再对<code>rc左孩子</code>进行递归。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">f</span>(lc, l, mid, x) + (c[p] - c[lc]);</span><br></pre></td></tr></table></figure>
<p>但是要注意！！！！贡献绝对不是<code>c[rc右孩子]</code>，绝对不是！！！！！！！！！！！！！！！！！！！！！</p>
<p>再次观察代码，我们自始至终都没有直接保存过右孩子的贡献，都是左孩子贡献+递归右孩子的结果，没有可加性！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">c[p] = c[lc] + f(rc, mid + <span class="number">1</span>, r, id[lc]);</span><br></pre></td></tr></table></figure>
<p>最重要的是，<code>c[rc右孩子]</code>是<code>rc右孩子</code>以<code>(mid + 1 + r) &gt;&gt; 1</code>为左端点得到的结果，我们现在需知道<code>rc右孩子</code>以<code>mid + 1</code>为左端点时的贡献，完全就是两码事。</p>
<p>所以，需要使用<code>c[rc] - c[rc左孩子]</code>得到<code>c[rc右孩子]</code></p></li>
</ol>
<p>最终得到代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (p &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (p &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="type">int</span> n, m, h[maxn];</span><br><span class="line"><span class="comment">// 线段树</span></span><br><span class="line"><span class="comment">// id：最大斜率的h数组下标</span></span><br><span class="line"><span class="comment">// c：能看到的楼房个数</span></span><br><span class="line"><span class="type">int</span> id[maxn &lt;&lt; <span class="number">2</span>], c[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// x下标的斜率是否大于y下标的斜率</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!y) <span class="keyword">return</span> h[x];</span><br><span class="line">  <span class="keyword">return</span> (ll)h[x] * y &gt; (ll)h[y] * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in">g</span>(l, x);</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">g</span>(id[lc], x))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(lc, l, mid, x) + (c[p] - c[lc]);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> + <span class="built_in">f</span>(rc, mid + <span class="number">1</span>, r, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    h[x] = v;</span><br><span class="line">    id[p] = c[p] = l;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">update</span>(lc, l, mid, x, v);</span><br><span class="line">  <span class="keyword">if</span> (x &gt; mid) <span class="built_in">update</span>(rc, mid + <span class="number">1</span>, r, x, v);</span><br><span class="line">  id[p] = <span class="built_in">g</span>(id[lc], id[rc]) ? id[lc] : id[rc];</span><br><span class="line">  c[p] = c[lc] + <span class="built_in">f</span>(rc, mid + <span class="number">1</span>, r, id[lc]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="type">int</span> x, v;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; v;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, v);</span><br><span class="line">    cout &lt;&lt; c[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="升级想法">升级想法</h2>
<p>很多时候并没有可减性，比如取极值，按位与或等等。</p>
<p>所以可以改一下定义，<code>c</code>代表当前区间，<code>rc</code>的可见房屋数量；<code>f</code>是每个区间的总可见房屋数量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in">g</span>(l, x);</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">g</span>(id[lc], x))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(lc, l, mid, x) + c[p];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> + <span class="built_in">f</span>(rc, mid + <span class="number">1</span>, r, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，就不存在减法了。</p>
<p>总代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (p &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (p &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="type">int</span> n, m, h[maxn];</span><br><span class="line"><span class="comment">// 线段树</span></span><br><span class="line"><span class="comment">// id：最大斜率的h数组下标</span></span><br><span class="line"><span class="comment">// c：右子树能看到的楼房个数</span></span><br><span class="line"><span class="type">int</span> id[maxn &lt;&lt; <span class="number">2</span>], c[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// x下标的斜率是否大于y下标的斜率</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!y) <span class="keyword">return</span> h[x];</span><br><span class="line">  <span class="keyword">return</span> (ll)h[x] * y &gt; (ll)h[y] * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in">g</span>(l, x);</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">g</span>(id[lc], x))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(lc, l, mid, x) + c[p];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> + <span class="built_in">f</span>(rc, mid + <span class="number">1</span>, r, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    h[x] = v;</span><br><span class="line">    id[p] = l;</span><br><span class="line">    c[p] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">update</span>(lc, l, mid, x, v);</span><br><span class="line">  <span class="keyword">if</span> (x &gt; mid) <span class="built_in">update</span>(rc, mid + <span class="number">1</span>, r, x, v);</span><br><span class="line">  id[p] = <span class="built_in">g</span>(id[lc], id[rc]) ? id[lc] : id[rc];</span><br><span class="line">  c[p] = <span class="built_in">f</span>(rc, mid + <span class="number">1</span>, r, id[lc]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="type">int</span> x, v;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; v;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, v);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2>
<p>小粉兔大佬的<a
href="https://www.cnblogs.com/PinkRabbit/p/Segment-Tree-and-Prefix-Maximums.html">思路</a>，未来还需要磨砺啊~</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P5459 回转寿司</title>
    <url>/2024/09/09/P5459-%E5%9B%9E%E8%BD%AC%E5%AF%BF%E5%8F%B8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线段树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">const</span> ll lx = <span class="number">-1e10</span> - <span class="number">1e9</span>, rx = <span class="number">1e10</span>;</span><br><span class="line">ll L, R, a[maxn];</span><br><span class="line"><span class="type">int</span> n, tot, root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  ll lc, rc;</span><br><span class="line">  ll cnt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc(x) tr[x].lc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc(x) tr[x].rc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cnt(x) tr[x].cnt</span></span><br><span class="line">&#125; tr[<span class="number">55</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ++tot;</span><br><span class="line">  <span class="built_in">lc</span>(tot) = <span class="built_in">rc</span>(tot) = <span class="built_in">cnt</span>(tot) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; <span class="built_in">cnt</span>(p) = <span class="built_in">cnt</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">cnt</span>(<span class="built_in">rc</span>(p)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, ll l, ll r, ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    <span class="built_in">cnt</span>(p) += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ll mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= mid) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">lc</span>(p)) <span class="built_in">lc</span>(p) = <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">update</span>(<span class="built_in">lc</span>(p), l, mid, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; mid) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">rc</span>(p)) <span class="built_in">rc</span>(p) = <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">update</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> p, ll l, ll r, ll L, ll R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> <span class="built_in">cnt</span>(p);</span><br><span class="line">  ll mid = l + (r - l) / <span class="number">2</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= mid &amp;&amp; <span class="built_in">lc</span>(p)) ans += <span class="built_in">ask</span>(<span class="built_in">lc</span>(p), l, mid, L, R);</span><br><span class="line">  <span class="keyword">if</span> (R &gt; mid &amp;&amp; <span class="built_in">rc</span>(p)) ans += <span class="built_in">ask</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  root = <span class="built_in">build</span>();</span><br><span class="line">  <span class="built_in">update</span>(root, lx, rx, <span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; L &gt;&gt; R;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">    a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    ans += <span class="built_in">ask</span>(root, lx, rx, a[i] - R, a[i] - L);</span><br><span class="line">    <span class="built_in">update</span>(root, lx, rx, a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>对原数组求前缀和保存到数组<code>a</code>，那么区间和就简化为<code>L &lt;= a[r] - a[l - 1] &lt;= R</code>，</p>
<p>移两边，式子变成<code>a[r] - R &lt;= a[l - 1] &lt;= a[r] - L</code></p>
<p>从左到右遍历前缀和数组，每个点<code>a[i]</code>当做<code>a[r]</code>，求区间<code>[a[r] - R, a[r] - L]</code>有多少个点。</p>
<p>（当然，要手动把<code>0</code>加到前缀和数组里，<code>0</code>也算左端点<code>a[l - 1]</code>）</p>
<p>使用权值线段树，由于这里数据范围太大，最小值是<code>-1e5 * 1e5 - 1e9</code>，最大值是<code>1e5 * 1e5 - 1e9</code></p>
<p>采用动态开点线段树即可</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P4513 小白逛公园</title>
    <url>/2024/09/03/P4513-%E5%B0%8F%E7%99%BD%E9%80%9B%E5%85%AC%E5%9B%AD/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线段树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// lx：左边界开始，向右走的连续区间最大和</span></span><br><span class="line"><span class="comment">// rx：右边界开始，向左走的连续区间最大和</span></span><br><span class="line"><span class="comment">// s：区间和</span></span><br><span class="line"><span class="comment">// mx：子区间和的最大值，题目要求的</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  ll lx, rx, s, mx;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lx(x) tr[x].lx</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rx(x) tr[x].rx</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> s(x) tr[x].s</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mx(x) tr[x].mx</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc(x) x &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc(x) (x &lt;&lt; 1) + 1</span></span><br><span class="line">&#125; tr[<span class="number">4</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">s</span>(p) = <span class="built_in">s</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">s</span>(<span class="built_in">rc</span>(p));</span><br><span class="line">  <span class="built_in">lx</span>(p) = <span class="built_in">max</span>(<span class="built_in">lx</span>(<span class="built_in">lc</span>(p)), <span class="built_in">s</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">lx</span>(<span class="built_in">rc</span>(p)));</span><br><span class="line">  <span class="built_in">rx</span>(p) = <span class="built_in">max</span>(<span class="built_in">rx</span>(<span class="built_in">rc</span>(p)), <span class="built_in">s</span>(<span class="built_in">rc</span>(p)) + <span class="built_in">rx</span>(<span class="built_in">lc</span>(p)));</span><br><span class="line">  <span class="built_in">mx</span>(p) = <span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">mx</span>(<span class="built_in">lc</span>(p)), <span class="built_in">mx</span>(<span class="built_in">rc</span>(p))), <span class="built_in">rx</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">lx</span>(<span class="built_in">rc</span>(p)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    <span class="built_in">lx</span>(p) = <span class="built_in">rx</span>(p) = <span class="built_in">s</span>(p) = <span class="built_in">mx</span>(p) = a[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid), <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, ll v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) == x &amp;&amp; <span class="built_in">r</span>(p) == x) &#123;</span><br><span class="line">    <span class="built_in">lx</span>(p) = <span class="built_in">rx</span>(p) = <span class="built_in">s</span>(p) = <span class="built_in">mx</span>(p) = v;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">update</span>(<span class="built_in">lc</span>(p), x, v);</span><br><span class="line">  <span class="keyword">if</span> (x &gt; mid) <span class="built_in">update</span>(<span class="built_in">rc</span>(p), x, v);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) <span class="keyword">return</span> tr[p];</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 只在左边</span></span><br><span class="line">  <span class="keyword">if</span> (r &lt;= mid)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ask</span>(<span class="built_in">lc</span>(p), l, r);</span><br><span class="line">  <span class="comment">// 只在右边</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ask</span>(<span class="built_in">rc</span>(p), l, r);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    node res, lc = <span class="built_in">ask</span>(<span class="built_in">lc</span>(p), l, r), rc = <span class="built_in">ask</span>(<span class="built_in">rc</span>(p), l, r);</span><br><span class="line">    res.s = lc.s + rc.s;</span><br><span class="line">    res.lx = <span class="built_in">max</span>(lc.lx, lc.s + rc.lx);</span><br><span class="line">    res.rx = <span class="built_in">max</span>(rc.rx, rc.s + lc.rx);</span><br><span class="line">    res.mx = <span class="built_in">max</span>(<span class="built_in">max</span>(lc.mx, rc.mx), lc.rx + rc.lx);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="type">int</span> opt, x, y;</span><br><span class="line">  ll v;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;opt);</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">      <span class="keyword">if</span> (x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">ask</span>(<span class="number">1</span>, x, y).mx);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;x, &amp;v);</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, x, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>求子区间和的最大值，单点修改区间询问考虑使用线段树。</p>
<p>答案子区间所处位置只有两种可能：</p>
<ol type="1">
<li><p>包含<code>mid</code>，那么答案就等于从<code>mid</code>开始分别向左、向右延伸得到的最大和</p>
<p>也就是<code>左孩子rx + 右孩子lx</code></p>
<img src="/2024/09/03/P4513-%E5%B0%8F%E7%99%BD%E9%80%9B%E5%85%AC%E5%9B%AD/1.png" class="" title="image-20240902234425688"></li>
<li><p>不包含<code>mid</code>，要么出现在左孩子，要么出现在右孩子</p>
<p>即<code>max(mx(左孩子), mx(右孩子))</code></p></li>
</ol>
<p>所以每段区间的答案等于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mx</span>(p) = <span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">mx</span>(<span class="built_in">lc</span>(p)), <span class="built_in">mx</span>(<span class="built_in">rc</span>(p))), <span class="built_in">rx</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">lx</span>(<span class="built_in">rc</span>(p)));</span><br></pre></td></tr></table></figure>
<p>如何计算每个区间的<code>lx</code>和<code>rx</code>呢？</p>
<p>每个区间的<code>lx</code>，</p>
<p>要么向右最远处的下标小于等于<code>mid</code>，此时等于左孩子的<code>lx</code>；</p>
<p>要么最远处的下标大于<code>mid</code>，此时等于左孩子的区间和<code>s</code>加上右孩子的<code>lx</code>，即</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lx</span>(p) = <span class="built_in">max</span>(<span class="built_in">lx</span>(<span class="built_in">lc</span>(p)), <span class="built_in">s</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">lx</span>(<span class="built_in">rc</span>(p)));</span><br></pre></td></tr></table></figure>
<p>同理，每个区间的<code>rx</code>，</p>
<p>要么向左最远处的下标大于<code>mid</code>，此时等于右孩子的<code>rx</code>；</p>
<p>要么向左最远处的下标小于等于<code>mid</code>，此时等于右孩子的区间和<code>s</code>加上左孩子的<code>rx</code>，即</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rx</span>(p) = <span class="built_in">max</span>(<span class="built_in">rx</span>(<span class="built_in">rc</span>(p)), <span class="built_in">s</span>(<span class="built_in">rc</span>(p)) + <span class="built_in">rx</span>(<span class="built_in">lc</span>(p)));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P5522 棠梨煎雪</title>
    <url>/2024/09/06/P5522-%E6%A3%A0%E6%A2%A8%E7%85%8E%E9%9B%AA/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线段树</li>
<li>状态压缩</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line">ll a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  ll s;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> s(x) tr[x].s</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc(x) x * 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc(x) x * 2 + 1</span></span><br><span class="line">&#125; tr[<span class="number">4</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">merge</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">-1</span> || y == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  ll a, b, s = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * m; i += <span class="number">2</span>) &#123;</span><br><span class="line">    a = (x &gt;&gt; i) &amp; <span class="number">3ll</span>, b = (y &gt;&gt; i) &amp; <span class="number">3ll</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">2ll</span>) &#123;</span><br><span class="line">      s |= (b &lt;&lt; i);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">2ll</span> || a == b) &#123;</span><br><span class="line">      s |= (a &lt;&lt; i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; <span class="built_in">s</span>(p) = <span class="built_in">merge</span>(<span class="built_in">s</span>(<span class="built_in">lc</span>(p)), <span class="built_in">s</span>(<span class="built_in">rc</span>(p))); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">count</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  ll cnt = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * m; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (((x &gt;&gt; i) &amp; <span class="number">3ll</span>) == <span class="number">2ll</span>) cnt *= <span class="number">2ll</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    <span class="built_in">s</span>(p) = a[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid), <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, ll v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) == <span class="built_in">r</span>(p)) &#123;</span><br><span class="line">    <span class="built_in">s</span>(p) = v;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">update</span>(<span class="built_in">lc</span>(p), x, v);</span><br><span class="line">  <span class="keyword">if</span> (x &gt; mid) <span class="built_in">update</span>(<span class="built_in">rc</span>(p), x, v);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) <span class="keyword">return</span> <span class="built_in">s</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) &#123;</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">ask</span>(<span class="built_in">lc</span>(p), l, r), <span class="built_in">ask</span>(<span class="built_in">rc</span>(p), l, r));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">ask</span>(<span class="built_in">lc</span>(p), l, r);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ask</span>(<span class="built_in">rc</span>(p), l, r);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;m, &amp;n, &amp;q);</span><br><span class="line">  <span class="type">char</span> str[<span class="number">64</span>];</span><br><span class="line">  ll s = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">      s |= (str[j] == <span class="string">&#x27;?&#x27;</span> ? <span class="number">2ll</span> : (str[j] - <span class="number">48</span>)) &lt;&lt; (<span class="number">2</span> * j);</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="type">int</span> opt, x, y;</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;opt, &amp;x);</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;y);</span><br><span class="line">      ans ^= <span class="built_in">count</span>(<span class="built_in">ask</span>(<span class="number">1</span>, x, y));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">      s = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        s |= (str[j] == <span class="string">&#x27;?&#x27;</span> ? <span class="number">2ll</span> : (str[j] - <span class="number">48</span>)) &lt;&lt; (<span class="number">2</span> * j);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, x, s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>实际上，就是所有字符串的对应每一位进行运算；每一位都有三种情况，所以使用两个二进制位，</p>
<p><code>00</code>代表<code>0</code>，<code>01</code>代表<code>1</code>，<code>10</code>代表<code>?</code>，</p>
<p>字符串最长<code>30</code>位，那么使用状态压缩最长<code>60</code>位，使用<code>long long</code>即可保存，该值记为<code>s</code></p>
<p>任意两个状态压缩的串儿合并时，就是进行按位运算：</p>
<ol type="1">
<li><p>如果两者有一个<code>?</code>，那么答案取决于另一个</p>
<p>比如<code>?</code>和<code>1</code>，肯定是<code>1</code>；</p>
<p><code>?</code>和<code>0</code>，肯定是<code>0</code>；</p>
<p><code>?</code>和<code>?</code>，还是<code>?</code></p></li>
<li><p>如果两者都是数字，且相等，那么就等于该数</p></li>
<li><p>如果两者都是数字，且不等，那么合并后的新状态违法，记<code>s</code>等于<code>-1</code></p></li>
</ol>
<p>至于答案，直接统计<code>s</code>中<code>2</code>的个数的累乘即可。</p>
<p>有<code>s = 00 10 00 10 00 10</code>，有3个<code>2</code>，根据乘法原理答案就等于<code>2 * 2 * 2 = 8</code></p>
<p>有<code>s = 00 00 01 01 01 01</code>，有0个<code>2</code>，那么只有<code>1</code>种情况</p>
<p>有<code>s = -1</code>，只有0种合法情况</p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>状态压缩</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P5579 Siano</title>
    <url>/2024/09/08/P5579-Siano/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线段树</li>
<li>二分</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// mx：区间最大值</span></span><br><span class="line"><span class="comment">// s：区间和</span></span><br><span class="line"><span class="comment">// inc：区间固定的增值</span></span><br><span class="line"><span class="comment">// tag_add：增加标签</span></span><br><span class="line"><span class="comment">// tag_chop：切割标签</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  ll mx, s, inc;</span><br><span class="line">  ll tag_add, tag_chop;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mx(x) tr[x].mx</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> s(x) tr[x].s</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inc(x) tr[x].inc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tag_add(x) tr[x].tag_add</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tag_chop(x) tr[x].tag_chop</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc(x) x * 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc(x) x * 2 + 1</span></span><br><span class="line">&#125; tr[<span class="number">4</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 由于是有序，区间最大值肯定来源于右孩子</span></span><br><span class="line">  <span class="built_in">mx</span>(p) = <span class="built_in">mx</span>(<span class="built_in">rc</span>(p));</span><br><span class="line">  <span class="built_in">s</span>(p) = <span class="built_in">s</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">s</span>(<span class="built_in">rc</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r, <span class="built_in">tag_chop</span>(p) = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    <span class="built_in">inc</span>(p) = a[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid), <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">inc</span>(p) = <span class="built_in">inc</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">inc</span>(<span class="built_in">rc</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// t：天数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p, ll t)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">s</span>(p) += t * <span class="built_in">inc</span>(p);</span><br><span class="line">  <span class="built_in">mx</span>(p) += t * a[<span class="built_in">r</span>(p)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v：阈值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chop</span><span class="params">(<span class="type">int</span> p, ll v)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">s</span>(p) = (<span class="built_in">r</span>(p) - <span class="built_in">l</span>(p) + <span class="number">1</span>) * v;</span><br><span class="line">  <span class="built_in">mx</span>(p) = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">tag_chop</span>(p) != <span class="number">-1</span>) &#123;</span><br><span class="line">    ll v = <span class="built_in">tag_chop</span>(p);</span><br><span class="line">    <span class="built_in">chop</span>(<span class="built_in">lc</span>(p), v), <span class="built_in">chop</span>(<span class="built_in">rc</span>(p), v);</span><br><span class="line">    <span class="built_in">tag_chop</span>(<span class="built_in">lc</span>(p)) = <span class="built_in">tag_chop</span>(<span class="built_in">rc</span>(p)) = v;</span><br><span class="line">    <span class="built_in">tag_add</span>(<span class="built_in">lc</span>(p)) = <span class="built_in">tag_add</span>(<span class="built_in">rc</span>(p)) = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">tag_chop</span>(p) = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">tag_add</span>(p)) &#123;</span><br><span class="line">    ll t = <span class="built_in">tag_add</span>(p);</span><br><span class="line">    <span class="built_in">add</span>(<span class="built_in">lc</span>(p), t), <span class="built_in">add</span>(<span class="built_in">rc</span>(p), t);</span><br><span class="line">    <span class="built_in">tag_add</span>(<span class="built_in">lc</span>(p)) += t, <span class="built_in">tag_add</span>(<span class="built_in">rc</span>(p)) += t;</span><br><span class="line">    <span class="built_in">tag_add</span>(p) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, ll v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= <span class="built_in">l</span>(p) &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) &#123;</span><br><span class="line">    <span class="built_in">chop</span>(p, v);</span><br><span class="line">    <span class="built_in">tag_add</span>(p) = <span class="number">0</span>, <span class="built_in">tag_chop</span>(p) = v;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">update</span>(<span class="built_in">lc</span>(p), l, r, v);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) <span class="built_in">update</span>(<span class="built_in">rc</span>(p), l, r, v);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大于v里选最小的，所以优先左孩子里选</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> p, ll v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) == <span class="built_in">r</span>(p)) <span class="keyword">return</span> <span class="built_in">mx</span>(p) &gt; v ? <span class="built_in">l</span>(p) : <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>, ans = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 左孩子最大值大于v，说明可能有解，向左走</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">mx</span>(<span class="built_in">lc</span>(p)) &gt; v) ans = <span class="built_in">search</span>(<span class="built_in">lc</span>(p), v);</span><br><span class="line">  <span class="keyword">if</span> (~ans) <span class="keyword">return</span> ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">search</span>(<span class="built_in">rc</span>(p), v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= <span class="built_in">l</span>(p) &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) <span class="keyword">return</span> <span class="built_in">s</span>(p);</span><br><span class="line">  <span class="built_in">down</span>(p);</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) ans += <span class="built_in">ask</span>(<span class="built_in">lc</span>(p), l, r);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) ans += <span class="built_in">ask</span>(<span class="built_in">rc</span>(p), l, r);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  ll pre = <span class="number">0</span>, t, d, v;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;d, &amp;v);</span><br><span class="line">    t = d - pre;</span><br><span class="line">    pre = d;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>, t), <span class="built_in">tag_add</span>(<span class="number">1</span>) += t;</span><br><span class="line">    <span class="type">int</span> idx = <span class="built_in">search</span>(<span class="number">1</span>, v);</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="built_in">ask</span>(<span class="number">1</span>, idx, n) - (n - idx + <span class="number">1</span>) * v;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, idx, n, v);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>一行草，按照<code>a</code>数组每天进行自增；</p>
<p>每次给你一个天数<code>d</code>和一个阈值<code>v</code>；要你在第<code>d</code>天时，删除大于<code>v</code>的部分，并输出删除部分的总和。</p>
<p><code>a</code>数组对顺序不敏感，所以将其排序，变成一个升序数组，显然右半部分的草一定大于等于左半部分。</p>
<p>也就是说，割草这一操作范围就是<code>idx ~ n</code>，是一个类似后缀的范围。</p>
<p><code>idx</code>就是大于<code>v</code>里下标最小的，由于数组已经有序，可以使用二分进行查找。</p>
<p>又因为是连续范围的修改，所以直接整合上线段树二分。</p>
<hr />
<p>线段树的标签优先级需要注意，</p>
<p>同一区间，若先有<code>tag_add</code>再有<code>tag_chop</code>，那么前者会被后者覆盖掉，因为不管你加了多少，都得砍成<code>tag_chop</code>；</p>
<p>若先有<code>tag_chop</code>再有<code>tag_add</code>，那么<code>tag_add</code>可以累加。</p>
<p>所以在下传标签时，应该先传<code>tag_chop</code>，再传<code>tag_add</code></p>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P6492 STEP</title>
    <url>/2024/09/03/P6492-STEP/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线段树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, q, a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  <span class="type">int</span> lx, rx, mx;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lx(x) tr[x].lx</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rx(x) tr[x].rx</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mx(x) tr[x].mx</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc(x) x * 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc(x) x * 2 + 1</span></span><br><span class="line">&#125; tr[<span class="number">4</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a[mid] != a[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="built_in">mx</span>(p) = <span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">mx</span>(<span class="built_in">lc</span>(p)), <span class="built_in">mx</span>(<span class="built_in">rc</span>(p))), <span class="built_in">rx</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">lx</span>(<span class="built_in">rc</span>(p)));</span><br><span class="line">    <span class="built_in">lx</span>(p) = <span class="built_in">mx</span>(<span class="built_in">lc</span>(p)) == <span class="built_in">r</span>(<span class="built_in">lc</span>(p)) - <span class="built_in">l</span>(<span class="built_in">lc</span>(p)) + <span class="number">1</span> ? <span class="built_in">mx</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">lx</span>(<span class="built_in">rc</span>(p))</span><br><span class="line">                                                 : <span class="built_in">lx</span>(<span class="built_in">lc</span>(p));</span><br><span class="line">    <span class="built_in">rx</span>(p) = <span class="built_in">mx</span>(<span class="built_in">rc</span>(p)) == <span class="built_in">r</span>(<span class="built_in">rc</span>(p)) - <span class="built_in">l</span>(<span class="built_in">rc</span>(p)) + <span class="number">1</span> ? <span class="built_in">mx</span>(<span class="built_in">rc</span>(p)) + <span class="built_in">rx</span>(<span class="built_in">lc</span>(p))</span><br><span class="line">                                                 : <span class="built_in">rx</span>(<span class="built_in">rc</span>(p));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">mx</span>(p) = <span class="built_in">max</span>(<span class="built_in">mx</span>(<span class="built_in">lc</span>(p)), <span class="built_in">mx</span>(<span class="built_in">rc</span>(p)));</span><br><span class="line">    <span class="built_in">lx</span>(p) = <span class="built_in">lx</span>(<span class="built_in">lc</span>(p)), <span class="built_in">rx</span>(p) = <span class="built_in">rx</span>(<span class="built_in">rc</span>(p));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    <span class="built_in">lx</span>(p) = <span class="built_in">rx</span>(p) = <span class="built_in">mx</span>(p) = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">build</span>(<span class="built_in">lc</span>(p), l, mid), <span class="built_in">build</span>(<span class="built_in">rc</span>(p), mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">up</span>(p, mid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) == x &amp;&amp; <span class="built_in">r</span>(p) == x) &#123;</span><br><span class="line">    a[x] ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">update</span>(<span class="built_in">lc</span>(p), x);</span><br><span class="line">  <span class="keyword">if</span> (x &gt; mid) <span class="built_in">update</span>(<span class="built_in">rc</span>(p), x);</span><br><span class="line">  <span class="built_in">up</span>(p, mid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">mx</span>(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>考虑线段树。</p>
<p>最长满足要求的子串，要么经过中间点<code>mid</code>，要么在左孩子，要么在右孩子。</p>
<p><code>lx(p)</code>代表当前节点<code>p</code>的区间从左边界向右走，能满足要求的最长连续子串长度；</p>
<p><code>rx(p)</code>代表当前节点<code>p</code>的区间从右边界向左走，能满足要求的最长连续子串长度。</p>
<p>如果<code>a[mid] != a[mid + 1]</code>，说明左孩子与右孩子可以有交集，很容易得到下面代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mx</span>(p) = <span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">mx</span>(<span class="built_in">lc</span>(p)), <span class="built_in">mx</span>(<span class="built_in">rc</span>(p))), <span class="built_in">rx</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">lx</span>(<span class="built_in">rc</span>(p)));</span><br><span class="line"><span class="built_in">lx</span>(p) = <span class="built_in">mx</span>(<span class="built_in">lc</span>(p)) == <span class="built_in">r</span>(<span class="built_in">lc</span>(p)) - <span class="built_in">l</span>(<span class="built_in">lc</span>(p)) + <span class="number">1</span> ? <span class="built_in">mx</span>(<span class="built_in">lc</span>(p)) + <span class="built_in">lx</span>(<span class="built_in">rc</span>(p))</span><br><span class="line">                                             : <span class="built_in">lx</span>(<span class="built_in">lc</span>(p));</span><br><span class="line"><span class="built_in">rx</span>(p) = <span class="built_in">mx</span>(<span class="built_in">rc</span>(p)) == <span class="built_in">r</span>(<span class="built_in">rc</span>(p)) - <span class="built_in">l</span>(<span class="built_in">rc</span>(p)) + <span class="number">1</span> ? <span class="built_in">mx</span>(<span class="built_in">rc</span>(p)) + <span class="built_in">rx</span>(<span class="built_in">lc</span>(p))</span><br><span class="line">                                             : <span class="built_in">rx</span>(<span class="built_in">rc</span>(p));</span><br></pre></td></tr></table></figure>
<p>如果<code>a[mid] == a[mid + 1]</code>，说明左右孩子不可以有交集，那答案就取两者最大：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mx</span>(p) = <span class="built_in">max</span>(<span class="built_in">mx</span>(<span class="built_in">lc</span>(p)), <span class="built_in">mx</span>(<span class="built_in">rc</span>(p)));</span><br><span class="line"><span class="built_in">lx</span>(p) = <span class="built_in">lx</span>(<span class="built_in">lc</span>(p)), <span class="built_in">rx</span>(p) = <span class="built_in">rx</span>(<span class="built_in">rc</span>(p));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-350. 巡逻</title>
    <url>/2024/08/18/acwing-350-%E5%B7%A1%E9%80%BB/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>树的直径</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>, maxm = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, k, tot = <span class="number">1</span>, l1, l2, head[maxn], d[maxn];</span><br><span class="line"><span class="type">int</span> ver[maxm], edge[maxm], nxt[maxm];</span><br><span class="line"><span class="comment">// 每条边的记号</span></span><br><span class="line"><span class="type">int</span> id[maxm];</span><br><span class="line"><span class="type">bool</span> v[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">  ver[++tot] = y, edge[tot] = z, nxt[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="comment">// 在树中，点到点之间只有唯一一条路径</span></span><br><span class="line">  <span class="comment">// 所以d数组刚好也作为标志数组</span></span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  q.<span class="built_in">push</span>(s);</span><br><span class="line">  d[s] = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> t = s;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (d[x] &gt; d[t]) t = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">      <span class="type">int</span> y = ver[i];</span><br><span class="line">      <span class="keyword">if</span> (~d[y]) <span class="keyword">continue</span>;</span><br><span class="line">      d[y] = d[x] + edge[i];</span><br><span class="line">      id[y] = i;</span><br><span class="line">      q.<span class="built_in">push</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (p != q) &#123;</span><br><span class="line">    edge[id[q]] = <span class="number">-1</span>;</span><br><span class="line">    edge[id[q] ^ <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    q = ver[id[q] ^ <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  v[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">    <span class="type">int</span> y = ver[i];</span><br><span class="line">    <span class="keyword">if</span> (v[y]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dp</span>(y);</span><br><span class="line">    l2 = <span class="built_in">max</span>(l2, d[x] + d[y] + edge[i]);</span><br><span class="line">    d[x] = <span class="built_in">max</span>(d[x], d[y] + edge[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x, y, z, i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="built_in">add</span>(x, y, <span class="number">1</span>), <span class="built_in">add</span>(y, x, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> p = <span class="built_in">bfs</span>(<span class="number">1</span>), q = <span class="built_in">bfs</span>(p);</span><br><span class="line">  l1 = d[q];</span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">2</span> * (n - <span class="number">1</span>) - l1 + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 直径部分取反</span></span><br><span class="line">  <span class="built_in">update</span>(p, q);</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  <span class="built_in">dp</span>(<span class="number">1</span>);</span><br><span class="line">  cout &lt;&lt; <span class="number">2</span> * (n - <span class="number">1</span>) - l1 + <span class="number">1</span> - l2 + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>在不加路径之前，总的开销是<code>2(n-1)</code>，因为每条路径都必须重复两次。</p>
<p>每加一条路径，路径两端点之间的原路径就会少走一次，新加的路径走一次（题目还说必须只能走一次），</p>
<p>所以选择树中的最长路径（直径）两端点进行连接以达到最佳效果。</p>
<p>假设原图如下，<code>1</code>为起点，每条路径都要走两次（如箭头所示），直径为<code>2 - 1 - 3 - 5 - 8</code>这一段</p>
<p>这里的边权均为非负，可以使用两次BFS进行求解直径。</p>
<img src="/2024/08/18/acwing-350-%E5%B7%A1%E9%80%BB/1.png" class="" title="image-20240818195137293">
<p>当链接<code>2</code>和<code>8</code>两点后，<code>2 - 1 - 3 - 5 - 8</code>整条直径只需要走一次，</p>
<p>假设这段直径长度为<code>l1</code>，当前的路径开销就是<code>2(n-1) - l1 + 1</code></p>
<img src="/2024/08/18/acwing-350-%E5%B7%A1%E9%80%BB/2.png" class="" title="image-20240818200231707">
<p>将直径部分全部取反，再次寻找新直径（这里只能用树形dp求），会得到以下两种情况：</p>
<ol type="1">
<li><p>新的直径不包含上一条直径的任一条路径。</p>
<p>譬如<code>6 - 5 - 7</code>为新直径，那么将<code>6</code>与<code>7</code>连接建立新路，如图所示。</p>
<p>假设新直径长度为<code>l2</code>，那么当前路径总开销为<code>2(n-1) - l1 + 1 - l2 + 1</code></p>
<img src="/2024/08/18/acwing-350-%E5%B7%A1%E9%80%BB/3.png" class="" title="image-20240818202534416"></li>
<li><p>新的直径包含上一条直径的某一条路径。</p>
<p>假设新直径为<code>6 - 5 - 3 - 4</code>，连接<code>6</code>与<code>4</code>建立新路，如图所示。</p>
<p><code>5 - 3</code>是两条直径的重叠部分，显然任意情况下它一定会被走两次；</p>
<p>处理第一条直径时，它被计算走了一次，所以这里需要让它再被计算一次，这正是取反的妙处。</p>
<p>在这里，<code>新直径l2 = 1 (6到5的边权) - 1 (5到3的边权) + 1 (3到4的边权)</code>，</p>
<p>减去<code>l2</code>不就相当于<strong>新直径其它部分正常减去一次，而<code>5 - 3</code>部分再走一次</strong>。</p>
<p>那么当前路径总开销依旧为<code>2(n-1) - l1 + 1 - l2 + 1</code></p>
<img src="/2024/08/18/acwing-350-%E5%B7%A1%E9%80%BB/4.png" class="" title="image-20240818203028222"></li>
</ol>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-351. 树网的核</title>
    <url>/2024/08/19/acwing-351-%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>树的直径</li>
<li>二分</li>
<li>单调队列</li>
<li>贪心</li>
<li>双指针</li>
<li>前缀和</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<p>首先证明两个直径的性质。</p>
<p>第一条，多条直径必相交于一点或一条公共路径。</p>
<p>假设<code>A1</code>到<code>B1</code>、<code>A2</code>到<code>B2</code>是两条不相交的直径，分别简写为<code>l1</code>和<code>l2</code></p>
<p>根据树的连通性原理，<code>A2</code>肯定与<code>l1</code>的某个点<code>C1</code>连通，这样<code>A2</code>才能与<code>A1</code>、<code>B1</code>连通</p>
<p>问题来了，<code>d == a + b</code>，且都是最长长度（因为是直径），那么<code>A1 - C1 - A2 - B2</code>这条路径不是更长吗？！</p>
<p>长度高达<code>a + c + d</code>，相当于<code>a + b + a + c</code>，远大于<code>a + b</code>，</p>
<p>这与直径的定义相悖，得证。</p>
<img src="/2024/08/19/acwing-351-%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8/1.png" class="" title="image-20240819003927727">
<p>第二条，任意两个<strong>同一侧</strong>的<strong>直径端点</strong>到相同直径分叉点的距离均相等。</p>
<p>假设有直径<code>A1 - C - D - B1</code>，还有直径<code>A2 - C - D - B2</code>，<code>CD</code>部分是共有的，长度设为<code>t</code>。</p>
<p>假设不平分，那么假设<code>a &gt; b</code>，<code>d &gt; c</code>，</p>
<p>显然得到<code>a + d + t &gt; b + c + t</code>，也就是<code>A2 - C - D - B1</code>大于<code>A1 - C - D - B2</code>，这与直径的定义相悖。</p>
<p>所以<code>a</code>一定等于<code>c</code>，<code>b</code>也一定等于<code>d</code>。</p>
<p>证毕。</p>
<img src="/2024/08/19/acwing-351-%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8/2.png" class="" title="image-20240819024014175">
<hr />
<p>概括一下题意：</p>
<blockquote>
<p>选一条直径，直径上选一段路径。</p>
<p>要让全树所有点，到这条路径的最大距离最小</p>
</blockquote>
<p>由于本题所有的边权均为非负，那么直径的端点显然只能是叶子节点，否则还能再长。</p>
<p>整个树可以抽象如下：</p>
<p><code>1</code>到<code>2</code>是一条直径，<code>3</code>到<code>4</code>是一条直径，<code>5</code>和<code>6</code>是直径分叉点，ABCDEF均为子树。</p>
<p>结合上述两条性质，选哪条直径对最大距离压根没有影响....</p>
<p>因为<code>1 - 5</code>和<code>3 - 5</code>距离完全相同，<code>2 - 6</code>和<code>4 - 6</code>距离也完全相同，其余子树都接在直径们的公共路径上。</p>
<p>所以直接两次BFS求出任意一条直径即可拿来做文章。</p>
<img src="/2024/08/19/acwing-351-%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8/3.png" class="" title="image-20240819143201446">
<h2 id="二分">二分</h2>
<p><code>最大值最小</code>显然符合二分的性质，考虑验证条件。</p>
<p>设最大距离为<code>mid</code>，如果每个点到所选路径的最大距离都不会超过<code>mid</code>，验证成功。</p>
<p>设直径的两端点分别为<code>p</code>和<code>q</code>，令它俩各向内收缩<code>mid</code>距离，分别到达点<code>u</code>和<code>v</code>，作图所示。</p>
<img src="/2024/08/19/acwing-351-%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8/4.png" class="" title="image-20240819153248278">
<ol type="1">
<li><p>如果<code>u - v</code>路径长度大于<code>s</code>，说明不满足题意。</p></li>
<li><p>子树<code>D</code>在<code>p - u</code>路径上，子树<code>E</code>在<code>q - v</code>路径上，</p>
<p>那么<code>D</code>或<code>E</code>的任意点到<code>u - v</code>的路径长度都不可能大于<code>mid</code>，否则<code>D 或 E - u - v - q</code>能成为新的直径。</p>
<p>换句话说，<code>p</code>和<code>q</code>尽量向内收缩的过程中，顺带还能确保所经路径上的其他子树的最大距离不会超过<code>mid</code>！</p>
<p>所以，如果<code>u &gt; v</code>，说明两侧子树到直径的任意子路径的最大长度都不会超过<code>mid</code></p></li>
<li><p>如果<code>u &lt; v</code>且<code>u - v</code>长度小于<code>s</code>，说明<code>u - v</code>这一段路径的子树的最大长度还需我们验证。</p>
<p>（根据第2条，<code>p - u</code>和<code>q - v</code>两条路径中的子树的最大长度必小于<code>mid</code>，无须验证）</p>
<p>我们把直径上的所有点都设置为<code>已访问</code>，然后令<code>u - v</code>这条路径上的所有点执行dfs求该点能到的最远距离，</p>
<p>这样就能找到图上A、B、C等子树到<code>u - v</code>的最远距离了。</p></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e5</span> + <span class="number">50</span>, maxm = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, s, tot = <span class="number">1</span>, head[maxm], ver[maxm], edge[maxm], nxt[maxm];</span><br><span class="line">ll d[maxm], id[maxm];</span><br><span class="line"><span class="type">bool</span> v[maxm];</span><br><span class="line">vector&lt;pair&lt;ll, ll&gt;&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">  ver[++tot] = y, edge[tot] = z, nxt[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> bg)</span> </span>&#123;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  d[bg] = <span class="number">0</span>, q.<span class="built_in">push</span>(bg);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">      <span class="type">int</span> y = ver[i];</span><br><span class="line">      <span class="keyword">if</span> (~d[y]) <span class="keyword">continue</span>;</span><br><span class="line">      q.<span class="built_in">push</span>(y);</span><br><span class="line">      d[y] = d[x] + edge[i];</span><br><span class="line">      id[y] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ed = bg;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[i] &gt; d[ed]) ed = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">route</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (q != p) &#123;</span><br><span class="line">    path.<span class="built_in">push_back</span>(&#123;q, d[q]&#125;);</span><br><span class="line">    q = ver[id[q] ^ <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  path.<span class="built_in">push_back</span>(&#123;q, d[q]&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mx_dis</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  v[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (ll i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">    ll y = ver[i];</span><br><span class="line">    <span class="keyword">if</span> (v[y]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">mx_dis</span>(y);</span><br><span class="line">    d[x] = <span class="built_in">max</span>(d[x], d[y] + edge[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll mid)</span> </span>&#123;</span><br><span class="line">  ll p = <span class="number">0</span>, q = path.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// p向中间走，假设停到u</span></span><br><span class="line">  <span class="keyword">while</span> (p + <span class="number">1</span> &lt; path.<span class="built_in">size</span>() &amp;&amp; path[p + <span class="number">1</span>].second &lt;= mid) ++p;</span><br><span class="line">  <span class="comment">// q向中间走，假设停到v</span></span><br><span class="line">  <span class="keyword">while</span> (q - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; path.<span class="built_in">back</span>().second - path[q - <span class="number">1</span>].second &lt;= mid) --q;</span><br><span class="line">  <span class="comment">// p &gt; q，说明直径两端所有的子树到uv路径的距离都小于mid</span></span><br><span class="line">  <span class="keyword">if</span> (p &gt; q) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// uv路径长度大于s，不满足题意</span></span><br><span class="line">  <span class="keyword">if</span> (path[q].second - path[p].second &gt; s) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v)), <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  <span class="comment">// 直径所有点都设为已访问</span></span><br><span class="line">  <span class="comment">// 求“直径上的点到其他子树的最远距离”就不会经过直径了</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>(); ++i) v[path[i].first] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = p; i &lt;= q; ++i) &#123;</span><br><span class="line">    <span class="built_in">mx_dis</span>(path[i].first);</span><br><span class="line">    <span class="keyword">if</span> (d[path[i].first] &gt; mid) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">  ll sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x, y, z, i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    <span class="built_in">add</span>(x, y, z), <span class="built_in">add</span>(y, x, z);</span><br><span class="line">    sum += z;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 寻找任意一条直径</span></span><br><span class="line">  <span class="type">int</span> p = <span class="built_in">bfs</span>(<span class="number">1</span>), q = <span class="built_in">bfs</span>(p);</span><br><span class="line">  <span class="comment">// 保存整条直径</span></span><br><span class="line">  <span class="built_in">route</span>(p, q);</span><br><span class="line">  <span class="built_in">reverse</span>(path.<span class="built_in">begin</span>(), path.<span class="built_in">end</span>());</span><br><span class="line">  ll l = <span class="number">0</span>, r = sum;</span><br><span class="line">  <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">    ll mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">      r = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调队列与暴力">单调队列与暴力</h2>
<p>抛开二分，我们直接考虑最大距离最小的情况。</p>
<p>当<code>i</code>、<code>j</code>两个游标在直径上移动时，可以发现，当前的路径最大值取决于以下式子：</p>
<blockquote>
<p>max(<code>p</code>到游标<code>i</code>的距离，<code>i</code>到<code>j</code>路径中子树的最大距离，<code>q</code>到游标<code>j</code>的距离)</p>
</blockquote>
<img src="/2024/08/19/acwing-351-%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8/5.png" class="" title="image-20240819181106086">
<p>在固定<code>i</code>的情况下，<code>j</code>越大，<code>q</code>到<code>j</code>的距离肯定更小，所以有两种办法：</p>
<ol type="1">
<li><p><code>i</code>与<code>j</code>维护一个单调队列，维护<code>i</code>到<code>j</code>之间子树的最大距离；</p>
<p>只要<code>i</code>到<code>j</code>的距离不超过<code>s</code>，<code>j</code>就一直向右扩张（贪心思路），在过程中比较上述式子。</p></li>
<li><p>求最大值的运算具有结合律和分配律，两个游标一定会经过直径上的所有子树；</p>
<p>那倒不如直接暴力求出所有子树的最大距离，是个定值，记为<code>mx_d</code>；</p>
<p>然后<code>i</code>、<code>j</code>俩游标正常移动，直接比较下述式子即可：</p>
<blockquote>
<p>max(<code>p</code>到游标<code>i</code>的距离，<code>mx_d</code>，<code>q</code>到游标<code>j</code>的距离)</p>
</blockquote></li>
</ol>
<h3 id="单调队列的写法">单调队列的写法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e5</span> + <span class="number">50</span>, maxm = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, s, t, tot = <span class="number">1</span>, head[maxm], ver[maxm], edge[maxm], nxt[maxm];</span><br><span class="line"><span class="type">int</span> d[maxm], id[maxm];</span><br><span class="line"><span class="type">bool</span> v[maxm];</span><br><span class="line"><span class="type">int</span> hd, tl, a[maxn], b[maxn], sum[maxn], dq[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">  ver[++tot] = y, edge[tot] = z, nxt[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> bg)</span> </span>&#123;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  d[bg] = <span class="number">0</span>, q.<span class="built_in">push</span>(bg);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">      <span class="type">int</span> y = ver[i];</span><br><span class="line">      <span class="keyword">if</span> (~d[y]) <span class="keyword">continue</span>;</span><br><span class="line">      q.<span class="built_in">push</span>(y);</span><br><span class="line">      d[y] = d[x] + edge[i];</span><br><span class="line">      id[y] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ed = bg;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[i] &gt; d[ed]) ed = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">route</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (q != p) &#123;</span><br><span class="line">    a[++t] = q;</span><br><span class="line">    b[t + <span class="number">1</span>] = edge[id[q]];</span><br><span class="line">    q = ver[id[q] ^ <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  a[++t] = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mx_dis</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  v[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">    <span class="type">int</span> y = ver[i];</span><br><span class="line">    <span class="keyword">if</span> (v[y]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">mx_dis</span>(y);</span><br><span class="line">    d[x] = <span class="built_in">max</span>(d[x], d[y] + edge[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x, y, z, i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    <span class="built_in">add</span>(x, y, z), <span class="built_in">add</span>(y, x, z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 寻找任意一条直径</span></span><br><span class="line">  <span class="type">int</span> p = <span class="built_in">bfs</span>(<span class="number">1</span>), q = <span class="built_in">bfs</span>(p);</span><br><span class="line">  <span class="comment">// 保存整条直径</span></span><br><span class="line">  <span class="built_in">route</span>(p, q);</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) v[a[i]] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    <span class="built_in">mx_dis</span>(a[i]);</span><br><span class="line">    <span class="comment">// 前缀和优化</span></span><br><span class="line">    sum[i] = sum[i - <span class="number">1</span>] + b[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (hd &lt; tl &amp;&amp; dq[hd] &lt; i) ++hd;</span><br><span class="line">    <span class="keyword">while</span> (j + <span class="number">1</span> &lt;= t &amp;&amp; sum[j + <span class="number">1</span>] - sum[i] &lt;= s) &#123;</span><br><span class="line">      ++j;</span><br><span class="line">      <span class="keyword">while</span> (hd &lt; tl &amp;&amp; d[a[j]] &gt; d[a[dq[tl - <span class="number">1</span>]]]) --tl;</span><br><span class="line">      dq[tl++] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, <span class="built_in">max</span>(d[a[dq[hd]]], <span class="built_in">max</span>(sum[i], sum[t] - sum[j])));</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="暴力的写法">暴力的写法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e5</span> + <span class="number">50</span>, maxm = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, s, t, tot = <span class="number">1</span>, head[maxm], ver[maxm], edge[maxm], nxt[maxm];</span><br><span class="line"><span class="type">int</span> d[maxm], id[maxm];</span><br><span class="line"><span class="type">bool</span> v[maxm];</span><br><span class="line"><span class="type">int</span> hd, tl, a[maxn], b[maxn], sum[maxn], dq[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">  ver[++tot] = y, edge[tot] = z, nxt[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> bg)</span> </span>&#123;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  d[bg] = <span class="number">0</span>, q.<span class="built_in">push</span>(bg);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">      <span class="type">int</span> y = ver[i];</span><br><span class="line">      <span class="keyword">if</span> (~d[y]) <span class="keyword">continue</span>;</span><br><span class="line">      q.<span class="built_in">push</span>(y);</span><br><span class="line">      d[y] = d[x] + edge[i];</span><br><span class="line">      id[y] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ed = bg;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[i] &gt; d[ed]) ed = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">route</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (q != p) &#123;</span><br><span class="line">    a[++t] = q;</span><br><span class="line">    b[t + <span class="number">1</span>] = edge[id[q]];</span><br><span class="line">    q = ver[id[q] ^ <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  a[++t] = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mx_dis</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  v[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">    <span class="type">int</span> y = ver[i];</span><br><span class="line">    <span class="keyword">if</span> (v[y]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">mx_dis</span>(y);</span><br><span class="line">    d[x] = <span class="built_in">max</span>(d[x], d[y] + edge[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x, y, z, i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    <span class="built_in">add</span>(x, y, z), <span class="built_in">add</span>(y, x, z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 寻找任意一条直径</span></span><br><span class="line">  <span class="type">int</span> p = <span class="built_in">bfs</span>(<span class="number">1</span>), q = <span class="built_in">bfs</span>(p);</span><br><span class="line">  <span class="comment">// 保存整条直径</span></span><br><span class="line">  <span class="built_in">route</span>(p, q);</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  <span class="type">int</span> mx_d = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) v[a[i]] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    <span class="built_in">mx_dis</span>(a[i]);</span><br><span class="line">    sum[i] = sum[i - <span class="number">1</span>] + b[i];</span><br><span class="line">    mx_d = <span class="built_in">max</span>(mx_d, d[a[i]]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j + <span class="number">1</span> &lt;= t &amp;&amp; sum[j + <span class="number">1</span>] - sum[i] &lt;= s) ++j;</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, <span class="built_in">max</span>(mx_d, <span class="built_in">max</span>(sum[i], sum[t] - sum[j])));</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>前缀和</tag>
        <tag>单调队列</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-389. 直径</title>
    <url>/2024/08/19/acwing-389-%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>树的直径</li>
<li>前缀和</li>
<li>双指针</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, tot = <span class="number">1</span>, head[maxn], ver[maxn], edge[maxn], nxt[maxn];</span><br><span class="line"><span class="type">int</span> m, a[maxn], id[maxn];</span><br><span class="line">ll d[maxn], sum[maxn];</span><br><span class="line"><span class="type">bool</span> v[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">  ver[++tot] = y, edge[tot] = z, nxt[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> st)</span> </span>&#123;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="built_in">sizeof</span>(d)), <span class="built_in">memset</span>(id, <span class="number">-1</span>, <span class="built_in">sizeof</span>(id));</span><br><span class="line">  d[st] = <span class="number">0</span>, q.<span class="built_in">push</span>(st);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">      <span class="type">int</span> y = ver[i];</span><br><span class="line">      <span class="keyword">if</span> (~d[y]) <span class="keyword">continue</span>;</span><br><span class="line">      d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">      q.<span class="built_in">push</span>(y);</span><br><span class="line">      id[y] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ed = st;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[i] &gt; d[ed]) ed = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">route</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (q != p) &#123;</span><br><span class="line">    a[++m] = q;</span><br><span class="line">    sum[m + <span class="number">1</span>] = sum[m] + edge[id[q]];</span><br><span class="line">    q = ver[id[q] ^ <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  a[++m] = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  v[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">    <span class="type">int</span> y = ver[i];</span><br><span class="line">    <span class="keyword">if</span> (v[y]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(y);</span><br><span class="line">    d[x] = <span class="built_in">max</span>(d[x], d[y] + edge[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x, y, z, i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    <span class="built_in">add</span>(x, y, z), <span class="built_in">add</span>(y, x, z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> p = <span class="built_in">bfs</span>(<span class="number">1</span>), q = <span class="built_in">bfs</span>(p);</span><br><span class="line">  <span class="built_in">route</span>(p, q);</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  <span class="comment">// 直径部分标记为“已访问”</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) v[a[i]] = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 直径上的每个点，不经过直径，能走到的最远距离</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">dfs</span>(a[i]);</span><br><span class="line">  <span class="type">int</span> u = <span class="number">-1</span>, ucnt, v = <span class="number">-1</span>, vcnt;</span><br><span class="line">  <span class="comment">// 正序一个方向</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">1</span>, i = <span class="number">2</span>; i &lt;= m - <span class="number">1</span>; ++i, ++cnt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[a[i]] == sum[i]) &#123;</span><br><span class="line">      u = i, ucnt = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 逆序一个方向</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">1</span>, i = m - <span class="number">1</span>; i &gt;= <span class="number">2</span>; --i, ++cnt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[a[i]] == sum[m] - sum[i]) &#123;</span><br><span class="line">      v = i, vcnt = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = m - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (~u) ans -= ucnt;</span><br><span class="line">  <span class="keyword">if</span> (~v) ans -= vcnt;</span><br><span class="line">  cout &lt;&lt; sum[m] &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>直径的必须边的模拟题，上图。</p>
<p>假设本图有三条直径，</p>
<p><code>1 - A - C - D - B - 2</code>、</p>
<p><code>3 - A - C - D - B - 4</code>、</p>
<p><code>5 - C - D - 6</code></p>
<p>共三条，可以找到必须边就是<code>CD</code>这条边。</p>
<img src="/2024/08/19/acwing-389-%E7%9B%B4%E5%BE%84/1.png" class="" title="image-20240819191358382">
<p>根据直径的性质，任意两个<strong>同一侧</strong>的<strong>直径端点</strong>到相同直径分叉点的距离均相等，</p>
<p>可以得知：</p>
<p>以<code>A</code>作为分叉点，那么<code>1A</code>等于<code>3A</code>；同样的，以<code>B</code>作为分叉点，那么<code>2B</code>等于<code>4B</code>。</p>
<p>以<code>C</code>作为分叉点，那么<code>1C</code>、<code>3C</code>等于<code>5C</code>；同样的，以<code>D</code>作为分叉点，那么<code>2D</code>、<code>4D</code>等于<code>6D</code>。</p>
<p>具体的解决方案如下：</p>
<ol type="1">
<li>求出任意一条直径</li>
<li>把直径上的所有点标记为已访问</li>
<li>求出直径上的所有点，<strong>不经过直径</strong>能走到的最远距离</li>
<li>游标<code>u</code>从直径起点<code>p</code>出发，停在<strong>最后一个</strong>满足最远距离等于路径<code>u - ... - p</code>长度</li>
<li>游标<code>v</code>从直径终点<code>q</code>出发，停在<strong>最后一个</strong>满足最远距离等于路径<code>v - ... - q</code>长度</li>
<li>此时的<code>u - ... - v</code>路径就是必须边</li>
</ol>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>前缀和</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-390. 逃学的小孩</title>
    <url>/2024/08/19/acwing-390-%E9%80%83%E5%AD%A6%E7%9A%84%E5%B0%8F%E5%AD%A9/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>树的直径</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, tot = <span class="number">1</span>, head[maxn], ver[maxn], edge[maxn], nxt[maxn];</span><br><span class="line">ll d[maxn], a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">  ver[++tot] = y, edge[tot] = z, nxt[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> st, ll d[])</span> </span>&#123;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="built_in">sizeof</span>(ll) * maxn);</span><br><span class="line">  d[st] = <span class="number">0</span>, q.<span class="built_in">push</span>(st);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">      <span class="type">int</span> y = ver[i];</span><br><span class="line">      <span class="keyword">if</span> (~d[y]) <span class="keyword">continue</span>;</span><br><span class="line">      d[y] = d[x] + edge[i];</span><br><span class="line">      q.<span class="built_in">push</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_mx</span><span class="params">(ll d[])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ed = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[ed] &lt; d[i]) ed = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x, y, z, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    <span class="built_in">add</span>(x, y, z), <span class="built_in">add</span>(y, x, z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">bfs</span>(<span class="number">1</span>, d);</span><br><span class="line">  <span class="type">int</span> p = <span class="built_in">get_mx</span>(d);</span><br><span class="line">  <span class="built_in">bfs</span>(p, d);</span><br><span class="line">  <span class="type">int</span> q = <span class="built_in">get_mx</span>(d);</span><br><span class="line">  ll ans = d[q];</span><br><span class="line">  <span class="built_in">bfs</span>(p, a), <span class="built_in">bfs</span>(q, b);</span><br><span class="line">  ll tmp, dis = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    tmp = <span class="built_in">min</span>(a[i], b[i]);</span><br><span class="line">    <span class="keyword">if</span> (tmp &gt; dis) &#123;</span><br><span class="line">      dis = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans + dis &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>题意翻译一下，从A点走到B点再走到C点，要让这两段距离最大。</p>
<p>做法如下：</p>
<ol type="1">
<li>找到一条直径，起点为p终点为q，这条距离肯定是最大的。</li>
<li>计算每个点<code>i</code>到<code>p</code>的距离，保存到<code>a[i]</code>，到<code>q</code>的距离，保存到<code>b[i]</code></li>
<li>每个点对结果的贡献就是<code>min(a[i], b[i])</code>，对所有点的贡献取最大值即可，设为<code>dis</code></li>
<li><code>dis + 直径</code>就是答案所求</li>
</ol>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title>hoj-4747 Mex</title>
    <url>/2024/09/14/hoj-4747-Mex/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线段树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc p &lt;&lt; 1 | 1</span></span><br><span class="line">ll n, a[maxn], mex[maxn], v[maxn], nxt[maxn], tmp[maxn];</span><br><span class="line"><span class="comment">// 线段树</span></span><br><span class="line"><span class="comment">// mx：区间最大值</span></span><br><span class="line"><span class="comment">// s：区间和</span></span><br><span class="line"><span class="comment">// tag：覆盖懒标签</span></span><br><span class="line">ll mx[maxn &lt;&lt; <span class="number">2</span>], s[maxn &lt;&lt; <span class="number">2</span>], tag[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">  s[p] = s[lc] + s[rc];</span><br><span class="line">  mx[p] = <span class="built_in">max</span>(mx[lc], mx[rc]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ll p, ll l, ll r, ll v)</span> </span>&#123;</span><br><span class="line">  mx[p] = v;</span><br><span class="line">  s[p] = v * (r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(ll p, ll l, ll r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (~tag[p]) &#123;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">f</span>(lc, l, mid, tag[p]), <span class="built_in">f</span>(rc, mid + <span class="number">1</span>, r, tag[p]);</span><br><span class="line">    tag[lc] = tag[rc] = tag[p];</span><br><span class="line">    tag[p] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll p, ll l, ll r)</span> </span>&#123;</span><br><span class="line">  tag[p] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    mx[p] = s[p] = mex[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(lc, l, mid), <span class="built_in">build</span>(rc, mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll p, ll l, ll r, ll L, ll R, ll v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="built_in">f</span>(p, l, r, v);</span><br><span class="line">    tag[p] = v;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">down</span>(p, l, r);</span><br><span class="line">  ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= mid) <span class="built_in">update</span>(lc, l, mid, L, R, v);</span><br><span class="line">  <span class="keyword">if</span> (R &gt; mid) <span class="built_in">update</span>(rc, mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分搜索</span></span><br><span class="line"><span class="function">ll <span class="title">bis</span><span class="params">(ll p, ll l, ll r, ll v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span> mx[p] &gt; v ? l : <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">down</span>(p, l, r);</span><br><span class="line">  ll mid = (l + r) &gt;&gt; <span class="number">1</span>, ans = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (mx[lc] &gt; v) ans = <span class="built_in">bis</span>(lc, l, mid, v);</span><br><span class="line">  <span class="keyword">if</span> (~ans) <span class="keyword">return</span> ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">bis</span>(rc, mid + <span class="number">1</span>, r, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">    <span class="comment">// 求出区间&#123;1, j&#125;的mex[j]，其中j∈&#123;1, n&#125;</span></span><br><span class="line">    ll m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      cin &gt;&gt; a[i];</span><br><span class="line">      <span class="comment">// 每个区间的mex不可能大于长度，所以大于长度的没必要计数</span></span><br><span class="line">      <span class="keyword">if</span> (a[i] &lt;= n) v[a[i]] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (v[m]) ++m;</span><br><span class="line">      mex[i] = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= n; ++i) tmp[i] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// nxt[x]，记录x右边第一个等于x的下标</span></span><br><span class="line">    <span class="keyword">for</span> (ll i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">      <span class="comment">// 同上，不需要记录非法值</span></span><br><span class="line">      <span class="keyword">if</span> (a[i] &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">      nxt[i] = tmp[a[i]];</span><br><span class="line">      tmp[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      ans += s[<span class="number">1</span>];</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, i, i, <span class="number">0</span>);</span><br><span class="line">      ll l = <span class="built_in">bis</span>(<span class="number">1</span>, <span class="number">1</span>, n, a[i]);</span><br><span class="line">      <span class="keyword">if</span> (l == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">      ll r = nxt[i] - <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>求<code>mex(1, j), 其中j∈&#123;1, n&#125;</code>可以发现，固定左端点时，右端点向右走，<code>mex</code>的值是单调不减的。</p>
<p><code>mex(2, i)</code>只比<code>mex(1, i)</code>少了<code>a[1]</code>，我们看一下<code>a[1]</code>对结果的影响：</p>
<img src="/2024/09/14/hoj-4747-Mex/1.png" class="" title="image-20240914223759916">
<p>根据上图可以看见，从左端点开始，所有大于<code>a[1]</code>的<code>mex</code>值都会变成<code>a[1]</code>，遇到下一个<code>a[1]</code>停止。</p>
<p>由于左端点固定时，右端点向右是单调不减的，我们需要通过二分找到大于<code>a[1]</code>的<code>mex</code>值里，数组下标最小的，也就是满足条件时一直向左边界靠拢；同时还有区间覆盖，考虑线段树即可。</p>
<p>初始时，我们把<code>mex(1, i)</code>保存到数组<code>mex[i]</code>当中去，线段树的叶子节点初始值就设定为数组<code>mex[i]</code>，有区间求和操作<code>s</code>还有区间最大值操作<code>mx</code>，此时以<code>1</code>为左端点的所有子区间<code>mex</code>值之和就等于<code>s[1]</code>。</p>
<p>在线段树中清除<code>a[1]</code>后，用线段树二分找到大于<code>a[1]</code>的<code>mex</code>值里数组下标最小的，记下标为<code>l</code>；</p>
<p>然后找到数组右边第一个等于<code>a[1]</code>的位置<code>r</code>，随后用线段树把<code>(l, r - 1)</code>这部分的<code>mex</code>值设为<code>a[1]</code>即可，此时就得到了以<code>2</code>为左端点的所有子区间<code>mex</code>值之和<code>s[1]</code>。</p>
]]></content>
      <categories>
        <category>hoj</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-2828 Buy Tickets</title>
    <url>/2024/09/14/poj-2828-Buy-Tickets/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>线段树</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (p &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (p &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, op[maxn], val[maxn];</span><br><span class="line"><span class="type">int</span> a[maxn], s[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    s[p] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(lc, l, mid), <span class="built_in">build</span>(rc, mid + <span class="number">1</span>, r);</span><br><span class="line">  s[p] = s[lc] + s[rc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    a[l] = v;</span><br><span class="line">    s[p] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (s[lc] &gt;= x)</span><br><span class="line">    <span class="built_in">update</span>(lc, l, mid, x, v);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">update</span>(rc, mid + <span class="number">1</span>, r, x - s[lc], v);</span><br><span class="line">  s[p] = s[lc] + s[rc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op[i], &amp;val[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, op[i] + <span class="number">1</span>, val[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>用<code>vector</code>可以直接过，不再诠释；这里展示一个线段树二分的做法。</p>
<p>正着弄，每次都会修改后续区间，非常麻烦，所以尝试反着弄。</p>
<p>根据题意，越后插入的，越在前面，并且只会插在已出现的人之前（没人你怎么插）。</p>
<p>比如有<code>(1, 1), (1, 2), (2, 3), (1, 4)</code>的插入顺序，最终结果就是<code>4 2 3 1</code></p>
<p>记录每个区间的空闲格子数，用线段树进行如下二分，假设当前要在第<code>x</code>个位置插入：</p>
<ol type="1">
<li>如果左孩子的空闲格子数大于等于<code>x</code>，就走向左孩子</li>
<li>否则就走向右孩子</li>
</ol>
<p>道理很简单，因为从后往前处理，插入位置的值就是最终结果；但是，会被其他人挤下去。</p>
<p>比如<code>(1, 1), (1, 2), (2, 3), (1, 4)</code>这个执行顺序，从后往前处理，</p>
<p>显然<code>2</code>位置会被<code>1</code>位置挤一次，因为<code>1</code>比<code>2</code>小，但是竟然出现在了<code>2</code>的后面，显然真正的<code>1</code>位置是有数字的。</p>
<p>如果改成<code>.....(2, 3), (3, 4)</code>就不会有问题，因为<code>3</code>位置比<code>2</code>大，挤不到。</p>
<p>所以本次线段树二分，实际上就是找一个<code>x</code>不会被挤的区间，这样的位置才是最终位置。</p>
]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>树的直径_解题技巧</title>
    <url>/2024/08/19/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="性质">性质</h1>
<ul>
<li><p>多条直径必相交于一点或一条公共路径。</p></li>
<li><p>任意两个<strong>同一侧</strong>的<strong>直径端点</strong>到相同直径分叉点的距离均相等。</p></li>
<li><p>直径一定是最长边。</p></li>
</ul>
<h1 id="模板">模板</h1>
<h2 id="两次bfs">两次BFS</h2>
<p>边权均非负的情况才可以用，用于记录整条直径。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找到以bg为起点的直径</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> bg)</span> </span>&#123;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">  d[bg] = <span class="number">0</span>, q.<span class="built_in">push</span>(bg);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">      <span class="type">int</span> y = ver[i];</span><br><span class="line">      <span class="keyword">if</span> (~d[y]) <span class="keyword">continue</span>;</span><br><span class="line">      q.<span class="built_in">push</span>(y);</span><br><span class="line">      d[y] = d[x] + edge[i];</span><br><span class="line">      id[y] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ed = bg;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[i] &gt; d[ed]) ed = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录p为起点，q为终点的直径，从终点q逆推至p</span></span><br><span class="line"><span class="comment">// 每次记录第t个点到a，第t+1个点到b，所以最后要把起点p单独记录一次</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">route</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (q != p) &#123;</span><br><span class="line">    a[++t] = q;</span><br><span class="line">    b[t + <span class="number">1</span>] = edge[id[q]];</span><br><span class="line">    q = ver[id[q] ^ <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  a[++t] = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树形dp">树形DP</h2>
<p>没有边权的正负限制，但只能保存直径的长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  v[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">    <span class="type">int</span> y = ver[i];</span><br><span class="line">    <span class="keyword">if</span> (v[y]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dp</span>(y);</span><br><span class="line">    l2 = <span class="built_in">max</span>(l2, d[x] + d[y] + edge[i]);</span><br><span class="line">    d[x] = <span class="built_in">max</span>(d[x], d[y] + edge[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="练习">练习</h1>
<ul>
<li><a
href="https://www.acwing.com/problem/content/description/352/">acwing-350</a>
模板题，记录直径并修改</li>
<li><a
href="https://www.acwing.com/problem/content/description/353/">acwing-351</a>
直径的性质</li>
<li><a
href="https://www.acwing.com/problem/content/description/391/">acwing-389</a>
直径的必须边</li>
<li><a
href="https://www.acwing.com/problem/content/description/392/">acwing-390</a></li>
</ul>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树 解题技巧</title>
    <url>/2024/09/22/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="编程技巧">编程技巧</h1>
<h2 id="普通线段树">普通线段树</h2>
<p>难点主要集中在标签下放与合并</p>
<p>在编程更新函数时，要考虑对同一区间反复更新不同标签的合并优先级；</p>
<p>该优先级也同样会应用到标签下放操作上。</p>
<h2 id="分治">分治</h2>
<p>可以左右对半分，可以偏左子树，可以偏右子树，完全服务于题目。</p>
<h2 id="二分">二分</h2>
<p><strong>二分依赖单调性</strong>，答案要么在左孩子，要么在右孩子，故而考虑左右孩子的优先级。</p>
<p>假设当前数组为升序，用其初始化线段树，求大于<code>v</code>的最小值下标。</p>
<p>那么应该保存每个区间的最大值，如果左孩子的最大值大于<code>v</code>，说明可能存在解，优先处理左孩子；</p>
<p>因为数组是升序，假设左右孩子都有解，显然左孩子的解才是正确答案。</p>
<h2 id="动态开点">动态开点</h2>
<p>一般用在区间范围过大，无法使用普通线段树的情况下。</p>
<p>普通线段树的空间开销是<code>4 * 数据范围</code>，动态开点线段树的空间开销是<code>询问次数 * log数据范围</code>，小了很多。</p>
<p>动态开点的编程也与普通线段树有细微差距，区间范围通过函数的参数传递，如果左右孩子不存在需要即时创建。</p>
<h2 id="合并">合并</h2>
<p>有合并、主席树两种思维。</p>
<p>合并思维并不会新开额外空间，是因为把所有子树的数据并到父树上；</p>
<p>但存在致命缺陷，父树合并子树结构后，子树很有可能会在父树合并期间被篡改原有数据，</p>
<p>所以不可以在合并后进行子区间的访问。</p>
<p>主席树思维则没有这个弊端，毕竟每次合并都会新开一个节点；当然代价就是空间占用过大，毕竟相当于直接新建一颗新树。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 合并思维</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p) <span class="keyword">return</span> q;</span><br><span class="line">  <span class="keyword">if</span> (!q) <span class="keyword">return</span> p;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    s[p] += s[q];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  lc[p] = <span class="built_in">merge</span>(lc[p], lc[q], l, mid);</span><br><span class="line">  rc[p] = <span class="built_in">merge</span>(rc[p], rc[q], mid + <span class="number">1</span>, r);</span><br><span class="line">  s[p] = s[lc[p]] + s[rc[p]];</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主席树新建节点思维</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> p + q;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    sum[++cnt] = sum[p] + sum[q];</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> u = ++cnt;</span><br><span class="line">  lc[u] = <span class="built_in">merge</span>(lc[p], lc[q], l, mid);</span><br><span class="line">  rc[u] = <span class="built_in">merge</span>(rc[p], rc[q], mid + <span class="number">1</span>, r);</span><br><span class="line">  sum[u] = sum[lc[u]] + sum[rc[u]];</span><br><span class="line">  <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="练习题">练习题</h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3372">P3372</a>
区间和</li>
<li><a href="https://www.luogu.com.cn/problem/P3870">P3870</a>
区间取反</li>
<li><a href="https://www.luogu.com.cn/problem/P1438">P1438</a>
差分、区间和</li>
<li><a href="https://www.luogu.com.cn/problem/P1253">P1253</a>
多标签处理（多标签可以抵消），区间覆盖、区间新增、区间极值</li>
<li><a href="https://www.luogu.com.cn/problem/P3373">P3373</a>
多标签处理（多标签可以抵消），区间乘法，区间加法</li>
<li><a href="https://www.luogu.com.cn/problem/P4513">P4513</a>
分治（左右孩子互不影响）</li>
<li><a href="https://www.luogu.com.cn/problem/P1471">P1471</a>
区间方差和</li>
<li><a href="https://www.luogu.com.cn/problem/P6492">P4692</a>
分治（左右孩子互不影响）</li>
<li><a href="https://www.luogu.com.cn/problem/P1637">P1637</a>
权值线段树/权值树状数组</li>
<li><a href="https://www.luogu.com.cn/problem/P1558">P1558</a>
区间与运算，状态压缩</li>
<li><a href="https://www.luogu.com.cn/problem/P5522">P5522</a>
区间交运算，状态压缩</li>
<li><a href="https://codeforces.com/problemset/problem/689/D">689D</a>
区间极值</li>
<li><a href="https://www.luogu.com.cn/problem/P4145">P4145</a>
势能线段树</li>
<li><a href="https://www.luogu.com.cn/problem/P2572">P2572</a>
分治（左右孩子互不影响），多标签处理，区间覆盖，区间取反；<strong>模板题</strong></li>
<li><a href="https://www.luogu.com.cn/problem/P4198">P4198</a>
分治（左孩子影响右孩子），<strong>模板题</strong></li>
<li><a href="https://www.luogu.com.cn/problem/P5579">P5579</a>
线段树二分，最大值里找最小</li>
<li><a href="http://poj.org/problem?id=2828">2828</a>
线段树二分，答案要么在左孩子要么在右</li>
<li><a href="https://acm.hdu.edu.cn/showproblem.php?pid=4747">4747</a>
线段树二分，最大找最小</li>
<li><a href="https://codeforces.com/problemset/problem/19/D">19D</a>
线段树二分，set优化，满足条件下找最小，<strong>模板题</strong></li>
<li><a href="https://www.luogu.com.cn/problem/P5459">P5459</a>
动态开点线段树</li>
<li><a href="https://codeforces.com/problemset/problem/915/E">915E</a>
动态开点线段树，<strong>模板题</strong></li>
<li><a
href="https://www.acwing.com/problem/content/description/355/">353</a>
线段树合并，LCA，树上差分，合并写法，<strong>模板题</strong></li>
<li><a href="https://www.luogu.com.cn/problem/P3899">P3899</a>
线段树合并，主席树写法，<strong>模板题</strong></li>
<li><a href="https://www.luogu.com.cn/problem/P3224">P3224</a>
线段树合并，并查集</li>
<li><a href="https://www.luogu.com.cn/problem/P3605">P3605</a>
线段树合并</li>
<li><a href="https://www.luogu.com.cn/problem/P3521">P3521</a>
线段树合并，逆序对</li>
</ul>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>357. 疫情控制</title>
    <url>/2024/09/28/357-%E7%96%AB%E6%83%85%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>贪心</li>
<li>二分</li>
<li>LCA</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e4</span> + <span class="number">50</span>, lg = (<span class="type">int</span>)(<span class="built_in">log2</span>(maxn)) + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> tot, head[maxn], ver[maxn &lt;&lt; <span class="number">1</span>], nxt[maxn &lt;&lt; <span class="number">1</span>], edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> n, m, d[maxn], f[maxn][lg], army[maxn];</span><br><span class="line">ll dist[maxn];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="comment">// 该结点为根的子树是否堵住</span></span><br><span class="line"><span class="type">bool</span> block[maxn];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="comment">// 二类军队</span></span><br><span class="line">pair&lt;ll, <span class="type">int</span>&gt; a[maxn];</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="comment">// 根结点的孩子中，有哪些不能堵住的</span></span><br><span class="line"><span class="type">int</span> son[maxn];</span><br><span class="line"><span class="comment">// 二类军队有没有被用过</span></span><br><span class="line"><span class="type">bool</span> used[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">  ver[++tot] = y, edge[tot] = z, nxt[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">      <span class="type">int</span> y = ver[i];</span><br><span class="line">      <span class="keyword">if</span> (d[y]) <span class="keyword">continue</span>;</span><br><span class="line">      q.<span class="built_in">push</span>(y);</span><br><span class="line">      d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">      dist[y] = dist[x] + edge[i];</span><br><span class="line">      f[y][<span class="number">0</span>] = x;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; lg; ++k) f[y][k] = f[f[y][k - <span class="number">1</span>]][k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向上爬，直到根结点的孩子为止</span></span><br><span class="line"><span class="comment">// pair&lt;ll, int&gt;：剩余时间，到达结点</span></span><br><span class="line"><span class="function">pair&lt;ll, <span class="type">int</span>&gt; <span class="title">go</span><span class="params">(<span class="type">int</span> x, ll mid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = lg - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x][i] &gt; <span class="number">1</span> &amp;&amp; dist[x] - dist[f[x][i]] &lt;= mid) &#123;</span><br><span class="line">      mid -= dist[x] - dist[f[x][i]];</span><br><span class="line">      x = f[x][i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">make_pair</span>(mid, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不考虑二类军队，只考虑一类军队</span></span><br><span class="line"><span class="comment">// 此刻根结点到各个叶子节点的连通性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> all_child_covered = <span class="number">1</span>;</span><br><span class="line">  <span class="type">bool</span> is_leaf = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">    <span class="type">int</span> y = ver[i];</span><br><span class="line">    <span class="keyword">if</span> (y == f) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(y, x);</span><br><span class="line">    is_leaf = <span class="number">0</span>;</span><br><span class="line">    all_child_covered &amp;= block[y];</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> &amp;&amp; !block[y]) son[++num] = y;</span><br><span class="line">  &#125;</span><br><span class="line">  block[x] = block[x] || (all_child_covered &amp;&amp; !is_leaf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> dist[x] &lt; dist[y]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll mid)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(block, <span class="number">0</span>, <span class="built_in">sizeof</span>(block));</span><br><span class="line">  <span class="built_in">memset</span>(used, <span class="number">0</span>, <span class="built_in">sizeof</span>(used));</span><br><span class="line">  num = cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    pair&lt;ll, <span class="type">int</span>&gt; t = <span class="built_in">go</span>(army[i], mid);</span><br><span class="line">    ll rst = t.first;</span><br><span class="line">    <span class="type">int</span> x = t.second;</span><br><span class="line">    <span class="keyword">if</span> (f[x][<span class="number">0</span>] &gt; <span class="number">1</span>)</span><br><span class="line">      <span class="comment">// 一类军队只能停在原地堵人</span></span><br><span class="line">      block[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// 每个二类军队还可能出去帮人，按减去根后的距离排序</span></span><br><span class="line">      a[++cnt] = &#123;rst - dist[x], x&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + cnt);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">    ll rst = a[i].first;</span><br><span class="line">    <span class="type">int</span> x = a[i].second;</span><br><span class="line">    <span class="comment">// 剩余路程小于到根距离，并且当前子树没被堵住</span></span><br><span class="line">    <span class="comment">// 那就把当前节点留下，否则全部拿去帮其他人</span></span><br><span class="line">    <span class="keyword">if</span> (rst &lt; dist[x] &amp;&amp; !block[x]) &#123;</span><br><span class="line">      block[x] = used[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(son + <span class="number">1</span>, son + <span class="number">1</span> + num, cmp);</span><br><span class="line">  <span class="comment">// 同向双指针</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= num; ++i) &#123;</span><br><span class="line">    <span class="comment">// 已经用某个二类军队堵住了</span></span><br><span class="line">    <span class="keyword">if</span> (block[son[i]]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= cnt &amp;&amp; (used[j] || a[j].first &lt; dist[son[i]])) ++j;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; cnt) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="type">int</span> x, y, z;</span><br><span class="line">  ll sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">    <span class="built_in">add</span>(x, y, z), <span class="built_in">add</span>(y, x, z);</span><br><span class="line">    sum += z;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;army[i]);</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="comment">// 二分答案，最后取左边界</span></span><br><span class="line">  ll l = <span class="number">0</span>, r = sum;</span><br><span class="line">  <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">      r = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, l &gt; sum ? <span class="number">-1</span> : l);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<h2 id="第一部分">第一部分</h2>
<p>根据题意，要尽可能地阻挡根节点到叶子节点的连通性，显然希望所有的军队往上冲。</p>
<p>因为树是一层一层发散的，越往上，能控制的叶子节点就越多。</p>
<p>故而很容易想到答案二分，在满足条件的情况下，选择向上冲刺距离最短的即为所求。</p>
<h2 id="第二部分">第二部分</h2>
<p>最终的冲刺结果一定分成两份：</p>
<ol type="1">
<li><p>第一类军队，到不了根节点</p>
<p>这类军队只能停留在原地堵人。</p></li>
<li><p>第二类军队，能到达根节点</p>
<p>把这类军队先留在根节点的孩子节点上待命，用<code>&#123;rst , x&#125;</code>来保存至<code>a</code>数组，</p>
<p>其中<code>rst</code>代表军队<code>x</code>可以跨过根节点多长距离。</p>
<p>因为这类军队可以选择留在原地堵人，也可以选择跨过根节点，去帮根节点的其他孩子堵人。</p>
<p>为什么不去根节点的孩子的孩子堵人？因为这是很明显的贪心策略。</p>
<p>由于路径是非负数，越往下开销越大，能堵的子树范围也更小，肯定不会优于直接去赌根节点的孩子。</p></li>
</ol>
<p>根据上面描述，作图如下：</p>
<img src="/2024/09/28/357-%E7%96%AB%E6%83%85%E6%8E%A7%E5%88%B6/1.png" class="" title="image-20240927233319809">
<h2 id="第三部分">第三部分</h2>
<p>先只考虑一类军队对连通性的影响，因为它们只能堵在原地，全局dfs一遍即可。</p>
<p>当然，只需要记录根节点孩子的连通性，如果该孩子依旧可以访问到任何一个叶子节点，那么记录到<code>son</code>数组。</p>
<p>现在的问题是，如何决定二类军队到底是留在原地，还是去帮其他人呢？</p>
<p>假设情况如下，有个点还需要人去填充，A点有1个军队，B点有2个军队。</p>
<img src="/2024/09/28/357-%E7%96%AB%E6%83%85%E6%8E%A7%E5%88%B6/2.png" class="" title="image-20240928000112979">
<p>很容易发现一个规律，如果<code>q &lt; p</code>并且该军队离开后反而打通了连通性，那么该军队就待在原地。</p>
<p>除此外的其他情况都可以去帮别人。</p>
<blockquote>
<p>道理很简单。</p>
<p>A点出发去堵人，需要消耗<code>p + q</code>，那么B点需要<code>r + p</code>来帮你堵上。</p>
<p>可问题在于，如果是B点去堵人，需要消耗<code>r + q &lt; r + p</code>，</p>
<p>也就是说，该情况下让B点去堵人反而比A点堵人更优。</p>
<p>这也是一个贪心策略，同样可以堵人，显然留下更长的距离更好，这样能满足更多的条件。</p>
</blockquote>
<p>根据上面的策略，从<code>a</code>筛选一批二类军队留下。</p>
<h2 id="第四部分">第四部分</h2>
<p><code>son</code>是需要军队的根节点孩子数组，<code>a</code>是空闲军队的根节点孩子数组，</p>
<p><code>son</code>对根节点距离进行排序，<code>a</code>对可用距离<code>rst</code>排序，</p>
<p>同时对两个数组进行单向双指针即可。</p>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>352. 闇の連鎖</title>
    <url>/2024/09/23/352-%E9%97%87%E3%81%AE%EF%A6%9A%E9%8E%96/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>树上差分</li>
<li>LCA</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">50</span>, lg = (<span class="type">int</span>)(<span class="built_in">log2</span>(maxn)) + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> tot, head[maxn], nxt[maxn &lt;&lt; <span class="number">1</span>], ver[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> d[maxn], f[maxn][lg];</span><br><span class="line">ll s[maxn];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; ver[++tot] = y, nxt[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  d[<span class="number">1</span>] = <span class="number">1</span>, q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">      <span class="type">int</span> y = ver[i];</span><br><span class="line">      <span class="keyword">if</span> (d[y]) <span class="keyword">continue</span>;</span><br><span class="line">      d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">      q.<span class="built_in">push</span>(y);</span><br><span class="line">      f[y][<span class="number">0</span>] = x;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; lg; ++j) f[y][j] = f[f[y][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (d[x] &lt; d[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = lg - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[f[x][i]] &gt;= d[y]) x = f[x][i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = lg - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">    <span class="type">int</span> y = ver[i];</span><br><span class="line">    <span class="keyword">if</span> (y == f) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(y, x);</span><br><span class="line">    s[x] += s[y];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">add</span>(x, y), <span class="built_in">add</span>(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    s[x] += <span class="number">1</span>, s[y] += <span class="number">1</span>, s[<span class="built_in">lca</span>(x, y)] -= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="number">0</span>)</span><br><span class="line">      ans += m;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="number">1</span>)</span><br><span class="line">      ans += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>通过作图可以发现：</p>
<ol type="1">
<li>主要边没有被附加边覆盖，切一刀即可不连通</li>
<li>主要边被一条附加边覆盖，切掉主要边和对应附加边即可不连通</li>
<li>被两条及以上覆盖，切两次无法达到不连通</li>
</ol>
<p>所以使用树上差分，计算每条边被多少条附加边覆盖即可。</p>
<img src="/2024/09/23/352-%E9%97%87%E3%81%AE%EF%A6%9A%E9%8E%96/1.png" class="" title="image-20240923143045435">
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title>356. 次小生成树</title>
    <url>/2024/09/26/356-%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>LCA</li>
<li>树上倍增</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">3e5</span> + <span class="number">50</span>, lg = (<span class="type">int</span>)(<span class="built_in">log2</span>(maxn)) + <span class="number">1</span>;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> n, m, tot, head[maxn], nxt[maxn &lt;&lt; <span class="number">1</span>], ver[maxn &lt;&lt; <span class="number">1</span>], edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="comment">// mx：倍增优化，第一维两点最大，第二维两点次大</span></span><br><span class="line"><span class="type">int</span> fa[maxn], d[maxn], f[maxn][lg], mx[maxn][lg][<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 保存边，用以kruskal</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> x, y, z;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> z &lt; a.z; &#125;</span><br><span class="line">&#125; e[maxn];</span><br><span class="line"><span class="comment">// 这条边在不在最小生成树当中</span></span><br><span class="line"><span class="type">bool</span> v[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">  ver[++tot] = y, nxt[tot] = head[x], edge[tot] = z, head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a和b合并到c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> c[<span class="number">2</span>], <span class="type">int</span> a[<span class="number">2</span>], <span class="type">int</span> b[<span class="number">2</span>])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) &#123;</span><br><span class="line">    c[<span class="number">1</span>] = <span class="built_in">max</span>(a[<span class="number">1</span>], b[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">0</span>] &gt; b[<span class="number">0</span>]) &#123;</span><br><span class="line">    c[<span class="number">1</span>] = <span class="built_in">max</span>(a[<span class="number">1</span>], b[<span class="number">0</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c[<span class="number">1</span>] = <span class="built_in">max</span>(a[<span class="number">0</span>], b[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  c[<span class="number">0</span>] = <span class="built_in">max</span>(a[<span class="number">0</span>], b[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">      <span class="type">int</span> y = ver[i];</span><br><span class="line">      <span class="keyword">if</span> (d[y]) <span class="keyword">continue</span>;</span><br><span class="line">      d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">      q.<span class="built_in">push</span>(y);</span><br><span class="line">      f[y][<span class="number">0</span>] = x;</span><br><span class="line">      mx[y][<span class="number">0</span>][<span class="number">0</span>] = edge[i];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; lg; ++j) &#123;</span><br><span class="line">        f[y][j] = f[f[y][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">merge</span>(mx[y][j], mx[y][j - <span class="number">1</span>], mx[f[y][j - <span class="number">1</span>]][j - <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> ans[<span class="number">2</span>], <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  ans[<span class="number">0</span>] = ans[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (d[x] &lt; d[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = lg - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[f[x][i]] &gt;= d[y]) &#123;</span><br><span class="line">      <span class="built_in">merge</span>(ans, ans, mx[x][i]);</span><br><span class="line">      x = f[x][i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = lg - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x][i] != f[y][i]) &#123;</span><br><span class="line">      <span class="built_in">merge</span>(ans, ans, mx[x][i]);</span><br><span class="line">      <span class="built_in">merge</span>(ans, ans, mx[y][i]);</span><br><span class="line">      x = f[x][i], y = f[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">merge</span>(ans, ans, mx[x][<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">merge</span>(ans, ans, mx[y][<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == fa[x] ? x : (fa[x] = <span class="built_in">get</span>(fa[x])); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="type">int</span> x, y, z;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    e[i].x = x, e[i].y = y, e[i].z = z;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 建树，并kruskal求最小生成树</span></span><br><span class="line">  <span class="built_in">sort</span>(e + <span class="number">1</span>, e + <span class="number">1</span> + m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i;</span><br><span class="line">  ll mst = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    x = <span class="built_in">get</span>(e[i].x), y = <span class="built_in">get</span>(e[i].y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">continue</span>;</span><br><span class="line">    mst += e[i].z;</span><br><span class="line">    fa[x] = y;</span><br><span class="line">    v[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">add</span>(e[i].x, e[i].y, e[i].z), <span class="built_in">add</span>(e[i].y, e[i].x, e[i].z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="type">int</span> delta = INT_MAX;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v[i] || e[i].x == e[i].y) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> t[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">lca</span>(t, e[i].x, e[i].y);</span><br><span class="line">    <span class="keyword">if</span> (e[i].z &gt; t[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="comment">// 边比最大值还大</span></span><br><span class="line">      delta = <span class="built_in">min</span>(delta, e[i].z - t[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t[<span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="comment">// 边等于最大值并且有次大边</span></span><br><span class="line">      delta = <span class="built_in">min</span>(delta, e[i].z - t[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; mst + delta &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>首先使用<code>kruskal</code>求出最小生成树，并保存下来。</p>
<p>连接一条非树边，这样会变成一个环，还需断开一条树边才能恢复成树。</p>
<p>这样整体的权值和会变大，增值为<code>delta</code>，所有可能的情况取最小的<code>delta</code>即可。</p>
<p>如图所示，x与y是最小生成树的两点，如果加入<code>x - y</code>这条非树边，那么必然要从<code>x - lca</code>或<code>lca - y</code>这两条树上路径中断开一条，否则就成环了。</p>
<img src="/2024/09/26/356-%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/1.png" class="" title="image-20240926140530343">
<p>假设非树边<code>xy</code>的值为<code>z</code>，而<code>x - lca</code>，<code>lca - y</code>树上路径的最大边权为<code>v1</code>，次大边权为<code>v2</code>。</p>
<p>显然，<code>z ≥ v1</code>恒成立，否则<code>z</code>就会被选入最小生成树了。</p>
<p>如果<code>z ＞ v1</code>，那么断开<code>v1</code>即可，<code>delta = z - v1</code>；</p>
<p>如果<code>z == v1</code>，连接<code>z</code>还是断开<code>v1</code>本质上没有区别，对<code>delta</code>没有贡献，所以选择断开<code>v2</code>，<code>delta = z - v2</code>；</p>
<p>当然，如果这个情况下没有次大边权也是不算情况内的。</p>
<hr />
<p>现在问题就变成了，如何快速求出两点路径间的最大边权与次大边权。</p>
<p>直接使用树上倍增进行优化即可，详见代码。</p>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>树上倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>354. 天天爱跑步</title>
    <url>/2024/09/24/354-%E5%A4%A9%E5%A4%A9%E7%88%B1%E8%B7%91%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>树上差分</li>
<li>时间戳</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">3e5</span> + <span class="number">50</span>, lg = (<span class="type">int</span>)(<span class="built_in">log2</span>(maxn)) + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> tot, head[maxn], nxt[maxn &lt;&lt; <span class="number">1</span>], ver[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> d[maxn], w[maxn], ans[maxn], f[maxn][lg];</span><br><span class="line"><span class="comment">// 两个方向的差分数组</span></span><br><span class="line"><span class="comment">// 第一维，左向上方向；第二维右向上方向</span></span><br><span class="line"><span class="type">int</span> c[maxn &lt;&lt; <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 得用vector，时间换空间，邻接表会炸</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> idx, value, kind;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; ver[++tot] = y, nxt[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_q</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> i, <span class="type">int</span> v, <span class="type">int</span> k)</span> </span>&#123; a[x].<span class="built_in">push_back</span>(&#123;i, v, k&#125;); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  d[<span class="number">1</span>] = <span class="number">1</span>, q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">      <span class="type">int</span> y = ver[i];</span><br><span class="line">      <span class="keyword">if</span> (d[y]) <span class="keyword">continue</span>;</span><br><span class="line">      d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">      q.<span class="built_in">push</span>(y);</span><br><span class="line">      f[y][<span class="number">0</span>] = x;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; lg; ++j) f[y][j] = f[f[y][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (d[x] &lt; d[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = lg - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[f[x][i]] &gt;= d[y]) x = f[x][i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = lg - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> v0 = c[w[x] + d[x]][<span class="number">0</span>], v1 = c[w[x] - d[x] + n][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">    <span class="type">int</span> y = ver[i];</span><br><span class="line">    <span class="keyword">if</span> (y == f) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it : a[x]) &#123;</span><br><span class="line">    <span class="type">int</span> i = it.idx, v = it.value, k = it.kind;</span><br><span class="line">    c[i][k] += v;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ans[x] = c[w[x] + d[x]][<span class="number">0</span>] - v0 + c[w[x] - d[x] + n][<span class="number">1</span>] - v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="type">int</span> x, y, s, t;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">add</span>(x, y), <span class="built_in">add</span>(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;s, &amp;t);</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">lca</span>(s, t);</span><br><span class="line">    <span class="built_in">add_q</span>(s, d[s], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (f[u][<span class="number">0</span>]) <span class="built_in">add_q</span>(f[u][<span class="number">0</span>], d[s], <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// +n是为了防止负数</span></span><br><span class="line">    <span class="built_in">add_q</span>(t, d[s] - <span class="number">2</span> * d[u] + n, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add_q</span>(u, d[s] - <span class="number">2</span> * d[u] + n, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>设<code>u = lca(s, t)</code>，一条路径可以被<code>u</code>分成两半，假设左半部分为<code>s</code>到含<code>u</code>这部分，右半部分为不含<code>u</code>到<code>t</code>这部分。</p>
<p>对于左半部分的点<code>x</code>，<code>s</code>如果在第<code>w[x]</code>到达，满足<code>d[s] = d[x] + w[x]</code>；</p>
<p>对于右半部分的点<code>x</code>，<code>s</code>如果在第<code>w[x]</code>到达，满足<code>d[s] - 2 * d[u] = w[x] - d[x]</code>。</p>
<p>所以得到，<code>每个点的答案 = 所有路径的左半部分对x的贡献 + 所有路径的右半部分对x的贡献</code></p>
<p>暴力的解决方案是每个点都开一个二维计数数组，即<code>c[maxn &lt;&lt; 1][2]</code>，</p>
<p>第一维记录左半部分的贡献，第二维记录右半部分的贡献。</p>
<p>对于路径左半部分的点，即<code>s ~ u</code>，全部在<code>c[d[s]][0]</code>下标自增即可；</p>
<p>原因在于，每个点的左贡献是通过访问<code>d[x] + w[x]</code>下标，如果<code>d[x] + w[x] == 某个d[s]</code>，那么该路径就会对本<code>x</code>有贡献；</p>
<p>同理，对于路径右半部分的点，即<code>u(不含) ~ t</code>，全部在<code>c[d[s] - 2 * d[u] + n][1]</code>下标自增即可；</p>
<p>（<code>+n</code>是为了防止负数下标导致越界）</p>
<p>原因在于，每个点的右贡献是通过访问<code>w[x] - d[x]</code>下标，如果<code>w[x] - d[x] == 某个d[s] - 2 * d[u]</code>，那么该路径就会对本<code>x</code>有贡献。</p>
<hr />
<p>整理一下，需要区间增减全部结束之后，再根据值域访问计数，很容易想到权值线段树，也就是树上差分+线段树合并这样的方案。</p>
<p>但本题空间只有<code>128MB</code>，按照线段树动态开点的特性，估算一下空间开销：</p>
<blockquote>
<p>树上差分每次需要更新2个点</p>
<p>mlogn的空间复杂度</p>
<p>3个数组，左孩子右孩子与区间计数和</p>
<p>int类型4个字节</p>
<p>总共2 × 3e5 × log2(3e5) × 3 × 4 / 1024 / 1024 = 137MB，直接爆了</p>
</blockquote>
<p>根据DFS序，仔细思考这点：</p>
<ul>
<li><p>所有的树上差分结束之后，结点本身与其所有子树的差分数组合并就得到了该结点的最终差分情况</p></li>
<li><p>每个点只关心<code>d[x] + w[x]</code>和<code>w[x] - d[x]</code>这俩下标的个数，不需要区间操作</p></li>
</ul>
<p>那么我们完全可以这么做：</p>
<ul>
<li><p><code>c[maxn &lt;&lt; 1][2]</code>数组作为全局差分数组，效果不变。</p></li>
<li><p>进入点<code>x</code>之前，记录两个方向的贡献：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> v0 = c[w[x] + d[x]][<span class="number">0</span>], v1 = c[w[x] - d[x] + n][<span class="number">1</span>];</span><br></pre></td></tr></table></figure></li>
<li><p><code>x</code>与所有子树的差分值合并之后得到的新贡献 -
旧贡献，不就是<code>x</code>所求吗！</p>
<p>道理很简单，计数满足<strong>区间可减性</strong>，进入后的计数 =
进入前的计数 + 变化量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> v0 = c[w[x] + d[x]][<span class="number">0</span>], v1 = c[w[x] - d[x] + n][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">    <span class="type">int</span> y = ver[i];</span><br><span class="line">    <span class="keyword">if</span> (y == f) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it : a[x]) &#123;</span><br><span class="line">    <span class="type">int</span> i = it.idx, v = it.value, k = it.kind;</span><br><span class="line">    c[i][k] += v;</span><br><span class="line">  &#125;</span><br><span class="line">  ans[x] = c[w[x] + d[x]][<span class="number">0</span>] - v0 + c[w[x] - d[x] + n][<span class="number">1</span>] - v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>树上差分</tag>
        <tag>时间戳</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing-391. 聚会</title>
    <url>/2024/09/22/391-%E8%81%9A%E4%BC%9A/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>LCA</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<p>见思路</p>
<h1 id="思路">思路</h1>
<p>由于是一棵树，x到y只有一条路径；考虑z点到x、y的情况分布如下。</p>
<p>要么在x子树中，要么在y子树中；</p>
<p>要么在lca(x, y)下，x上；要么在lca(x, y)下，y上；</p>
<p>要么在lca(x, y)上。</p>
<img src="/2024/09/22/391-%E8%81%9A%E4%BC%9A/1.png" class="" title="image-20240922201500698">
<p>可以发现规律：</p>
<ol type="1">
<li><p>三个点，最多只有两种不同的<code>lca</code></p></li>
<li><p>答案一定是两种<code>lca</code>中最深的那个</p></li>
</ol>
<p>随后就很容易得到答案了，分类讨论即可</p>
<h2 id="倍增写法">倍增写法</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e5</span> + <span class="number">50</span>, lg = (<span class="type">int</span>)(<span class="built_in">log2</span>(maxn)) + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> tot, head[maxn], nxt[maxn &lt;&lt; <span class="number">1</span>], ver[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> d[maxn], f[maxn][lg];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; ver[++tot] = y, nxt[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dis</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123; <span class="keyword">return</span> d[x] + d[y] - <span class="number">2</span> * d[z]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  d[<span class="number">1</span>] = <span class="number">1</span>, q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">      <span class="type">int</span> y = ver[i];</span><br><span class="line">      <span class="keyword">if</span> (d[y]) <span class="keyword">continue</span>;</span><br><span class="line">      q.<span class="built_in">push</span>(y);</span><br><span class="line">      d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">      f[y][<span class="number">0</span>] = x;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; lg; ++j) f[y][j] = f[f[y][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (d[x] &lt; d[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = lg - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[f[x][i]] &gt;= d[y]) x = f[x][i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = lg - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="type">int</span> x, y, z;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">add</span>(x, y), <span class="built_in">add</span>(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="type">int</span> pos, cost;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">    <span class="type">int</span> xy = <span class="built_in">lca</span>(x, y), xz = <span class="built_in">lca</span>(x, z), yz = <span class="built_in">lca</span>(y, z);</span><br><span class="line">    <span class="keyword">if</span> (d[xz] &gt;= d[xy] &amp;&amp; d[xz] &gt;= d[yz]) &#123;</span><br><span class="line">      pos = xz;</span><br><span class="line">      cost = <span class="built_in">dis</span>(x, pos, pos) + <span class="built_in">dis</span>(z, pos, pos) + <span class="built_in">dis</span>(pos, y, xy);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d[yz] &gt;= d[xy] &amp;&amp; d[yz] &gt;= d[xz]) &#123;</span><br><span class="line">      pos = yz;</span><br><span class="line">      cost = <span class="built_in">dis</span>(y, pos, pos) + <span class="built_in">dis</span>(z, pos, pos) + <span class="built_in">dis</span>(pos, x, xy);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pos = xy;</span><br><span class="line">      cost = <span class="built_in">dis</span>(x, pos, pos) + <span class="built_in">dis</span>(y, pos, pos) + <span class="built_in">dis</span>(pos, z, xz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, pos, cost);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tarjan写法">Tarjan写法</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> tot, head[maxn], nxt[maxn &lt;&lt; <span class="number">1</span>], ver[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> a[maxn], b[maxn], c[maxn];</span><br><span class="line"><span class="comment">// xy保存在第一维，xz保存在第二维，yz保存在第三维</span></span><br><span class="line"><span class="type">int</span> lca[<span class="number">3</span> * maxn];</span><br><span class="line"><span class="comment">// hq对vq的lca，保存在lca[idx]</span></span><br><span class="line"><span class="type">int</span> tq, hq[maxn], nq[<span class="number">6</span> * maxn], vq[<span class="number">6</span> * maxn], idx[<span class="number">6</span> * maxn];</span><br><span class="line"><span class="type">int</span> fa[maxn], v[maxn], d[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; ver[++tot] = y, nxt[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_q</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 特判一下，因为v[x] == v[y] == 1时，不会更新lca</span></span><br><span class="line">  <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">    lca[i] = x;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  vq[++tq] = y, nq[tq] = hq[x], idx[tq] = i, hq[x] = tq;</span><br><span class="line">  vq[++tq] = x, nq[tq] = hq[y], idx[tq] = i, hq[y] = tq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dis</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123; <span class="keyword">return</span> d[x] + d[y] - <span class="number">2</span> * d[z]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">get</span>(fa[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  v[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">    <span class="type">int</span> y = ver[i];</span><br><span class="line">    <span class="keyword">if</span> (v[y]) <span class="keyword">continue</span>;</span><br><span class="line">    d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">tarjan</span>(y);</span><br><span class="line">    fa[y] = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = hq[x]; i; i = nq[i]) &#123;</span><br><span class="line">    <span class="type">int</span> y = vq[i];</span><br><span class="line">    <span class="keyword">if</span> (v[y] == <span class="number">2</span>) lca[idx[i]] = <span class="built_in">get</span>(y);</span><br><span class="line">  &#125;</span><br><span class="line">  v[x] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="type">int</span> x, y, z;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">add</span>(x, y), <span class="built_in">add</span>(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">    a[i] = x, b[i] = y, c[i] = z;</span><br><span class="line">    <span class="built_in">add_q</span>(x, y, i), <span class="built_in">add_q</span>(x, z, i + m), <span class="built_in">add_q</span>(y, z, i + <span class="number">2</span> * m);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> pos, cost;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> x = a[i], y = b[i], z = c[i];</span><br><span class="line">    <span class="type">int</span> xy = lca[i], xz = lca[i + m], yz = lca[i + <span class="number">2</span> * m];</span><br><span class="line">    <span class="keyword">if</span> (d[xz] &gt;= d[xy] &amp;&amp; d[xz] &gt;= d[yz]) &#123;</span><br><span class="line">      pos = xz;</span><br><span class="line">      cost = <span class="built_in">dis</span>(x, pos, pos) + <span class="built_in">dis</span>(z, pos, pos) + <span class="built_in">dis</span>(pos, y, xy);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d[yz] &gt;= d[xy] &amp;&amp; d[yz] &gt;= d[xz]) &#123;</span><br><span class="line">      pos = yz;</span><br><span class="line">      cost = <span class="built_in">dis</span>(y, pos, pos) + <span class="built_in">dis</span>(z, pos, pos) + <span class="built_in">dis</span>(pos, x, xy);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pos = xy;</span><br><span class="line">      cost = <span class="built_in">dis</span>(x, pos, pos) + <span class="built_in">dis</span>(y, pos, pos) + <span class="built_in">dis</span>(pos, z, xz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, pos, cost);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>355. 异象石</title>
    <url>/2024/09/25/355-%E5%BC%82%E8%B1%A1%E7%9F%B3/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>LCA</li>
<li>时间戳</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>, lg = (<span class="type">int</span>)(<span class="built_in">log2</span>(maxn)) + <span class="number">1</span>;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> n, m, tot, head[maxn], nxt[maxn &lt;&lt; <span class="number">1</span>], ver[maxn &lt;&lt; <span class="number">1</span>], edge[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="comment">// d：到根结点深度</span></span><br><span class="line"><span class="comment">// dis：到根结点距离</span></span><br><span class="line">ll ans, d[maxn], dis[maxn], f[maxn][lg];</span><br><span class="line"><span class="comment">// 时间戳</span></span><br><span class="line"><span class="type">int</span> cnt, dfn[maxn];</span><br><span class="line"><span class="comment">// 按第一维时间戳排序</span></span><br><span class="line">set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">  ver[++tot] = y, nxt[tot] = head[x], edge[tot] = z, head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  d[<span class="number">1</span>] = <span class="number">1</span>, q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">      <span class="type">int</span> y = ver[i];</span><br><span class="line">      <span class="keyword">if</span> (d[y]) <span class="keyword">continue</span>;</span><br><span class="line">      d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">      q.<span class="built_in">push</span>(y);</span><br><span class="line">      f[y][<span class="number">0</span>] = x;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; lg; ++j) f[y][j] = f[f[y][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (d[x] &lt; d[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = lg - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[f[x][i]] &gt;= d[y]) x = f[x][i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = lg - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dist</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> dis[x] + dis[y] - <span class="number">2</span> * dis[<span class="built_in">lca</span>(x, y)]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">  dfn[x] = ++cnt;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">    <span class="type">int</span> y = ver[i];</span><br><span class="line">    <span class="keyword">if</span> (y == f) <span class="keyword">continue</span>;</span><br><span class="line">    dis[y] = dis[x] + edge[i];</span><br><span class="line">    <span class="built_in">dfs</span>(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;::iterator it = s.<span class="built_in">lower_bound</span>(<span class="built_in">make_pair</span>(dfn[x], x));</span><br><span class="line">  <span class="keyword">if</span> (it == s.<span class="built_in">begin</span>()) it = s.<span class="built_in">end</span>();</span><br><span class="line">  <span class="keyword">return</span> (--it)-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">suf</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;::iterator it = s.<span class="built_in">upper_bound</span>(<span class="built_in">make_pair</span>(dfn[x], x));</span><br><span class="line">  <span class="keyword">if</span> (it == s.<span class="built_in">end</span>()) it = s.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">    ans += <span class="number">2</span> * <span class="built_in">dist</span>(s.<span class="built_in">begin</span>()-&gt;second, x);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">pre</span>(x), r = <span class="built_in">suf</span>(x);</span><br><span class="line">    ans += <span class="built_in">dist</span>(l, x) + <span class="built_in">dist</span>(x, r) - <span class="built_in">dist</span>(l, r);</span><br><span class="line">  &#125;</span><br><span class="line">  s.<span class="built_in">insert</span>(&#123;dfn[x], x&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  s.<span class="built_in">erase</span>(&#123;dfn[x], x&#125;);</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">pre</span>(x), r = <span class="built_in">suf</span>(x);</span><br><span class="line">    ans -= <span class="built_in">dist</span>(l, x) + <span class="built_in">dist</span>(x, r) - <span class="built_in">dist</span>(l, r);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="type">int</span> x, y, z;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">    <span class="built_in">add</span>(x, y, z), <span class="built_in">add</span>(y, x, z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">  <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">    <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      <span class="built_in">insert</span>(x);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      <span class="built_in">erase</span>(x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>假设有图如下，数字代表DFS序；实际上题目就是问<code>1 2 4 6 8 9</code>构成的子树大小。</p>
<p>可以发现，跟着<code>2 - 4 - 6 - 8 - 9 - 2</code>这个顺序走，路径长度就是这个子树的两倍。</p>
<img src="/2024/09/25/355-%E5%BC%82%E8%B1%A1%E7%9F%B3/1.jpg" class="" title="551d5800c5f74818db5deb41fa8cb24">
<p>所以用<code>set</code>维护dfs序即可，假设当前的<code>set</code>为空</p>
<ul>
<li>插入dfs序<code>2</code>，那么<code>ans</code>设为<code>0</code>，因为没有路径</li>
<li>插入dfs序<code>4</code>，<code>ans</code>等于<code>2 * dist(2, 4)</code></li>
<li>插入dfs序<code>6</code>，新增了<code>2 - 6</code>与<code>4 - 6</code>这两段路径，<code>ans += dist(2, 6) + dist(4, 6) - dist(2, 4)</code></li>
<li>删除同理不再赘述；最后<code>ans &gt;&gt; 1</code>就是答案</li>
</ul>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>时间戳</tag>
      </tags>
  </entry>
  <entry>
    <title>树上差分 解题技巧</title>
    <url>/2024/09/26/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="练习题">练习题</h1>
<ul>
<li><p><a
href="https://www.acwing.com/problem/content/description/354/">闇の連鎖</a>
模板题</p></li>
<li><p><a
href="https://www.acwing.com/problem/content/355/">雨天的尾巴</a>
树上差分，线段树合并</p></li>
<li><p><a
href="https://www.acwing.com/problem/content/description/356/">天天爱跑步</a>
树上差分，时间戳优化</p></li>
</ul>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
      <tags>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title>364. 网络</title>
    <url>/2024/10/05/364-%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>双连通分量</li>
<li>并查集</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>, maxm = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, tot, head[maxn], ver[maxm &lt;&lt; <span class="number">1</span>], nxt[maxm &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> num, dcc, c[maxn], dfn[maxn], low[maxn];</span><br><span class="line"><span class="type">bool</span> bridge[maxm &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 缩点的新树</span></span><br><span class="line"><span class="type">int</span> ans, tc, hc[maxn], vc[maxm &lt;&lt; <span class="number">1</span>], nc[maxm &lt;&lt; <span class="number">1</span>], d[maxn], fa[maxn];</span><br><span class="line"><span class="comment">// 新树的父亲节点</span></span><br><span class="line"><span class="type">int</span> go[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; ver[++tot] = y, nxt[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_c</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; vc[++tc] = y, nc[tc] = hc[x], hc[x] = tc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == fa[x] ? x : (fa[x] = <span class="built_in">get</span>(fa[x])); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> in_edge)</span> </span>&#123;</span><br><span class="line">  dfn[x] = low[x] = ++num;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">    <span class="type">int</span> y = ver[i];</span><br><span class="line">    <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">      <span class="built_in">tarjan</span>(y, i);</span><br><span class="line">      low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">      <span class="keyword">if</span> (low[y] &gt; dfn[x]) &#123;</span><br><span class="line">        bridge[i] = bridge[i ^ <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i != (in_edge ^ <span class="number">1</span>)) &#123;</span><br><span class="line">      low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  c[x] = dcc;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">    <span class="type">int</span> y = ver[i];</span><br><span class="line">    <span class="keyword">if</span> (bridge[i] || c[y]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_c</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = hc[x]; i; i = nc[i]) &#123;</span><br><span class="line">    <span class="type">int</span> y = vc[i];</span><br><span class="line">    <span class="keyword">if</span> (d[y]) <span class="keyword">continue</span>;</span><br><span class="line">    d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">    go[y] = x;</span><br><span class="line">    <span class="built_in">dfs_c</span>(y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// x，y可能已经不是桥了</span></span><br><span class="line">  x = <span class="built_in">get</span>(x), y = <span class="built_in">get</span>(y);</span><br><span class="line">  <span class="keyword">while</span> (x != y) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[x] &lt; d[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// x到go[x]的边全部变成非桥边</span></span><br><span class="line">    fa[x] = <span class="built_in">get</span>(go[x]);</span><br><span class="line">    x = <span class="built_in">get</span>(x);</span><br><span class="line">    --ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x, y, q, t = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) &amp;&amp; n) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(hc, <span class="number">0</span>, <span class="built_in">sizeof</span>(hc));</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(c));</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="built_in">sizeof</span>(dfn));</span><br><span class="line">    <span class="built_in">memset</span>(bridge, <span class="number">0</span>, <span class="built_in">sizeof</span>(bridge));</span><br><span class="line">    tot = tc = <span class="number">1</span>;</span><br><span class="line">    dcc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">      <span class="built_in">add</span>(x, y), <span class="built_in">add</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 缩点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!c[i]) &#123;</span><br><span class="line">        ++dcc;</span><br><span class="line">        <span class="built_in">dfs</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建新树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= tot; i += <span class="number">2</span>) &#123;</span><br><span class="line">      x = ver[i ^ <span class="number">1</span>], y = ver[i];</span><br><span class="line">      <span class="keyword">if</span> (c[x] != c[y]) &#123;</span><br><span class="line">        <span class="built_in">add_c</span>(c[x], c[y]), <span class="built_in">add_c</span>(c[y], c[x]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = dcc - <span class="number">1</span>, d[<span class="number">1</span>] = <span class="number">1</span>, <span class="built_in">dfs_c</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= dcc; i++) fa[i] = i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\n&quot;</span>, ++t);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">      <span class="keyword">if</span> (c[x] != c[y]) <span class="built_in">calc</span>(c[x], c[y]);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>缩点之后，就是一棵树。</p>
<p>如果两个点在同一个边双，加一条边并不会影响桥的个数；</p>
<p>如果两个点不在同一个边双，加一条边则会变成环，环内所有桥都变成非桥边。</p>
<img src="/2024/10/05/364-%E7%BD%91%E7%BB%9C/1.png" class="" title="image-20241005190033864">
<p>由于只能一条条边向上走，所以不需要LCA；但依然需要使用并查集来跳过非桥边以加速。</p>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>双连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>363. B城</title>
    <url>/2024/10/02/363-B%E5%9F%8E/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>割点</li>
</ul>
<span id="more"></span>
<h1 id="题解">题解</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">50</span>, maxm = <span class="number">5e5</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> tot, head[maxn], nxt[maxm &lt;&lt; <span class="number">1</span>], ver[maxm &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> num, dfn[maxn], low[maxn], sz[maxn];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans[maxn];</span><br><span class="line"><span class="type">bool</span> cut[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; ver[++tot] = y, nxt[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  dfn[x] = low[x] = ++num;</span><br><span class="line">  sz[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) &#123;</span><br><span class="line">    <span class="type">int</span> y = ver[i];</span><br><span class="line">    <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">      <span class="comment">// 搜索树上</span></span><br><span class="line">      <span class="built_in">tarjan</span>(y);</span><br><span class="line">      sz[x] += sz[y];</span><br><span class="line">      low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">      <span class="keyword">if</span> (low[y] &gt;= dfn[x]) &#123;</span><br><span class="line">        ++flag;</span><br><span class="line">        ans[x] += <span class="number">1ll</span> * sz[y] * (n - sz[y]);</span><br><span class="line">        sum += sz[y];</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="number">1</span> || flag &gt; <span class="number">1</span>) cut[x] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 非树边</span></span><br><span class="line">      low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cut[x])</span><br><span class="line">    ans[x] += (n - <span class="number">1</span>) + <span class="number">1ll</span> * (n - <span class="number">1</span> - sum) * (sum + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ans[x] = <span class="number">2</span> * (n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x, y, i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="built_in">add</span>(x, y), <span class="built_in">add</span>(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路">思路</h1>
<p>直接联想到割点。</p>
<p>假设点P为割点，可以作图如下，拆分为A、B、C三个连通块与1个P点，那么有序点对应该是：</p>
<p><code>(A, n-A)</code>，<code>(B, n-B)</code>，<code>(C, n-C)</code>，<code>(1, n-1)也就是P点自身</code></p>
<img src="/2024/10/02/363-B%E5%9F%8E/1.jpg" class="" title="db935718a1b2840195aaddb8525f1a8">
<p>如果点P不是割点，那就是<code>2 * (n - 1)</code>；因为是有序点对，点P可以在前面也可以在后面。</p>
]]></content>
      <categories>
        <category>acwing</category>
      </categories>
      <tags>
        <tag>割点</tag>
      </tags>
  </entry>
  <entry>
    <title>3181. 执行操作可获得的最大总奖励 II</title>
    <url>/2025/10/25/3181-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E6%80%BB%E5%A5%96%E5%8A%B1-II/</url>
    <content><![CDATA[<h1 id="考点">考点</h1>
<ul>
<li>01背包</li>
<li>位运算</li>
<li>贪心</li>
</ul>
<span id="more"></span>
<h1 id="思路">思路</h1>
<p>根据题意，规定每个数字只能接在序列和小于它的子序列尾部，求最大序列和
那么就有两条贪心策略：</p>
<ol type="1">
<li>将输入序列进行排序，从左到右依次处理，因为有效序列只能出现<code>1 2 5</code>，而不可能出现<code>5 2 1</code>或者<code>2 5 1</code></li>
<li>排序后去重，因为<code>1 1 2</code>这种序列也不可能出现</li>
<li>同2，在做DP时，背包容量不会超过<code>最大元素 * 2 - 1</code>，比如<code>1 2 3 3</code>的上限不可能是<code>6</code></li>
</ol>
<p>接下来考虑01背包的转移方程：</p>
<p><code>f[i][j]</code>，从<code>1 ~ i</code>中选出容量等于<code>j</code>的最大价值，初值为<code>f[0][0] = 0</code>，<code>f[0][1 ~ 最大元素 * 2 - 1] = 负无穷，表示不可达</code></p>
<p>考虑第<code>i</code>个物品：</p>
<p>要么不对<code>f[i][j]</code>有贡献，<code>f[i][j] = f[i - 1][j]</code>；</p>
<p>要么对<code>f[i][j]</code>有贡献，注意，由于本题限制选第<code>i</code>个数时，从前<code>i - 1</code>个数中选的序列和不能超过第<code>i</code>个数，所以当且仅当<code>j - a[i] &lt; a[i]</code>，即<code>j &lt; 2 * a[i]</code>时，才可以转移<code>f[i][j] = f[i][j - a[i]] + a[i]</code>；</p>
<p>最后结果在<code>f[n][0 ~ 最大元素 * 2 - 1]</code>取极值即可</p>
<p>至此，可以得到如下复杂度的代码（使用滚动数组去掉第一维），但仍会超时</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e4</span> + <span class="number">50</span>, maxm = <span class="number">5e5</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> n, W, a[maxn], f[maxm];</span><br><span class="line">  <span class="built_in">Solution</span>() &#123; n = W = <span class="number">0</span>, <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a)), <span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="built_in">sizeof</span>(f)); &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxTotalReward</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; rewardValues)</span> </span>&#123;</span><br><span class="line">    n = rewardValues.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      a[i] = rewardValues[i - <span class="number">1</span>];</span><br><span class="line">      W = <span class="built_in">max</span>(W, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    W = <span class="number">2</span> * W - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    n = <span class="built_in">unique</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n) - (a + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> res = a[<span class="number">1</span>];</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = W; j &gt;= a[i]; --j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j - a[i] &lt; a[i]) f[j] = <span class="built_in">max</span>(f[j], f[j - a[i]] + a[i]);</span><br><span class="line">        res = <span class="built_in">max</span>(res, f[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>考虑优化，由于题目问的仅仅是可行性，所以没必要做计算，将转移方程修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f[j] = f[j]，j - a[i] &gt;= a[i]时；</span><br><span class="line"></span><br><span class="line">f[j] = f[j] | f[j - a[i]]，j - a[i] &lt; a[i]时。</span><br><span class="line"></span><br><span class="line">那么可以总结一句话，f[j] |= f[j - a[i]]， a[i] &lt;= j &lt; 2 * a[i]时。</span><br><span class="line"></span><br><span class="line">初始时除f[0] = 1外其余均为0表示不可达状态，结果在f[0 ~ 最大元素 * 2 - 1] 取极值。</span><br></pre></td></tr></table></figure>
<p>再次观察上次转移方程，发现可以使用一句位运算来替代：<code>f |= (f &amp; ((1 &lt;&lt; a[i]) - 1)) &lt;&lt; a[i];</code></p>
<p>即先取出<code>f</code>的低<code>a[i]</code>位，再左移<code>a[i]</code>位进行与运算，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e4</span> + <span class="number">50</span>, maxm = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">  bitset&lt;maxm&gt; f;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxTotalReward</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    n = <span class="built_in">unique</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) - (a.<span class="built_in">begin</span>());</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      f |= (f &amp; <span class="built_in">bitset</span>&lt;maxm&gt;((<span class="number">1</span> &lt;&lt; a[i]) - <span class="number">1</span>)) &lt;&lt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = a[n - <span class="number">1</span>] * <span class="number">2</span> - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">      <span class="keyword">if</span> (f[j]) <span class="keyword">return</span> j;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但由于<code>bitset</code>并不支持减法，只能采用最笨的办法，先把除低<code>a[i]</code>位之外的位清零，即低<code>a[i]</code>位左移<code>maxm - a[i]</code>位，然后再右移<code>maxm - 2 * a[i]</code>后进行与运算，得到最终解</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e4</span> + <span class="number">50</span>, maxm = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">  bitset&lt;maxm&gt; f;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxTotalReward</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    n = <span class="built_in">unique</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) - (a.<span class="built_in">begin</span>());</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> shift = maxm - a[i];</span><br><span class="line">      f |= (f &lt;&lt; shift) &gt;&gt; (shift - a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = a[n - <span class="number">1</span>] * <span class="number">2</span> - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">      <span class="keyword">if</span> (f[j]) <span class="keyword">return</span> j;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>01背包</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划_解题技巧</title>
    <url>/2025/10/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="背包">01背包</h1>
<ul>
<li><a
href="https://leetcode.cn/problems/maximum-total-reward-using-operations-ii/">3181.
执行操作可获得的最大总奖励 II</a></li>
</ul>
]]></content>
      <categories>
        <category>解题技巧</category>
      </categories>
  </entry>
</search>
